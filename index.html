<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/361bbdad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/361bbdad/" class="post-title-link" itemprop="url">主流数据库对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-01 07:50:16" itemprop="dateCreated datePublished" datetime="2025-09-01T07:50:16+08:00">2025-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">数据库综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="主流数据库对比"><a href="#主流数据库对比" class="headerlink" title="主流数据库对比"></a>主流数据库对比</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/query-languages/sql/sql-data-types">Elasticsearch 数据类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/bson-types/">MongoDB 数据类型</a></li>
</ul>
<p>:::</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>Elasticsearch</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>整数型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>byte</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>short</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>integer</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>long</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>unsigned_long</code></a></td>
<td>int、long</td>
</tr>
<tr>
<td>浮点型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>float</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/number"><code>double</code></a></td>
<td>double、decimal</td>
</tr>
<tr>
<td>布尔型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/boolean"><code>boolean</code></a></td>
<td>bool</td>
</tr>
<tr>
<td>字符串型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/keyword">keyword</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/text"><code>text</code></a></td>
<td>string</td>
</tr>
<tr>
<td>二进制型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/binary"><code>binary</code></a></td>
<td>binData</td>
</tr>
<tr>
<td>时间类型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/date"><code>date</code></a></td>
<td>date、timestamp</td>
</tr>
<tr>
<td>组合类型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/object"><code>object</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/nested"><code>nested</code></a></td>
<td>object、array</td>
</tr>
<tr>
<td>特殊类型</td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/null-value"><code>null</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/ip"><code>ip</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/version"><code>version</code></a></td>
<td>null、regex、objectId、javascript</td>
</tr>
</tbody></table>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/crud/">MongoDB 官方文档之 CRUD 操作</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">Elasticsearch 官方文档之快速入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/343.html">Elasticsearch 从入门到实践之文档的基础操作</a></li>
</ul>
<p>:::</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Elasticsearch</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>增</td>
<td><code>PUT &lt;index&gt;/_doc/&lt;id&gt;</code><br/><code>PUT &lt;index&gt;/_create/&lt;id&gt;</code><br/><code>POST &lt;index&gt;/_doc</code></td>
<td><code>db.collection.insertOne()</code><br/><code>db.collection.insertMany()</code></td>
</tr>
<tr>
<td>删</td>
<td><code>DELETE &lt;index&gt;/_doc/&lt;id&gt;</code></td>
<td><code>db.collection.deleteOne()</code><br/><code>db.collection.deleteMany()</code></td>
</tr>
<tr>
<td>改</td>
<td><code>POST &lt;index&gt;/_update/&lt;id&gt;</code></td>
<td><code>db.collection.updateOne()</code><br/><code>db.collection.updateMany()</code><br/><code>db.collection.replaceOne()</code></td>
</tr>
<tr>
<td>查</td>
<td><code>GET &lt;index&gt;/_doc/&lt;id&gt;</code></td>
<td><code>db.collection.find()</code></td>
</tr>
<tr>
<td>批处理</td>
<td><code>_bulk</code>、<code>_mget</code>、<code>_msearch</code></td>
<td><code>db.collection.insertMany()</code><br/><code>db.collection.bulkWrite()</code></td>
</tr>
</tbody></table>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">Elasticsearch 官方文档之聚合</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/348.html">Elasticsearch 从入门到实践之聚合</a></li>
</ul>
<p>:::</p>
<h3 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h3><table>
<thead>
<tr>
<th align="left">RDBM</th>
<th>Elasticsearch</th>
<th align="left">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>WHERE</code></td>
<td>query</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match"><code>$match</code></a></td>
</tr>
<tr>
<td align="left"><code>GROUP BY</code>、<code>HAVING</code></td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html"><strong>Bucket（桶聚合）</strong></a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group"><code>$group</code></a>、<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match"><code>$match</code></a></td>
</tr>
<tr>
<td align="left"><code>SELECT</code></td>
<td>field</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project"><code>$project</code></a></td>
</tr>
<tr>
<td align="left"><code>ORDER BY</code></td>
<td>order</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#pipe._S_sort"><code>$sort</code></a></td>
</tr>
<tr>
<td align="left"><code>LIMIT</code></td>
<td>size</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#pipe._S_limit"><code>$limit</code></a></td>
</tr>
<tr>
<td align="left"><code>SUM()</code></td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-sum-aggregation.html">sum</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum"><code>$sum</code></a></td>
</tr>
<tr>
<td align="left"><code>COUNT()</code></td>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-valuecount-aggregation.html">value_count</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/count-accumulator/"><code>$count</code></a></td>
</tr>
<tr>
<td align="left"><code>JOIN</code></td>
<td></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup"><code>$lookup</code></a></td>
</tr>
<tr>
<td align="left"><code>SELECT INTO NEW_TABLE</code></td>
<td></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#pipe._S_out"><code>$out</code></a></td>
</tr>
<tr>
<td align="left"><code>MERGE INTO TABLE</code></td>
<td></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#pipe._S_merge"><code>$merge</code></a></td>
</tr>
<tr>
<td align="left"><code>UNION ALL</code></td>
<td></td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/#pipe._S_unionWith"><code>$unionWith</code></a></td>
</tr>
</tbody></table>
<p>Elasticsearch 提供了极其丰富的聚合能力。</p>
<p>MongoDB 提供了丰富的聚合能力。</p>
<h3 id="Elasticsearch-聚合"><a href="#Elasticsearch-聚合" class="headerlink" title="Elasticsearch 聚合"></a>Elasticsearch 聚合</h3><p>在 ES 中，不仅仅是普通搜索，相关性计算（评分）和聚合计算也是先在每个 shard 的本地进行计算，再由 coordinate node 进行汇总。由于分片的本地计算是独立的，只能基于数据子集来进行计算，所以难免出现数据偏差。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012144894.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012145912.png"></p>
<p>要解决聚合准确性问题，有两个解决方案：</p>
<ul>
<li>解决方案 1：当数据量不大的情况下，<strong>设置主分片数为 1</strong>，这意味着在数据全集上进行聚合。但这种方案不太现实。</li>
<li>解决方案 2：<strong>设置 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-shard-size"><code>shard_size</code></a> 参数</strong>，将计算数据范围变大，<strong>牺牲整体性能，提高精准度</strong>。shard_size 的默认值是 <code>size * 1.5 + 10</code>。</li>
</ul>
<p>Elasticsearch 将聚合分为三类：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html"><strong>Metric（指标聚合）</strong></a>：根据字段值进行<strong>统计</strong>计算<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html">max</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html">min</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html">avg</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-sum-aggregation.html">sum</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html">stats</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-rate-aggregation.html">rate</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html">cardinality</a></li>
<li>…</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html"><strong>Bucket（桶聚合）</strong></a>：根据字段值、范围或其他条件进行<strong>分组</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html">filter</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html">filters</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html">terms</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-multi-terms-aggregation.html">multi_terms</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html">range</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html">composite</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html">nested</a></li>
<li>…</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html"><strong>Pipeline（管道聚合）</strong></a>：对其他聚合输出的结果进行<strong>再次聚合</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-max-bucket-aggregation.html">max_bucket</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-min-bucket-aggregation.html">min_bucket</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-avg-bucket-aggregation.html">avg_bucket</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-sum-bucket-aggregation.html">sum_bucket</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-stats-bucket-aggregation.html">stats_bucket</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-correlation-aggregation.html">bucket_correlation</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-sort-aggregation.html">bucket_sort</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-normalize-aggregation.html">normalize</a></li>
</ul>
</li>
</ul>
<h3 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h3><p>MongoDB 使用 <a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.aggregate/#mongodb-method-db.collection.aggregate"><code>db.collection.aggregate()</code></a> 方法分 <a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation-pipeline/#std-label-aggregation-pipeline-operator-reference">阶段</a> 进行聚合计算。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="逻辑存储"><a href="#逻辑存储" class="headerlink" title="逻辑存储"></a>逻辑存储</h3><table>
<thead>
<tr>
<th>RDBM</th>
<th>Elasticsearch</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>无</td>
<td>database</td>
</tr>
<tr>
<td>table</td>
<td>index</td>
<td>collection</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>document</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>field</td>
</tr>
<tr>
<td>index</td>
<td>无</td>
<td>index</td>
</tr>
</tbody></table>
<h3 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h3><p>MongoDB：MongoDB 的物理存储机制和 MySQL 较为相近。</p>
<ul>
<li><strong>文件级存储</strong>： 一个 MongoDB 实例可以包含多个数据库，每个数据库对应一组 <code>.wt</code> 文件，集合和索引分散在这些文件中。<ul>
<li><code>collection-*.wt</code>： 存储集合数据的文件。</li>
<li><code>index-*.wt</code>： 存储索引数据的文件。</li>
<li><code>WiredTiger.wt</code>： 一个元数据文件，跟踪所有其他文件。</li>
<li><code>WiredTiger.lock</code>： 锁文件，标识该数据目录正在被使用。</li>
<li><code>journal/</code>： 预写事务日志目录。</li>
</ul>
</li>
<li><strong>内存优先</strong>： 几乎所有操作都在<strong>解压后的缓存</strong>中进行，延迟写入磁盘。<ul>
<li><strong>工作方式</strong>： 它缓存的是<strong>解压后的</strong>数据和索引的<strong>页（Page）</strong>。查询首先在缓存中查找，如果找不到（cache miss），才会从磁盘读取对应的页，解压后加载到缓存中。</li>
<li><strong>页面淘汰</strong>： 使用 <strong>LRU (Least Recently Used)</strong> 算法淘汰最久未使用的页。</li>
</ul>
</li>
<li><strong>磁盘管理</strong><ul>
<li>**记录 (Record)**： 对应一个 BSON 文档及其头部信息。</li>
<li>**页 (Page)**： 磁盘 IO 的基本单位。一个页包含多个记录（文档）或索引项。</li>
<li>**区域 (Extent)**： 一组连续的页，分配给特定的集合或索引。<ul>
<li>当集合需要更多空间时，WiredTiger 会分配一个新的 Extent 给它。</li>
<li>这种预分配策略有助于减少碎片和提高写入性能。</li>
</ul>
</li>
</ul>
</li>
<li><strong>持久化</strong><ul>
<li><strong>oplog</strong>：服务层的逻辑日志，类似 MySQL 服务层的 binlog，用于主从同步，恢复数据。</li>
<li><strong>Journal</strong>：WiredTiger 存储引擎的物理日志，类似 InnoDB 的 Redo Log，都是<strong>预写日志（Write-Ahead Log, WAL）</strong>的实现。</li>
<li><strong>Checkpoint</strong>：MySQL 和 MongoDB 都会定期将内存中的修改<strong>批量、一致地</strong>写入磁盘文件，减少随机 IO。需要故障恢复时，也都是基于最后一个 Checkpoint，逐一重放操作，以恢复数据。</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><table>
<thead>
<tr>
<th></th>
<th>Elasticsearch</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>索引数据结构</td>
<td>字典树（FST）</td>
<td>B+树</td>
</tr>
<tr>
<td>索引类型</td>
<td>倒排索引</td>
<td>单字段索引，复合索引，多键索引，全文搜索，地理空间索引，哈希索引</td>
</tr>
<tr>
<td>索引优化</td>
<td></td>
<td>覆盖索引、最左匹配原则</td>
</tr>
</tbody></table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">MySQL （以 InnoDB 集群为例）</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>复制单元</strong></td>
<td align="left"><strong>数据库 (Database)</strong></td>
<td align="left"><strong>索引 (Index)</strong> 的 <strong>分片</strong></td>
<td align="left"><strong>集合 (Collection)</strong></td>
</tr>
<tr>
<td align="left"><strong>核心架构模型</strong></td>
<td align="left">**主从复制 (Master-Slave)**：主负责读写，从只负责读</td>
<td align="left">**对等节点 (Peer-to-Peer)**：无中心主节点。任何节点都可接收请求并路由</td>
<td align="left">**副本集 (Replica Set)**：主负责读写，从只负责读</td>
</tr>
<tr>
<td align="left"><strong>节点角色</strong></td>
<td align="left"><strong>Primary</strong> &amp; <strong>Replica</strong>：角色清晰固定</td>
<td align="left"><strong>所有节点对等</strong>：但可配置专属角色（如 Master-eligible, Data, Ingest, Coordinating）</td>
<td align="left"><strong>Primary</strong>, <strong>Secondary</strong>, <strong>Arbiter</strong>：角色清晰，内置<strong>自动故障转移</strong>（通过心跳和选举）</td>
</tr>
<tr>
<td align="left"><strong>数据同步方式</strong></td>
<td align="left"><strong>基于 Binlog 的逻辑复制</strong>：主节点将写操作记录到 Binlog，从节点拉取 Binlog，并重放（Replay）SQL 语句</td>
<td align="left"><strong>基于 Translog 的段同步</strong>：主分片处理写请求，并将操作同步到副本分片</td>
<td align="left"><strong>基于 Oplog 的逻辑复制</strong>：主节点将写操作记录到 Oplog，从节点异步拉取并重放这些操作</td>
</tr>
<tr>
<td align="left"><strong>一致性模型</strong></td>
<td align="left"><strong>强一致性（默认）</strong>：从节点默认异步复制，但可配置为<strong>半同步</strong>（至少一个从节点确认）以实现强一致性</td>
<td align="left"><strong>最终一致性</strong>：默认异步复制，支持通过写入 <code>consistency</code> 参数来来控制写操作的一致性级别；通过 <code>preference</code> 参数来控制读一致性</td>
<td align="left"><strong>最终一致性（默认）</strong>：读写关注（Write Concern &amp; Read Concern）可灵活配置，从最终一致到强一致（如 <code>&#123;w: &quot;majority&quot;&#125;</code>）</td>
</tr>
<tr>
<td align="left"><strong>自动故障转移</strong></td>
<td align="left"><strong>依赖外部组件</strong>：如 Group Replication 或 InnoDB Cluster 提供内置选主。传统主从依赖外部工具（MHA, Orchestrator）</td>
<td align="left"><strong>内置</strong>：由主节点管理集群状态，并在节点失败时重新分配分片</td>
<td align="left"><strong>内置</strong>：副本集成员通过心跳检测，自动触发选举产生新的主节点</td>
</tr>
</tbody></table>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li><strong>核心目标一致</strong>：三者都为实现<strong>高可用（HA）</strong> 和<strong>灾难恢复（DR）</strong> 而设计，防止单点故障导致服务中断。</li>
<li><strong>数据冗余</strong>：都是通过将数据复制到多个节点来实现数据冗余。</li>
<li><strong>读写分离</strong>：都支持将读请求分发到副本节点，从而提升系统的整体读吞吐量。</li>
<li><strong>异步复制为基</strong>：默认的复制方式都是<strong>异步</strong>的，以优先保证主节点的写入性能。</li>
<li><strong>日志驱动</strong>：依赖于一种<strong>预写日志（WAL）</strong> 的变体来驱动复制：<ul>
<li>MySQL → Binlog 和 Redo Log（InnoDB 引擎）</li>
<li>Elasticsearch → Translog</li>
<li>MongoDB → Oplog 和 Journal（WiredTiger 引擎）</li>
</ul>
</li>
<li><strong>提供一致性配置</strong>： 三者都提供了配置参数，允许用户在<strong>性能</strong>和<strong>一致性</strong>之间进行权衡。</li>
</ol>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">MySQL</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
<th align="left">利弊分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>架构哲学</strong></td>
<td align="left"><strong>中心化、主从分明</strong></td>
<td align="left"><strong>去中心化、对等网络</strong></td>
<td align="left"><strong>中心化、内置自治</strong></td>
<td align="left"><strong>ES</strong> 的架构无单点瓶颈，更易于水平扩展。<strong>MySQL&#x2F;MongoDB</strong> 的单一主节点简化了数据一致性管理，但主节点可能成为瓶颈和单点故障（需通过选主解决）。</td>
</tr>
<tr>
<td align="left"><strong>配置与管理</strong></td>
<td align="left"><strong>相对复杂</strong>：传统主从配置繁琐；现代组复制&#x2F;InnoDB 集群简化了操作，但依然较重</td>
<td align="left"><strong>非常简单</strong>：开箱即用。节点加入集群后自动分配数据，运维成本极低</td>
<td align="left"><strong>非常简单</strong>：副本集配置简单，内置自动化程度高，运维友好</td>
<td align="left"><strong>ES &amp; MongoDB</strong> 在易用性上胜出，<strong>MySQL</strong> 的复制生态更庞大但也更复杂</td>
</tr>
<tr>
<td align="left"><strong>一致性控制</strong></td>
<td align="left"><strong>最强最灵活</strong>：支持全局事务（XA）、半同步复制，能轻松实现跨节点的强一致性</td>
<td align="left"><strong>最弱</strong>：主要为搜索场景设计，偏向最终一致性。虽支持仲裁，但不像关系型数据库那样严格</td>
<td align="left"><strong>灵活可调</strong>：通过读写关注可在最终一致和强一致之间平滑切换，适应多种场景</td>
<td align="left"><strong>MySQL</strong> 是金融等强一致性场景的首选。<strong>MongoDB</strong> 提供了很好的灵活性。<strong>ES</strong> 不适合强一致性事务场景。</td>
</tr>
<tr>
<td align="left"><strong>扩展性</strong></td>
<td align="left"><strong>读扩展性好，写扩展性差</strong>：可以通过添加只读副本来扩展读能力，但写操作始终只能在主节点上进行</td>
<td align="left"><strong>读写扩展性极佳</strong>：通过分片将数据分散，读写都可以在多个分片上并行进行，真正实现水平扩展</td>
<td align="left"><strong>读写扩展性好</strong>：结合<strong>分片集群</strong>，可以将数据分散到多个分片（每个分片是一个副本集），实现写的水平扩展。读扩展通过副本集本身实现</td>
<td align="left"><strong>ES</strong> 和 <strong>MongoDB（分片集群）</strong> 在应对海量数据和高并发写入方面天生优于 <strong>MySQL</strong>。MySQL 的写扩展需要通过应用层分库分表，复杂度高</td>
</tr>
<tr>
<td align="left"><strong>延迟与性能</strong></td>
<td align="left">复制延迟可能导致从节点读到的数据是旧的</td>
<td align="left">搜索性能极高，但数据同步延迟可能比数据库更高</td>
<td align="left">复制延迟通常较低，Oplog 操作日志效率很高</td>
<td align="left"><strong>ES</strong> 为搜索性能优化，可能牺牲部分实时性。<strong>MySQL&#x2F;MongoDB</strong> 更注重数据的实时同步。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>强一致性、复杂事务的 OLTP 应用</strong>：如金融系统、电商核心交易系统</td>
<td align="left"><strong>搜索、日志分析、OLAP</strong>：如商品检索、日志平台、大数据分析</td>
<td align="left"><strong>灵活模型、高吞吐的 Web 应用</strong>：如内容管理系统、用户画像、实时分析</td>
<td align="left">复制机制的设计直接反映了其目标场景。<strong>MySQL 为交易而生，ES 为搜索而生，MongoDB 为灵活扩展的现代应用而生。</strong></td>
</tr>
</tbody></table>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th align="left">数据库</th>
<th align="left">复制机制优势</th>
<th align="left">复制机制劣势</th>
<th align="left">典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>MySQL</strong></td>
<td align="left"><strong>强一致性保证，事务支持完备</strong>，生态成熟。</td>
<td align="left"><strong>写扩展性困难</strong>，架构复杂，运维成本较高。</td>
<td align="left">银行系统、会计软件、任何需要严格 ACID 事务的场景。</td>
</tr>
<tr>
<td align="left"><strong>Elasticsearch</strong></td>
<td align="left"><strong>真正的水平扩展</strong>，读写性能极高，容错和恢复自动化程度极高，运维简单。</td>
<td align="left"><strong>最终一致性</strong>，不支持事务，不保证数据的实时性。</td>
<td align="left">全文搜索引擎、日志和指标分析、应用程序搜索。</td>
</tr>
<tr>
<td align="left"><strong>MongoDB</strong></td>
<td align="left"><strong>扩展性良好</strong>（读和写），<strong>灵活性高</strong>（一致性可调），运维简单，内置自动故障转移。</td>
<td align="left">默认<strong>最终一致性</strong>，多文档事务性能有损耗（相比 MySQL）。</td>
<td align="left">物联网、内容管理、移动应用、实时分析。</td>
</tr>
</tbody></table>
<p><strong>如何选择：</strong></p>
<ul>
<li><strong>如果应用核心是「交易」和「强一致性」</strong>：选择 <strong>MySQL</strong>。它的复制机制为数据安全性和一致性提供了最坚实的基础。</li>
<li><strong>如果应用核心是「搜索」和「大数据分析」</strong>：选择 <strong>Elasticsearch</strong>。它的分布式对等架构为海量数据的查询和分析提供了无与伦比的性能和扩展性。</li>
<li><strong>如果应用需要「灵活的数据模型」、「快速迭代」和「水平扩展」，同时需要一定的一致性控制</strong>：选择 <strong>MongoDB</strong>。它在扩展性、一致性和易用性之间取得了最佳平衡。</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">MySQL</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>分区目的</strong></td>
<td align="left"><strong>水平扩展写入能力，管理超大表</strong></td>
<td align="left"><strong>水平扩展读写能力，实现分布式计算</strong></td>
<td align="left"><strong>水平扩展读写能力，支持海量数据增长</strong></td>
</tr>
<tr>
<td align="left"><strong>分区&#x2F;分片单元</strong></td>
<td align="left"><strong>表 (Table)</strong></td>
<td align="left"><strong>分片 (Shard)</strong><br/>一个独立的Lucene索引，是数据移动的基本单位。</td>
<td align="left"><strong>块 (Chunk)</strong><br/>一个分片键值范围的连续数据段。默认大小64MB。</td>
</tr>
<tr>
<td align="left"><strong>核心架构</strong></td>
<td align="left"><strong>需要外部中间件或自定义逻辑</strong></td>
<td align="left"><strong>原生集成，对应用完全透明</strong></td>
<td align="left"><strong>原生集成，对应用近乎透明</strong></td>
</tr>
<tr>
<td align="left"><strong>分片键 (Shard Key)</strong></td>
<td align="left">**分区键 (Partition Key)**，在表定义时指定。</td>
<td align="left">**路由键 (Routing Key)**，默认是 <code>_id</code>，可自定义。</td>
<td align="left">**分片键 (Shard Key)**，在集合分片时指定，选择至关重要。</td>
</tr>
<tr>
<td align="left"><strong>分片策略</strong></td>
<td align="left"><strong>范围分区 (RANGE)<strong>、</strong>哈希分区 (HASH)<strong>、</strong>KEY 分区</strong></td>
<td align="left"><strong>哈希分片 （默认）</strong>，基于路由键的哈希值。</td>
<td align="left"><strong>范围分片 (Ranged)<strong>、</strong>哈希分片 (Hashed)<strong>、</strong>混合分片 (Zoned)</strong></td>
</tr>
<tr>
<td align="left"><strong>数据分布目标</strong></td>
<td align="left"><strong>将数据拆分到不同物理文件，</strong> 便于管理和局部优化。<strong>并不自动分布到不同服务器</strong>。</td>
<td align="left"><strong>将数据均匀分布到集群所有节点</strong>，实现负载均衡和并行处理。</td>
<td align="left"><strong>将数据均匀分布到分片集群的所有分片（Shard）</strong> 上，每个分片是一个副本集。</td>
</tr>
<tr>
<td align="left"><strong>查询路由</strong></td>
<td align="left"><strong>应用层负责</strong>。应用必须知道如何将查询路由到正确的分区。</td>
<td align="left"><strong>协调节点负责</strong>。应用可连接任意节点，节点自动路由查询。</td>
<td align="left"><strong>mongos 路由器负责</strong>。应用连接 <code>mongos</code>，由它自动路由和聚合结果。</td>
</tr>
<tr>
<td align="left"><strong>跨分片查询</strong></td>
<td align="left"><strong>极其困难</strong>。需要查询所有分区并手动合并结果，性能极差。</td>
<td align="left"><strong>原生支持</strong>。搜索和聚合查询自动并行化，由协调节点汇总结果。</td>
<td align="left"><strong>原生支持</strong>。多数查询通过 <code>mongos</code> 自动路由和聚合。但某些操作（如<code>$lookup</code>）受限。</td>
</tr>
<tr>
<td align="left"><strong>再平衡 (Rebalance)</strong></td>
<td align="left"><strong>不支持自动再平衡</strong>。需要手动导出&#x2F;导入数据，操作复杂且耗时。</td>
<td align="left"><strong>自动再平衡</strong><br/>节点数变化后，ES 自动在节点间迁移分片，实现负载均衡<br/>集群中的 master 节点负责所有元数据变更和分片分配决策</td>
<td align="left"><strong>自动再平衡</strong>。<br/>当分片间的块数量差异超过某个阈值时触发<br/>由<strong>配置服务器（Config Server）</strong> 管理元数据，并触发平衡器迁移数据块</td>
</tr>
</tbody></table>
<h3 id="相同点-1"><a href="#相同点-1" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li><strong>核心目标一致</strong>： 三者都为了突破单机硬件（CPU、内存、磁盘）的限制，通过将数据分散到多个节点来实现<strong>水平扩展</strong>。</li>
<li><strong>基于键值分区</strong>： 都要求选择一个或多个字段的值作为依据（分片键&#x2F;分区键&#x2F;路由键），通过这个值的哈希或范围来决定数据的具体位置。</li>
<li><strong>面临类似挑战</strong>： 都需要解决<strong>跨分片查询</strong>、<strong>数据分布均衡性</strong>、<strong>事务支持</strong>（难度高）和<strong>集群管理</strong>的复杂性。</li>
</ol>
<h3 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">MySQL</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
<th align="left">利弊分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性与集成度</strong></td>
<td align="left"><strong>极低</strong> 自身分区功能弱，需借助中间件（如 Vitess, ShardingSphere）或应用层自己分库分表。</td>
<td align="left"><strong>极高</strong> <strong>开箱即用</strong>。创建索引时指定分片数即可，集群自动管理数据分布、查询路由和再平衡。</td>
<td align="left"><strong>高</strong> 原生支持。需部署 <code>mongos</code> 和配置服务器，但一旦搭建完成，对应用透明。</td>
<td align="left"><strong>ES &gt; MongoDB &gt; MySQL</strong>。ES 的分布式设计是骨子里的，体验最无缝。MySQL 的分片需要大量的开发和运维投入。</td>
</tr>
<tr>
<td align="left"><strong>数据均衡与再平衡</strong></td>
<td align="left"><strong>手动</strong> 需要 DBA 手动干预数据迁移，过程繁琐且易出错。</td>
<td align="left"><strong>全自动</strong> 是 ES 的核心优势之一。节点增减自动触发分片重平衡，无需人工干预。</td>
<td align="left"><strong>自动</strong> 平衡器自动在分片间迁移<strong>数据块（Chunks）</strong> 以保持均衡。</td>
<td align="left"><strong>ES 和 MongoDB 的自动再平衡是巨大优势</strong>，极大降低了运维成本。MySQL 在这方面几乎是空白的。</td>
</tr>
<tr>
<td align="left"><strong>查询支持</strong></td>
<td align="left"><strong>极差</strong> 跨分片查询是噩梦。JOIN、ORDER BY + LIMIT 等操作几乎无法高效进行。</td>
<td align="left"><strong>极佳</strong> <strong>核心优势</strong>。所有搜索和聚合 API 都是为分布式设计，自动并行化，对用户无感。</td>
<td align="left"><strong>良好</strong> 大多数 CRUD 操作都能被正确路由。但跨分片聚合、<code>$lookup</code>（表连接）性能较差。</td>
<td align="left"><strong>ES 作为搜索引擎，在分布式查询上碾压其他两者</strong>。MongoDB 支持常见操作，但复杂操作受限。MySQL 的跨分片查询基本不可用。</td>
</tr>
<tr>
<td align="left"><strong>分片键选择</strong></td>
<td align="left"><strong>影响管理，不影响性能</strong> 选择主要影响数据归档和管理（如按时间分区删除旧数据）。</td>
<td align="left"><strong>影响性能</strong> 路由键影响数据分布的均匀性。自定义路由键可优化查询，将相关数据放在同一分片。</td>
<td align="left"><strong>至关重要</strong> <strong>一旦选择不可更改</strong>。直接影响性能、数据分布和扩展性。不合适的键会导致<strong>数据热点</strong>和<strong>性能瓶颈</strong>。</td>
<td align="left"><strong>MongoDB 的分片键选择是“一次性”的重大架构决策</strong>，责任最大。ES 和 MySQL 相对灵活一些。</td>
</tr>
<tr>
<td align="left"><strong>事务支持</strong></td>
<td align="left"><strong>强（单机）</strong> 在单分区内支持完整 ACID。跨分片事务需要借助中间件，复杂度高，性能差。</td>
<td align="left"><strong>无</strong> 不支持 ACID 事务。提供部分原子性操作（如脚本更新）。</td>
<td align="left"><strong>支持（多文档）</strong> 4.0+ 支持跨分片的多文档事务，但性能有损耗，默认有 60 秒超时限制。</td>
<td align="left"><strong>MySQL 在单机事务上最强</strong>。<strong>MongoDB 提供了跨分片事务的能力</strong>，是一个折中方案。<strong>ES 完全不考虑事务</strong>，这是为其搜索场景做的取舍。</td>
</tr>
</tbody></table>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th align="left">数据库</th>
<th align="left">分区机制优势</th>
<th align="left">分区机制劣势</th>
<th align="left">典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>MySQL</strong></td>
<td align="left"><strong>单机性能强大</strong>，分区可用于<strong>数据生命周期管理</strong>（如高效删除旧数据）。</td>
<td align="left"><strong>分片功能极其薄弱</strong>，需要大量外部工作和自定义开发，<strong>运维复杂度最高</strong>。</td>
<td align="left">单表数据量巨大且需要定期归档清理的场景（如日志表、事件表）。真正的水平扩展必须依赖中间件。</td>
</tr>
<tr>
<td align="left"><strong>Elasticsearch</strong></td>
<td align="left"><strong>原生分布式，易用性顶级</strong>，<strong>自动再平衡</strong>，<strong>分布式查询能力无敌</strong>。</td>
<td align="left"><strong>不支持事务</strong>，不适合强一致性要求的 OLTP 场景。</td>
<td align="left"><strong>搜索、日志、分析</strong>等海量数据<strong>读多写少</strong>的场景。天生为分布式查询而生。</td>
</tr>
<tr>
<td align="left"><strong>MongoDB</strong></td>
<td align="left"><strong>原生分片，自动平衡</strong>，对应用透明。<strong>支持跨分片事务</strong>（有限制）。</td>
<td align="left"><strong>分片键选择是永久且关键的</strong>，一旦选择错误代价巨大。复杂查询支持不如 ES。</td>
<td align="left"><strong>需要水平扩展的 OLTP 类应用</strong>，数据模型灵活，读写吞吐量要求高。如游戏、物联网、内容平台。</td>
</tr>
</tbody></table>
<p><strong>如何选择：</strong></p>
<ol>
<li><strong>如果主要需求是「搜索」和「分析」</strong>：选择 <strong>Elasticsearch</strong>。它的分区和分布式查询是业界的黄金标准，完全无需你操心数据如何分布和查询如何执行。</li>
<li><strong>如果需要一个「可水平扩展的通用数据库」，用于现代应用</strong>：选择 <strong>MongoDB</strong>。它的分片集群是内置的，提供了良好的扩展性和灵活性，同时还能支持跨分片事务，适合各种 Web 和移动应用。</li>
<li><strong>如果数据量很大但主要是「单机操作」，或需要「严格的单机事务」</strong>：选择 <strong>MySQL</strong>。可以使用其分区功能来管理大表，但不要指望它原生能提供分布式数据库的能力。真正的分片需要引入复杂的中间件，这通常是最后的选择。</li>
</ol>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><h3 id="核心机制对比"><a href="#核心机制对比" class="headerlink" title="核心机制对比"></a>核心机制对比</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>故障检测核心</strong></td>
<td align="left"><strong>Zen Discovery</strong>：自定义的节点发现和故障检测协议。主节点（Master-elected）负责监控集群状态。</td>
<td align="left"><strong>心跳机制 (Heartbeat)</strong> 副本集成员间每2秒发送一次心跳包。</td>
</tr>
<tr>
<td align="left"><strong>检测指标</strong></td>
<td align="left">节点存活状态、网络分区、分片分配状态</td>
<td align="left">节点存活状态、优先级、Optime（操作时间戳）</td>
</tr>
<tr>
<td align="left"><strong>故障恢复</strong></td>
<td align="left"><strong>重新选主 &amp; 分片重分配</strong><br/>1. 选举新主节点<br/>2. 新主节点将缺失的副本分片提升为主分片，并在其他节点上创建新的副本分片</td>
<td align="left"><strong>自动故障转移 (Failover)</strong><br/>1. 剩余节点发起选举<br/>2. 基于节点优先级、Optime 等规则选举出新主节点</td>
</tr>
<tr>
<td align="left"><strong>选举算法</strong></td>
<td align="left"><strong>Bully-like 算法</strong> 基于节点ID和集群状态，更简单高效。</td>
<td align="left"><strong>Raft 协议变体</strong> 在分布式共识和效率之间取得平衡，易于理解。</td>
</tr>
<tr>
<td align="left"><strong>数据一致性保证</strong></td>
<td align="left"><strong>最终一致性</strong> 恢复期间可能读取旧数据，同步队列可能导致数据延迟。</td>
<td align="left"><strong>最终一致性 -&gt; 强一致可调</strong> 默认最终一致，但通过写关注 <code>&#123;w: &quot;majority&quot;&#125;</code> 可保证读己之写和强一致性。</td>
</tr>
<tr>
<td align="left"><strong>恢复后数据同步</strong></td>
<td align="left"><strong>分片同步</strong> 新的副本分片从主分片拉取数据进行完整同步。</td>
<td align="left"><strong>初始同步 &amp; Oplog 重放</strong> 新节点先做全量同步，然后持续重放主节点的 Oplog 以保持数据最新。</td>
</tr>
<tr>
<td align="left"><strong>运维复杂度</strong></td>
<td align="left"><strong>低</strong> 几乎全自动化，对用户透明，运维非常简单。</td>
<td align="left"><strong>中</strong> 配置简单，但需要理解选举规则和优先级，运维比ES复杂但比MySQL简单。</td>
</tr>
</tbody></table>
<h3 id="相同点-2"><a href="#相同点-2" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li><strong>基于心跳检测</strong>： 都依赖于节点间定期发送心跳包来检测对方是否存活。</li>
<li><strong>自动选主</strong>： 在主节点故障时，都具备<strong>自动选举新主节点</strong>的能力，无需人工干预。</li>
<li><strong>多数派原则</strong>： 都遵循“多数派”（Quorum）原则来避免脑裂（Split-Brain）。即集群必须拥有超过半数的投票节点在线才能正常进行主节点选举和数据写入，否则整个集群会进入只读或不可用状态以保护数据。</li>
</ol>
<h3 id="不同点-2"><a href="#不同点-2" class="headerlink" title="不同点"></a>不同点</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Elasticsearch</th>
<th align="left">MongoDB</th>
<th align="left">利弊分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>架构哲学</strong></td>
<td align="left"><strong>可用性与分区容错性优先</strong> 源自CAP理论的AP系统，优先保证服务可用性和扩展性，接受最终一致性。</td>
<td align="left"><strong>灵活可调</strong> 在CAP中偏向CP（一致性+分区容错性），但通过读写关注允许应用选择一致性级别。</td>
<td align="left">ES 为搜索性能和可用性牺牲一致性。MongoDB 试图在中间取得平衡。</td>
</tr>
<tr>
<td align="left"><strong>故障检测粒度</strong></td>
<td align="left"><strong>分片级 &amp; 节点级</strong> 不仅检测节点，更关注每个分片（数据副本）的状态，粒度更细。</td>
<td align="left"><strong>节点级</strong> 关注副本集成员节点的状态。</td>
<td align="left"><strong>ES 的检测粒度最细</strong>，因为它管理的是分片而非整个节点，恢复可以更精细。</td>
</tr>
<tr>
<td align="left"><strong>恢复速度</strong></td>
<td align="left"><strong>非常快</strong> 选举速度快，且分片恢复是并行进行的，单个分片故障不影响其他分片。</td>
<td align="left"><strong>快</strong> Raft选举效率高，通常在10秒内完成故障转移。数据同步基于高效的Oplog。</td>
<td align="left"><strong>ES 和 MongoDB 的恢复速度通常快于 MySQL</strong>，对业务影响更小。</td>
</tr>
<tr>
<td align="left"><strong>脑裂</strong></td>
<td align="left"><strong>通过 <code>minimum_master_nodes</code> 配置防止</strong> 需要人工正确配置，配置不当有脑裂风险。7.x 后，由集群自动控制</td>
<td align="left"><strong>通过选举规则避免</strong> 只有拥有最新数据（最高optime）的节点才可能当选为主，防止数据回退。</td>
<td align="left"><strong>ES 需要人工配置保证，MongoDB 通过规则自动保证</strong>。</td>
</tr>
<tr>
<td align="left"><strong>数据冲突解决</strong></td>
<td align="left"><strong>最后写入获胜</strong> 基于版本号或时间戳，可能导致数据丢失。</td>
<td align="left"><strong>基于Oplog顺序</strong> 复制是单向的（主-&gt;从），从根本上避免了写入冲突。</td>
<td align="left"><strong>MySQL 和 MongoDB 能很好地避免数据冲突，ES 不擅长处理写入冲突。</strong></td>
</tr>
</tbody></table>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th align="left">数据库</th>
<th align="left">故障恢复优势</th>
<th align="left">故障恢复劣势</th>
<th align="left">典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Elasticsearch</strong></td>
<td align="left"><strong>恢复自动化程度最高，速度最快</strong>，分片级故障隔离，集群扩展和恢复无比流畅。</td>
<td align="left"><strong>只有最终一致性</strong>，故障期间和恢复后可能读到旧数据，有脑裂配置风险。</td>
<td align="left"><strong>日志、监控、搜索</strong>等允许数据短暂不一致、但要求高可用和高吞吐的AP场景。</td>
</tr>
<tr>
<td align="left"><strong>MongoDB</strong></td>
<td align="left"><strong>在一致性和可用性之间平衡良好</strong>，故障转移快（秒级），配置简单，支持可调一致性。</td>
<td align="left"><strong>分片集群的恢复比副本集更复杂</strong>，可能会遇到<strong>性能抖动</strong>（jumbo chunks、平衡器运行）。</td>
<td align="left"><strong>现代Web应用、物联网平台</strong>等需要<strong>高可用</strong>、<strong>灵活数据模型</strong>，并能接受最终一致或配置强一致的场景。</td>
</tr>
</tbody></table>
<p><strong>如何选择：</strong></p>
<ol>
<li><strong>如果业务要求是「数据绝对不能错」，宁可停止服务也要保证一致性</strong>：选择 <strong>MySQL</strong>。它的强一致性模型和基于共识的故障恢复机制为此而生。</li>
<li><strong>如果业务要求是「服务绝对不能停」，可以接受秒级的数据延迟</strong>：选择 <strong>Elasticsearch</strong>。它的分布式设计和快速恢复能力能最大程度保证服务的可用性和连续性。非常适合可观测性场景。</li>
<li><strong>如果需要一个「兼顾可用性与一致性」的通用数据库，希望故障恢复快速且对业务透明</strong>：选择 <strong>MongoDB</strong>。它在两者之间取得了最佳实践，故障转移速度快，并且通过读写关注给了开发者灵活选择的权利，适合大多数互联网应用。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/7c4efd53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/7c4efd53/" class="post-title-link" itemprop="url">Dubbo 面试之应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-29 23:27:50" itemprop="dateCreated datePublished" datetime="2025-05-29T23:27:50+08:00">2025-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo-面试之应用"><a href="#Dubbo-面试之应用" class="headerlink" title="Dubbo 面试之应用"></a>Dubbo 面试之应用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="【简单】Dubbo-是什么？为什么使用-Dubbo？"><a href="#【简单】Dubbo-是什么？为什么使用-Dubbo？" class="headerlink" title="【简单】Dubbo 是什么？为什么使用 Dubbo？"></a>【简单】Dubbo 是什么？为什么使用 Dubbo？</h3><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo</a> 是一款高性能、轻量级的开源 Java RPC 框架。</p>
<p>Dubbo 提供了三大核心能力：</p>
<ul>
<li><strong>面向接口的远程过程调用（RPC）</strong>：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。</li>
<li><strong>智能容错和负载均衡</strong>：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。</li>
<li><strong>服务自动注册和发现</strong>：支持多种注册中心服务，服务实例上下线实时感知。</li>
</ul>
<h3 id="【简单】Dubbo3-有什么新特性？"><a href="#【简单】Dubbo3-有什么新特性？" class="headerlink" title="【简单】Dubbo3 有什么新特性？"></a>【简单】Dubbo3 有什么新特性？</h3><p>Dubbo3 的核心新特性：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/triple/">新通信协议 - Triple</a> - Triple 协议是 Dubbo3 设计的基于 HTTP 的 RPC 通信协议规范。它<strong>完全兼容 gRPC 协议</strong>，支持 Request-Response、Streaming 流式等通信模型，<strong>可同时运行在 HTTP&#x2F;1 和 HTTP&#x2F;2 之上</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1/">应用级服务发现</a><ul>
<li>接口级服务发现，以接口为粒度将信息注册到注册中心。举例来说，如果有 10 个 RPC Provider，部署在 100 台机器实例上，就要注册 <code>10 * 100</code> 条数据。</li>
<li>应用级服务发现，以应用为粒度将信息注册到注册中心。将信息进行了<strong>拆分</strong>：接口元数据信息、接口和应用的映射关系维护在元数据中心；应用信息维护在注册中心。这样的好处是，存储的数据量大大减少，则传输数据的 I&#x2F;O 开销也随之显著减少。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/mesh/">Dubbo Mesh</a> - 让 Dubbo 应用能够无缝接入 Istio 等业界主流服务网格产品。</li>
</ul>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/581776302">技术创想 66 | Dubbo3.0 应用级服务注册原理</a></p>
</blockquote>
<h3 id="【简单】Dubbo-的配置方式有哪些？"><a href="#【简单】Dubbo-的配置方式有哪些？" class="headerlink" title="【简单】Dubbo 的配置方式有哪些？"></a>【简单】Dubbo 的配置方式有哪些？</h3><p>Dubbo 支持多种配置方式，适用于不同开发场景：</p>
<table>
<thead>
<tr>
<th>配置方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>XML</strong></td>
<td>结构清晰，易于维护</td>
<td>配置冗长</td>
<td>传统 Spring 项目</td>
</tr>
<tr>
<td><strong>Properties</strong></td>
<td>简单轻量</td>
<td>复杂配置不便</td>
<td>小型项目或少量配置</td>
</tr>
<tr>
<td><strong>注解</strong></td>
<td>代码简洁，集成方便</td>
<td>灵活性较低</td>
<td>Spring Boot&#x2F;Cloud 项目</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>高度灵活，动态可控</td>
<td>代码侵入性强</td>
<td>框架集成或动态调整需求</td>
</tr>
</tbody></table>
<p><strong>XML 配置</strong></p>
<ul>
<li><p><strong>适用场景</strong>：传统 Spring 项目，配置直观但较冗长。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Properties 配置</strong></p>
<ul>
<li><p><strong>适用场景</strong>：简单项目，配置项较少时使用。</p>
</li>
<li><p><strong>示例</strong>（<code>application.properties</code>）：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">demo-provider</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Spring 注解配置</strong></p>
<ul>
<li><p><strong>适用场景</strong>：Spring Boot&#x2F;Cloud 项目，简化 XML 配置。</p>
</li>
<li><p><strong>核心注解</strong>：</p>
<ul>
<li><code>@Service</code>（暴露服务）</li>
<li><code>@Reference</code>（引用服务）</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>  <span class="comment">// Dubbo 服务提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Reference</span>  <span class="comment">// Dubbo 服务消费者</span></span><br><span class="line"><span class="keyword">private</span> DemoService demoService;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>API 编程配置</strong></p>
<ul>
<li><p><strong>适用场景</strong>：动态配置、框架集成等需要灵活控制的场景。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationConfig</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;demo-provider&quot;</span>);</span><br><span class="line"><span class="type">RegistryConfig</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>);</span><br><span class="line"><span class="type">ProtocolConfig</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>(<span class="string">&quot;dubbo&quot;</span>, <span class="number">20880</span>);</span><br><span class="line"></span><br><span class="line">ServiceConfig&lt;DemoService&gt; service = <span class="keyword">new</span> <span class="title class_">ServiceConfig</span>&lt;&gt;();</span><br><span class="line">service.setInterface(DemoService.class);</span><br><span class="line">service.setRef(<span class="keyword">new</span> <span class="title class_">DemoServiceImpl</span>());</span><br><span class="line">service.export();  <span class="comment">// 暴露服务</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="【中等】Dubbo-中如何实现服务端与客户端的版本兼容？"><a href="#【中等】Dubbo-中如何实现服务端与客户端的版本兼容？" class="headerlink" title="【中等】Dubbo 中如何实现服务端与客户端的版本兼容？"></a>【中等】Dubbo 中如何实现服务端与客户端的版本兼容？</h3><h4 id="版本和分组"><a href="#版本和分组" class="headerlink" title="版本和分组"></a>版本和分组</h4><p>Dubbo 服务中，接口并不能唯一确定一个服务，<strong>只有 <code>接口+分组+版本号</code> 的三元组才能唯一确定一个服务</strong>。</p>
<ul>
<li>当同一个接口针对不同的业务场景、不同的使用需求或者不同的功能模块等场景，可使用服务分组来区分不同的实现方式。同时，这些不同实现所提供的服务是可并存的，也支持互相调用。</li>
<li>当接口实现需要升级又要保留原有实现的情况下，即出现不兼容升级时，我们可以使用不同版本号进行区分。</li>
</ul>
<p>下面以官方示例来解释一下如何指定版本。</p>
<p>假设，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DevelopService</span> &#123;</span><br><span class="line">    String <span class="title function_">invoke</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本 1 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService(group = &quot;group1&quot;, version = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevelopProviderServiceV1</span> <span class="keyword">implements</span> <span class="title class_">DevelopService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invoke</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;ServiceV1 param:&quot;</span>).append(param);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本 2 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService(group = &quot;group2&quot;, version = &quot;2.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevelopProviderServiceV2</span> <span class="keyword">implements</span> <span class="title class_">DevelopService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">invoke</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;ServiceV2 param:&quot;</span>).append(param);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨版本升级"><a href="#跨版本升级" class="headerlink" title="跨版本升级"></a>跨版本升级</h4><p>可以按照以下的步骤进行版本迁移：</p>
<ol>
<li>在低压力时间段，先部署部分 Provider 新版本</li>
<li>再将所有 Consumer 升级为新版本</li>
<li>然后将剩下的一半提供者升级为新版本</li>
</ol>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<blockquote>
<p>参考用例 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-samples/tree/master/2-advanced/dubbo-samples-version">https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-version</a></p>
</blockquote>
<p><strong>服务提供者</strong></p>
<p>老版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>新版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务消费者</strong></p>
<p>老版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>新版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="不区分版本"><a href="#不区分版本" class="headerlink" title="不区分版本"></a>不区分版本</h4><p>如果不需要区分版本，可以按照以下的方式配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过以上描述，可以看到，通过版本号来进行 Dubbo 接口升级实际上较为麻烦。如果接口提供方和消费方分属不同的业务团队，同步发版就更加麻烦了。因此，在实际应用中，更常见的操作是应该尽量充分考虑接口的后向兼容性，确保不会影响旧版本的调用。需要考虑的点如下：</p>
<ul>
<li>如果方法签名无任何变化，不会影响旧版本的调用。服务提供方可以直接先全量上线。</li>
<li>如果入参、出参上新增属性，不会影响旧版本的调用（当然，对于新增属性的逻辑处理要充分考虑兼容性）。服务提供方可以直接先全量上线，消费方根据需要选择是否后续安排对接。</li>
<li>如果入参、出参上删除或修改属性，会影响旧版本调用，可以新增接口。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/version_group/">Dubbo 官方文档之版本与分组</a></p>
</blockquote>
<h3 id="【中等】Dubbo-中的分组（Group）是如何使用的？"><a href="#【中等】Dubbo-中的分组（Group）是如何使用的？" class="headerlink" title="【中等】Dubbo 中的分组（Group）是如何使用的？"></a>【中等】Dubbo 中的分组（Group）是如何使用的？</h3><p><strong>核心作用</strong></p>
<p>Dubbo 分组通过轻量级的逻辑隔离，在不增加物理部署成本的情况下实现服务治理能力。</p>
<ul>
<li><strong>服务隔离</strong>：逻辑划分不同服务实例</li>
<li><strong>流量控制</strong>：实现定向路由和灰度发布</li>
</ul>
<p><strong>基础配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.DemoService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;group1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务消费方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.DemoService&quot;</span> <span class="attr">group</span>=<span class="string">&quot;group1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>典型应用场景</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>配置示例</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>多版本</strong></td>
<td><code>group=&quot;v1.0&quot;</code></td>
<td>新旧版本服务共存</td>
</tr>
<tr>
<td><strong>多环境</strong></td>
<td><code>group=&quot;prod&quot;</code></td>
<td>隔离生产&#x2F;测试环境</td>
</tr>
<tr>
<td><strong>灰度发布</strong></td>
<td><code>group=&quot;canary&quot;</code></td>
<td>定向流量到金丝雀版本</td>
</tr>
</tbody></table>
<p><strong>高级配置方式</strong></p>
<ul>
<li><p><strong>全局默认分组</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">group</span>=<span class="string">&quot;default-group&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">group</span>=<span class="string">&quot;default-group&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态分组</strong>（通过 RPC 上下文）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RpcContext.getContext().setAttachment(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;dynamic-group&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li>分组命名采用「<code>业务_环境_版本</code>」规范（如：payment_prod_v2）</li>
<li>配合标签路由实现更精细的流量控制</li>
<li>生产环境建议开启分组校验：<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.provider.group-validation</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="【中等】Dubbo-中如何配置多协议、多注册中心？"><a href="#【中等】Dubbo-中如何配置多协议、多注册中心？" class="headerlink" title="【中等】Dubbo 中如何配置多协议、多注册中心？"></a>【中等】Dubbo 中如何配置多协议、多注册中心？</h3><p>有时服务会面对不同用户，支持多协议可以提高服务的兼容性和灵活性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明两种协议 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rest&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 为不同服务指定协议 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.UserService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.ApiService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rest&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="【中等】Dubbo-中如何配置多注册中心？"><a href="#【中等】Dubbo-中如何配置多注册中心？" class="headerlink" title="【中等】Dubbo 中如何配置多注册中心？"></a>【中等】Dubbo 中如何配置多注册中心？</h3><p>多注册中心可以提高服务的可用性以及容灾能力，任一中心宕机不影响服务注册和发现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明两个注册中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;zookeeper1&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.1.1:2181&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;zookeeper2&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.1.2:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务同时注册到两个中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.OrderService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zookeeper1,zookeeper2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>注册中心 ID 需唯一，用逗号分隔可指定多个</li>
<li>消费端无需特殊配置，自动发现所有注册中心的服务</li>
</ul>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><h3 id="【中等】Dubbo-的超时问题如何排查与调优？"><a href="#【中等】Dubbo-的超时问题如何排查与调优？" class="headerlink" title="【中等】Dubbo 的超时问题如何排查与调优？"></a>【中等】Dubbo 的超时问题如何排查与调优？</h3><p><strong>核心排查步骤</strong></p>
<ol>
<li><p><strong>明确超时位置</strong></p>
<ul>
<li>区分是消费端超时（<code>TimeoutException</code>）还是服务端处理超时</li>
<li>检查报错日志中的<code>side</code>标识（consumer&#x2F;provider）</li>
</ul>
</li>
<li><p><strong>关键配置检查</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端配置</span></span><br><span class="line"><span class="attr">dubbo.provider.timeout</span>=<span class="string">3000  # 默认服务超时时间</span></span><br><span class="line"><span class="attr">dubbo.provider.executes</span>=<span class="string">200  # 最大并发执行数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 消费端配置</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">1000  # 调用超时时间（优先级更高）</span></span><br><span class="line"><span class="attr">dubbo.reference.timeout</span>=<span class="string">2000  # 方法级超时配置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监控指标分析</strong></p>
<ul>
<li>观察<code>RT</code>（响应时间）分布：P90&#x2F;P99 是否接近超时阈值</li>
<li>检查<code>TPS</code>与线程池活跃度：是否达到<code>executes</code>限制</li>
</ul>
</li>
</ol>
<p><strong>常见问题场景</strong></p>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>典型表现</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>网络抖动</td>
<td>偶发超时，伴随 Connection 异常</td>
<td>增大超时时间+重试机制</td>
</tr>
<tr>
<td>服务端阻塞</td>
<td>RT 曲线陡增</td>
<td>优化 SQL&#x2F;缓存+线程池扩容</td>
</tr>
<tr>
<td>消费端配置不合理</td>
<td>特定服务超时</td>
<td>调整方法级 timeout</td>
</tr>
<tr>
<td>级联超时</td>
<td>多层服务同时超时</td>
<td>设置合理超时阶梯+熔断降级</td>
</tr>
</tbody></table>
<p><strong>调优方案</strong></p>
<ol>
<li><p><strong>分层超时设置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基础服务设置长超时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;BaseService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 聚合服务设置短超时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;AggregateService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态调整策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 RpcContext 动态设置</span></span><br><span class="line">RpcContext.getContext().set(<span class="string">&quot;timeout&quot;</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程池优化</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">provider:</span></span><br><span class="line">    <span class="attr">threads:</span> <span class="number">200</span> <span class="comment"># IO 线程数</span></span><br><span class="line">    <span class="attr">threadpool:</span> <span class="string">cached</span> <span class="comment"># 弹性线程池</span></span><br><span class="line">    <span class="attr">queues:</span> <span class="number">0</span> <span class="comment"># 不堆积请求</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. **熔断降级配合**</span><br><span class="line"></span><br><span class="line">   ```xml</span><br><span class="line">   <span class="comment">&lt;!-- 结合 Sentinel 实现自动熔断 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;query&quot;</span> <span class="attr">sentinel</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>高级排查工具</strong></p>
<p>（1）<strong>Arthas 诊断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控方法执行时间</span></span><br><span class="line">watch com.example.ServiceImpl * <span class="string">&#x27;&#123;params,returnObj&#125;&#x27;</span> -x 3 -n 5 -b</span><br></pre></td></tr></table></figure>

<p>（2）<strong>全链路追踪</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Filter 中记录关键节点耗时</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Method &#123;&#125; cost &#123;&#125;ms&quot;</span>, inv.getMethodName(),</span><br><span class="line">            System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践建议</strong></p>
<ol>
<li><p><strong>超时公式参考</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">理想超时时间 </span>=<span class="string"> 平均 RT × 3 + 安全余量 (200~500ms)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置优先级原则</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法级 &gt; 接口级 &gt; 全局配置</span><br><span class="line">消费端配置 &gt; 服务端配置</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生产环境推荐</strong></p>
<ul>
<li>所有服务显式声明超时时间</li>
<li>核心服务设置<code>timeout=&quot;3000&quot; retries=&quot;0&quot;</code></li>
<li>非核心服务设置<code>timeout=&quot;1000&quot; retries=&quot;1&quot;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注</strong>：超时时间不是越长越好，需要平衡用户体验和系统资源占用。建议通过压测确定合理阈值。</p>
</blockquote>
<h3 id="【中等】如何在-Dubbo-中优化网络通信性能？"><a href="#【中等】如何在-Dubbo-中优化网络通信性能？" class="headerlink" title="【中等】如何在 Dubbo 中优化网络通信性能？"></a>【中等】如何在 Dubbo 中优化网络通信性能？</h3><p><strong>核心优化措施</strong></p>
<ol>
<li><p><strong>序列化优化</strong></p>
<ul>
<li>优先选用<code>Kryo</code>（高性能）或<code>Protobuf</code>（跨语言）</li>
<li>避免使用 Java 原生序列化</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">serialization</span>=<span class="string">&quot;kryo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接管理</strong></p>
<ul>
<li>强制启用长连接复用</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">keepalive:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">connections:</span> <span class="number">10</span> <span class="comment"># 每个服务维持的连接数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>网络参数调优</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Netty 参数优化</span></span><br><span class="line"><span class="attr">io.netty.allocator.type</span>=<span class="string">pooled</span></span><br><span class="line"><span class="attr">io.netty.noPreferDirect</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">dubbo.protocol.payload</span>=<span class="string">8388608  # 8MB 最大包</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>进阶优化手段</strong></p>
<table>
<thead>
<tr>
<th>优化方向</th>
<th>具体实施</th>
<th>预期收益</th>
</tr>
</thead>
<tbody><tr>
<td>数据压缩</td>
<td>启用<code>gzip</code>压缩（&gt;1KB 数据有效）</td>
<td>带宽减少 30%-70%</td>
</tr>
<tr>
<td>异步 IO</td>
<td>配置<code>dispatcher=message</code></td>
<td>吞吐量提升 20%-40%</td>
</tr>
<tr>
<td>批量调用</td>
<td>实现<code>BatchInvoker</code>接口</td>
<td>RPS 提升 50%+</td>
</tr>
<tr>
<td>EPoll 模式</td>
<td><code>-Dio.netty.epoll.enabled=true</code>（Linux）</td>
<td>延迟降低 10%-15%</td>
</tr>
</tbody></table>
<p><strong>关键配置示例</strong></p>
<ol>
<li><p><strong>服务提供方配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ProtocolConfig <span class="title function_">protocolConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProtocolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">    config.setThreads(<span class="number">200</span>);          <span class="comment">// IO 线程数</span></span><br><span class="line">    config.setBufferSize(<span class="number">16384</span>);     <span class="comment">// 16KB 缓冲区</span></span><br><span class="line">    config.setAccepts(<span class="number">1000</span>);         <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> **消费方超时控制**</span><br><span class="line">   ```xml</span><br><span class="line">   &lt;dubbo:<span class="keyword">reference</span> <span class="keyword">timeout</span>=<span class="string">&quot;1000&quot;</span>&gt;</span><br><span class="line">     &lt;dubbo:method <span class="built_in">name</span>=<span class="string">&quot;query&quot;</span> <span class="keyword">timeout</span>=<span class="string">&quot;500&quot;</span>/&gt;</span><br><span class="line">   &lt;/dubbo:<span class="keyword">reference</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>性能验证指标</strong></p>
<ol>
<li><p><strong>关键监控点</strong></p>
<ul>
<li>网络吞吐量：<code>netstat -s | grep segments</code></li>
<li>线程池状态：<code>DubboPREFIX.thread.pool.active.count</code></li>
<li>序列化耗时：<code>DubboPREFIX.serialize.time</code></li>
</ul>
</li>
<li><p><strong>压测建议</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟不同数据包大小 (1K/10K/1M)</span></span><br><span class="line">jmeter -n -t dubbo_perf.jmx -l result.csv</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>最佳实践</strong>：建议先进行基准测试（1K&#x2F;10K&#x2F;100K 数据包），逐步调整参数。典型优化效果：</p>
<ul>
<li>小包场景：TPS 提升 30%-50%</li>
<li>大包场景：吞吐量提升 2-3 倍</li>
<li>延迟敏感场景：P99 降低 20%-40%</li>
</ul>
</blockquote>
<h3 id="【中等】如何调试-Dubbo-的服务调用失败问题？"><a href="#【中等】如何调试-Dubbo-的服务调用失败问题？" class="headerlink" title="【中等】如何调试 Dubbo 的服务调用失败问题？"></a>【中等】如何调试 Dubbo 的服务调用失败问题？</h3><p><strong>快速定位步骤</strong></p>
<ol>
<li><p><strong>错误类型识别</strong></p>
<ul>
<li><code>TimeoutException</code>：调用超时（网络&#x2F;服务端阻塞）</li>
<li><code>RpcException</code>：RPC 协议错误（序列化&#x2F;版本不匹配）</li>
<li><code>NoProviderException</code>：服务未注册&#x2F;下线</li>
</ul>
</li>
<li><p><strong>关键日志检查</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Dubbo 错误日志（通常包含错误根源）</span></span><br><span class="line">grep -E <span class="string">&quot;Exception|ERROR&quot;</span> dubbo.log</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>常见问题诊断表</strong></p>
<table>
<thead>
<tr>
<th>错误现象</th>
<th>可能原因</th>
<th>排查工具</th>
</tr>
</thead>
<tbody><tr>
<td>持续 NoProvider</td>
<td>注册中心异常&#x2F;服务未发布</td>
<td><code>telnet registryIP 2181</code></td>
</tr>
<tr>
<td>偶发 Timeout</td>
<td>网络抖动&#x2F;服务端 Full GC</td>
<td><code>ping</code>+<code>jstat -gc PID</code></td>
</tr>
<tr>
<td>序列化失败</td>
<td>参数类型不匹配</td>
<td>Arthas <code>watch</code>参数检查</td>
</tr>
<tr>
<td>线程池耗尽</td>
<td>服务端并发过高</td>
<td><code>dubbo-admin</code>线程池监控</td>
</tr>
</tbody></table>
<p><strong>深度排查工具</strong></p>
<p>（1）<strong>Arthas 诊断</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查服务提供者状态</span></span><br><span class="line">watch com.xxx.ServiceImpl * <span class="string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span> -x 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪调用链路</span></span><br><span class="line">trace com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br></pre></td></tr></table></figure>

<p>（2）<strong>网络分析</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查网络连通性</span></span><br><span class="line">tcpping providerIP 20880</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓包分析（需 sudo 权限）</span></span><br><span class="line">tcpdump -i eth0 port 20880 -w dubbo.pcap</span><br></pre></td></tr></table></figure>

<p>（3）<strong>注册中心检查</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Zookeeper 服务列表查询</span></span><br><span class="line"><span class="built_in">ls</span> /dubbo/com.xxx.Service/providers</span><br></pre></td></tr></table></figure>

<p><strong>典型解决方案</strong></p>
<p>（1）<strong>服务不可用场景</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加重试机制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）<strong>性能瓶颈场景</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">provider:</span></span><br><span class="line">    <span class="attr">threads:</span> <span class="number">500</span> <span class="comment"># 扩大线程池</span></span><br><span class="line">    <span class="attr">accepts:</span> <span class="number">1000</span> <span class="comment"># 增加连接数</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">payload:</span> <span class="number">52428800</span> <span class="comment"># 增大传输包限制 (50MB)</span></span><br></pre></td></tr></table></figure>

<p>（3）<strong>版本冲突场景</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 明确指定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">version</span>=<span class="string">&quot;1.2.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>预防建议</strong></p>
<p>（1）<strong>监控配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 Dubbo QoS 在线诊断</span></span><br><span class="line"><span class="attr">dubbo.application.qos.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">dubbo.application.qos.port</span>=<span class="string">22222</span></span><br></pre></td></tr></table></figure>

<p>（2）<strong>日志增强</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorLogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;RPC 失败：&#123;&#125;.&#123;&#125;, 参数：&#123;&#125;&quot;</span>,</span><br><span class="line">                invoker.getInterface(),</span><br><span class="line">                inv.getMethodName(),</span><br><span class="line">                Arrays.toString(inv.getArguments()));</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：建议结合 APM 工具（SkyWalking&#x2F;Pinpoint）建立全链路监控，80%的调用失败问题可通过监控指标提前预警。</p>
</blockquote>
<h3 id="【中等】Dubbo-的序列化异常如何解决？"><a href="#【中等】Dubbo-的序列化异常如何解决？" class="headerlink" title="【中等】Dubbo 的序列化异常如何解决？"></a>【中等】Dubbo 的序列化异常如何解决？</h3><p><strong>核心解决步骤</strong></p>
<ol>
<li><p><strong>依赖检查</strong>：确保序列化库（如 Kryo&#x2F;FastJson）版本一致，排除冲突。</p>
</li>
<li><p><strong>序列化合规性</strong>：</p>
<ul>
<li>所有传输类需实现<code>Serializable</code>接口</li>
</ul>
</li>
</ol>
<ul>
<li>非序列化字段用<code>transient</code>标记</li>
</ul>
<ol start="3">
<li><p><strong>版本与配置统一</strong>：服务端&#x2F;客户端使用相同序列化协议（如 Hessian2）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">serialization</span>=<span class="string">&quot;kryo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>日志分析</strong>：通过错误日志定位具体异常类（如<code>NotSerializableException</code>）</p>
</li>
</ol>
<p><strong>高阶优化方案</strong></p>
<ul>
<li><p><strong>自定义序列化器</strong>：实现<code>ObjectInput</code>&#x2F;<code>ObjectOutput</code>接口处理特殊对象</p>
</li>
<li><p><strong>性能选型</strong></p>
<table>
<thead>
<tr>
<th>协议</th>
<th>性能</th>
<th>稳定性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Kryo</td>
<td>★★★</td>
<td>★★</td>
<td>高性能内部调用</td>
</tr>
<tr>
<td>Hessian2</td>
<td>★★</td>
<td>★★★</td>
<td>跨语言兼容场景</td>
</tr>
</tbody></table>
</li>
<li><p><strong>调试技巧</strong></p>
<ul>
<li>显式定义<code>serialVersionUID</code>防版本冲突</li>
<li>抓包对比序列化前后数据一致性</li>
</ul>
</li>
</ul>
<p><strong>典型报错处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：字段缺失 Serializable 导致的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Address addr; <span class="comment">// 避免序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 显式声明 UID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：生产环境推荐 Hessian2 作为默认协议平衡稳定性与性能，关键服务建议压测验证序列化性能。</p>
</blockquote>
<h3 id="【中等】Dubbo-的服务无法发现，可能的原因有哪些？"><a href="#【中等】Dubbo-的服务无法发现，可能的原因有哪些？" class="headerlink" title="【中等】Dubbo 的服务无法发现，可能的原因有哪些？"></a>【中等】Dubbo 的服务无法发现，可能的原因有哪些？</h3><p>按<strong>注册中心→提供者→消费者→网络→版本</strong>顺序排查，结合日志与工具快速定位问题。多数情况由<strong>配置不一致</strong>或<strong>网络隔离</strong>导致。</p>
<p><strong>核心排查方向</strong></p>
<table>
<thead>
<tr>
<th><strong>问题类型</strong></th>
<th><strong>关键检查点</strong></th>
<th><strong>验证方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>注册中心问题</strong></td>
<td>- 注册中心（Zookeeper&#x2F;Nacos）是否运行<br>- 网络连通性（telnet 检测端口）<br>- 配置地址是否正确</td>
<td><code>telnet 注册中心 IP 端口</code><br>查看注册中心控制台服务列表</td>
</tr>
<tr>
<td><strong>服务提供者问题</strong></td>
<td>- <code>@Service</code>&#x2F;XML 配置是否正确<br>- 服务启动日志是否有报错<br>- 是否注册到正确分组&#x2F;版本</td>
<td>检查 Dubbo 启动日志<br><code>netstat -tlnp</code>确认服务端口监听</td>
</tr>
<tr>
<td><strong>服务消费者问题</strong></td>
<td>- 引用配置（接口名&#x2F;版本&#x2F;组）是否匹配<br>- 依赖冲突（如 Dubbo 多版本）<br>- 消费者缓存未更新</td>
<td>对比提供者&#x2F;消费者配置<br>清理消费者本地缓存（<code>rm -rf ~/.dubbo/</code>）</td>
</tr>
<tr>
<td><strong>网络问题</strong></td>
<td>- 防火墙&#x2F;安全组策略<br>- DNS 解析问题<br>- 跨机房网络延迟</td>
<td><code>ping</code>&#x2F;<code>traceroute</code>测试<br>检查 iptables 规则</td>
</tr>
<tr>
<td><strong>版本不匹配</strong></td>
<td>- 接口版本号（<code>version</code>）是否一致<br>- 方法签名变更未同步</td>
<td>对比提供者与消费者的<code>@Reference(version=&quot;x.x&quot;)</code></td>
</tr>
</tbody></table>
<p><strong>高频问题解决方案</strong></p>
<ul>
<li><p><strong>注册中心连接失败</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 检查配置示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.1.100:2181&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>确保：</p>
<ul>
<li>地址协议前缀正确（如<code>zookeeper://</code>或<code>nacos://</code>）</li>
<li>超时时间足够（默认 1000ms 可能太短）</li>
</ul>
</li>
<li><p><strong>服务未注册成功</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;1.0.0&quot;, group = &quot;order&quot;)</span> <span class="comment">// 提供者注解</span></span><br><span class="line"><span class="meta">@Reference(version = &quot;1.0.0&quot;, group = &quot;order&quot;)</span> <span class="comment">// 消费者注解</span></span><br></pre></td></tr></table></figure>

<p>确保：</p>
<ul>
<li>版本号（<code>version</code>）和分组（<code>group</code>）完全匹配</li>
<li>接口包路径一致（避免 IDE 自动导入错误包）</li>
</ul>
</li>
<li><p><strong>消费者缓存脏数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 Dubbo 本地缓存</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.dubbo/  <span class="comment"># Linux/Mac</span></span><br><span class="line">del /s /q %USERPROFILE%\.dubbo  <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进阶诊断工具</strong></p>
<ul>
<li><p><strong>开启 Dubbo 调试日志</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">logging.level.org.apache.dubbo</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<ul>
<li>观察服务注册&#x2F;订阅日志</li>
<li>检查<code>Invoker</code>转换异常</li>
</ul>
</li>
<li><p><strong>使用 Telnet 直连调试</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet 服务提供者 IP 20880</span><br><span class="line">&gt; <span class="built_in">ls</span> -l  <span class="comment"># 列出所有服务</span></span><br><span class="line">&gt; invoke 接口名。方法名（参数）  <span class="comment"># 手动测试调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注册中心控制台</strong></p>
<ul>
<li><strong>Zookeeper</strong>：<code>zkCli.sh</code>查看<code>/dubbo/接口名/providers</code>节点</li>
<li><strong>Nacos</strong>：控制台检查服务列表是否可见</li>
</ul>
</li>
</ul>
<p><strong>预防建议</strong></p>
<ul>
<li><strong>标准化配置</strong>：使用 Maven 属性管理版本号，避免手动配置不一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.7.15<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>健康检查</strong>：集成 Spring Boot Actuator 监控 Dubbo 服务状态</li>
<li><strong>灰度发布</strong>：通过<code>group</code>区分环境（如<code>group=&quot;prod&quot;</code>&#x2F;<code>group=&quot;test&quot;</code>）</li>
</ul>
<h3 id="【中等】Dubbo-的服务上线后无法调用，可能的原因有哪些？"><a href="#【中等】Dubbo-的服务上线后无法调用，可能的原因有哪些？" class="headerlink" title="【中等】Dubbo 的服务上线后无法调用，可能的原因有哪些？"></a>【中等】Dubbo 的服务上线后无法调用，可能的原因有哪些？</h3><p><strong>网络问题</strong></p>
<p>检查方法：</p>
<ul>
<li><code>ping</code> 测试网络连通性。</li>
<li><code>telnet/nc</code> 检查端口是否开放（如 Dubbo 默认端口 20880）。</li>
<li><code>traceroute</code> 分析网络路径是否异常。</li>
</ul>
<p><strong>服务注册失败</strong></p>
<p>排查步骤：</p>
<ul>
<li>确认注册中心（如 Zookeeper）是否正常运行，使用 <code>zkCli.sh</code> 查看节点。</li>
<li>检查 <code>&lt;dubbo:registry address=&quot;...&quot;&gt;</code> 配置是否正确。</li>
<li>查看服务提供者日志，确认是否报注册失败错误。</li>
</ul>
<p><strong>服务依赖问题</strong></p>
<p>关键点：</p>
<ul>
<li>确保 Maven 依赖无冲突（特别是 Dubbo 版本）。</li>
<li>关注日志中的 <code>ClassNotFoundException</code> 或 <code>NoClassDefFoundError</code>。</li>
</ul>
<p><strong>消费者配置错误</strong></p>
<p>常见错误：</p>
<ul>
<li>版本号不一致：<code>&lt;dubbo:reference version=&quot;...&quot;&gt;</code> 需与提供者匹配。</li>
<li>分组不一致：检查 <code>group</code> 配置是否一致。</li>
</ul>
<p><strong>防火墙拦截</strong></p>
<p>解决方案：</p>
<ul>
<li>开放 Dubbo 服务端口（如 20880）。</li>
<li>检查云服务器安全组或本地防火墙规则（如 iptables）。</li>
</ul>
<p><strong>代码&#x2F;配置错误</strong></p>
<p>重点检查：</p>
<ul>
<li>XML 配置：<code>&lt;dubbo:service&gt;</code>、<code>&lt;dubbo:reference&gt;</code> 等标签参数是否正确。</li>
<li>注解配置：<code>@Service</code>、<code>@Reference</code> 是否被 Spring 扫描到。</li>
</ul>
<p><strong>扩展工具与技巧</strong></p>
<ul>
<li><strong>注册中心调试</strong>：通过 Zookeeper 命令（<code>ls /dubbo/服务名</code>）查看注册情况。</li>
<li><strong>Dubbo Admin</strong>：使用控制台查看服务状态和调用关系。</li>
<li><strong>日志分析</strong>：开启 Dubbo 调试日志（<code>logger.org.apache.dubbo=DEBUG</code>）定位问题。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo Github</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/design/">Dubbo 框架设计</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a7d97a68/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a7d97a68/" class="post-title-link" itemprop="url">Dubbo 面试之服务治理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-29 23:27:50" itemprop="dateCreated datePublished" datetime="2025-05-29T23:27:50+08:00">2025-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo-面试之服务治理"><a href="#Dubbo-面试之服务治理" class="headerlink" title="Dubbo 面试之服务治理"></a>Dubbo 面试之服务治理</h1><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><h3 id="【中等】什么是服务注册与发现？Dubbo-如何实现？"><a href="#【中等】什么是服务注册与发现？Dubbo-如何实现？" class="headerlink" title="【中等】什么是服务注册与发现？Dubbo 如何实现？"></a>【中等】什么是服务注册与发现？Dubbo 如何实现？</h3><p>::: info 什么是服务注册与发现？<br>:::</p>
<p>服务注册与发现是微服务的核心基础设施，通过<strong>解耦服务地址硬编码</strong>，实现<strong>动态扩缩容</strong>和<strong>故障自动恢复</strong>。</p>
<ul>
<li><strong>服务注册（Registration）</strong>：服务提供者（Provider）启动时，将自己的 <strong>IP、端口、接口名</strong> 等信息上报到<strong>注册中心</strong>（如 Zookeeper&#x2F;Nacos）。<strong>举例</strong>：<code>订单服务</code>启动后，向注册中心注册：<code>&quot;order-service: 192.168.1.100:8080&quot;</code>。</li>
<li><strong>服务发现（Discovery）</strong>：服务消费者（Consumer）从注册中心 <strong>拉取可用服务列表</strong>，并基于负载均衡策略选择目标实例。<strong>举例</strong>：<code>支付服务</code>需要调用<code>订单服务</code>时，从注册中心获取所有可用的<code>order-service</code>节点列表。</li>
</ul>
<p><strong>注册阶段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Provider--&gt;|1. 注册地址|Registry(Zookeeper/Nacos)</span><br></pre></td></tr></table></figure>

<p><strong>发现阶段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Consumer--&gt;|2. 拉取服务列表|Registry</span><br><span class="line">Consumer--&gt;|3. 调用目标 Provider|Provider</span><br></pre></td></tr></table></figure>

<p>::: info 有哪些常见的注册中心？<br>:::</p>
<p><strong>主流注册中心对比</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>代表产品</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP 型</strong></td>
<td>Zookeeper&#x2F;Consul&#x2F;Etcd</td>
<td>强一致性，适合金融类业务</td>
</tr>
<tr>
<td><strong>AP 型</strong></td>
<td>Eureka</td>
<td>高可用优先，适合互联网场景</td>
</tr>
<tr>
<td><strong>混合型</strong></td>
<td>Nacos</td>
<td>可调整副本数、同步策略，来确立偏重</td>
</tr>
</tbody></table>
<p>Dubbo 中可以通过 <code>registry</code> 配置来指定注册中心。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供者注册 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.OrderService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务消费者发现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.OrderService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="【简单】Dubbo-支持哪些注册中心？"><a href="#【简单】Dubbo-支持哪些注册中心？" class="headerlink" title="【简单】Dubbo 支持哪些注册中心？"></a>【简单】Dubbo 支持哪些注册中心？</h3><p>不同于传统的 Dubbo2，Dubbo3 中定义了三种中心：注册中心、配置中心、元数据中心。配置中心、元数据中心是实现 Dubbo 高阶服务治理能力会依赖的组件，如流量管控规则等，相比于注册中心通常这两个组件的配置是可选的。</p>
<p>配置方式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dubbo</span></span><br><span class="line"> <span class="string">registry</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">nacos://localhost:8848</span></span><br><span class="line"> <span class="string">config-center</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">nacos://localhost:8848</span></span><br><span class="line"> <span class="string">metadata-report</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">nacos://localhost:8848</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>对于部分注册中心类型（如 Zookeeper、Nacos 等），Dubbo 会默认同时将其用作元数据中心和配置中心（建议保持默认开启状态）。</strong></p>
<p>Dubbo 目前支持的主流注册中心实现包括：</p>
<ul>
<li>Zookeeper</li>
<li>Nacos</li>
<li>Redis</li>
<li>Consul</li>
<li>Etcd</li>
<li>更多实现</li>
</ul>
<p>同时也支持 Kubernetes、Mesh 体系的服务发现，具体请参考 <a target="_blank" rel="noopener" href="http://localhost:1313/zh-cn/overview/mannual/java-sdk/tasks/deploy/">使用教程 - kubernetes 部署</a></p>
<h3 id="【简单】注册中心挂了可以继续通信吗？"><a href="#【简单】注册中心挂了可以继续通信吗？" class="headerlink" title="【简单】注册中心挂了可以继续通信吗？"></a>【简单】注册中心挂了可以继续通信吗？</h3><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h3 id="【中等】注册中心是选择-CP-还是-AP？"><a href="#【中等】注册中心是选择-CP-还是-AP？" class="headerlink" title="【中等】注册中心是选择 CP 还是 AP？"></a>【中等】注册中心是选择 CP 还是 AP？</h3><p>::: info 什么是 CAP？<br>:::</p>
<p>在分布式系统领域，有一个著名的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 理论</a>。CAP 定理提出：分布式系统有三个指标，这三个指标不能同时做到：</p>
<ul>
<li><strong>一致性（Consistency）</strong> - 在任何给定时间，网络中的所有节点都具有完全相同（最近）的值。</li>
<li><strong>可用性（Availability）</strong> - 对网络的每个请求都会返回响应，但不能保证返回的数据是最新的。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> - 即使任意数量的节点出现故障，网络仍会继续运行。</li>
</ul>
<p>CAP 就是取 Consistency、Availability、Partition Tolerance 的首字母而命名。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405160639643.png"></p>
<p>在分布式系统中，分区容错性是一个既定的事实：因为分布式系统总会出现各种各样的问题，如由于网络原因而导致节点失联；发生机器故障；机器重启或升级等等。因此，<strong>CAP 定理实际上是要在可用性（A）和一致性（C）之间做权衡</strong>。</p>
<p>::: info 注册中心选 AP 还是 CP？<br>:::</p>
<p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 理论</a>，三种特性无法同时达成，必须在可用性和一致性之间做取舍。于是，根据不同侧重点，注册中心可以分为 CP 和 AP 两个阵营：</p>
<ul>
<li><strong>CP 型注册中心</strong> - <strong>牺牲可用性来换取数据强一致性</strong>，最典型的例子就是 ZooKeeper，etcd，Consul 了。ZooKeeper 集群内只有一个 Leader，而且在 Leader 无法使用的时候通过算法选举出一个新的 Leader。这个 Leader 的目的就是保证写信息的时候只向这个 Leader 写入，Leader 会同步信息到 Followers，这个过程就可以保证数据的强一致性。但如果多个 ZooKeeper 之间网络出现问题，造成出现多个 Leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 Consul 集群内都是通过 Raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。</li>
<li><strong>AP 型注册中心</strong> - <strong>牺牲一致性（只保证最终一致性）来换取可用性</strong>，最典型的例子就是 Eureka 了。Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>
<li><strong>CP &amp; AP 都支持型注册中心</strong> - Nacos 的内在设计偏向于 CP，即在发生网络分区的情况下优先保证数据的一致性和分区容错性，牺牲一定的可用性。虽然 Nacos 的内在设计偏向于 CP，但通过合理的配置与实践，可以在一定程度上优化其可用性。例如：调整副本数、配置同步策略。更多详情可以参考：<a target="_blank" rel="noopener" href="https://nacos.io/en/blog/faq/nacos-user-question-history10508/?spm=5238cd80.e9131ff.0.0.69845e2958zjvo&source=wuyi">Nacos CAP</a></li>
</ul>
<p>选择 CP 还是 AP，根据实际需要来定：如果业务场景要求强一致，优先选择 CP 型注册中心；如果业务场景强调可用性，优先选择 AP 型注册中心。</p>
<p>::: info 注册中心选型对比</p>
<p>:::</p>
<table>
<thead>
<tr>
<th>注册中心</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Zookeeper</strong></td>
<td>CP 系统，强一致性，高延迟</td>
<td>对一致性要求高的传统项目</td>
</tr>
<tr>
<td><strong>Nacos</strong></td>
<td>AP&#x2F;CP 可切换，支持动态配置</td>
<td>云原生、微服务架构</td>
</tr>
<tr>
<td><strong>Consul</strong></td>
<td>多数据中心，健康检查完善</td>
<td>跨机房服务发现</td>
</tr>
</tbody></table>
<h3 id="【中等】Dubbo-的服务自动上线与下线机制是怎样的？"><a href="#【中等】Dubbo-的服务自动上线与下线机制是怎样的？" class="headerlink" title="【中等】Dubbo 的服务自动上线与下线机制是怎样的？"></a>【中等】Dubbo 的服务自动上线与下线机制是怎样的？</h3><p>::: info 服务自动上线流程</p>
<p>:::</p>
<ul>
<li><strong>启动注册</strong>：</li>
<li>服务提供者启动时，解析配置文件（如 <code>dubbo:service</code> 或注解 <code>@Service</code>），获取服务接口、方法、版本、分组等信息。<ul>
<li>将服务元数据（如 IP、端口、接口名）注册到注册中心（如 Zookeeper&#x2F;Nacos）。</li>
<li>注册中心存储服务信息，形成服务目录（如 Zookeeper 的 <code>/dubbo/&#123;service&#125;/providers</code> 节点）。</li>
</ul>
</li>
<li><strong>消费者发现</strong>：<ul>
<li>消费者启动时，从注册中心拉取服务提供者列表，并建立长连接。</li>
<li>注册中心推送变更通知（如新服务上线），消费者动态更新本地服务列表。</li>
</ul>
</li>
</ul>
<p>::: info 服务自动下线流程</p>
<p>:::</p>
<ul>
<li><strong>主动下线</strong>：</li>
<li>服务提供者正常关闭时，触发 Shutdown Hook，向注册中心发送注销请求。<ul>
<li>注册中心删除对应节点，消费者通过事件监听感知服务下线。</li>
</ul>
</li>
<li><strong>被动下线</strong>：<ul>
<li><strong>心跳检测</strong>：若提供者宕机，注册中心未收到心跳（如 Zookeeper 的 Session 超时），自动剔除故障节点。</li>
<li><strong>消费者容错</strong>：已连接的消费者通过故障处理机制（如 Failover）切换至其他可用节点。</li>
</ul>
</li>
</ul>
<p>::: info 关键保障机制</p>
<p>:::</p>
<ul>
<li><strong>心跳保活</strong>：默认心跳间隔 60 秒（可调），超时时间建议 3 倍心跳间隔。</li>
<li><strong>重试容错</strong>：消费者支持 <code>retries</code> 配置（如 Failover 策略），避免单点故障。</li>
<li><strong>优雅停机</strong>：通过 <code>ProtocolConfig.destroy()</code> 确保注销完成后再终止 JVM。</li>
</ul>
<p>::: info 高级治理能力</p>
<p>:::</p>
<ul>
<li><strong>版本灰度</strong>：通过 <code>version</code> 字段实现多版本共存，逐步下线旧版本。</li>
<li><strong>权重调整</strong>：动态修改服务权重（如 Nacos 控制台），实现平滑流量迁移。</li>
<li><strong>无损下线</strong>：结合 QOS 命令（<code>offline</code>）或 PreStop Hook，确保流量完全迁移后再下线。</li>
</ul>
<p>::: info 常见问题排查</p>
<p>:::</p>
<ul>
<li><p><strong>服务未注册</strong>：</p>
<ul>
<li>检查注册中心地址、网络连通性。</li>
<li>查看提供者日志是否有 <code>RegistryFailedException</code>。</li>
</ul>
</li>
<li><p><strong>僵尸节点</strong>：</p>
<ul>
<li>手动清理注册中心残留节点（如 Zookeeper 的 <code>delete /dubbo/&#123;service&#125;/providers/xxx</code>）。</li>
<li>调整心跳超时时间，避免因网络抖动误判。</li>
</ul>
</li>
<li><p><strong>消费者未感知下线</strong>：</p>
<ul>
<li>确认注册中心支持事件推送（如 Nacos 的 <code>notify</code> 机制）。</li>
<li>检查消费者是否配置了 <code>check=false</code>（禁用启动时强依赖检查）。</li>
</ul>
</li>
</ul>
<p>::: info 最佳实践</p>
<p>:::</p>
<ul>
<li><strong>生产环境建议</strong>：<ul>
<li>使用 Nacos 作为注册中心，兼顾可用性和动态配置能力。</li>
<li>开启 Dubbo Admin 监控，实时查看服务状态。</li>
</ul>
</li>
<li><strong>停机操作</strong>：先通过 <code>telnet 127.0.0.1 20880</code> 执行 <code>invoke offline()</code> 命令，再重启服务。</li>
<li><strong>版本迭代</strong>：采用 <code>version=&quot;1.0.0&quot;</code> 和 <code>group=&quot;canary&quot;</code> 分批次上线，降低风险。</li>
</ul>
<h3 id="【困难】Dubbo3-的应用级服务发现的工作原理是什么？"><a href="#【困难】Dubbo3-的应用级服务发现的工作原理是什么？" class="headerlink" title="【困难】Dubbo3 的应用级服务发现的工作原理是什么？"></a>【困难】Dubbo3 的应用级服务发现的工作原理是什么？</h3><p><strong>【应用级服务发现】是 Dubbo3 引入的新特性</strong>，旨在解决大规模微服务架构下 <strong>注册中心压力大</strong> 和 <strong>服务治理效率低</strong> 的问题。其核心思想是 <strong>以应用为维度注册实例</strong>，而非传统接口级注册。</p>
<p>应用级注册通过 <strong>注册与元数据分离</strong>，将注册中心的数据量降低至常数级，显著提升了大规模微服务架构的可扩展性。其核心创新在于：</p>
<ul>
<li><strong>注册中心只存应用实例</strong>，元数据独立存储；</li>
<li><strong>消费者按需加载接口信息</strong>，减少网络开销；</li>
<li><strong>完美兼容旧模式</strong>，支持渐进式迁移。</li>
</ul>
<p><strong>与传统接口级注册的对比</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Dubbo2（接口级）</strong></th>
<th><strong>Dubbo3（应用级）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>注册单位</strong></td>
<td>每个服务接口单独注册（如 <code>com.example.UserService</code>）</td>
<td>整个应用的所有接口统一注册（如 <code>user-service-app</code>）</td>
</tr>
<tr>
<td><strong>注册数据量</strong></td>
<td>随接口数量线性增长（100 接口&#x3D;100 条注册记录）</td>
<td>恒定（1 个应用&#x3D;1 条注册记录）</td>
</tr>
<tr>
<td><strong>服务发现粒度</strong></td>
<td>接口级别</td>
<td>应用级别（消费者按需拉取接口元数据）</td>
</tr>
</tbody></table>
<p>::: info 接口级服务发现工作原理</p>
<p>:::</p>
<p>Dubbo3 以前的版本采用的是接口级服务发现。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/blog/proposals/discovery/interface-data1.png" alt="interface-data1"></p>
<p>Provider 部署的应用中通常会有多个 Service，每个 service 都可能会有其独有的配置。Service 服务发布的过程，其实就是基于这个服务配置生成地址 URL 的过程，生成的地址数据如图所示。</p>
<p>注册中心的地址数据存储结构，以 Service 服务名为数据划分依据，将一个服务下的所有地址数据都作为子节点进行聚合，子节点的内容就是实际可访问的 ip 地址，也就是我们 Dubbo 中 URL，格式就是刚才 Provider 实例生成的。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/blog/proposals/discovery/interface-data2.png" alt="interface-data2"></p>
<p>这里把 URL 地址数据划分成了几份：</p>
<ul>
<li><strong>实例可访问地址</strong>：主要信息包含 ip 和 port，消费端将基于这条数据生成 tcp 网络链接，作为后续 RPC 数据的传输载体。</li>
<li><strong>RPC 元数据</strong>：元数据用于定义和描述一次 RPC 请求。它可以分为两类：<ul>
<li><strong>具体的 RPC 服务信息</strong>：如版本号、分组以及方法相关信息；</li>
<li><strong>RPC 配置数据</strong>：控制 RPC 调用的行为，同步 Provider 进程实例的状态（如超时时间、数据编码的序列化方式等）。</li>
</ul>
</li>
<li><strong>自定义元数据</strong>：用户可任意扩展并添加自定义元数据。</li>
</ul>
<p>综上，有以下结论：</p>
<ol>
<li>服务发现聚合的 key 就是 RPC 粒度的服务</li>
<li>注册中心同步的数据不止包含地址，还包含了各种元数据以及配置</li>
<li>得益于 1 与 2，Dubbo 实现了支持应用、RPC 服务、方法粒度的服务治理能力</li>
</ol>
<p>这就是一直以来 Dubbo2 在易用性、服务治理功能性、可扩展性上强于很多服务框架的真正原因。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/blog/proposals/discovery/interface-defect.png" alt="interface-defect"></p>
<p>接口级注册的易用性是有代价的，它限制了整体架构的扩展性，在大规模 Dubbo 集群中尤为凸显。其突出问题如下：</p>
<ul>
<li><strong>注册中心集群容量会成为瓶颈</strong>：由于所有的 URL 地址数据都被发送到注册中心，注册中心的存储容量达到上限，推送效率也随之下降。</li>
<li><strong>消费端资源消耗较大</strong>：在消费端，Dubbo2 框架常驻内存已超 40%，每次地址推送带来的 cpu 等资源消耗率也非常高，影响正常的业务调用。</li>
</ul>
<p>为什么会出现这个问题？举例来说，假设有一个普通的 Dubbo Provider 应用，该应用内部定义有 10 个 RPC Service，应用被部署在 100 个机器实例上。这个应用在集群中产生的数据量将会是 <code>Service 数 * 机器实例数</code>，也就是 <code>10 * 100 = 1000</code> 条数据。数据会从两个维度放大：</p>
<ul>
<li><strong>从地址角度</strong>。100 条唯一的实例地址，被放大 10 倍</li>
<li><strong>从服务角度</strong>。10 条唯一的服务元数据，被放大 100 倍</li>
</ul>
<p>::: info 应用级服务发现工作原理</p>
<p>:::</p>
<p><img src="https://cn.dubbo.apache.org/imgs/blog/proposals/discovery/app-workflow.png" alt="app-metadataservice"></p>
<p><strong>提供者服务注册</strong></p>
<ul>
<li>启动时，应用（如 <code>user-service-app</code>）将所有服务接口的 <strong>元数据</strong>（方法列表、协议等）上报至 <strong>元数据中心</strong>（如 Nacos）。</li>
<li>仅将 <strong>应用名+实例 IP+端口</strong> 注册到 <strong>注册中心</strong>（如 ZooKeeper），<strong>不包含接口信息</strong>。</li>
</ul>
<p><strong>消费者服务发现</strong></p>
<ul>
<li><strong>订阅目标应用</strong>：<ul>
<li>消费者（如 <code>order-service-app</code>）从注册中心获取目标应用（如 <code>user-service-app</code>）的 <strong>实例列表</strong>（IP+端口）。</li>
<li><strong>不直接获取接口信息</strong>，避免注册中心数据膨胀。</li>
</ul>
</li>
<li><strong>按需拉取元数据</strong>：<ul>
<li>消费者首次调用前，从 <strong>元数据中心</strong> 拉取目标应用的接口元数据（如 <code>UserService</code> 的方法签名）。</li>
<li>本地缓存元数据，后续调用直接使用。</li>
</ul>
</li>
</ul>
<p><strong>调用过程</strong></p>
<ul>
<li>消费者通过 <strong>应用名+接口名</strong> 定位实例，发起 RPC 调用（协议兼容 Dubbo2）。</li>
<li>负载均衡在应用实例级别进行（如随机选择 <code>user-service-app</code> 的一个实例）。</li>
</ul>
<p><strong>关键设计优势</strong></p>
<ul>
<li><strong>注册中心轻量化</strong>：实例数从 <code>O（接口数×实例数）</code> 降至 <code>O（实例数）</code>，适合万级节点集群。</li>
<li><strong>动态扩容高效</strong>：新增接口无需重复注册，只需更新元数据中心。</li>
<li><strong>兼容性保障</strong>：支持与 Dubbo2 的接口级注册共存，平滑升级。</li>
</ul>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1/">Dubbo3 应用级服务发现设计</a></p>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="【中等】Dubbo-支持哪些负载均衡方式？各有什么利弊？"><a href="#【中等】Dubbo-支持哪些负载均衡方式？各有什么利弊？" class="headerlink" title="【中等】Dubbo 支持哪些负载均衡方式？各有什么利弊？"></a>【中等】Dubbo 支持哪些负载均衡方式？各有什么利弊？</h3><p>Dubbo 提供了多种均衡策略，缺省为 <code>weighted random</code> 基于权重的随机负载均衡策略。</p>
<p>具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例。</p>
<p>目前 Dubbo 内置了如下负载均衡算法，可通过调整配置项启用。</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">算法类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Random</td>
<td align="left">加权随机</td>
<td align="left">默认算法，默认权重相同</td>
</tr>
<tr>
<td align="left">RoundRobin</td>
<td align="left">加权轮询</td>
<td align="left">借鉴于 Nginx 的平滑加权轮询算法，默认权重相同，</td>
</tr>
<tr>
<td align="left">LeastActive</td>
<td align="left">最少活跃优先 + 加权随机</td>
<td align="left">背后是能者多劳的思想</td>
</tr>
<tr>
<td align="left">ShortestResponse</td>
<td align="left">最短响应优先 + 加权随机</td>
<td align="left">更加关注响应速度</td>
</tr>
<tr>
<td align="left">ConsistentHash</td>
<td align="left">一致性哈希</td>
<td align="left">确定的入参，确定的提供者，适用于有状态请求</td>
</tr>
<tr>
<td align="left">P2C</td>
<td align="left">Power of Two Choice</td>
<td align="left">随机选择两个节点后，继续选择“连接数”较小的那个节点。</td>
</tr>
<tr>
<td align="left">Adaptive</td>
<td align="left">自适应负载均衡</td>
<td align="left">在 P2C 算法基础上，选择二者中 load 最小的那个节点</td>
</tr>
</tbody></table>
<p>Dubbo 的负载均衡配置可以细粒度到服务、方法级别，且 <code>dubbo:service</code> 和 <code>dubbo:reference</code> 均可配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>::: info Random（随机）</p>
<p>:::</p>
<ul>
<li><strong>加权随机</strong>，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
<li>缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<p>::: info RoundRobin（轮询）</p>
<p>:::</p>
<ul>
<li><strong>加权轮询</strong>，按公约后的权重设置轮询比率，循环调用节点</li>
<li>缺点：同样存在慢的提供者累积请求的问题。</li>
</ul>
<p>::: info LeastActive（最少活跃优先）</p>
<p>:::</p>
<ul>
<li><strong>加权最少活跃调用优先</strong>，活跃数越低，越优先调用，相同活跃数的进行加权随机。活跃数指调用前后计数差（针对特定提供者：请求发送数 - 响应返回数），表示特定提供者的任务堆积量，活跃数越低，代表该提供者处理能力越强。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大；相对的，处理能力越强的节点，处理更多的请求。</li>
</ul>
<p>::: info ShortestResponse（最短响应优先）<br>:::</p>
<ul>
<li><strong>加权最短响应优先</strong>，在最近一个滑动窗口中，响应时间越短，越优先调用。相同响应时间的进行加权随机。</li>
<li>使得响应时间越快的提供者，处理更多的请求。</li>
<li>缺点：可能会造成流量过于集中于高性能节点的问题。</li>
</ul>
<p>这里的响应时间 &#x3D; 某个提供者在窗口时间内的平均响应时间，窗口时间默认是 30s。</p>
<p>::: info ConsistentHash（一致性 Hash）<br>:::</p>
<ul>
<li><strong>一致性 Hash</strong>，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Consistent_hashing">Consistent Hashing | WIKIPEDIA</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<p>::: info P2C<br>:::</p>
<p>Power of Two Choice 算法简单但是经典，主要思路如下：</p>
<ol>
<li>对于每次调用，从可用的 provider 列表中做两次随机选择，选出两个节点 providerA 和 providerB。</li>
<li>比较 providerA 和 providerB 两个节点，选择其“当前正在处理的连接数”较小的那个节点。</li>
</ol>
<p>以下是 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/reference/proposals/heuristic-flow-control/#p2c%20%E7%AE%97%E6%B3%95">Dubbo P2C 算法实现提案</a></p>
<p>::: info Adaptive（自适应）<br>:::</p>
<p>Adaptive 即自适应负载均衡，是一种能根据后端实例负载自动调整流量分布的算法实现，它总是尝试将请求转发到负载最小的节点。</p>
<p>以下是 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/reference/proposals/heuristic-flow-control/#adaptive%E7%AE%97%E6%B3%95">Dubbo Adaptive 算法实现提案</a></p>
<blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/core-features/load-balance/">Dubbo 官方文档之负载均衡</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/6da58e4b/">负载均衡</a></li>
</ul>
</blockquote>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><h3 id="【中等】Dubbo-如何进行服务路由控制？"><a href="#【中等】Dubbo-如何进行服务路由控制？" class="headerlink" title="【中等】Dubbo 如何进行服务路由控制？"></a>【中等】Dubbo 如何进行服务路由控制？</h3><p><strong>路由规则</strong></p>
<table>
<thead>
<tr>
<th align="left">策略类型</th>
<th align="left">配置方式</th>
<th align="left">匹配维度</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>条件路由</strong></td>
<td align="left">DSL 表达式&#x2F;IP 段匹配</td>
<td align="left">方法名、参数、来源 IP</td>
<td align="left">灰度发布、环境隔离</td>
</tr>
<tr>
<td align="left"><strong>标签路由</strong></td>
<td align="left">实例元数据标记</td>
<td align="left">逻辑分组（如地域、版本）</td>
<td align="left">金丝雀发布、A&#x2F;B 测试</td>
</tr>
<tr>
<td align="left"><strong>脚本路由</strong></td>
<td align="left">Groovy&#x2F;JS 脚本</td>
<td align="left">复杂业务逻辑</td>
<td align="left">动态分流（如 VIP 用户）</td>
</tr>
</tbody></table>
<p><strong>配置方案</strong></p>
<p><strong>条件路由强化</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多条件组合路由（支持&amp;&amp;,||,! 运算符）</span></span><br><span class="line"><span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;method=createOrder &amp;&amp; userLevel=VIP =&gt; 192.168.1.100&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;headers.appVersion=3.2.* =&gt; region=hangzhou&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>动态生效技巧</strong>：通过<code>force:false</code>实现软路由，当目标节点不可用时自动降级</p>
<p><strong>标签路由进阶</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程式打标（配合配置中心）</span></span><br><span class="line">RpcContext.getContext().setAttachment(<span class="string">&quot;traffic-tag&quot;</span>, <span class="string">&quot;experimental&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践</strong>：建立标签命名规范（如<code>env=prod</code>、<code>version=2.0</code>）</p>
<p><strong>架构图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Admin[管理控制台] --&gt;|推送规则| ConfigCenter[配置中心]</span><br><span class="line">    ConfigCenter --&gt;|实时同步| Provider[服务节点]</span><br><span class="line">    Consumer --&gt;|路由决策| RouterChain[路由链]</span><br><span class="line">    RouterChain --&gt;|过滤| LB[负载均衡]</span><br></pre></td></tr></table></figure>

<p><strong>动态管控</strong></p>
<ul>
<li><strong>规则存储</strong>：建议使用 Nacos&#x2F;Apollo 替代 Zookeeper，支持规则版本回溯</li>
<li><strong>实时生效</strong>：消费者节点秒级感知（长连接推送）</li>
<li><strong>兜底策略</strong>：本地缓存最后有效规则，避免配置中心不可用</li>
</ul>
<p><strong>生产级解决方案</strong></p>
<p><strong>场景：跨机房流量调度</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于地域标签的路由</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;region=shanghai&#x27;</span></span><br><span class="line">    <span class="attr">addresses:</span> [<span class="string">&#x27;10.1.1.1-10.1.1.20&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;region=beijing&#x27;</span></span><br><span class="line">    <span class="attr">addresses:</span> [<span class="string">&#x27;10.2.1.1-10.2.1.20&#x27;</span>]</span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;=&gt; region=shanghai&#x27;</span> <span class="comment"># 默认路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;headers.forceZone=beijing =&gt; region=beijing&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>性能优化</strong>：</p>
<ul>
<li>路由缓存：本地缓存路由决策结果（TTL 5s）</li>
<li>预计算：在服务目录更新时提前生成路由快照</li>
</ul>
<p><strong>异常处理机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义路由失败处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRouterFailover</span> <span class="keyword">implements</span> <span class="title class_">RouterListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRouteFail</span><span class="params">(Invoker&lt;?&gt; invoker)</span> &#123;</span><br><span class="line">        Metrics.counter(<span class="string">&quot;route_fail&quot;</span>).increment();</span><br><span class="line">        <span class="comment">// 自动切换备用集群。..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>监控指标设计</strong></p>
<table>
<thead>
<tr>
<th>指标名称</th>
<th>采集方式</th>
<th>告警阈值</th>
</tr>
</thead>
<tbody><tr>
<td>路由命中率</td>
<td>采样统计（每 1min）</td>
<td>&lt;95% 触发警告</td>
</tr>
<tr>
<td>规则变更频率</td>
<td>配置中心事件监听</td>
<td>&gt;5 次&#x2F;分钟告警</td>
</tr>
<tr>
<td>跨域调用比例</td>
<td>标签路由计数器</td>
<td>超出预设范围报警</td>
</tr>
</tbody></table>
<p><strong>与治理功能联动</strong></p>
<ul>
<li><strong>负载均衡</strong>：路由结果作为 LB 的优先权重依据</li>
<li><strong>限流</strong>：按路由维度设置独立限流规则</li>
<li><strong>熔断</strong>：路由异常节点自动加入熔断黑名单</li>
</ul>
<p><strong>实施建议</strong>：</p>
<ul>
<li>先通过<code>&lt;dubbo:parameter key=&quot;router&quot; value=&quot;tag&quot; /&gt;</code>启用基础路由</li>
<li>使用 Arthas 的<code>watch</code>命令实时观察路由决策过程</li>
<li>在预发布环境进行规则压测（模拟 1000 次&#x2F;秒规则变更）</li>
</ul>
<h3 id="【中等】Dubbo-路由是怎样工作的？"><a href="#【中等】Dubbo-路由是怎样工作的？" class="headerlink" title="【中等】Dubbo 路由是怎样工作的？"></a>【中等】Dubbo 路由是怎样工作的？</h3><p>以下是 Dubbo 单个路由器的工作过程，路由器接收一个服务的实例地址集合作为输入，基于请求上下文 (Request Context) 和 (Router Rule) 实际的路由规则定义对输入地址进行匹配，所有匹配成功的实例组成一个地址子集，最终地址子集作为输出结果继续交给下一个路由器或者负载均衡组件处理。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/traffic/router1.png" alt="Router"></p>
<p>通常，在 Dubbo 中，多个路由器组成一条路由链共同协作，前一个路由器的输出作为另一个路由器的输入，经过层层路由规则筛选后，最终生成有效的地址集合。</p>
<ul>
<li>Dubbo 中的每个服务都有一条完全独立的路由链，每个服务的路由链组成可能不通，处理的规则各异，各个服务间互不影响。</li>
<li>对单条路由链而言，即使每次输入的地址集合相同，根据每次请求上下文的不同，生成的地址子集结果也可能不同。</li>
</ul>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/traffic/router2.png" alt="Router"></p>
<h3 id="【中等】Dubbo-支持哪些路由方式？分别适用于什么场景？"><a href="#【中等】Dubbo-支持哪些路由方式？分别适用于什么场景？" class="headerlink" title="【中等】Dubbo 支持哪些路由方式？分别适用于什么场景？"></a>【中等】Dubbo 支持哪些路由方式？分别适用于什么场景？</h3><p>Dubbo 的路由规则可以基于应用、服务、方法、参数等粒度精准的控制请求分发，根据请求的目标服务、方法以及请求体中的其他附加参数进行匹配，符合匹配条件的请求会进一步的按照特定规则转发到一个地址子集。</p>
<p>Dubbo 支持以下路由规则：</p>
<ul>
<li>标签路由规则</li>
<li>条件路由规则</li>
<li>脚本路由规则</li>
<li>动态配置规则</li>
</ul>
<p>::: info 标签路由规则</p>
<p>:::</p>
<p><strong>标签路由</strong>通过将某一个服务的实例划分到不同的<strong>分组</strong>，<strong>约束具有特定标签的流量只能在指定分组中流转</strong>，不同分组为不同的流量场景服务，从而实现流量隔离的目的。<strong>标签路由可以作为蓝绿发布、灰度发布等场景能力的基础</strong>。</p>
<p>标签路由规则是一个非此即彼的流量隔离方案，也就是匹配标签的请求会 100% 转发到有相同标签的实例，没有匹配标签的请求会 100% 转发到其余未匹配的实例。如果您需要按比例的流量调度方案，请参考示例 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/core-features/tasks/traffic-management/weight/">基于权重的按比例流量路由</a>。</p>
<p><strong>标签主要是指对 Provider 端应用实例的分组</strong>，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标。<strong>动态规则打标</strong>可以在运行时动态的圈住一组机器实例，而<strong>静态规则打标</strong>则需要实例重启后才能生效，其中，动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p>
<p>::: info 条件路由规则</p>
<p>:::</p>
<p>条件路由与标签路由的工作模式非常相似，也是首先对请求中的参数进行匹配，<strong>符合匹配条件的请求将被转发到包含特定实例地址列表的子集</strong>。相比于标签路由，条件路由的匹配方式更灵活：</p>
<ul>
<li>在标签路由中，一旦给某一台或几台机器实例打了标签，则这部分实例就会被立马从通用流量集合中移除，不同标签之间不会再有交集。有点类似下图，地址集合在输入阶段就已经划分明确。</li>
</ul>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/traffic/tag-condition-compare1.png" alt="tag-condition-compare"></p>
<ul>
<li>而从条件路由的视角，所有的实例都是一致的，路由过程中不存在分组隔离的问题，每次路由过滤都是基于全量地址中执行</li>
</ul>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/traffic/tag-condition-compare2.png" alt="tag-condition-compare"></p>
<p>条件路由规则的主体 <code>conditions</code> 主要包含两部分内容：</p>
<ul>
<li>&#x3D;&gt; 之前的为请求参数匹配条件，指定的<strong>匹配条件指定的参数</strong>将与<strong>消费者的请求上下文 (URL)<strong>、甚至</strong>方法参数</strong>进行对比，当消费者满足匹配条件时，对该消费者执行后面的地址子集过滤规则。</li>
<li>&#x3D;&gt; 之后的为地址子集过滤条件，指定的<strong>过滤条件指定的参数</strong>将与**提供者实例地址 (URL) **进行对比，消费者最终只能拿到符合过滤条件的实例列表，从而确保流量只会发送到符合条件的地址子集。<ul>
<li>如果匹配条件为空，表示对所有请求生效，如：<code>=&gt; status != staging</code></li>
<li>如果过滤条件为空，表示禁止来自相应请求的访问，如：<code>application = product =&gt;</code></li>
</ul>
</li>
</ul>
<p>::: info 脚本路由规则</p>
<p>:::</p>
<p>脚本路由是最直观的路由方式，同时它也是当前最灵活的路由规则，因为你可以在脚本中定义任意的地址筛选规则。如果我们为某个服务定义一条脚本规则，则后续所有请求都会先执行一遍这个脚本，脚本过滤出来的地址即为请求允许发送到的、有效的地址集合。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configVersion:</span> <span class="string">v3.0</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">demo-provider</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">javascript</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  (function route(invokers,invocation,context) &#123;</span></span><br><span class="line"><span class="string">      var result = new java.util.ArrayList(invokers.size());</span></span><br><span class="line"><span class="string">      for (i = 0; i &lt; invokers.size(); i ++) &#123;</span></span><br><span class="line"><span class="string">          if (&quot;10.20.3.3&quot;.equals(invokers.get(i).getUrl().getHost())) &#123;</span></span><br><span class="line"><span class="string">              result.add(invokers.get(i));</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return result;</span></span><br><span class="line"><span class="string">  &#125; (invokers, invocation, context)); // 表示立即执行方法</span></span><br></pre></td></tr></table></figure>

<p>::: info 动态配置规则</p>
<p>:::</p>
<p>通过 Dubbo 提供的动态配置规则，可以动态的修改 Dubbo 服务进程的运行时行为，整个过程不需要重启，配置参数实时生效。基于这个强大的功能，基本上所有运行期参数都可以动态调整，比如超时时间、临时开启 Access Log、修改 Tracing 采样率、调整限流降级参数、负载均衡、线程池配置、日志等级、给机器实例动态打标签等。与上文讲到的流量管控规则类似，动态配置规则支持应用、服务两个粒度，也就是说一次可以选择只调整应用中的某一个或几个服务的参数配置。</p>
<p>当然，出于系统稳定性、安全性的考量，有些特定的参数是不允许动态修改的，但除此之外，基本上所有参数都允许动态修改，很多强大的运行态能力都可以通过这个规则实现。通常 URL 地址中的参数均可以修改，这在每个语言实现的参考手册里也记录了一些更详细的说明。</p>
<h3 id="【中等】如何在-Dubbo-中使用直连提供者？"><a href="#【中等】如何在-Dubbo-中使用直连提供者？" class="headerlink" title="【中等】如何在 Dubbo 中使用直连提供者？"></a>【中等】如何在 Dubbo 中使用直连提供者？</h3><p><strong>核心配置方式</strong></p>
<ul>
<li><strong>XML 配置</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">interface</span>=<span class="string">&quot;com.example.MyService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">&quot;dubbo://192.168.1.100:20880/com.example.MyService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注解配置</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(url = &quot;dubbo://192.168.1.100:20880/com.example.MyService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br></pre></td></tr></table></figure>

<p><strong>关键特性</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>协议格式</strong></td>
<td><code>dubbo://IP:PORT/接口全限定名</code></td>
</tr>
<tr>
<td><strong>绕过注册中心</strong></td>
<td>直接连接指定服务节点，避免注册中心复杂度</td>
</tr>
<tr>
<td><strong>即时生效</strong></td>
<td>配置修改后无需重启服务</td>
</tr>
</tbody></table>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>开发调试</strong>：快速连接本地&#x2F;测试环境服务</li>
<li><strong>问题排查</strong>：临时绕过注册中心验证服务可用性</li>
<li><strong>单元测试</strong>：固定服务端点保证测试稳定性</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>生产环境风险</strong></p>
<ul>
<li>丧失服务发现能力（无法自动感知节点上下线）</li>
<li>缺少负载均衡和熔断机制</li>
<li>配置维护成本高（需手动管理所有节点地址）</li>
</ul>
</li>
<li><p><strong>安全建议</strong></p>
<ul>
<li>限制直连 IP 白名单</li>
<li>避免在配置文件中硬编码地址（建议使用环境变量）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://$&#123;PROVIDER_IP&#125;:20880/com.example.MyService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>调试技巧</strong></p>
<ul>
<li><strong>动态切换</strong>：通过 JVM 参数临时启用直连</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcom<span class="selector-class">.example</span><span class="selector-class">.MyService</span>.url=dubbo:<span class="comment">//127.0.0.1:20880</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>组合使用</strong>：保留注册中心配置，通过<code>url</code>属性覆盖特定服务</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;nacos://localhost:8848&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://192.168.1.100:20880&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.MyService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践</strong>：建议仅在非生产环境使用直连模式，生产环境应通过注册中心实现服务发现和治理。</p>
</blockquote>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="【中等】Dubbo-中的流量控制策略有哪些？"><a href="#【中等】Dubbo-中的流量控制策略有哪些？" class="headerlink" title="【中等】Dubbo 中的流量控制策略有哪些？"></a>【中等】Dubbo 中的流量控制策略有哪些？</h3><p>流量控制策略主要包括：限流、熔断、降级</p>
<p>Dubbo 中，可以通过集成 Hystrix 或 Sentinel 来实现限流、熔断、降级。</p>
<h3 id="【中等】什么是-Dubbo-的-Mock-机制？如何使用？"><a href="#【中等】什么是-Dubbo-的-Mock-机制？如何使用？" class="headerlink" title="【中等】什么是 Dubbo 的 Mock 机制？如何使用？"></a>【中等】什么是 Dubbo 的 Mock 机制？如何使用？</h3><p>Dubbo 的 Mock 机制是一种用于服务降级的功能。当远程调用失败或不稳定时，通过 Mock 机制可以返回预先定义的结果，从而保证服务的可用性。</p>
<p>除了 Dubbo，很多分布式框架和微服务架构都会提供类似的服务降级功能。比如 Spring Cloud 里面的 Hystrix，可以通过配置降级策略，在服务异常时返回降级数据。</p>
<p><strong>配置方式</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">实现方式</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全局配置</strong></td>
<td align="left">XML 配置</td>
<td align="left"><code>&lt;dubbo:reference mock=&quot;true&quot; interface=&quot;com.xx.DemoService&quot;/&gt;</code></td>
</tr>
<tr>
<td align="left"><strong>注解配置</strong></td>
<td align="left">@Reference 注解</td>
<td align="left"><code>@Reference(mock = &quot;true&quot;) private DemoService demoService;</code></td>
</tr>
<tr>
<td align="left"><strong>自定义 Mock</strong></td>
<td align="left">实现 Mock 类</td>
<td align="left">略</td>
</tr>
</tbody></table>
<p><strong>高级配置</strong></p>
<ul>
<li><strong>强制 Mock</strong>：<code>mock=&quot;force:return empty&quot;</code>（直接返回 Mock 结果）</li>
<li><strong>失败 Mock</strong>：<code>mock=&quot;fail:return null&quot;</code>（仅调用失败时生效）</li>
<li><strong>方法级 Mock</strong>：<code>mock=&quot;return &#123;methodName&#125;&quot;</code>（指定方法 Mock）</li>
</ul>
<p><strong>典型应用场景</strong></p>
<ul>
<li><strong>容灾场景</strong>：网络故障&#x2F;服务不可用时的兜底方案</li>
<li><strong>开发测试</strong>：解耦依赖服务，提升开发效率</li>
<li><strong>性能保障</strong>：非核心服务降级，保障核心链路</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>生产环境建议</strong>：<ul>
<li>配合超时配置使用：<code>&lt;dubbo:reference timeout=&quot;3000&quot; mock=&quot;true&quot;/&gt;</code></li>
<li>避免写操作接口使用 Mock</li>
</ul>
</li>
<li><strong>性能影响</strong>：<ul>
<li>Mock 类应保持简单逻辑</li>
<li>复杂 Mock 可能成为性能瓶颈</li>
</ul>
</li>
</ul>
<p><strong>与其他方案对比</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>触发条件</th>
<th>粒度</th>
<th>实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dubbo Mock</strong></td>
<td>调用失败</td>
<td>方法级</td>
<td>低</td>
</tr>
<tr>
<td><strong>熔断器</strong></td>
<td>错误率阈值</td>
<td>服务级</td>
<td>中</td>
</tr>
<tr>
<td><strong>限流</strong></td>
<td>流量阈值</td>
<td>系统级</td>
<td>高</td>
</tr>
</tbody></table>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><h3 id="【中等】如何在-Dubbo-中使用健康检查？"><a href="#【中等】如何在-Dubbo-中使用健康检查？" class="headerlink" title="【中等】如何在 Dubbo 中使用健康检查？"></a>【中等】如何在 Dubbo 中使用健康检查？</h3><p>Dubbo 通过 <strong>多级健康检查机制</strong> 保障服务可用性，开发者可根据业务需求选择默认配置或扩展自定义检查逻辑。</p>
<p><strong>健康检查方式</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>触发条件</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>配置示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>服务提供者探活</strong></td>
<td>定时心跳检测（默认 3 秒）</td>
<td>快速发现宕机节点</td>
<td><code>&lt;dubbo:provider heartbeat=&quot;5000&quot;/&gt;</code></td>
</tr>
<tr>
<td><strong>注册中心剔除</strong></td>
<td>长连接断开后自动摘除（如 Zookeeper）</td>
<td>防止调用失效节点</td>
<td>无需配置，依赖注册中心能力</td>
</tr>
<tr>
<td><strong>接口级检查</strong></td>
<td>自定义<code>HealthCheck</code>接口实现</td>
<td>精细化业务健康状态（如依赖 DB）</td>
<td>实现<code>org.apache.dubbo.health.HealthChecker</code></td>
</tr>
</tbody></table>
<p><strong>关键配置参数</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务端配置示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">heartbeat</span>=<span class="string">&quot;3000&quot;</span>                 &lt;!<span class="attr">--</span> <span class="attr">心跳间隔</span>（<span class="attr">毫秒</span>） <span class="attr">--</span>&gt;</span></span><br><span class="line">    heartbeat-timeout=&quot;60000&quot;        <span class="comment">&lt;!-- 超时剔除时间 --&gt;</span></span><br><span class="line">    checks=&quot;true&quot;                    <span class="comment">&lt;!-- 开启消费者检查（默认 true） --&gt;</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端配置示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span></span></span><br><span class="line"><span class="tag">    <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>                    &lt;!<span class="attr">--</span> <span class="attr">启动时不强制检查提供者</span>（<span class="attr">默认为</span> <span class="attr">true</span> <span class="attr">阻塞启动</span>） <span class="attr">--</span>&gt;</span></span><br><span class="line">    stale-check=&quot;true&quot;               <span class="comment">&lt;!-- 启用陈旧节点检查 --&gt;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>自定义健康检查（高级）</strong></p>
<p><strong>步骤</strong>：</p>
<ol>
<li><p>实现<code>HealthChecker</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbHealthChecker</span> <span class="keyword">implements</span> <span class="title class_">HealthChecker</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHealthy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkDatabaseConnection(); <span class="comment">// 自定义检查逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SPI 注册（在<code>META-INF/dubbo/org.apache.dubbo.health.HealthChecker</code>文件添加）：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dbHealth</span>=<span class="string">com.example.DbHealthChecker</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>监控与运维建议</strong></p>
<ul>
<li><strong>日志监控</strong>：关注<code>HeartbeatFailedEvent</code>告警日志</li>
<li><strong>组合策略</strong>：<ul>
<li>生产环境建议同时启用 <strong>心跳检测</strong> + <strong>注册中心剔除</strong></li>
<li>关键服务补充 <strong>接口级检查</strong>（如数据库&#x2F;缓存连接）</li>
</ul>
</li>
<li><strong>压测注意</strong>：高频心跳可能增加注册中心负载，需调整<code>heartbeat</code>参数平衡敏感度与性能</li>
</ul>
<h3 id="【中等】Dubbo-有哪些集群容错策略？"><a href="#【中等】Dubbo-有哪些集群容错策略？" class="headerlink" title="【中等】Dubbo 有哪些集群容错策略？"></a>【中等】Dubbo 有哪些集群容错策略？</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg" alt="Dubbo 容错"></p>
<p>图中节点关系说明：</p>
<ul>
<li>这里的 <code>Invoker</code> 是 <code>Provider</code> 的一个可调用 <code>Service</code> 的抽象，<code>Invoker</code> 封装了 <code>Provider</code> 地址及 <code>Service</code> 接口信息</li>
<li><code>Directory</code> 代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更</li>
<li><code>Cluster</code> 将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code>，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个</li>
<li><code>Router</code> 负责从多个 <code>Invoker</code> 中按路由规则选出子集，比如读写分离，应用隔离等</li>
<li><code>LoadBalance</code> 负责从多个 <code>Invoker</code> 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选</li>
</ul>
<p>Dubbo 支持的容错策略：</p>
<ul>
<li><strong>Failover</strong> - <strong>失败自动切换</strong>。当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数（不含第一次）。</li>
<li><strong>Failfast</strong> - <strong>快速失败</strong>。只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe</strong> - <strong>失败安全</strong>。出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback</strong> - <strong>失败自动恢复</strong>。后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li><strong>Forking</strong> - <strong>并行调用多个服务器</strong>。只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</li>
<li><strong>Broadcast</strong> - <strong>广播调用所有提供者</strong>。逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<p>集群容错配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="可观测"><a href="#可观测" class="headerlink" title="可观测"></a>可观测</h2><h3 id="【中等】Dubbo-提供了哪些监控能力？"><a href="#【中等】Dubbo-提供了哪些监控能力？" class="headerlink" title="【中等】Dubbo 提供了哪些监控能力？"></a>【中等】Dubbo 提供了哪些监控能力？</h3><p>Dubbo 内部维护了多个纬度的可观测指标，并且支持多种方式的可视化监测。可观测性指标从总体上来说分为三个度量纬度：</p>
<ul>
<li><strong>Admin</strong> - Admin 控制台可视化展示了集群中的应用、服务、实例及依赖关系，支持流量治理规则下发，同时还提供如服务测试、mock、文档管理等提升研发测试效率的工具。</li>
<li><strong>Metrics</strong> - Dubbo 统计了一系列的流量指标如 QPS、RT、成功请求数、失败请求数等，还包括一系列的内部组件状态如线程池数、服务健康状态等。</li>
<li><strong>Tracing</strong> - Dubbo 与业界主流的链路追踪工作做了适配，包括 Skywalking、Zipkin、Jaeger 都支持 Dubbo 服务的链路追踪。</li>
<li><strong>Logging</strong> - Dubbo 支持多种日志框架适配。以 Java 体系为例，支持包括 Slf4j、Log4j2、Log4j、Logback、Jcl 等，用户可以基于业务需要选择合适的框架；同时 Dubbo 还支持 Access Log 记录请求踪迹。</li>
</ul>
<h3 id="【中等】Dubbo-的-Monitor-是如何工作的？"><a href="#【中等】Dubbo-的-Monitor-是如何工作的？" class="headerlink" title="【中等】Dubbo 的 Monitor 是如何工作的？"></a>【中等】Dubbo 的 Monitor 是如何工作的？</h3><p>Dubbo Monitor 在设计上兼顾低侵入性、高性能、实时性。</p>
<p><strong>核心职责</strong></p>
<ul>
<li><strong>数据采集</strong>：通过<code>MonitorFilter</code>拦截每次服务调用，记录：调用次数、调用时间、耗时、成功数、失败数、异常等信息。</li>
<li><strong>数据上报</strong>：采用非阻塞方式上报统计信息到监控中心，避免影响业务性能。</li>
<li><strong>存储和分析</strong>：监控中心可以是第三方监控系统，如：Zabbix、Prometheus 或 Dubbo 内置的轻量级实现，持久化存储数据。</li>
<li><strong>可视化</strong>：可视化可以选择 Dubbo 提供的轻量级实现 Dubbo Admin，也可以集成第三方可视化 Dashboard。</li>
</ul>
<p><strong>关键组件</strong></p>
<ul>
<li><strong>MonitorFilter</strong><ul>
<li><strong>调用前</strong>：记录开始时间。</li>
<li><strong>调用后</strong>：计算耗时，封装监控数据（成功&#x2F;失败状态）。</li>
<li><strong>上报</strong>：通过<code>MonitorProtocol</code>异步发送数据。</li>
</ul>
</li>
<li><strong>MonitorProtocol</strong>：专为监控设计的轻量协议，支持批量上报，降低网络开销。</li>
</ul>
<p><strong>高可用与扩展</strong></p>
<ul>
<li><strong>多实例部署</strong>：监控中心集群化，避免单点故障。</li>
<li><strong>弹性扩展</strong>：采用分布式存储（如 ES、时序数据库）应对高流量。</li>
</ul>
<p><strong>监控数据流</strong></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务调用 → MonitorFilter 拦截 → 记录指标 → 异步上报 → <span class="literal">Monitor</span> 中心 → 存储 → 可视化</span><br></pre></td></tr></table></figure>

<h3 id="【困难】如何在-Dubbo-中处理服务调用链路追踪？"><a href="#【困难】如何在-Dubbo-中处理服务调用链路追踪？" class="headerlink" title="【困难】如何在 Dubbo 中处理服务调用链路追踪？"></a>【困难】如何在 Dubbo 中处理服务调用链路追踪？</h3><p><strong>核心实现步骤</strong></p>
<ol>
<li><p><strong>集成追踪框架</strong></p>
<ul>
<li>选择 SkyWalking&#x2F;Zipkin&#x2F;Jaeger 等工具</li>
</ul>
</li>
</ol>
<ul>
<li>添加对应依赖（如<code>skywalking-agent.jar</code>）</li>
</ul>
<ol start="2">
<li><p><strong>配置 Dubbo 过滤器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局启用追踪过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">filter</span>=<span class="string">&quot;tracingFilter&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">filter</span>=<span class="string">&quot;tracingFilter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现追踪过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &#123;PROVIDER, CONSUMER&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TracingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 1. 从 invocation 获取/生成 TraceID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> getOrCreateTraceId(inv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 记录开始时间（RPC 上下文/ThreadLocal）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 传递追踪上下文（通过 RpcContext）</span></span><br><span class="line">            RpcContext.getContext().setAttachment(<span class="string">&quot;traceId&quot;</span>, traceId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 执行实际调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 上报追踪数据</span></span><br><span class="line">            report(traceId, inv, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键设计要点</strong></p>
<ol>
<li><p><strong>上下文传播</strong></p>
<ul>
<li>通过<code>RpcContext</code>传递<code>TraceID</code>和<code>SpanID</code></li>
<li>跨服务时自动携带 HTTP Headers&#x2F;Dubbo Attachments</li>
</ul>
</li>
<li><p><strong>异步上报</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用异步线程池上报</span></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    tracer.report(<span class="keyword">new</span> <span class="title class_">Span</span>(traceId, duration));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>采样控制</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在配置文件中控制采样率</span></span><br><span class="line"><span class="attr">dubbo.tracing.sample-rate</span>=<span class="string">0.1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>主流方案对比</strong></p>
<table>
<thead>
<tr>
<th>框架</th>
<th>数据存储</th>
<th>可视化</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>SkyWalking</td>
<td>ES&#x2F;H2</td>
<td>原生 UI</td>
<td>零侵入、APM 集成度高</td>
</tr>
<tr>
<td>Zipkin</td>
<td>Cassandra&#x2F;ES</td>
<td>Zipkin UI</td>
<td>轻量级、部署简单</td>
</tr>
<tr>
<td>Jaeger</td>
<td>Cassandra&#x2F;Kafka</td>
<td>Jaeger UI</td>
<td>Uber 开源、支持大规模集群</td>
</tr>
</tbody></table>
<p><strong>生产建议</strong></p>
<ol>
<li><p><strong>性能优化</strong></p>
<ul>
<li>采用异步批量上报（如 Jaeger 的 gRPC reporter）</li>
<li>对高频服务启用采样（1%~10%）</li>
</ul>
</li>
<li><p><strong>异常处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 标记错误 span</span></span><br><span class="line">    span.tag(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展功能</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加自定义标签</span></span><br><span class="line">span.tag(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;north-1&quot;</span>);</span><br><span class="line"><span class="comment">// 记录业务指标</span></span><br><span class="line">span.log(<span class="string">&quot;order_amount&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>注</strong>：新版 Dubbo 已内置 Tracing 支持，可通过<code>dubbo-spring-boot-starter</code>快速集成，推荐优先使用官方方案。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo Github</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/design/">Dubbo 框架设计</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/14f9d9b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/14f9d9b0/" class="post-title-link" itemprop="url">Java 虚拟机面试二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-30 06:33:26" itemprop="dateCreated datePublished" datetime="2025-04-30T06:33:26+08:00">2025-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-虚拟机面试二"><a href="#Java-虚拟机面试二" class="headerlink" title="Java 虚拟机面试二"></a>Java 虚拟机面试二</h1><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="【困难】如何判断-Java-对象是否可以被回收？"><a href="#【困难】如何判断-Java-对象是否可以被回收？" class="headerlink" title="【困难】如何判断 Java 对象是否可以被回收？"></a>【困难】如何判断 Java 对象是否可以被回收？</h3><p>判断 Java 对象是否可以被回收有两种方法：</p>
<ul>
<li>引用计数法</li>
<li>可达性分析法</li>
</ul>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>引用计数算法<strong>简单高效</strong>，但是<strong>存在循环引用问题</strong>——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为循环引用的存在，所以 <strong>Java 虚拟机不适用引用计数算法</strong>。</p>
<h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>通过 <strong>GC Roots</strong> 作为起始点进行搜索，JVM 将能够到达到的对象视为<strong>存活</strong>，不可达的对象视为<strong>死亡</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-root.png"></p>
<p><strong>可作为 GC Roots 的对象</strong>包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象（如当前方法局部变量）。</li>
<li>本地方法栈（JNI）中引用的 Native 对象。</li>
<li>方法区中静态属性（<code>static</code>字段）引用的对象。</li>
<li>方法区中常量（<code>final</code>常量）引用的对象。</li>
</ul>
<h4 id="方法区的回收条件"><a href="#方法区的回收条件" class="headerlink" title="方法区的回收条件"></a>方法区的回收条件</h4><p>主要回收<strong>废弃常量</strong>和<strong>不再使用的类</strong>。</p>
<p>不再使用的类定义如下：</p>
<ul>
<li>Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已被回收。</li>
<li>该类对应的 <code>Class</code> 对象无任何地方引用（如反射）。</li>
</ul>
<p>以上为<strong>类卸载必要条件，且全部满足也不一定被卸载</strong>。</p>
<h4 id="常见内存泄漏场景"><a href="#常见内存泄漏场景" class="headerlink" title="常见内存泄漏场景"></a>常见内存泄漏场景</h4><p><strong>内存泄漏的本质是对象无法回收</strong>，常见的有以下情况：</p>
<ul>
<li>静态容器（如 <code>static HashMap</code>）持有对象。</li>
<li>未关闭的资源（如数据库连接、流）。</li>
<li>监听器未注销。</li>
<li>不合理使用 <code>finalize()</code> 导致对象复活。</li>
</ul>
<h3 id="【中等】为什么不建议使用-finalize-？"><a href="#【中等】为什么不建议使用-finalize-？" class="headerlink" title="【中等】为什么不建议使用 finalize()？"></a>【中等】为什么不建议使用 finalize()？</h3><p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。<code>finalize()</code> 方法是 Java 提供的对象被垃圾回收前最后的自救机会（在 GC 时被调用一次）。</p>
<ul>
<li><strong>调用时机</strong>：对象被标记为垃圾后、实际回收前，由 JVM 的垃圾回收线程触发（不保证立即执行）。</li>
<li><strong>自救机制</strong>：在 <code>finalize()</code> 中重新让对象被引用（如赋值给静态变量），可避免本次回收。</li>
<li><strong>风险</strong>：<ul>
<li><strong>执行时机不确定，可能永远不调用</strong>。</li>
<li><strong>性能差（延迟回收），易导致内存泄漏</strong>。</li>
</ul>
</li>
</ul>
<p>**不要使用 finalize()**！在 Java 9 后，<code>finalize()</code> 直接被标记为 <code>@Deprecated</code>。推荐用 <code>try-with-resources</code> 或显式调用 <code>close()</code> 管理资源。</p>
<h3 id="【中等】Java-对象有哪些引用类型？"><a href="#【中等】Java-对象有哪些引用类型？" class="headerlink" title="【中等】Java 对象有哪些引用类型？"></a>【中等】Java 对象有哪些引用类型？</h3><p>在 Java 中，对象的引用类型决定了它们如何被垃圾回收（GC）处理，主要分为 <strong>4 种引用类型</strong>，按强度从高到低排列如下：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>回收时机</th>
<th>是否可获取对象（<code>get()</code>）</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>永不回收（除非显式置空）</td>
<td>是</td>
<td>常规对象</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时</td>
<td>是</td>
<td>缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>GC 运行时</td>
<td>是</td>
<td>避免内存泄漏（如 <code>WeakHashMap</code>）</td>
</tr>
<tr>
<td>虚引用</td>
<td>GC 运行时</td>
<td>否</td>
<td>对象回收跟踪（如堆外内存管理）</td>
</tr>
</tbody></table>
<p><strong>（1）强引用（Strong Reference）</strong></p>
<p><strong>被强引用关联的对象不会被垃圾收集器回收。</strong></p>
<p>强引用：使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br></pre></td></tr></table></figure>

<p><strong>回收条件</strong>：当 <code>obj = null</code> 或超出作用域时，对象变为可回收状态。</p>
<p><strong>（2）软引用（Soft Reference）</strong></p>
<p><strong>被软引用关联的对象，只有在内存不够的情况下才会被回收。</strong></p>
<p>软引用：使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> softRef.get(); <span class="comment">// 可能返回 null（如果被回收）</span></span><br></pre></td></tr></table></figure>

<p><strong>用途</strong>：适合实现缓存（如图片缓存）。</p>
<p><strong>（3）弱引用（Weak Reference）</strong></p>
<p><strong>被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。</strong></p>
<p>使用 <code>WeakReference</code> 类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.gc();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> weakRef.get(); <span class="comment">// 通常返回 null</span></span><br></pre></td></tr></table></figure>

<p><strong>用途</strong>：适合临时缓存（如 <code>WeakHashMap</code> 的键）、避免内存泄漏。</p>
<p><strong>（4）虚引用（Phantom Reference）</strong></p>
<p>虚引用又称为幽灵引用或者幻影引用。</p>
<p>无法通过虚引用获取对象（<code>get()</code> 始终返回 <code>null</code>）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p>使用 <code>PhantomReference</code> 来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line">System.gc();</span><br><span class="line">Reference&lt;?&gt; ref = queue.poll(); <span class="comment">// 不为 null 说明对象被回收</span></span><br></pre></td></tr></table></figure>

<p><strong>用途</strong>：管理堆外内存（如 NIO 的 <code>DirectByteBuffer</code>）。</p>
<p><strong>对比</strong>：</p>
<ol>
<li><strong>强引用</strong>是默认方式，其他引用需显式使用 <code>java.lang.ref</code> 包下的类。</li>
<li><strong>软引用 vs 弱引用</strong>：<ul>
<li>软引用适合保留缓存直到内存紧张；</li>
<li>弱引用立即释放，避免内存泄漏。</li>
</ul>
</li>
<li><strong>虚引用</strong>的唯一用途是关联 <code>ReferenceQueue</code>，用于对象回收后的通知。</li>
</ol>
<p>通过合理选择引用类型，可以优化内存管理并避免内存泄漏问题。</p>
<h3 id="【中等】Java-中有哪些垃圾回收算法？"><a href="#【中等】Java-中有哪些垃圾回收算法？" class="headerlink" title="【中等】Java 中有哪些垃圾回收算法？"></a>【中等】Java 中有哪些垃圾回收算法？</h3><p>Java 中的垃圾回收（GC）算法主要分为以下几类，每种算法针对不同的场景和内存区域（如年轻代、老年代）进行优化。</p>
<p>垃圾收集的性能指标主要有两点：</p>
<ul>
<li><strong>停顿时间</strong> - 停顿时间是因为 GC 而导致程序不能工作的时间长度。</li>
<li><strong>吞吐量</strong> - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。</li>
</ul>
<p>以下是核心算法及其特点的概括：</p>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-sweep.jpg"></p>
<ul>
<li><strong>原理</strong>：<ol>
<li><strong>标记</strong>：从 GC Roots 出发，标记所有可达对象。</li>
<li><strong>清除</strong>：遍历堆内存，回收未被标记的对象。</li>
</ol>
</li>
<li><strong>缺点</strong>：<ul>
<li>产生<strong>内存碎片</strong>（不连续空间），可能导致大对象分配失败。</li>
<li>效率较低（需遍历全堆）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：老年代（如 CMS 回收器的初始阶段）。</li>
</ul>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-compact.jpg"></p>
<ul>
<li><strong>原理</strong>：<ol>
<li><strong>标记</strong>：与标记-清除相同，标记可达对象。</li>
<li><strong>整理</strong>：将存活对象向内存一端移动，清理边界外空间。</li>
</ol>
</li>
<li><strong>优点</strong>：避免内存碎片。</li>
<li><strong>缺点</strong>：移动对象开销大（需更新引用地址）。</li>
<li><strong>适用场景</strong>：适合<strong>老年代</strong>，对象存活率高（如 Serial Old、Parallel Old 回收器）。</li>
</ul>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-copying.jpg"></p>
<ul>
<li><strong>原理</strong>：<ul>
<li>将内存分为两块（<code>From</code> 和 <code>To</code> 空间），每次只使用一块。</li>
<li>GC 时将存活对象从 <code>From</code> 复制到 <code>To</code> 空间，并清空 <code>From</code>。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>无内存碎片。</li>
<li>高效（仅复制存活对象）。</li>
</ul>
</li>
<li><strong>缺点</strong>：内存利用率仅 50%（需预留一半空间）。</li>
<li><strong>适用场景</strong>：年轻代（如 Serial、ParNew 等回收器），因年轻代对象存活率低。</li>
<li><strong>优化</strong>：实际 JVM 将年轻代分为 <strong>Eden</strong> 和 <strong>Survivor（From&#x2F;To）</strong> 区（比例通常为 <code>8:1:1</code>），通过多次复制到 Survivor 区避免浪费。</li>
</ul>
<h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p><strong>分代收集是 JVM 在吞吐量、延迟和内存占用之间找到的经典平衡点</strong>，而新一代 GC 则通过更复杂的并发机制尝试突破其限制。</p>
<p><strong>跨代引用处理</strong>：使用<strong>记忆集</strong>（<strong>Remembered Set</strong>）记录老年代对年轻代的引用，避免全堆扫描。</p>
<p>根据对象存活周期将堆分为<strong>年轻代</strong>和<strong>老年代</strong>，对不同区域采用不同算法：</p>
<ul>
<li><strong>年轻代</strong>：复制算法（因对象朝生夕死，存活率低）。</li>
<li><strong>老年代</strong>：标记-清除或标记-整理（因对象存活率高）。</li>
<li><strong>永久代</strong>：这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存。在 JDK 8 之后就不存在永久代这块儿了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png"></p>
<h4 id="分区算法（Region-Based）"><a href="#分区算法（Region-Based）" class="headerlink" title="分区算法（Region-Based）"></a>分区算法（Region-Based）</h4><ul>
<li><strong>原理</strong>：将堆划分为多个独立区域（如 G1 的 <strong>Region</strong>），优先回收垃圾最多的区域。</li>
<li><strong>优点</strong>：<ul>
<li>控制每次回收的区域数量，减少停顿时间（<strong>STW</strong>）。</li>
<li>适合大内存应用（如 G1、ZGC、Shenandoah）。</li>
</ul>
</li>
</ul>
<h4 id="增量算法（Incremental）"><a href="#增量算法（Incremental）" class="headerlink" title="增量算法（Incremental）"></a>增量算法（Incremental）</h4><ul>
<li><strong>目标</strong>：减少单次 GC 停顿时间，通过分阶段执行 GC 与用户线程交替运行。</li>
<li><strong>缺点</strong>：<ul>
<li>线程切换开销大，整体吞吐量可能下降。</li>
</ul>
</li>
<li><strong>现代实现</strong>：如 CMS 的并发标记阶段。</li>
</ul>
<h4 id="常见垃圾回收器与算法对应"><a href="#常见垃圾回收器与算法对应" class="headerlink" title="常见垃圾回收器与算法对应"></a>常见垃圾回收器与算法对应</h4><table>
<thead>
<tr>
<th>回收器</th>
<th>新生代算法</th>
<th>老年代算法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>复制</td>
<td>标记-整理</td>
<td>单线程，STW 时间长。</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>复制</td>
<td>标记-整理</td>
<td>Serial 的多线程版。</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>复制</td>
<td>标记-整理</td>
<td>吞吐量优先。</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>-</td>
<td>标记-清除（并发）</td>
<td>低延迟，但内存碎片多。</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>复制 + 分区</td>
<td>标记-整理 + 分区</td>
<td>兼顾吞吐与延迟，Region 分区。</td>
</tr>
<tr>
<td><strong>ZGC&#x2F;Shenandoah</strong></td>
<td>复制 + 分区</td>
<td>标记-整理 + 分区</td>
<td>亚毫秒级停顿，并发标记&#x2F;整理。</td>
</tr>
</tbody></table>
<p>现代 JVM 趋向于使用<strong>分代+分区+并发</strong>的复合算法（如 G1），在吞吐量和延迟之间取得平衡。</p>
<h3 id="【中等】Java-中常见的垃圾收集器有哪些？"><a href="#【中等】Java-中常见的垃圾收集器有哪些？" class="headerlink" title="【中等】Java 中常见的垃圾收集器有哪些？"></a>【中等】Java 中常见的垃圾收集器有哪些？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-overview.jpg" alt="img"></p>
<p>以下是 Java 主要垃圾收集器的详细对比表格，涵盖算法、特点、适用场景和关键参数：</p>
<table>
<thead>
<tr>
<th><strong>垃圾收集器</strong></th>
<th><strong>分类</strong></th>
<th><strong>算法</strong></th>
<th><strong>目标</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>JDK 版本</strong></th>
<th><strong>启用参数</strong></th>
<th><strong>优缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial GC</strong></td>
<td>串行</td>
<td>新生代：复制<br>老年代：标记-整理</td>
<td>简单低开销</td>
<td>单核、客户端应用、小堆</td>
<td>所有版本</td>
<td><code>-XX:+UseSerialGC</code></td>
<td>✅ 内存占用小<br>❌ 全程 STW，延迟高</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行（吞吐优先）</td>
<td>新生代：复制</td>
<td>高吞吐量</td>
<td>后台计算、多核大堆</td>
<td>JDK 1.4+</td>
<td><code>-XX:+UseParallelGC</code></td>
<td>✅ 吞吐量高<br>❌ 停顿时间较长</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行（吞吐优先）</td>
<td>老年代：标记-整理</td>
<td>配合 Parallel Scavenge</td>
<td>与 Parallel Scavenge 搭配使用</td>
<td>JDK 6+</td>
<td><code>-XX:+UseParallelOldGC</code></td>
<td>✅ 老年代并行回收<br>❌ 仍以吞吐优先，延迟较高</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代：复制</td>
<td>低停顿（与 CMS 配合）</td>
<td>需与 CMS 搭配的多核环境</td>
<td>JDK 1.4+</td>
<td><code>-XX:+UseParNewGC</code></td>
<td>✅ 多线程版 Serial GC<br>❌ 仅新生代，需搭配 CMS</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发（低延迟）</td>
<td>老年代：标记-清除</td>
<td>最小化停顿时间</td>
<td>老年代低延迟应用</td>
<td>JDK 1.4-14</td>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>✅ 并发收集，低停顿<br>❌ 内存碎片、并发模式失败风险</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>分区+并发</td>
<td>标记-整理（分 Region）</td>
<td>平衡吞吐与延迟</td>
<td>大堆（数十 GB）、JDK 8+ 默认</td>
<td>JDK 7+（JDK 9+默认）</td>
<td><code>-XX:+UseG1GC</code></td>
<td>✅ 可预测停顿、大堆友好<br>❌ 内存占用略高</td>
</tr>
<tr>
<td><strong>ZGC</strong></td>
<td>并发</td>
<td>染色指针+读屏障</td>
<td>亚毫秒级停顿（&lt;10ms）</td>
<td>超大堆（TB 级）、云原生</td>
<td>JDK 11+</td>
<td><code>-XX:+UseZGC</code></td>
<td>✅ 极低停顿、堆大小几乎无限制<br>❌ JDK 11+ 支持，兼容性要求高</td>
</tr>
<tr>
<td><strong>Shenandoah</strong></td>
<td>并发</td>
<td>转发指针+读屏障</td>
<td>低延迟（与 ZGC 竞争）</td>
<td>Red Hat 系、低延迟大堆</td>
<td>JDK 12+</td>
<td><code>-XX:+UseShenandoahGC</code></td>
<td>✅ 并发压缩、无停顿扩展<br>❌ 非 Oracle 官方默认</td>
</tr>
</tbody></table>
<p><strong>关键对比维度</strong></p>
<ul>
<li><strong>吞吐量</strong>：Parallel GC（Parallel Scavenge + Parallel Old）最优。</li>
<li><strong>延迟</strong>：ZGC&#x2F;Shenandoah &lt; G1 &lt; CMS &lt; Parallel GC。</li>
<li><strong>堆大小</strong>：<ul>
<li>小堆（&lt;4GB）：Serial GC &#x2F; Parallel GC。</li>
<li>大堆（4GB~数十 GB）：G1。</li>
<li>超大堆（TB 级）：ZGC&#x2F;Shenandoah。</li>
</ul>
</li>
<li><strong>版本兼容性</strong>：<ul>
<li>JDK 8：默认 Parallel GC，可选 G1&#x2F;CMS（CMS 已废弃）。</li>
<li>JDK 11+：默认 G1，可选 ZGC&#x2F;Shenandoah。</li>
</ul>
</li>
</ul>
<p><strong>选择建议</strong></p>
<ul>
<li><strong>常规服务端应用</strong>：JDK 8 用 <code>G1</code>，JDK 11+ 用 <code>ZGC</code>（若需超低延迟）。</li>
<li><strong>批处理任务</strong>：<code>Parallel GC</code>（高吞吐优先）。</li>
<li><strong>资源受限环境</strong>：<code>Serial GC</code>（如嵌入式设备）。</li>
<li><strong>兼容性测试</strong>：JDK 11+ 可试用 <code>Shenandoah</code>（非 Oracle 官方构建需注意）。</li>
</ul>
<p>通过此表格可快速定位适合业务需求的 GC 组合。</p>
<h3 id="【困难】为什么-Java-8-移除了永久代（PermGen）并引入了元空间（Metaspace）？"><a href="#【困难】为什么-Java-8-移除了永久代（PermGen）并引入了元空间（Metaspace）？" class="headerlink" title="【困难】为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？"></a>【困难】为什么 Java 8 移除了永久代（PermGen）并引入了元空间（Metaspace）？</h3><p>Java 8 用元空间替代永久代，解决了 PermGen 固定大小易导致内存溢出和垃圾回收效率低的问题。元空间使用本地内存，具备更灵活的内存分配能力，提升了垃圾收集和内存管理的效率。</p>
<p><strong>永久代（PermGen）的主要问题</strong></p>
<ul>
<li><strong>固定大小限制</strong>：永久代大小通过 <code>-XX:MaxPermSize</code> 设定，默认较小（64MB~128MB），易触发 <code>OutOfMemoryError: PermGen space</code>，尤其是动态加载类过多时（如频繁部署的 Web 应用）。</li>
<li><strong>垃圾回收效率低</strong>：永久代与老年代共用垃圾回收机制（Full GC 时才会回收），类卸载条件苛刻（需类加载器被回收）。</li>
<li><strong>内存管理不灵活</strong>：永久代在 JVM 堆内分配，与对象堆共享内存空间，易导致堆内存碎片化。</li>
</ul>
<p><strong>元空间（Metaspace）的优势</strong></p>
<ul>
<li><strong>使用本地内存（Native Memory）</strong>：元空间直接分配在操作系统的本地内存中，默认无上限（仅受系统物理内存限制），避免 <code>PermGen</code> 大小硬限制问题。可通过 <code>-XX:MaxMetaspaceSize</code> 设置上限（如不设置则动态扩展）。</li>
<li><strong>自动调整大小</strong>：元空间可以根据需要自动扩展大小，从而降低了 OOM 的风险。</li>
<li><strong>性能优化</strong>：元空间由于在堆外，因此减少了 Full GC 触发频率。避免了频繁回收 PermGen 时的停顿。</li>
</ul>
<p><strong>永久代 vs. 元空间</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>永久代（PermGen）</strong></th>
<th><strong>元空间（Metaspace）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>JVM 堆内存</td>
<td>本地内存（Native Memory）</td>
</tr>
<tr>
<td><strong>大小限制</strong></td>
<td><code>-XX:MaxPermSize</code> 固定上限</td>
<td>默认无上限，可设 <code>-XX:MaxMetaspaceSize</code></td>
</tr>
<tr>
<td><strong>垃圾回收</strong></td>
<td>依赖 Full GC</td>
<td>独立回收，条件更宽松</td>
</tr>
<tr>
<td><strong>OOM 错误</strong></td>
<td><code>OutOfMemoryError: PermGen space</code></td>
<td><code>OutOfMemoryError: Metaspace</code></td>
</tr>
</tbody></table>
<h3 id="【困难】Java-中的-Young-GC、Old-GC、Full-GC-和-Mixed-GC-的区别是什么？"><a href="#【困难】Java-中的-Young-GC、Old-GC、Full-GC-和-Mixed-GC-的区别是什么？" class="headerlink" title="【困难】Java 中的 Young GC、Old GC、Full GC 和 Mixed GC 的区别是什么？"></a>【困难】Java 中的 Young GC、Old GC、Full GC 和 Mixed GC 的区别是什么？</h3><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p><strong>Young GC 又称为 YGC 或 Minor GC，即年轻代垃圾回收</strong>。</p>
<ul>
<li><strong>目标</strong>：高效回收短期对象，减少全局停顿时间，避免频繁扫描老年代。</li>
<li><strong>作用范围</strong>：仅回收 <strong>年轻代</strong>（Eden + Survivor 区，即 S0&#x2F;S1）。</li>
<li><strong>触发条件</strong>：当年轻代内存（尤其是 Eden 区）被填满时触发。<ul>
<li><strong>Eden 区空间不足</strong>：新对象优先分配在 Eden 区，Eden 满时触发 YGC。</li>
<li><strong>Eden + Survivor 区空间不足</strong>：若 Eden + Survivor 区无法容纳存活对象，触发 YGC，部分对象可能直接晋升老年代。</li>
<li><strong>Full GC 前置操作</strong>：如 Parallel Scavenge，默认在 Full GC 前先执行 YGC（可通过 <code>-XX:+ScavengeBeforeFullGC</code> 控制）。</li>
</ul>
</li>
<li><strong>关键机制</strong><ul>
<li><strong>对象分配</strong>：新对象优先分配在 Eden 区。</li>
<li><strong>对象晋升</strong>：<ul>
<li>年龄阈值：<code>-XX:MaxTenuringThreshold</code>（默认 15）。</li>
<li><strong>提前晋升</strong>：若 Survivor 区空间不足，存活对象直接进入老年代。</li>
</ul>
</li>
<li><strong>复制算法</strong>：存活对象在 Eden 和 Survivor 区间拷贝，清空原区域。</li>
</ul>
</li>
<li><strong>特点</strong><ul>
<li><strong>回收速度快</strong>（通常毫秒级），但会触发 STW。</li>
<li><strong>高效回收</strong>：针对短期对象，减少老年代扫描。</li>
</ul>
</li>
<li><strong>要点</strong><ul>
<li><strong>Survivor 区溢出</strong>：存活对象过多时，直接晋升老年代，可能引发老年代积压。</li>
<li><strong>与 Full GC 的关系</strong>：Minor GC 前会检查老年代剩余空间，若不足可能触发 <strong>Full GC</strong>（取决于 GC 策略）。</li>
</ul>
</li>
<li><strong>参数</strong><ul>
<li><code>-XX:MaxTenuringThreshold=15</code>：晋升老年代的年龄阈值。</li>
<li><code>-XX:SurvivorRatio=8</code>：Eden 区与单个 Survivor 区的比例（默认 8:1:1）。</li>
</ul>
</li>
</ul>
<h4 id="Old-GC"><a href="#Old-GC" class="headerlink" title="Old GC"></a>Old GC</h4><p><strong>Old GC (Major GC 或 OGC) ，老年代垃圾回收</strong></p>
<ul>
<li>作用范围：只针对老年代。</li>
<li>触发条件：当老年代空间不足时触发，通常是当从年轻代晋升到老年代的对象过多，或者老年代的存活对象数量达到一定阈值时。</li>
<li>执行方式：只回收老年代的对象，年轻代不受影响。</li>
<li>特点：执行时间比 Young GC 长，因为老年代中的对象存活时间更长，且数量较多。</li>
</ul>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p><strong>Full GC，全堆垃圾回收</strong></p>
<ul>
<li>作用范围：对整个堆内存（包括年轻代和老年代）进行回收。</li>
<li>触发条件：当老年代空间不足且无法通过老年代垃圾回收释放足够空间，或其他情况导致系统内存压力较大时触发（如 System.gc () 调用）。</li>
<li>执行方式：回收所有代（年轻代、老年代）中的垃圾，并且可能会伴随着元空间的回收。</li>
<li>特点：回收时间最长，会触发整个 JVM 的停顿（Stop - The - World），对性能有较大影响，通常不希望频繁发生。</li>
</ul>
<p><strong>Full GC</strong> 是对整个 <strong>Java 堆（年轻代 + 老年代）</strong> 和 <strong>方法区（元空间&#x2F;Metaspace）</strong> 进行垃圾回收，部分收集器还会回收直接内存（如 ZGC）。</p>
<p><strong>Full GC 特点</strong>：</p>
<ul>
<li><strong>Stop-The-World（STW）</strong> 时间较长（秒级），对性能影响显著。</li>
<li>回收算法因 GC 类型而异（如 Serial Old 使用标记-整理，CMS 使用并发标记-清除）。</li>
</ul>
<p><strong>Full GC 触发条件</strong></p>
<table>
<thead>
<tr>
<th><strong>触发条件</strong></th>
<th><strong>具体原因</strong></th>
<th><strong>关联参数&#x2F;备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>老年代空间不足</strong></td>
<td>老年代无法通过垃圾回收释放足够空间，无法容纳新晋升的对象</td>
<td><code>-Xmx</code>（老年代最大值）、<code>-XX:CMSInitiatingOccupancyFraction</code>（CMS 触发阈值）</td>
</tr>
<tr>
<td><strong>永久代&#x2F;元空间不足</strong></td>
<td>Java 7 及之前：永久代（PermGen）耗尽<br>Java 8+：元空间（Metaspace）超过阈值</td>
<td><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code>（Java 8+）</td>
</tr>
<tr>
<td><strong>显式调用 System.gc()</strong></td>
<td>代码调用 <code>System.gc()</code> 或通过 <code>jmap -dump</code> 等工具触发（不保证立即执行）</td>
<td><code>-XX:+DisableExplicitGC</code>（禁用显式 GC）</td>
</tr>
<tr>
<td><strong>空间分配担保失败</strong></td>
<td>年轻代晋升时，老年代剩余空间不足（<code>Promotion Failed</code>）</td>
<td><code>-XX:HandlePromotionFailure</code>（JDK 6u24 后默认启用）</td>
</tr>
<tr>
<td><strong>晋升老年代失败</strong></td>
<td>大对象或长期存活对象直接进入老年代，但老年代空间不足</td>
<td><code>-XX:PretenureSizeThreshold</code>（大对象直接晋升阈值）</td>
</tr>
<tr>
<td><strong>平均晋升大小预测失败</strong></td>
<td>Young GC 前，统计发现历史平均晋升大小 &gt; 老年代当前剩余空间</td>
<td>依赖 JVM 自适应策略（如 <code>-XX:+UseAdaptiveSizePolicy</code>）</td>
</tr>
</tbody></table>
<p><strong>减少 Full GC 的优化策略</strong></p>
<table>
<thead>
<tr>
<th><strong>优化方向</strong></th>
<th><strong>具体措施</strong></th>
<th><strong>关键参数示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调整堆内存</strong></td>
<td>增大堆大小，避免老年代频繁耗尽</td>
<td><code>-Xms4g -Xmx4g</code>（初始和最大堆一致，避免动态扩容）</td>
</tr>
<tr>
<td><strong>增大年轻代比例</strong></td>
<td>减少对象过早晋升到老年代</td>
<td><code>-XX:NewRatio=2</code>（老年代：新生代&#x3D;2:1）、<code>-Xmn2g</code>（直接设置年轻代大小）</td>
</tr>
<tr>
<td><strong>调整元空间大小</strong></td>
<td>避免元空间动态扩展触发 Full GC</td>
<td><code>-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m</code></td>
</tr>
<tr>
<td><strong>避免大对象直接晋升</strong></td>
<td>减少大对象分配或调整晋升阈值</td>
<td><code>-XX:PretenureSizeThreshold=1m</code>（&gt;1MB 对象直接进老年代）</td>
</tr>
<tr>
<td><strong>选择低延迟 GC 算法</strong></td>
<td>如 G1 或 ZGC，减少 Full GC 频率</td>
<td><code>-XX:+UseG1GC</code>、<code>-XX:+UseZGC</code></td>
</tr>
<tr>
<td><strong>监控与调优</strong></td>
<td>通过日志分析 Full GC 原因（如 <code>-XX:+PrintGCDetails</code>）</td>
<td><code>jstat -gcutil</code>、<code>jmap -histo</code> 等工具辅助定位问题。</td>
</tr>
</tbody></table>
<p><strong>常见表现与影响</strong></p>
<ul>
<li><strong>应用卡顿</strong>：STW 导致所有业务线程暂停（如接口超时、TPS 骤降）。</li>
<li><strong>频繁 Full GC</strong>：可能由内存泄漏、不合理对象分配或 JVM 参数配置不当引起（如 <code>-Xmx</code> 过小）。</li>
</ul>
<p><strong>优化建议</strong></p>
<ul>
<li><strong>避免内存泄漏</strong>：检查长生命周期对象（如缓存）是否无限制增长。</li>
<li><strong>调整 JVM 参数</strong>：<ul>
<li>增大老年代空间（<code>-Xmx</code> 和 <code>-Xms</code> 设为一致，避免动态扩容触发 GC）。</li>
<li>优化晋升阈值（<code>-XX:MaxTenuringThreshold</code>）。</li>
<li>使用更高效的 GC 器（如 G1&#x2F;ZGC 替代 CMS）。</li>
</ul>
</li>
<li><strong>禁用显式 GC</strong>：添加 <code>-XX:+DisableExplicitGC</code>。</li>
</ul>
<p><strong>关键参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>打印 GC 日志，分析 Full GC 原因</td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize=256m</code></td>
<td>设置元空间初始大小</td>
</tr>
<tr>
<td><code>-XX:CMSInitiatingOccupancyFraction=70</code></td>
<td>CMS 老年代占用率触发阈值</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：Full GC 是 JVM 内存回收的最后手段，触发条件复杂，需结合日志和监控定位根本原因，针对性优化堆大小、GC 策略或代码逻辑。</p>
<h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><p><strong>Mixed GC （仅适用于 G1 GC 的混合垃圾回收）</strong></p>
<ul>
<li>作用范围：同时回收年轻代和部分老年代区域。</li>
<li>触发条件：当 G1 垃圾回收器发现老年代区域的垃圾过多时触发。</li>
<li>执行方式：混合回收年轻代和部分老年代区域，主要目的是减少老年代中的垃圾积压。</li>
<li>特点：结合了 YGC 的快速回收和 OGC 的深度回收，尽量减少停顿时间，适用于大内存应用。</li>
</ul>
<h3 id="【困难】Java-的-CMS-垃圾回收流程是怎样的？"><a href="#【困难】Java-的-CMS-垃圾回收流程是怎样的？" class="headerlink" title="【困难】Java 的 CMS 垃圾回收流程是怎样的？"></a>【困难】Java 的 CMS 垃圾回收流程是怎样的？</h3><p>CMS 是一种以<strong>低延迟</strong>为目标的垃圾回收器，主要用于老年代回收，其核心流程分为四个阶段，其中两个阶段会触发 <strong>STW（Stop-The-World）</strong>，其余阶段与用户线程并发执行。</p>
<p>CMS 收集器运行步骤如下：</p>
<ol>
<li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li><strong>并发清除</strong>：回收在标记阶段被鉴定为不可达的对象。不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-cms.jpg"></p>
<p><strong>CMS 的缺陷与应对措施</strong></p>
<ul>
<li><strong>内存碎片</strong>：长期运行后可能触发 <strong>Full GC</strong>（压缩内存），通过 <code>-XX:CMSFullGCsBeforeCompaction</code> 设置压缩频率。</li>
<li><strong>并发模式失败（Concurrent Mode Failure）</strong>：<ul>
<li>老年代空间不足时，退化为 Serial Old 收集器（STW 时间更长）。</li>
<li>优化：调整 <code>-XX:CMSInitiatingOccupancyFraction</code>（默认 68%，建议 70-80%）。</li>
</ul>
</li>
<li><strong>浮动垃圾</strong>：需预留空间（通过 <code>-XX:+UseCMSInitiatingOccupancyOnly</code> 避免动态调整阈值）。</li>
</ul>
<h3 id="【困难】Java-的-G1-垃圾回收流程是怎样的？"><a href="#【困难】Java-的-G1-垃圾回收流程是怎样的？" class="headerlink" title="【困难】Java 的 G1 垃圾回收流程是怎样的？"></a>【困难】Java 的 G1 垃圾回收流程是怎样的？</h3><p>G1 通过分区和增量回收实现低延迟，兼顾吞吐量与内存碎片控制，是 JDK 9 后的默认垃圾回收器。</p>
<p><strong>核心设计思想</strong></p>
<ul>
<li><strong>分区（Region）模型</strong>：将堆划分为多个大小相等的 <strong>Region</strong>（默认约 2048 个），动态分代（逻辑区分 Eden&#x2F;Survivor&#x2F;Old&#x2F;Humongous 区）。</li>
<li><strong>停顿预测模型</strong>：根据用户设定的 <code>-XX:MaxGCPauseMillis</code>（默认 200ms），优先回收<strong>垃圾最多（Garbage-First）的 Region</strong>。</li>
<li><strong>并发标记</strong>：减少 STW 时间，但最终标记和拷贝阶段仍需停顿。</li>
<li><strong>混合回收</strong>：兼顾年轻代和老年代，避免 Full GC。</li>
<li><strong>适用场景</strong>：大堆内存（4GB+）、需平衡吞吐与延迟的应用（如 JDK9+默认 GC）。</li>
</ul>
<p>G1 的垃圾回收分为两大阶段：</p>
<ol>
<li><strong>并发标记阶段</strong>（Concurrent Marking，基于 SATB 算法）</li>
<li><strong>对象拷贝阶段</strong>（Evacuation，STW）</li>
</ol>
<h4 id="G1-并发标记阶段（SATB-Based）"><a href="#G1-并发标记阶段（SATB-Based）" class="headerlink" title="G1 并发标记阶段（SATB-Based）"></a>G1 并发标记阶段（SATB-Based）</h4><ol>
<li><strong>初始标记（Initial Marking，STW）</strong>：标记从 GC Roots 直接可达的对象。<ul>
<li>短暂 STW（Stop-The-World）。</li>
<li>使用**外部 Bitmap **记录存活对象（而非对象头）。</li>
<li>通常与年轻代回收（Young GC）同步触发。</li>
</ul>
</li>
<li><strong>并发标记（Concurrent Marking）</strong>：递归标记所有可达对象。<ul>
<li>与用户线程并发执行。</li>
<li>使用** SATB（Snapshot-At-The-Beginning）**算法记录标记过程中的引用变化（通过写屏障维护）。</li>
</ul>
</li>
<li><strong>最终标记（Final Marking，STW）</strong>：处理 SATB 队列中的引用变更，完成最终标记。<ul>
<li>短暂 STW。</li>
<li>修正并发标记期间漏标的对象。</li>
</ul>
</li>
<li><strong>清理阶段（Cleanup，STW）</strong><ul>
<li>统计每个 Region 的存活对象比例。</li>
<li>回收<strong>完全无存活对象</strong>的 Region（直接整区回收）。</li>
<li>生成<strong>回收集合（CSet）</strong>供后续拷贝阶段使用。</li>
</ul>
</li>
</ol>
<h4 id="对象拷贝阶段（Evacuation，STW）"><a href="#对象拷贝阶段（Evacuation，STW）" class="headerlink" title="对象拷贝阶段（Evacuation，STW）"></a>对象拷贝阶段（Evacuation，STW）</h4><ul>
<li><strong>作用</strong>：将回收集合（CSet）中的存活对象拷贝到空闲 Region。</li>
<li><strong>流程</strong>：<ol>
<li>根据标记结果，选择垃圾比例高的 Region 组成 CSet。</li>
<li>并行将 CSet 中的存活对象复制到新 Region（类似复制算法）。</li>
<li>清空原 Region，加入空闲列表。</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li>完全 STW，是 G1 的主要停顿来源。</li>
<li>支持<strong>混合回收（Mixed GC）</strong>：同时回收年轻代和老年代 Region。</li>
</ul>
</li>
</ul>
<h4 id="G1-Mixed-GC（混合回收）"><a href="#G1-Mixed-GC（混合回收）" class="headerlink" title="G1 Mixed GC（混合回收）"></a>G1 Mixed GC（混合回收）</h4><ul>
<li><strong>触发条件</strong>：老年代占用超过阈值（<code>-XX:InitiatingHeapOccupancyPercent</code>，默认 45%）。</li>
<li><strong>行为</strong>：<ol>
<li>在年轻代回收时，**额外选择部分老年代 Region **加入 CSet。</li>
<li>通过<code>-XX:G1MixedGCLiveThresholdPercent</code>控制老年代 Region 的回收阈值（存活对象比例低于该值才回收）。</li>
</ol>
</li>
</ul>
<p><strong>关键机制</strong></p>
<ul>
<li><strong>Remembered Set（RSet）</strong>：每个 Region 维护一个 RSet，记录其他 Region 对它的引用，避免全堆扫描。</li>
<li><strong>Humongous 区</strong>：存放大对象（超过 Region 50%），直接分配在 Old 区，避免反复拷贝。</li>
</ul>
<p><strong>参数配置</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-XX:+UseG1GC</code></td>
<td>启用 G1 回收器</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis=200</code></td>
<td>目标最大停顿时间</td>
</tr>
<tr>
<td><code>-XX:InitiatingHeapOccupancyPercent=45</code></td>
<td>触发 Mixed GC 的堆占用率阈值</td>
</tr>
<tr>
<td><code>-XX:G1HeapRegionSize=2M</code></td>
<td>设置 Region 大小（1MB~32MB，需为 2 的幂）</td>
</tr>
</tbody></table>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>优势</strong>：<ul>
<li>可控停顿时间，适合大堆（数十 GB）应用。</li>
<li>内存整理减少碎片（复制算法）。</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>内存占用较高（RSet 和并发标记开销）。</li>
<li>复杂场景下可能退化为 Serial Old（如分配失败）。</li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>替代 CMS，适用于 <strong>JDK 8+</strong> 的中大堆应用（如 6GB~100GB）。</li>
<li>对延迟敏感且需平衡吞吐量的场景（如微服务、实时系统）。</li>
</ul>
<h3 id="【困难】Java-的-ZGC-垃圾回收流程是怎样的？"><a href="#【困难】Java-的-ZGC-垃圾回收流程是怎样的？" class="headerlink" title="【困难】Java 的 ZGC 垃圾回收流程是怎样的？"></a>【困难】Java 的 ZGC 垃圾回收流程是怎样的？</h3><h3 id="【困难】JVM-垃圾回收时产生的-concurrent-mode-failure-的原因是什么？"><a href="#【困难】JVM-垃圾回收时产生的-concurrent-mode-failure-的原因是什么？" class="headerlink" title="【困难】JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？"></a>【困难】JVM 垃圾回收时产生的 concurrent mode failure 的原因是什么？</h3><p><strong>Concurrent Mode Failure</strong> 是 <strong>CMS（Concurrent Mark-Sweep）</strong> 垃圾回收器在并发清理阶段失败，被迫触发 <strong>Full GC（Serial Old）</strong> 的现象，导致长时间 STW（Stop-The-World），影响应用响应速度。</p>
<p><strong>CMS 工作流程</strong>：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：标记根对象直接关联的对象（短暂停顿）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：与应用线程并发，标记老年代存活对象。</li>
<li><strong>重新标记（Remark）</strong>：修正并发标记期间变动的对象（短暂停顿）。</li>
<li><strong>并发清理（Concurrent Sweep）</strong>：清除垃圾对象（并发执行）。</li>
</ol>
<p><strong>优化措施</strong></p>
<ul>
<li><strong>增加老年代内存</strong>：调整 <code>-Xmx</code> 和 <code>-XX:CMSInitiatingOccupancyFraction</code>，降低 CMS 触发频率。</li>
<li><strong>调低 CMS 触发阈值</strong>：通过 <code>-XX:CMSInitiatingOccupancyFraction=&lt;N&gt;</code> 提前触发回收（如设为 70%）。</li>
<li><strong>碎片整理</strong>：配置 <code>-XX:+UseCMSCompactAtFullCollection</code>，在 Full GC 后整理碎片。</li>
<li><strong>增加年轻代内存</strong>：减少对象晋升老年代的频率，降低老年代压力。</li>
</ul>
<p><strong>典型 CMS 参数配置示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseConcMarkSweepGC \</span><br><span class="line">     -XX:CMSInitiatingOccupancyFraction=70 \</span><br><span class="line">     -XX:+UseCMSCompactAtFullCollection \</span><br><span class="line">     -Xmx4g -Xms4g YourApplication</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/4dec9ccb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/4dec9ccb/" class="post-title-link" itemprop="url">MyBatis 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-30 06:33:26" itemprop="dateCreated datePublished" datetime="2025-04-30T06:33:26+08:00">2025-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/ORM/" itemprop="url" rel="index"><span itemprop="name">ORM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis-面试"><a href="#MyBatis-面试" class="headerlink" title="MyBatis 面试"></a>MyBatis 面试</h1><h3 id="【简单】MyBatis-中-和-的区别是什么？"><a href="#【简单】MyBatis-中-和-的区别是什么？" class="headerlink" title="【简单】MyBatis 中 #{} 和 ${} 的区别是什么？"></a>【简单】MyBatis 中 #{} 和 ${} 的区别是什么？</h3><p><strong>MyBatis 中 <code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong><code>#&#123;&#125;</code>（预编译占位符）</strong></th>
<th><strong><code>$&#123;&#125;</code>（字符串拼接）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层原理</strong></td>
<td>使用 <code>PreparedStatement</code>，生成带 <code>?</code> 的 SQL，预编译防止注入。</td>
<td>直接拼接字符串到 SQL 中，无参数化处理。</td>
</tr>
<tr>
<td><strong>SQL 注入风险</strong></td>
<td>❌ 安全（自动转义特殊字符）。</td>
<td>✔️ 高风险（需手动过滤参数）。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>动态条件值（如 <code>WHERE id = #&#123;value&#125;</code>）。</td>
<td>动态表名、列名（如 <code>ORDER BY $&#123;column&#125;</code>）。</td>
</tr>
<tr>
<td><strong>数据类型处理</strong></td>
<td>自动识别 Java 类型，匹配 JDBC 类型（如 <code>Date</code>→<code>TIMESTAMP</code>）。</td>
<td>原样替换，可能导致语法错误（如字符串未加引号）。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>预编译 SQL 可复用，高效。</td>
<td>每次生成新 SQL，效率较低。</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>xml SELECT * FROM user WHERE name = #&#123;name&#125;</code></td>
<td><code>xml SELECT * FROM $&#123;tableName&#125;</code></td>
</tr>
</tbody></table>
<p><strong>关键结论</strong></p>
<ul>
<li>**优先用 <code>#&#123;&#125;</code>**：处理用户输入或条件值，确保安全。</li>
<li>**谨慎用 <code>$&#123;&#125;</code>**：仅用于非用户输入的动态 SQL 部分（如动态表名），需手动过滤参数。</li>
<li><strong>常见错误</strong>：<ul>
<li>错误：<code>ORDER BY #&#123;column&#125;</code>（预编译后引号包裹列名，语法错误）。</li>
<li>正确：<code>ORDER BY $&#123;column&#125; LIMIT #&#123;limit&#125;</code>（混合使用）。</li>
</ul>
</li>
</ul>
<p><strong>底层机制对比</strong></p>
<p><strong><code>#&#123;&#125;</code> 的执行流程（安全）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 生成的 SQL（预编译）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 参数值通过 PreparedStatement 安全传递</span></span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>$&#123;&#125;</code> 的执行流程（风险）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 生成的 SQL（直接拼接）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;  <span class="comment">-- 注入攻击示例</span></span><br></pre></td></tr></table></figure>

<p><strong>何时必须使用 <code>$&#123;&#125;</code>？</strong></p>
<ol>
<li><p><strong>动态表名&#x2F;列名</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM $&#123;tableName&#125; WHERE $&#123;column&#125; = #&#123;value&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SQL 函数或关键字</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY $&#123;sortField&#125; $&#123;sortOrder&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>安全建议</strong></p>
<ul>
<li>使用 <code>$&#123;&#125;</code> 时，用 <code>@Param</code> 注解白名单校验：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; <span class="title function_">selectByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 手动校验表名合法性 --&gt;</span></span><br><span class="line">SELECT * FROM $&#123;tableName&#125;</span><br><span class="line">WHERE 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;tableName in &#123;&#x27;user&#x27;, &#x27;order&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">  AND status = #&#123;status&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="【简单】MyBatis-如何实现一对一、一对多的关联查询-？"><a href="#【简单】MyBatis-如何实现一对一、一对多的关联查询-？" class="headerlink" title="【简单】MyBatis 如何实现一对一、一对多的关联查询 ？"></a>【简单】MyBatis 如何实现一对一、一对多的关联查询 ？</h3><h3 id="【简单】使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#【简单】使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="【简单】使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>【简单】使用 MyBatis 的 mapper 接口调用时有哪些要求？</h3><h3 id="【简单】MyBatis-自带的连接池有了解过吗？"><a href="#【简单】MyBatis-自带的连接池有了解过吗？" class="headerlink" title="【简单】MyBatis 自带的连接池有了解过吗？"></a>【简单】MyBatis 自带的连接池有了解过吗？</h3><h3 id="【简单】MyBatis-和-Hibernate-有哪些差异？"><a href="#【简单】MyBatis-和-Hibernate-有哪些差异？" class="headerlink" title="【简单】MyBatis 和 Hibernate 有哪些差异？"></a>【简单】MyBatis 和 Hibernate 有哪些差异？</h3><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>MyBatis</strong></th>
<th><strong>Hibernate</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SQL 灵活性</strong></td>
<td>方便优化 SQL，<strong>灵活性高</strong></td>
<td>自动生成 SQL，复杂查询需 HQL 或原生 SQL，<strong>灵活性较低</strong></td>
</tr>
<tr>
<td><strong>学习成本</strong></td>
<td>需熟悉 SQL 和数据库特性，适合有 SQL 经验的团队。</td>
<td>面向对象思维，适合快速上手 ORM 的团队。</td>
</tr>
<tr>
<td><strong>开发效率</strong></td>
<td>需手动编写 SQL 和结果映射，适合定制化需求。</td>
<td>自动化 CRUD，快速开发简单应用。</td>
</tr>
<tr>
<td><strong>缓存机制</strong></td>
<td>提供一级&#x2F;二级缓存，需手动管理。</td>
<td>内置多级缓存（查询缓存、集合缓存），自动化程度高。</td>
</tr>
<tr>
<td><strong>数据库兼容性</strong></td>
<td>SQL 依赖具体数据库语法，<strong>移植性较差</strong>。</td>
<td>通过方言（Dialect）适配多数据库，<strong>移植性好</strong>。</td>
</tr>
<tr>
<td><strong>关联映射</strong></td>
<td>需手动配置 <code>&lt;association&gt;</code>&#x2F;<code>&lt;collection&gt;</code>。</td>
<td>自动管理对象关系（如 <code>@OneToMany</code>），配置简洁。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>复杂查询、高性能系统（如金融、电商）。</td>
<td>快速开发、对象模型复杂的应用（如管理后台）。</td>
</tr>
</tbody></table>
<p><strong>总结选择建议</strong></p>
<ul>
<li><p><strong>选择 MyBatis</strong>：  </p>
<ul>
<li>需要精细控制 SQL，追求极致性能。  </li>
<li>项目涉及多表复杂查询或数据库特性优化。</li>
</ul>
</li>
<li><p><strong>选择 Hibernate</strong>：  </p>
<ul>
<li>快速开发，业务以简单 CRUD 为主。  </li>
<li>团队熟悉 ORM，希望减少 SQL 编写。</li>
</ul>
</li>
</ul>
<p><strong>混合使用</strong>：部分项目用 MyBatis 处理复杂查询，Hibernate 处理简单模块。</p>
<h3 id="【中等】说说-MyBatis-的缓存机制？"><a href="#【中等】说说-MyBatis-的缓存机制？" class="headerlink" title="【中等】说说 MyBatis 的缓存机制？"></a>【中等】说说 MyBatis 的缓存机制？</h3><h3 id="【中等】MyBatis-写个-Xml-映射文件，再写个-DAO-接口就能执行，这个原理是什么？"><a href="#【中等】MyBatis-写个-Xml-映射文件，再写个-DAO-接口就能执行，这个原理是什么？" class="headerlink" title="【中等】MyBatis 写个 Xml 映射文件，再写个 DAO 接口就能执行，这个原理是什么？"></a>【中等】MyBatis 写个 Xml 映射文件，再写个 DAO 接口就能执行，这个原理是什么？</h3><h3 id="【中等】MyBatis-动态-sql-有什么用？执行原理？有哪些动态-sql？"><a href="#【中等】MyBatis-动态-sql-有什么用？执行原理？有哪些动态-sql？" class="headerlink" title="【中等】MyBatis 动态 sql 有什么用？执行原理？有哪些动态 sql？"></a>【中等】MyBatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h3><h3 id="【中等】MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#【中等】MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="【中等】MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>【中等】MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><h3 id="【中等】简述-MyBatis-的插件运行原理，以及如何编写一个插件？"><a href="#【中等】简述-MyBatis-的插件运行原理，以及如何编写一个插件？" class="headerlink" title="【中等】简述 MyBatis 的插件运行原理，以及如何编写一个插件？"></a>【中等】简述 MyBatis 的插件运行原理，以及如何编写一个插件？</h3><h3 id="【中等】JDBC-编程有哪些不足之处，MyBatis-是如何解决的？"><a href="#【中等】JDBC-编程有哪些不足之处，MyBatis-是如何解决的？" class="headerlink" title="【中等】JDBC 编程有哪些不足之处，MyBatis 是如何解决的？"></a>【中等】JDBC 编程有哪些不足之处，MyBatis 是如何解决的？</h3><h3 id="【中等】MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#【中等】MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="【中等】MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>【中等】MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><h3 id="【中等】MyBatis-如何实现数据库类型和-Java-类型的转换的？"><a href="#【中等】MyBatis-如何实现数据库类型和-Java-类型的转换的？" class="headerlink" title="【中等】MyBatis 如何实现数据库类型和 Java 类型的转换的？"></a>【中等】MyBatis 如何实现数据库类型和 Java 类型的转换的？</h3><h2 id="【中等】MyBatis-有哪些核心组件？"><a href="#【中等】MyBatis-有哪些核心组件？" class="headerlink" title="【中等】MyBatis  有哪些核心组件？"></a>【中等】MyBatis  有哪些核心组件？</h2><p>MyBatis 有以下核心组件：</p>
<ul>
<li>**<code>SqlSessionFactoryBuilder</code>**：负责创建 <code>SqlSessionFactory</code> 实例。用完即弃。</li>
<li>**<code>SqlSessionFactory</code>**：负责创建 <code>SqlSession</code> 实例。全局单例，配置中心。</li>
<li>**<code>SqlSession</code>**：通过方法签名和 <code>Mapper</code> 相互映射。请求级核心，需及时关闭。</li>
<li>**<code>Mapper</code>**：映射器是一些由用户创建的、绑定 SQL 语句的接口。轻量级对象，随用随建。</li>
</ul>
<p>下面是它们之间的关系：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder → SqlSessionFactory → SqlSession → Mapper Proxy</span><br><span class="line">       (方法级)               (应用级)           (请求级)        (方法级)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510113446.png" alt="img"></p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><ul>
<li><strong>生命周期</strong>：<strong>方法级</strong>（最短）</li>
<li><strong>作用</strong>：用于构建 <code>SqlSessionFactory</code>，解析 XML 配置（如 <code>mybatis-config.xml</code>）。</li>
<li><strong>特点</strong>：<ul>
<li>构建完成后即可销毁，无状态，不占用资源。</li>
<li>通常作为局部变量使用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><ul>
<li><strong>生命周期</strong>：<strong>应用级</strong>（最长）</li>
<li><strong>作用</strong>：创建 <code>SqlSession</code>，全局唯一，线程安全。</li>
<li><strong>特点</strong>：<ul>
<li>通常作为单例存在于整个应用运行期间。</li>
<li>维护数据库连接池和全局配置（如缓存、别名）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐通过单例管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><ul>
<li><strong>生命周期</strong>：<strong>请求&#x2F;事务级</strong></li>
<li><strong>作用</strong>：执行 SQL、获取 Mapper 接口实例、管理事务。</li>
<li><strong>特点</strong>：<ul>
<li><strong>非线程安全</strong>，每次请求需创建新实例，用完后必须关闭（避免连接泄漏）。</li>
<li>默认不自动提交事务，需手动 <code>commit()</code> 或 <code>rollback()</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession()) &#123;  <span class="comment">// 自动关闭</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    session.commit();  <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><ul>
<li><strong>生命周期</strong>：<strong>方法级</strong>（与 <code>SqlSession</code> 绑定）</li>
<li><strong>作用</strong>：通过动态代理将接口方法调用转换为 SQL 执行。</li>
<li><strong>特点</strong>：<ul>
<li>由 <code>SqlSession</code> 创建，生命周期跟随 <code>SqlSession</code>。</li>
<li>无需手动实现，MyBatis 自动生成代理类。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理对象随 SqlSession 销毁而失效</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>

<h2 id="【中等】能详细说说-MyBatis-的执行流程吗？"><a href="#【中等】能详细说说-MyBatis-的执行流程吗？" class="headerlink" title="【中等】能详细说说 MyBatis 的执行流程吗？"></a>【中等】能详细说说 MyBatis 的执行流程吗？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512173437.png" alt="img"></p>
<h2 id="【困难】MyBatis-的架构是如何设计的？"><a href="#【困难】MyBatis-的架构是如何设计的？" class="headerlink" title="【困难】MyBatis 的架构是如何设计的？"></a>【困难】MyBatis 的架构是如何设计的？</h2><p>MyBatis 的架构设计通过 <strong>分层解耦</strong> 和 <strong>动态代理</strong> 实现了 SQL 与 Java 代码的分离，其核心在于：</p>
<ul>
<li><strong>配置驱动</strong>：集中管理 SQL 和映射规则。</li>
<li><strong>组件化</strong>：各层职责单一，易于扩展（如插件）。</li>
<li><strong>平衡灵活与易用</strong>：既保留 JDBC 的掌控力，又简化了重复操作。</li>
</ul>
<p>这种设计使其在需要高性能和灵活 SQL 的场景中表现优异，尤其适合中大型复杂业务系统。</p>
<p>MyBatis 的架构设计以 <strong>SQL 与 Java 对象的灵活映射</strong> 为核心，采用分层模块化设计，平衡了灵活性与易用性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512114852.png" alt="img"></p>
<p><strong>分层架构设计</strong></p>
<p>MyBatis 的架构分为四层，各层职责明确，通过接口解耦：</p>
<table>
<thead>
<tr>
<th><strong>层级</strong></th>
<th><strong>核心组件</strong></th>
<th><strong>职责</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>接口层</strong></td>
<td><code>SqlSession</code>、<code>Mapper</code> 接口</td>
<td>提供开发者使用的 API（如 <code>selectOne</code>、<code>insert</code>），屏蔽底层实现细节。</td>
</tr>
<tr>
<td><strong>核心处理层</strong></td>
<td><code>Executor</code>、<code>StatementHandler</code></td>
<td>执行 SQL 语句、处理参数绑定和结果映射，实现插件拦截链。</td>
</tr>
<tr>
<td><strong>基础支撑层</strong></td>
<td><code>DataSource</code>、<code>Transaction</code></td>
<td>管理数据库连接池、事务，提供类型转换（<code>TypeHandler</code>）和缓存支持。</td>
</tr>
<tr>
<td><strong>扩展层</strong></td>
<td><code>Interceptor</code>（插件）</td>
<td>通过动态代理拦截核心组件，实现功能扩展（如分页、性能监控）。</td>
</tr>
</tbody></table>
<h3 id="基础支撑层"><a href="#基础支撑层" class="headerlink" title="基础支撑层"></a>基础支撑层</h3><p><strong>功能</strong>：为上层提供通用能力支持</p>
<ul>
<li>**类型处理器 (TypeHandler)**：处理 Java 类型与 JDBC 类型转换（如 <code>String</code> ↔ <code>VARCHAR</code>）。支持自定义扩展（如枚举类型转换）。</li>
<li><strong>连接管理</strong>：集成连接池（如 HikariCP、Druid），管理数据库连接。</li>
<li><strong>事务管理</strong>：提供 JDBC 和 Managed 两种事务模式（可集成 Spring 事务）。</li>
<li><strong>缓存管理</strong>：一级缓存（<code>SqlSession</code> 级别）、二级缓存（<code>Mapper</code> 级别）。支持 Redis、Ehcache 等第三方缓存集成。</li>
</ul>
<h3 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h3><p><strong>功能</strong>：执行 SQL 并处理结果映射</p>
<ul>
<li>**配置解析 (Configuration)**：加载 <code>mybatis-config.xml</code> 和 <code>Mapper.xml</code>，存储所有配置信息（如别名、插件）。</li>
<li>**SQL 解析 (SqlSource &amp; BoundSql)**：解析动态 SQL（<code>&lt;if&gt;</code>、<code>&lt;foreach&gt;</code>），生成可执行的 SQL 字符串和参数映射。</li>
<li><strong>执行器 (Executor)</strong><ul>
<li><strong>类型</strong>：<ul>
<li><code>SimpleExecutor</code>：默认执行器，每次执行新开 <code>PreparedStatement</code>。</li>
<li><code>ReuseExecutor</code>：复用 <code>Statement</code> 对象。</li>
<li><code>BatchExecutor</code>：批量操作优化。</li>
</ul>
</li>
<li><strong>职责</strong>：调用 JDBC 执行 SQL，触发插件拦截链。</li>
</ul>
</li>
<li>**结果集处理 (ResultSetHandler)**：将 <code>ResultSet</code> 转换为 Java 对象（根据 <code>ResultMap</code> 或自动映射）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b69d49b5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b69d49b5/" class="post-title-link" itemprop="url">MySQL 面试之事务和锁篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-24 22:42:57" itemprop="dateCreated datePublished" datetime="2025-03-24T22:42:57+08:00">2025-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-面试之事务和锁篇"><a href="#MySQL-面试之事务和锁篇" class="headerlink" title="MySQL 面试之事务和锁篇"></a>MySQL 面试之事务和锁篇</h1><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-transaction-model.html">MySQL 官方文档之 InnoDB 锁和事务模型</a></li>
</ul>
</blockquote>
<h3 id="【简单】什么是事务，什么是-ACID？"><a href="#【简单】什么是事务，什么是-ACID？" class="headerlink" title="【简单】什么是事务，什么是 ACID？"></a>【简单】什么是事务，什么是 ACID？</h3><p><strong>事务指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。通俗来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242207831.png"></p>
<p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p>
<h3 id="【中等】事务存在哪些并发一致性问题？"><a href="#【中等】事务存在哪些并发一致性问题？" class="headerlink" title="【中等】事务存在哪些并发一致性问题？"></a>【中等】事务存在哪些并发一致性问题？</h3><p>事务中存在的并发一致性问题有：</p>
<ul>
<li>丢失修改</li>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<p><strong>“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换</strong>。</p>
<p>如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242209867.png"></p>
<p><strong>“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据</strong>。</p>
<p>如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242210430.png"></p>
<p><strong>“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致</strong>。</p>
<p>如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242211015.png"></p>
<p><strong>“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据</strong>。</p>
<p>事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242212639.png"></p>
<h3 id="【中等】长事务可能会导致哪些问题？"><a href="#【中等】长事务可能会导致哪些问题？" class="headerlink" title="【中等】长事务可能会导致哪些问题？"></a>【中等】长事务可能会导致哪些问题？</h3><p>长事务可能会导致以下问题：</p>
<ul>
<li><strong>锁竞争与资源阻塞</strong><ul>
<li>长事务长时间持有锁，导致其他事务阻塞，增加系统等待时间，降低并发性能。</li>
<li>业务线程因数据库请求等待而阻塞，可能引发连锁反应（如服务雪崩），造成严重线上事故。</li>
</ul>
</li>
<li><strong>死锁风险增加</strong> - 多个长事务互相等待对方释放锁，容易形成死锁，导致系统无法正常执行。</li>
<li><strong>主从延迟问题</strong> - 主库执行时间长，从库同步及重放耗时增加，导致主从数据长时间不一致。</li>
<li><strong>回滚效率低下</strong> - 长事务执行中途失败时，回滚操作会浪费已执行的资源与时间，影响系统效率。</li>
</ul>
<h3 id="【困难】事务的二阶段提交是什么？"><a href="#【困难】事务的二阶段提交是什么？" class="headerlink" title="【困难】事务的二阶段提交是什么？"></a>【困难】事务的二阶段提交是什么？</h3><p>事务的二阶段提交确保 <strong>redo log（重做日志）</strong> 和 <strong>binlog（二进制日志）</strong> 的一致性，防止崩溃恢复时出现数据丢失或不一致。</p>
<p><strong>两阶段流程</strong></p>
<ul>
<li><strong>Prepare 阶段（准备阶段）</strong> - InnoDB 写入 redo log，并标记为 <strong>prepare</strong> 状态（事务预提交，但未最终提交）。</li>
<li><strong>Commit 阶段（提交阶段）</strong> - MySQL Server 写入 <strong>binlog</strong>（记录 DML 操作）。binlog 写入成功后，InnoDB 将 redo log 状态改为 <strong>commit</strong>，完成事务提交。</li>
</ul>
<p><strong>binlog 和 redo log 的区别</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>redo log</strong></th>
<th align="left"><strong>binlog</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所属层级</strong></td>
<td align="left">InnoDB 引擎层</td>
<td align="left">MySQL Server 层</td>
</tr>
<tr>
<td align="left"><strong>日志类型</strong></td>
<td align="left">记录数据页的<strong>物理日志</strong></td>
<td align="left">记录 DML&#x2F;DDL 操作的<strong>逻辑日志</strong></td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left">固定大小，<strong>环形写入</strong></td>
<td align="left"><strong>追加写入</strong>，可无限增长</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left"><strong>崩溃恢复</strong>（保证数据持久性）</td>
<td align="left"><strong>主从复制、数据恢复、备份</strong></td>
</tr>
</tbody></table>
<p><strong>为什么需要二阶段提交？</strong></p>
<p>无论是单独先写 redo log 或先写 binlog，都可能导致数据不一致：</p>
<ol>
<li><strong>先写 redo log，后写 binlog</strong>（宕机时 binlog 未写入） - redo log 恢复数据，但 binlog 缺失该事务 → <strong>主从数据不一致</strong>。</li>
<li><strong>先写 binlog，后写 redo log</strong>（宕机时 redo log 未写入） - binlog 有记录，但 redo log 未提交 → <strong>数据库实际数据丢失</strong>，与 binlog 不一致。</li>
</ol>
<p>为了解决以上问题，所以需要事务二阶段提交（<code>repare</code> → <code>commit</code>），以确保写入两日志的原子性。</p>
<p><strong>二阶段提交如何保证一致性？</strong></p>
<p>MySQL 崩溃恢复时，检查两日志状态：</p>
<ul>
<li><strong>redo log prepare，binlog 未写入</strong> - 直接回滚（两日志均无有效记录）。</li>
<li><strong>redo log prepare，binlog 已写入</strong> - 对比两日志数据：<ul>
<li><strong>一致</strong>：提交事务（redo log commit）。</li>
<li><strong>不一致</strong>：回滚事务（保证数据一致）。</li>
</ul>
</li>
</ul>
<h3 id="【中等】有哪些事务隔离级别，分别解决了什么问题？"><a href="#【中等】有哪些事务隔离级别，分别解决了什么问题？" class="headerlink" title="【中等】有哪些事务隔离级别，分别解决了什么问题？"></a>【中等】有哪些事务隔离级别，分别解决了什么问题？</h3><p>为了解决以上提到的并发一致性问题，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p>
<p>事务隔离级别从低到高分别是：</p>
<ul>
<li><strong>读未提交（read uncommitted）</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</li>
<li><strong>读已提交（read committed）</strong> - 是指，<strong>事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。<ul>
<li><strong>读已提交解决了脏读的问题</strong>。</li>
<li>读已提交是大多数数据库的默认事务隔离级别，如 Oracle。</li>
</ul>
</li>
<li><strong>可重复读（repeatable read）</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。<ul>
<li><strong>可重复读解决了不可重复读问题</strong>。</li>
<li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li>
</ul>
</li>
<li><strong>串行化（serializable ）</strong> - 是指，<strong>强制事务串行执行</strong>，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。<ul>
<li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li>
<li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li>
</ul>
</li>
</ul>
<p>事务隔离级别对并发一致性问题的解决情况：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">丢失修改</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
</tr>
</tbody></table>
<h3 id="【中等】MySQL-的默认事务隔离级别是什么？为什么？"><a href="#【中等】MySQL-的默认事务隔离级别是什么？为什么？" class="headerlink" title="【中等】MySQL 的默认事务隔离级别是什么？为什么？"></a>【中等】MySQL 的默认事务隔离级别是什么？为什么？</h3><p>事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p>
<p>MySQL 中的事务功能是在存储引擎层实现的，<strong>并非所有存储引擎都支持事务功能</strong>。比如 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p>
<p><strong>大部分数据库的默认隔离级别是“读已提交”</strong>。然而，<strong>InnoDB 的默认隔离级别是“可重复读”</strong>。这是为了兼容早期 binlog 的 statement 格式问题。如果使用可重复读以下的隔离级别，使用了 statement 格式的 binlog 会产生主从数据不一致的问题。</p>
<p>此外，<strong>在 InnoDB 中，可重复读隔离级别虽然不能解决幻读，但是可以很大程度的避免幻读的发生</strong>。根据不同的查询方式，分别提出了避免幻读的方案：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 <code>select</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（<code>select ... for update</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p>很大程度的避免幻读，不代表完全解决幻读问题，下面是两个示例：</p>
<ul>
<li>对于快照读，MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</li>
<li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</li>
</ul>
<h3 id="【困难】MySQL-是如何实现事务的？"><a href="#【困难】MySQL-是如何实现事务的？" class="headerlink" title="【困难】MySQL 是如何实现事务的？"></a>【困难】MySQL 是如何实现事务的？</h3><p>MySQL 主要是通过 <strong>锁</strong>、<strong>Redo Log</strong> 、<strong>Undo Log</strong>、<strong>MVCC</strong> 来实现事务。</p>
<ul>
<li>MySQL 利用锁（行锁、间隙锁等等机制），<strong>控制数据的并发修改</strong>，满足事务的隔离性。</li>
<li><strong>Redo Log（重做日志）</strong>，它会<strong>记录事务对数据库的所有修改</strong>，当 MySQL 发生宕机或崩溃时，<strong>通过重放 redo log 就可以恢复数据</strong>，用来满足事务的持久性。</li>
<li><strong>Undo Log（回滚日志）</strong>，它会<strong>记录事务的反向操作</strong>，简单地说就是保存数据的历史版本，<strong>用于事务的回滚</strong>，使得事务执行失败之后可以恢复之前的样子。实现原子性和隔离性</li>
<li><strong>MVCC（多版本并发控制）</strong>，满足了非锁定读的需求，提高了并发度，<strong>实现了读已提交和可重复读两种隔离级别</strong>，实现了事务的隔离性。</li>
</ul>
<p>事务实现了原子性、隔离性和持久性特性后，本身就达到了一致性的目的。</p>
<h3 id="【困难】什么是-MVCC？"><a href="#【困难】什么是-MVCC？" class="headerlink" title="【困难】什么是 MVCC？"></a>【困难】什么是 MVCC？</h3><p><strong>MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”</strong>。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读&#x2F;写并发冲突，可以将其看成一种乐观锁。</p>
<p>不仅是 MySQL，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。<strong>MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式</strong>。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>::: info MVCC 实现原理</p>
<p>:::</p>
<p>MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。</p>
<h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：</p>
<ul>
<li><code>row_id</code> - <strong>隐藏的自增 ID</strong>。如果数据表没有指定主键，InnoDB 会自动基于 <code>row_id</code> 产生一个聚簇索引。</li>
<li><code>trx_id</code> - <strong>最近修改的事务 ID</strong>。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li><code>roll_pointer</code> - <strong>回滚指针</strong>，指向这条记录的上一个版本。</li>
</ul>
<h4 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h4><p>MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 <code>roll_pointer</code> 把一个数据行的所有快照链接起来，构成一个<strong>版本链</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242213050.png"></p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p><strong>ReadView 就是事务进行快照读时产生的读视图（快照）</strong>。</p>
<p>ReadView 有四个重要的字段：</p>
<ul>
<li><code>m_ids</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li><code>min_trx_id</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 <code>m_ids</code> 的最小值。</li>
<li><code>max_trx_id</code> - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；</li>
<li><code>creator_trx_id</code> - 指的是创建该 ReadView 的事务的事务 ID。</li>
</ul>
<p>在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：</p>
<ul>
<li>已提交事务</li>
<li>已启动但未提交的事务</li>
<li>未启动的事务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242214504.png"></p>
<blockquote>
<p>ReadView 如何判断版本链中哪个版本可见？</p>
</blockquote>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li><code>trx_id == creator_trx_id</code> - 表示 <code>trx_id</code> 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。</li>
<li><code>trx_id &lt; min_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。</li>
<li><code>trx_id &gt;= max_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。</li>
<li><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> - 需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中<ul>
<li>如果 <code>trx_id</code> 在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。</li>
<li>如果 <code>trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务已提交，当前事务可以访问。</li>
</ul>
</li>
</ul>
<p>这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p>
<h3 id="【困难】MVCC-实现了哪些隔离级别，如何实现的？"><a href="#【困难】MVCC-实现了哪些隔离级别，如何实现的？" class="headerlink" title="【困难】MVCC 实现了哪些隔离级别，如何实现的？"></a>【困难】MVCC 实现了哪些隔离级别，如何实现的？</h3><p>对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。</p>
<blockquote>
<p>MVCC 如何实现可重复读隔离级别</p>
</blockquote>
<p><strong>可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView</strong>。这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 将 value 设为 200；</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据，value 依旧为 100；</li>
</ul>
<p>以上操作，如下图所示。T2 事务在事务过程中，是否可以看到 T1 事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242217983.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出 <code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见。</li>
</ul>
<p>综上所述，在 T2 事务中，自始至终只能看到 <code>trx_id = 100</code> 的版本记录。</p>
<blockquote>
<p>MVCC 如何实现读已提交隔离级别</p>
</blockquote>
<p><strong>读已提交隔离级别每次读取数据时都会创建一个 ReadView</strong>。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 将 value 设为 100；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 100；</li>
</ul>
<p>以上操作，如下图所示，T2 事务在事务过程中，是否可以看到其他事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242218464.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出第二次查询时（T1 更新未提交），<code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见；而第三次查询时（T1 更新已提交），<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中可见；</li>
</ul>
<p>综上所述，在 T2 事务中，当 T1 事务提交前，可读取到的是 <code>trx_id = 100</code> 的版本记录；当 T1 事务提交后，可读取到的是 <code>trx_id = 101</code> 的版本记录。</p>
<blockquote>
<p>MVCC + Next-Key Lock 如何解决幻读</p>
</blockquote>
<p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 <code>SELECT</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 <code>SELECT ... FOR UPDATE</code> 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</li>
</ul>
<h3 id="【困难】各事务隔离级别是如何实现的？"><a href="#【困难】各事务隔离级别是如何实现的？" class="headerlink" title="【困难】各事务隔离级别是如何实现的？"></a>【困难】各事务隔离级别是如何实现的？</h3><p>四种隔离级别具体是如何实现的呢？</p>
<p>以 InnoDB 的事务实现来说明：</p>
<ul>
<li>对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。<ul>
<li>“读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView</li>
<li>“可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。</li>
</ul>
</li>
</ul>
<h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><h3 id="【中等】MySQL-中有哪些锁？"><a href="#【中等】MySQL-中有哪些锁？" class="headerlink" title="【中等】MySQL 中有哪些锁？"></a>【中等】MySQL 中有哪些锁？</h3><p>为了解决并发一致性问题，MySQL 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。</p>
<h4 id="独享锁和共享锁"><a href="#独享锁和共享锁" class="headerlink" title="独享锁和共享锁"></a>独享锁和共享锁</h4><p><strong>独享锁（Exclusive）</strong>：简写为 X 锁，又称为“写锁”、“排它锁”。</p>
<ul>
<li>特性<ul>
<li>用于写入操作</li>
<li>完全排他，同一时间仅允许一个事务持有</li>
</ul>
</li>
<li>加锁<ul>
<li><code>SELECT ... FOR UPDATE</code></li>
<li>DML 语句（隐式加锁）</li>
</ul>
</li>
</ul>
<p><strong>共享锁（Shared）</strong>：简写为 S 锁，又称为“读锁”。</p>
<ul>
<li>特性<ul>
<li>用于读取操作</li>
<li>允许多事务并发持有，互不阻塞</li>
</ul>
</li>
<li>加锁<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code></li>
<li><code>SELECT ... FOR SHARE</code>（MySQL 8.0+）</li>
</ul>
</li>
</ul>
<p><strong>存储引擎实现差异</strong></p>
<ul>
<li><strong>MyISAM</strong>：仅支持表级锁<ul>
<li><code>LOCK TABLES ... READ</code> → S 锁</li>
<li><code>LOCK TABLES ... WRITE</code> → X 锁</li>
</ul>
</li>
<li><strong>InnoDB</strong>：支持行级锁和表级锁<ul>
<li>默认使用行锁（更细粒度）</li>
<li>特殊场景退化为表锁（如无索引更新）</li>
</ul>
</li>
</ul>
<h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><p>基于加锁方式分类，MySQL 可以分为悲观锁和乐观锁。</p>
<ul>
<li><strong>悲观锁</strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul>
<li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li>
<li>实现方式：<strong>使用数据库中的锁机制</strong>。</li>
</ul>
</li>
<li><strong>乐观锁</strong> - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。<ul>
<li>实现方式：<strong>更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要引入乐观锁？</p>
</blockquote>
<p>乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。</p>
<p><strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。那么，为了提高并发度，能不能尽量不加锁呢？</p>
<p>乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。</p>
<p>【示例】MySQL 乐观锁示例</p>
<p>假设，order 表中有一个字段 status，表示订单状态：status 为 1 代表订单未支付；status 为 2 代表订单已支付。现在，要将 id 为 1 的订单状态置为已支付，则操作如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> status, version <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<p>乐观锁的<strong>优点</strong>是：减少锁竞争，提高并发度。</p>
<p>乐观锁的<strong>缺点</strong>是：</p>
<ul>
<li><strong>存在 ABA 问题</strong>。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了</li>
<li>如果乐观锁所检查的数据存在大量锁竞争，会由于<strong>不断循环重试，产生大量的 CPU 开销</strong>。</li>
</ul>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁是 MySQL 中一种<strong>锁住整个数据库实例</strong>的机制，使数据库处于<strong>只读状态</strong>，禁止所有数据修改操作（DML、DDL）。</p>
<p><strong>加锁、解锁</strong></p>
<p>加全局锁（Flush Tables With Read Lock, FTWRL）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES <span class="keyword">WITH</span> READ LOCK;</span><br></pre></td></tr></table></figure>

<p>阻塞所有 <strong>写操作（INSERT&#x2F;UPDATE&#x2F;DELETE）</strong> 和 <strong>DDL（ALTER&#x2F;DROP）</strong>，但允许读操作（SELECT）。</p>
<p>释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li><strong>数据库备份</strong>（确保备份数据一致性）</li>
<li><strong>主从同步初始化</strong></li>
<li><strong>防止数据修改</strong>（维护期间禁止写入）</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul>
<li><strong>表锁</strong>：<strong>锁定整张表</strong>，是 MyISAM 引擎的默认锁类型，InnoDB 引擎在特定情况下也会使用。<ul>
<li><strong>表共享读锁（Table Read Lock）</strong>：<code>LOCK TABLE table_name READ</code><ul>
<li>所有会话可以<strong>同时读取</strong>该表</li>
<li><strong>禁止任何会话写入</strong>（INSERT&#x2F;UPDATE&#x2F;DELETE）</li>
<li>读锁之间<strong>不互斥</strong>（多个事务可同时持有读锁）</li>
</ul>
</li>
<li><strong>表独占写锁（Table Write Lock）</strong>：<code>LOCK TABLE table_name WRITE</code><ul>
<li><strong>仅允许当前会话读写</strong>该表</li>
<li>其他会话<strong>无法读取或写入</strong>（完全排他）</li>
<li>写锁<strong>与其他所有锁互斥</strong>（包括读锁和其他写锁）</li>
</ul>
</li>
</ul>
</li>
<li><strong>元数据锁（Metadata Lock, MDL）</strong>：自动加锁，保护表结构，防止在查询或修改时表结构被更改。<ul>
<li>增删改查，加读锁</li>
<li>结构变更，加写锁</li>
</ul>
</li>
<li><strong>意向锁（Intention Lock）</strong>：用于快速判断表中是否有行被锁定，从而优化锁冲突检测效率。<ul>
<li><strong>意向共享锁（IS）</strong>：表示事务准备在表的某些行上加 S 锁（共享锁），如 <code>SELECT ... LOCK IN SHARE MODE</code>。</li>
<li><strong>意向独享锁（IX）</strong>：表示事务准备在表的某些行上加 X 锁（排他锁），如 <code>SELECT ... FOR UPDATE</code> 或 DML 操作。</li>
</ul>
</li>
<li><strong>自增锁（Auto Increment Lock）</strong>：确保并发插入时自增值的正确分配。<ul>
<li><strong>确保自增值连续</strong>：防止多个事务同时插入数据时，自增列出现重复或跳跃。</li>
<li><strong>保证唯一性</strong>：避免并发插入时多个事务获取相同的自增值，导致主键冲突。</li>
<li><strong>支持事务回滚</strong>：如果事务回滚，已分配的自增值不会回退，但后续插入仍会继续递增，确保不重复。</li>
</ul>
</li>
</ul>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul>
<li><p><strong>记录锁（Record Lock）</strong>：锁定索引中的<strong>单条记录</strong>。</p>
<ul>
<li>仅锁住符合条件的行，不影响其他行</li>
<li>如果表无索引，InnoDB 会退化为表锁<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对 id=1 的记录加锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>间隙锁（Gap Lock）</strong>：锁定索引记录之间的<strong>间隙</strong>，防止其他事务在这个范围内插入数据。</p>
<ul>
<li><p>仅存在于<strong>可重复读</strong>隔离级别，为了解决幻读问题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁定 20-30 之间的间隙</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>临键锁（Next-Key Lock）</strong>：<strong>记录锁+间隙锁</strong>的组合，锁定记录及前面的间隙。</p>
<ul>
<li>InnoDB 默认的行锁方式</li>
<li>同时防止幻读和保证当前读的一致性<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁定 id&gt;10 的记录及后面的间隙</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>插入意向锁（Insert Intention Lock）</strong>：在 <code>INSERT</code> 操作前设置，表示准备插入</p>
<ul>
<li>不阻塞其他插入意向锁</li>
<li>会等待间隙锁释放<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自动获取插入意向锁</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="【中等】死锁是如何产生的？"><a href="#【中等】死锁是如何产生的？" class="headerlink" title="【中等】死锁是如何产生的？"></a>【中等】死锁是如何产生的？</h3><p><strong>死锁</strong>是指，<strong>多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p>
<p><strong>死锁产生条件（必须同时满足）</strong></p>
<ul>
<li><strong>互斥</strong>：资源一次只能被一个事务占用（如行锁）。</li>
<li><strong>占有并等待</strong>：事务持有资源的同时，等待其他事务释放资源。</li>
<li><strong>不可强占</strong>：事务已获得的资源不能被强制抢占，只能主动释放。</li>
<li><strong>循环等待</strong>：事务之间形成循环等待。</li>
</ul>
<h3 id="【困难】如何避免死锁？"><a href="#【困难】如何避免死锁？" class="headerlink" title="【困难】如何避免死锁？"></a>【困难】如何避免死锁？</h3><p><strong>死锁的四个必要条件</strong>：<strong>互斥、占有且等待、不可强占、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：</p>
<ul>
<li>更新表时，<strong>尽量使用主键更新</strong>，减少冲突；</li>
<li><strong>避免长事务</strong>，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；</li>
<li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li>
<li>在编程中<strong>尽量按照固定的顺序来处理数据库记录</strong>，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li>
<li>在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；</li>
<li>还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</li>
</ul>
<h3 id="【困难】如何解决死锁？"><a href="#【困难】如何解决死锁？" class="headerlink" title="【困难】如何解决死锁？"></a>【困难】如何解决死锁？</h3><p>当出现死锁以后，有两种策略：</p>
<ul>
<li><strong>设置事务等待锁的超时时间</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>
<li><strong>开启死锁检测</strong>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，若直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当事务被锁时，就要查看它所依赖的线程是否被其他事务锁住，如此循环，来判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/">图解 MySQL 介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9303ab78/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9303ab78/" class="post-title-link" itemprop="url">MySQL 面试之索引篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-24 22:42:57" itemprop="dateCreated datePublished" datetime="2025-03-24T22:42:57+08:00">2025-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-面试之索引篇"><a href="#MySQL-面试之索引篇" class="headerlink" title="MySQL 面试之索引篇"></a>MySQL 面试之索引篇</h1><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><h3 id="【简单】什么是索引？为什么要使用索引？"><a href="#【简单】什么是索引？为什么要使用索引？" class="headerlink" title="【简单】什么是索引？为什么要使用索引？"></a>【简单】什么是索引？为什么要使用索引？</h3><p><strong>“索引”是数据库为了提高查找效率的一种数据结构</strong>。</p>
<p>日常生活中，我们可以通过检索目录，来快速定位书本中的内容。索引和数据表，就好比目录和书，想要高效查询数据表，索引至关重要。在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，<strong>设置合理的索引是数据库查询性能优化的最有效手段</strong>。</p>
<h3 id="【简单】索引的优点和缺点是什么？"><a href="#【简单】索引的优点和缺点是什么？" class="headerlink" title="【简单】索引的优点和缺点是什么？"></a>【简单】索引的优点和缺点是什么？</h3><p>✅️️️️️️️ 索引的优点：</p>
<ul>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong>，从而加快检索速度。</li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong>。</li>
<li><strong>索引可以将随机 I&#x2F;O 变为顺序 I&#x2F;O</strong>。</li>
<li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>❌ 索引的缺点：</p>
<ul>
<li><strong>创建和维护索引要耗费时间</strong>，这会随着数据量的增加而增加。</li>
<li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立联合索引那么需要的空间就会更大。</li>
<li><strong>写操作（<code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低</strong>。</li>
</ul>
<h3 id="【中等】何时适用索引？何时不适用索引？"><a href="#【中等】何时适用索引？何时不适用索引？" class="headerlink" title="【中等】何时适用索引？何时不适用索引？"></a>【中等】何时适用索引？何时不适用索引？</h3><ul>
<li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li>
<li>要<strong>考虑删除未使用的索引</strong>。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。索引需要占用额外的存储空间；此外，表更新时，需要同步维护索引。索引越多，意味着维护所付出的成本越高，因此，应尽量扩展已有索引，而不是不假思索的新建索引。</li>
</ul>
<blockquote>
<p>✅️️️️ 什么情况<strong>适用</strong>索引？</p>
</blockquote>
<ul>
<li><strong>高频查询的字段</strong>：频繁作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，应考虑设为索引。</li>
<li><strong>频繁用于 <code>ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code> 的列</strong>。将该列作为索引，可以帮助加快这些操作。</li>
</ul>
<blockquote>
<p>❌ 什么情况<strong>不适用</strong>索引？</p>
</blockquote>
<ul>
<li><strong>非常小的表</strong>：对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li><strong>特大型的表</strong>：建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
<li><strong>高频更新的表</strong>：表更新时，需要同步维护索引，有额外的开销，会影响性能。</li>
<li><strong>低频查询的字段</strong>：很少作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，建立索引而带来的空间开销和维护成本可能超过查询性能提升所带来的收益。</li>
<li><strong>高度重复的字段</strong>：若索引字段的重复度高，意味着选择性低（如性别字段只有男和女），索引的效果不明显，且会增加额外的存储空间。</li>
<li><strong>长文本的字段</strong>：如 TEXT、BLOB 或非常长的 VARCHAR 类型，字段常包含大量数据。<ul>
<li>数据量大时，无法用内存排序，只能利用磁盘文件排序，速度很慢。</li>
<li>数据页默认 16KB，存储数据有限，超出范围，需要扫描多次 I&#x2F;O。</li>
<li>这种类型的数据如果有查询需求，应考虑使用 ES 来进行全文检索。</li>
</ul>
</li>
</ul>
<h3 id="【中等】哪些情况下，索引会失效？"><a href="#【中等】哪些情况下，索引会失效？" class="headerlink" title="【中等】哪些情况下，索引会失效？"></a>【中等】哪些情况下，索引会失效？</h3><p>导致索引失效的情况有：</p>
<ul>
<li><strong>违反最左前缀原则</strong><ul>
<li>❌跳过了最左列（如索引 <code>(a,b,c)</code>，但查询 <code>WHERE b=1</code>）</li>
<li>❌中间列被跳过（如 <code>WHERE a=1 AND c=3</code>，<code>c</code> 无法使用索引）</li>
</ul>
</li>
<li><strong>对索引使用函数或计算</strong><ul>
<li>❌ <code>WHERE YEAR(date_column) = 2023</code></li>
<li>❌ <code>WHERE column * 2 = 10</code></li>
<li>❌ <code>WHERE SUBSTRING(name, 1, 3) = &#39;Tom&#39;</code></li>
</ul>
</li>
<li><strong>数据类型不匹配（隐式类型转换）</strong><ul>
<li>❌ <code>WHERE string_column = 123</code>（字符串列用数字比较）</li>
<li>❌ <code>WHERE int_column = &#39;123&#39;</code>（数字列用字符串比较）</li>
</ul>
</li>
<li><strong>使用 <code>OR</code> 连接非索引列</strong><ul>
<li>❌ <code>WHERE a=1 OR b=2</code>（如果 <code>b</code> 无索引，全表扫描）</li>
<li>✅ <code>WHERE a=1 OR a=2</code>（<code>a</code> 有索引，可以优化）</li>
</ul>
</li>
<li><strong>使用范围查询（&gt;、&lt;、BETWEEN、LIKE）后的列失效</strong><ul>
<li>✅ <code>WHERE a=1 AND b=2</code>（<code>a, b</code> 都能用索引）</li>
<li>❌ <code>WHERE a&gt;1 AND b=2</code>（<code>a</code> 是范围查询，<code>b</code> 无法用索引）</li>
<li>❌ <code>WHERE name LIKE &#39;%abc&#39;</code>（前导通配符 <code>%</code> 导致索引失效）</li>
</ul>
</li>
<li><strong>使用 <code>!=</code>、<code>&lt;&gt;</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code></strong><ul>
<li>❌ <code>WHERE status != &#39;active&#39;</code></li>
<li>❌ <code>WHERE age NOT IN (18, 20)</code></li>
<li>❌ <code>WHERE phone IS NULL</code></li>
</ul>
</li>
</ul>
<h3 id="【简单】索引有哪些分类？"><a href="#【简单】索引有哪些分类？" class="headerlink" title="【简单】索引有哪些分类？"></a>【简单】索引有哪些分类？</h3><p>MySQL 索引可以从以下四个维度来分类：</p>
<ul>
<li>按【<strong>数据结构</strong>】分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong></li>
<li>按【<strong>物理存储</strong>】分类：<strong>聚簇索引、二级索引（辅助索引）</strong></li>
<li>按【<strong>字段特性</strong>】分类：<strong>主键索引、普通索引、前缀索引</strong></li>
<li>按【<strong>字段个数</strong>】分类：<strong>单列索引、联合索引（复合索引、组合索引）</strong></li>
</ul>
<h3 id="【简单】-和-in-的顺序对于命中索引是否有影响？"><a href="#【简单】-和-in-的顺序对于命中索引是否有影响？" class="headerlink" title="【简单】&#x3D; 和 in 的顺序对于命中索引是否有影响？"></a>【简单】&#x3D; 和 in 的顺序对于命中索引是否有影响？</h3><p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，MySQL 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="【简单】索引有哪些常见数据结构？"><a href="#【简单】索引有哪些常见数据结构？" class="headerlink" title="【简单】索引有哪些常见数据结构？"></a>【简单】索引有哪些常见数据结构？</h3><p>在 MySQL 中，<strong>索引是在存储引擎层而不是服务器层实现的</strong>，所以，并没有统一的索引标准。不同存储引擎的索引的数据结构也不相同。下面是 MySQL 常用存储引擎对一些主要索引数据结构的支持：</p>
<table>
<thead>
<tr>
<th>索引数据结构&#x2F;存储引擎</th>
<th>InnoDB 引擎</th>
<th>MyISAM 引擎</th>
<th>Memory 引擎</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B+ 树索引</strong></td>
<td>✅️️️️️️️</td>
<td>✅️️️️️️️</td>
<td>✅️️️️️️️</td>
</tr>
<tr>
<td><strong>Hash 索引</strong></td>
<td>❌</td>
<td>❌</td>
<td>✅️️️️️️️</td>
</tr>
<tr>
<td><strong>Full Text 索引</strong></td>
<td>✅️️️️️️️</td>
<td>✅️️️️️️️</td>
<td>❌</td>
</tr>
</tbody></table>
<p>MySQL 索引的常见数据结构：</p>
<ul>
<li><strong>哈希索引</strong><ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
<li><strong>只支持等值比较查询</strong> - 包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；<strong>不支持任何范围查询</strong>，如 <code>WHERE price &gt; 100</code>。</li>
<li><strong>无法用于排序</strong> - 因为哈希索引数据不是按照索引值顺序存储的。</li>
<li><strong>不支持部分索引匹配查找</strong> - 因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li><strong>不能用索引中的值来避免读取行</strong> - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
</li>
<li>B 树索引<ul>
<li>适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</li>
<li>所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>所有的叶子节点由指针连接。</li>
</ul>
</li>
</ul>
<h3 id="【中等】为什么-InnoDB-采用-B-树索引？"><a href="#【中等】为什么-InnoDB-采用-B-树索引？" class="headerlink" title="【中等】为什么 InnoDB 采用 B+ 树索引？"></a>【中等】为什么 InnoDB 采用 B+ 树索引？</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 $$O(log(N))$$。</p>
<p>当然为了维持 $$O(log(N))$$ 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 $$O(log(N))$$。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I&#x2F;O 消耗，相对于内存存取，I&#x2F;O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I&#x2F;O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I&#x2F;O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解 B+Tree 时，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>首先，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的 B+Tree。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200304235424.jpg"></p>
<blockquote>
<p>B+ 树 vs B 树</p>
</blockquote>
<ul>
<li>B+ 树只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+ 树的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</li>
<li>另外，B+ 树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li>
</ul>
<blockquote>
<p>B+ 树 vs 二叉树</p>
</blockquote>
<ul>
<li>对于有 N 个叶子节点的 B+ 树，其搜索复杂度为 <code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</li>
<li>在实际的应用当中， d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+ 树的高度依然维持在 1<del>3 层左右，也就是说一次数据查询操作只需要做 1</del>3 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</li>
<li>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+ 树高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</li>
</ul>
<p>一言以蔽之，使用 B+ 树，而不是二叉树，是为了减少树的高度，也就是为了减少磁盘 I&#x2F;O 次数。</p>
<blockquote>
<p>B+ 树索引和 Hash 索引的差异</p>
</blockquote>
<ul>
<li><strong>B+ 树索引支持范围查询</strong>；Hash 索引不支持。</li>
<li><strong>B+ 树索引支持联合索引的最左匹配原则</strong>；Hash 索引不支持。</li>
<li><strong>B+ 树索引支持排序</strong>；Hash 索引不支持。</li>
<li><strong>B+ 树索引支持模糊查询</strong>；Hash 索引不支持。</li>
<li>Hash 索引的等值查询比 B+ 树索引效率高。</li>
</ul>
<p>综上，Hash 索引的应用场景很苛刻，不适用于绝大多数场景。</p>
<h3 id="【中等】B-树索引能存多少数据？"><a href="#【中等】B-树索引能存多少数据？" class="headerlink" title="【中等】B+ 树索引能存多少数据？"></a>【中等】B+ 树索引能存多少数据？</h3><p>在 InnoDB 存储引擎中，B+ 树默认数据页大小为 <strong>16KB</strong>。</p>
<p>所有 B+ 树都是从高度为 1 的树开始，然后根据数据的插入，慢慢增加树的高度。随着插入 B+ 树索引的记录变多，1 个页（16K）无法存放这么多数据，所以会发生 B+ 树的分裂，B+ 树的高度变为 2。</p>
<blockquote>
<p>非叶子节点可存储的记录数</p>
</blockquote>
<p>根节点和中间节点存放的是索引键对，由（索引键、指针）组成。</p>
<p>索引键就是排序的列，而指针是指向下一层的地址，在 MySQL 的 InnoDB 存储引擎中占用 6 个字节。若主键是 BIGINT 类型，占 8 个字节。也即是说，这样的一个键值对需要 <code>8+6 = 14</code> 字节。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非叶子节点可存储的记录数 <span class="operator">=</span> 页大小（<span class="number">16</span>K） / 键值对大小（<span class="number">14</span>） ≈ <span class="number">1100</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>叶子节点可存储的记录数</p>
</blockquote>
<p>为了方便计算，假设数据记录的平均大小为 1000 字节（实际一般小于这个值），则</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">叶子节点可存储的记录数 <span class="operator">=</span> 页大小（<span class="number">16</span>K） / 记录平均大小（<span class="number">1000</span>） ≈ <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>由此可知，树高度为 2 的 B+ 树索引，有一个根节点，约 1100 个叶子节点。因此，最多能存放的记录数为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">二层</span> <span class="string">B+</span> <span class="string">树记录数</span> <span class="string">≈</span> <span class="number">171100</span> <span class="string">*</span> <span class="number">16</span> <span class="string">=</span>  <span class="number">17</span><span class="string">,600</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何推算不同高度的 B+ 树可存储的记录数</p>
</blockquote>
<p>综上所述，数据记录的平均大小为 1000 字节，主键为 <code>BIGINT</code> 的表，可以按如下推算其可存储的记录数：</p>
<ul>
<li>高度为 2 的 B+树索引最多能存放约 <code>1100 * 16 =  17,600</code> 条记录（约 1.76 万），查询时只需 2 次 I&#x2F;O。</li>
<li>高度为 3 的 B+树索引最多能存放约 <code>1100 * 1100 * 16 =  19,360,000</code> 条记录（约 2 千万），查询时只需 3 次 I&#x2F;O。</li>
<li>高度为 4 的 B+树索引最多能存放约 <code>1100 * 1100 * 1100 * 16 =  21,296,000,000</code> 条记录（约 200 多亿），查询时只需 4 次 I&#x2F;O。</li>
</ul>
<p>优化 B+ 树索引的插入性能：</p>
<ul>
<li>顺序插入（如自增 ID 或时间列）的维护代价小，性能较好。</li>
<li>无序插入（如用户昵称）会导致页分裂、旋转等开销较大的操作，影响性能。</li>
<li>主键设计应尽量使用顺序值（如自增 ID），以保证高并发场景下的性能。</li>
</ul>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="【中等】聚簇索引和非聚簇索引有什么区别？"><a href="#【中等】聚簇索引和非聚簇索引有什么区别？" class="headerlink" title="【中等】聚簇索引和非聚簇索引有什么区别？"></a>【中等】聚簇索引和非聚簇索引有什么区别？</h3><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引又被称为<strong>聚簇索引（clustered index），其叶子节点存的是整行数据</strong>。</p>
<ul>
<li>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快。</li>
<li>因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</li>
<li>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行。</li>
</ul>
<p>非主键索引又被称为<strong>二级索引（secondary index），其叶子节点存的是主键的值</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索主键索引树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503221604600.png"></p>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<h3 id="【简单】什么是覆盖索引？"><a href="#【简单】什么是覆盖索引？" class="headerlink" title="【简单】什么是覆盖索引？"></a>【简单】什么是覆盖索引？</h3><p><strong>覆盖索引是指：二级索引上的信息满足查询所需的所有字段，不需要回表查询聚簇索引上的数据</strong>。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<h2 id="字段特性索引"><a href="#字段特性索引" class="headerlink" title="字段特性索引"></a>字段特性索引</h2><h3 id="【简单】AUTO-INCREMENT-列达到最大值时会发生什么？"><a href="#【简单】AUTO-INCREMENT-列达到最大值时会发生什么？" class="headerlink" title="【简单】AUTO_INCREMENT 列达到最大值时会发生什么？"></a>【简单】AUTO_INCREMENT 列达到最大值时会发生什么？</h3><blockquote>
<p>配置主键</p>
</blockquote>
<p>在 MySQL 中，如果表定义的自增 ID 到达上限后，再申请下一个 ID，得到的值不变！因此会导致重复值的错误。</p>
<blockquote>
<p>没有配置主键</p>
</blockquote>
<p>如果 InnoDB 表中没有配置主键，InnoDB 会自动创建一个不可见的、长度为 6 个字节的 row_id 作为默认主键。</p>
<p>InnoDB 在全局维护一个 <code>dict_sys.row_id</code> 值。每次插入一行数据时，都会获取当前的 <code>dict_sys.row_id</code> 值，并将其加 1。<code>row_id</code> 的范围是 <code>0</code> 到 <code>2^48 - 1</code>。当 <code>row_id</code> 达到上限后，会从 <code>0</code> 开始重新循环。</p>
<p>如果插入的新数据的 <code>row_id</code> 在表中已存在，老数据会被新数据覆盖，且不会产生任何报错。可以通过 <code>gdb</code> 动态修改 <code>dict_sys.row_id</code> 来验证这一行为。</p>
<h3 id="【简单】普通键和唯一键，应该怎么选择？"><a href="#【简单】普通键和唯一键，应该怎么选择？" class="headerlink" title="【简单】普通键和唯一键，应该怎么选择？"></a>【简单】普通键和唯一键，应该怎么选择？</h3><p>唯一索引的主要作用是保证数据的唯一性，而普通索引则更灵活。在业务代码保证不会写入重复数据的情况下，普通索引和唯一索引在查询性能上几乎没有差别。</p>
<p><strong>普通索引</strong> 在更新操作中性能更优，尤其是在写多读少的场景下，能够利用 change buffer 减少磁盘 I&#x2F;O。</p>
<p><strong>唯一索引</strong> 适用于需要保证数据唯一性的场景，但在更新操作中性能较差，因为它无法使用 change buffer。</p>
<p>在业务允许的情况下，<strong>优先选择普通索引</strong>，因为它可以利用 change buffer 来提升更新性能。如果业务要求必须保证数据的唯一性，则必须使用唯一索引。</p>
<p><strong>查询过程的性能差异</strong>：对于查询操作，普通索引和唯一索引的性能差异微乎其微。唯一索引在找到第一个满足条件的记录后会停止检索，而普通索引需要继续查找下一个记录，但由于数据页的读取方式，这种差异可以忽略不计。</p>
<p><strong>更新过程的性能差异</strong>：更新操作中，普通索引可以利用 <strong>change buffer</strong> 来优化性能，而唯一索引则不能使用 change buffer。</p>
<ul>
<li><strong>change buffer</strong> 是一种将更新操作缓存在内存中的机制，减少了对磁盘的随机读取，从而提升了更新操作的性能。</li>
<li>唯一索引在更新时需要检查唯一性约束，必须将数据页读入内存，增加了磁盘 I&#x2F;O 的开销。</li>
</ul>
<p><strong>change buffer 的应用</strong></p>
<ul>
<li>change buffer 的数据是持久化的，即使机器掉电重启，change buffer 中的数据也不会丢失，因为它会被写入磁盘。</li>
<li>change buffer 适用于写多读少的场景，如账单类、日志类系统，因为这些场景下数据页在写入后不会立即被访问，change buffer 可以显著减少磁盘 I&#x2F;O。</li>
<li>对于写后立即查询的场景，change buffer 的效果不明显，甚至可能增加维护成本。</li>
</ul>
<p><strong>change buffer vs. redo log</strong></p>
<ul>
<li><strong>redo log</strong> 主要减少随机写磁盘的 I&#x2F;O 消耗，将随机写转换为顺序写。</li>
<li><strong>change buffer</strong> 主要减少随机读磁盘的 I&#x2F;O 消耗，通过缓存更新操作来减少磁盘读取。</li>
</ul>
<h3 id="【中等】为什么不推荐使用外键？"><a href="#【中等】为什么不推荐使用外键？" class="headerlink" title="【中等】为什么不推荐使用外键？"></a>【中等】为什么不推荐使用外键？</h3><p><strong>逻辑外键</strong>是一种在应用程序层面上管理和维护数据完整性的方法，而不是通过数据库本身的外键约束。主要是利用应用程序代码来保证引用的完整性。</p>
<p>逻辑外键的优缺点：</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>灵活性高</strong>：应用程序层面控制，可以更灵活地实现复杂的业务逻辑。</li>
<li><strong>性能优化</strong>：避免了数据库层面的约束检查，可以在某些情况下提高性能（详细看扩展知识）。</li>
<li><strong>跨数据库兼容性</strong>：逻辑外键在不同类型的数据之间更容易迁移。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>代码复杂性增加</strong>：需要在应用程序代码中手动实现和维护引用完整性，增加了代码的复杂性和错误的可能性。</li>
<li><strong>一致性风险</strong>：如果应用程序代码未正确实现引用完整性检查，可能导致数据不一致。</li>
<li><strong>维护成本高</strong>：逻辑外键需要开发人员持续关注和维护，增加了维护成本。</li>
</ul>
<p>物理外键的优缺点：</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>自动维护引用完整性</strong>：数据库会自动检查和维护外键约束，确保数据的一致性。</li>
<li><strong>减少应用层复杂性</strong>：开发人员不需要手动管理引用完整性，减少了代码的复杂性和错误的可能性。</li>
<li><strong>数据完整性保障</strong>：数据库层面的约束能够更有效地防止非法数据的插入或更新。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>性能开销</strong>：外键约束会增加插入、更新和删除操作的开销，特别是在处理大量数据时。</li>
<li><strong>迁移和复制的复杂性</strong>：在进行数据库迁移或复制时，外键约束可能会增加复杂性，需要小心处理。</li>
<li><strong>灵活性较低</strong>：物理外键在某些复杂业务逻辑下可能不够灵活，需要更多的手动控制。</li>
</ul>
<h3 id="【中等】什么是前缀索引？"><a href="#【中等】什么是前缀索引？" class="headerlink" title="【中等】什么是前缀索引？"></a>【中等】什么是前缀索引？</h3><p><strong>“前缀索引”是指索引开始的部分字符</strong>。对于 <code>BLOB</code>&#x2F;<code>TEXT</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p>前缀索引的优点是可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。</p>
<p>前缀索引的缺点是<strong>会降低索引的区分度</strong>。此外，**<code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引**。</p>
<h2 id="字段个数索引"><a href="#字段个数索引" class="headerlink" title="字段个数索引"></a>字段个数索引</h2><h3 id="【中等】什么是索引最左匹配原则？"><a href="#【中等】什么是索引最左匹配原则？" class="headerlink" title="【中等】什么是索引最左匹配原则？"></a>【中等】什么是索引最左匹配原则？</h3><p>使用联合索引时，查询条件必须从索引的最左列开始匹配。</p>
<p>其底层原理是，InnoDB 的索引采用 B+ 树数据结构，按字段顺序存储。其存储结构，决定了其查询时，必须遵循从左到右的顺序。</p>
<p>具体来说，最左匹配原则有以下几个要点：</p>
<blockquote>
<p>为方便直观的阐述，这里假设有一张表 t，设置了联合索引 <code>(a, b, c)</code>。</p>
</blockquote>
<ul>
<li><strong>必须包含最左列</strong>：如果查询条件中不包含最左列，则联合索引失效。即查询条件必须包含 <code>a</code> 才能使用索引。<ul>
<li>✅ <code>WHERE a=1</code>（能用索引）。</li>
<li>❌ <code>WHERE b=2</code>（不能使用索引，因为跳过了 <code>a</code>）。</li>
</ul>
</li>
<li><strong>连续匹配</strong>：不能跳过中间列，否则后面的列无法索引。<ul>
<li>✅ <code>WHERE a=1 AND b=2</code>（能使用 <code>a, b</code> 两列索引）。</li>
<li>❌ <code>WHERE a=1 AND c=3</code>（只能用到 <code>a</code>，<code>c</code> 无法索引，因为跳过了 <code>b</code>）。值得一提的是，MySQL 5.6 支持了<strong>索引下推</strong>（InnoDB 和 MyISAM 支持），允许这种情况下，将匹配 a 字段的数据推送到引擎层，由引擎层在这些数据中过滤出匹配 c 字段的数据，以此提升查询效率。</li>
</ul>
</li>
<li><strong>遇到范围查询，右侧失效</strong>：<ul>
<li>遇到 <code>&gt;</code>、<code>&lt;</code>、前缀 <code>LIKE</code>（%xx） 会停止匹配</li>
<li>注意：若遇到 &gt;&#x3D;、&lt;&#x3D;、<code>BETWEEN</code>、后缀 <code>LIKE</code>（xx%）这种范围查询，不会停止匹配，因为这些查询包含一个等值判断，可以直接定位到某个数据，向后扫描</li>
</ul>
</li>
</ul>
<p><strong>最左前缀匹配命中示例</strong></p>
<p>假设有索引 <code>(name, age, city)</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">✅ <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span>  <span class="comment">-- 完整使用索引</span></span><br><span class="line">✅ <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span>                     <span class="comment">-- 使用 name 和 age</span></span><br><span class="line">✅ <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span>                               <span class="comment">-- 仅使用 name</span></span><br><span class="line">❌ <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">25</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span>                  <span class="comment">-- 跳过了 name，无法使用索引</span></span><br><span class="line">❌ <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span>            <span class="comment">-- 只能用到 name，跳过了 age，但可以应用索引下推</span></span><br></pre></td></tr></table></figure>

<p>综上，优化 SQL 时，应尽量让查询条件符合最左前缀匹配原则，以提高查询效率。</p>
<h3 id="【中等】什么是索引下推？"><a href="#【中等】什么是索引下推？" class="headerlink" title="【中等】什么是索引下推？"></a>【中等】什么是索引下推？</h3><p>索引下推是一种减少回表查询、提高查询效率的技术。索引下推主要应用于联合索引。</p>
<p>它允许 MySQL 在使用索引查找数据时，将部分查询条件下推到存储引擎层进行过滤，从而减少需要从表中读取的数据行，减少 IO 操作。</p>
<p>索引下推注意点：</p>
<ul>
<li>MySQL 5.6 及以后版本支持索引下推，适用于 InnoDB 和 MyISAM 存储引擎。</li>
<li>综上，包含子查询，索引下推可能不会生效。</li>
<li>使用函数或表达式时，索引下推不会生效。</li>
<li>使用聚簇索引（主键）查询时，索引下推不会生效，因为它主要针对非聚簇索引。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/121084592">https://zhuanlan.zhihu.com/p/121084592</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/">图解 MySQL 介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8c04ec1b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8c04ec1b/" class="post-title-link" itemprop="url">《姜承尧的 MySQL 实战宝典》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-17 07:17:11" itemprop="dateCreated datePublished" datetime="2025-03-17T07:17:11+08:00">2025-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《姜承尧的-MySQL-实战宝典》笔记"><a href="#《姜承尧的-MySQL-实战宝典》笔记" class="headerlink" title="《姜承尧的 MySQL 实战宝典》笔记"></a>《姜承尧的 MySQL 实战宝典》笔记</h1><p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=869">拉勾教育教程 - 姜承尧的 MySQL 实战宝典</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/8c04ec1b/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/73d709d5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/73d709d5/" class="post-title-link" itemprop="url">MySQL CRUD</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-13 08:05:53" itemprop="dateCreated datePublished" datetime="2025-03-13T08:05:53+08:00">2025-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-CRUD"><a href="#MySQL-CRUD" class="headerlink" title="MySQL CRUD"></a>MySQL CRUD</h1><p>::: info 概述</p>
<p><strong>CRUD</strong> 由英文单词 <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete 的首字母组成，即<strong>增删改查</strong>。</p>
<p>本文通过介绍基本的 MySQL CRUD 方法，向读者呈现如何访问 MySQL 数据。</p>
<p>扩展阅读：<a href="https://dunwu.github.io/waterdrop/pages/2a3b4ae0/">SQL 语法必知必会</a></p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/73d709d5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/4a421d1e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/4a421d1e/" class="post-title-link" itemprop="url">MySQL 数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-13 08:05:53" itemprop="dateCreated datePublished" datetime="2025-03-13T08:05:53+08:00">2025-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h1><p>::: info 概述</p>
<p>数据类型在 MySQL 中扮演着至关重要的角色，它定义了表中每个字段可以存储的数据种类和格式。</p>
<p>MySQL 支持多种类型，大致可以分为三类：数值、时间和字符串类型。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/4a421d1e/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"aeeb3f9beb9de9d8a40e72b74dc3ab8e"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
