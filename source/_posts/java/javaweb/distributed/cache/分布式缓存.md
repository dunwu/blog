---
title: 分布式缓存
date: 2018-07-05
categories:
- 分布式
tags:
- 分布式
- 缓存
---

# 分布式缓存

<!-- TOC depthFrom:2 depthTo:3 -->

- [1. 缓存概述](#1-缓存概述)
    - [1.1. 缓存的原理](#11-缓存的原理)
    - [1.2. 缓存分类](#12-缓存分类)
    - [1.3. 缓存媒介](#13-缓存媒介)
    - [1.4. 缓存设计](#14-缓存设计)
- [2. CDN 缓存](#2-cdn-缓存)
    - [2.1. CDN 原理](#21-cdn-原理)
    - [2.2. CDN 优缺点](#22-cdn-优缺点)
    - [2.3. CND 架构参考](#23-cnd-架构参考)
    - [2.4. CND 技术实践](#24-cnd-技术实践)
- [3. 反向代理缓存](#3-反向代理缓存)
    - [3.1. 缓存原理](#31-缓存原理)
    - [3.2. Squid 示例](#32-squid-示例)
    - [3.3. 代理缓存比较](#33-代理缓存比较)
- [4. 分布式缓存](#4-分布式缓存)
    - [4.1. Memcache](#41-memcache)
    - [4.2. Memcache 工作原理](#42-memcache-工作原理)
    - [4.3. Memcache 集群](#43-memcache-集群)
    - [4.4. Redis](#44-redis)
    - [4.5. Redis 常用数据类型](#45-redis-常用数据类型)
    - [4.6. Redis 集群](#46-redis-集群)
    - [4.7. Memcache 与 Redis 的比较](#47-memcache-与-redis-的比较)
- [5. 本地缓存](#5-本地缓存)
    - [5.1. 硬盘缓存](#51-硬盘缓存)
    - [5.2. 内存缓存](#52-内存缓存)
- [6. 缓存架构示例](#6-缓存架构示例)
- [7. 数据一致性](#7-数据一致性)
    - [7.1. 场景介绍](#71-场景介绍)
    - [7.2. 解决方法](#72-解决方法)
    - [7.3. 其他方法](#73-其他方法)
- [8. 缓存高可用](#8-缓存高可用)
    - [8.1. 解决方法](#81-解决方法)
    - [8.2. 其他方法](#82-其他方法)
- [9. 缓存问题](#9-缓存问题)
    - [9.1. 缓存雪崩](#91-缓存雪崩)
    - [9.2. 缓存穿透](#92-缓存穿透)
    - [9.3. 缓存预热](#93-缓存预热)
    - [9.4. 缓存更新](#94-缓存更新)
    - [9.5. 缓存降级](#95-缓存降级)

<!-- /TOC -->

## 1. 缓存概述

缓存是分布式系统中的重要组件，主要解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。

### 1.1. 缓存的原理

1.  将数据写入/读取速度更快的存储（设备）；
2.  将数据缓存到离应用最近的位置；
3.  将数据缓存到离用户最近的位置。

### 1.2. 缓存分类

在分布式系统中，缓存的应用非常广泛，从部署角度有以下几个方面的缓存应用。

1.  CDN 缓存；
2.  反向代理缓存；
3.  分布式 Cache；
4.  本地应用缓存；

### 1.3. 缓存媒介

- 常用中间件：Varnish，Ngnix，Squid，Memcache，Redis，Ehcache 等；
- 缓存的内容：文件，数据，对象；
- 缓存的介质：CPU，内存（本地，分布式），磁盘（本地，分布式）

### 1.4. 缓存设计

缓存设计需要解决以下几个问题：

（1）缓存什么？

哪些数据需要缓存：热点数据、静态资源

（2）缓存的位置？

CDN，反向代理，分布式缓存服务器，本机（内存，硬盘）

（3）如何缓存的问题？

- 过期策略
  - 固定时间：比如指定缓存的时间是 30 分钟；
  - 相对时间：比如最近 10 分钟内没有访问的数据；
- 同步机制
  - 实时写入；（推）
  - 异步刷新；（推拉）

## 2. CDN 缓存

CDN 主要解决将数据缓存到离用户最近的位置，一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

### 2.1. CDN 原理

CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。

（1）未部署 CDN 应用前

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062828308-319014468.png"/></div><br>

网络路径：

- 请求：本机网络（局域网）——》运营商网络——》应用服务器机房
- 响应：应用服务器机房——》运营商网络——》本机网络（局域网）

在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。

（2）部署 CDN 应用后

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062837558-517040681.png"/></div><br>

网络路径：

- 请求：本机网络（局域网）——》运营商网络
- 响应：运营商网络——》本机网络（局域网）

在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。

与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高的系统的响应速度。

### 2.2. CDN 优缺点

（1）优点（摘自百度百科）

- 本地 Cache 加速：提升访问速度，尤其含有大量图片和静态页面站点；
- 镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；
- 远程加速：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；
- 带宽优化：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。
- 集群抗攻击：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。

（2）缺点

a. 动态资源缓存，需要注意实时性；

解决：主要缓存静态资源，动态资源建立多级缓存或准实时同步；

b. 如何保证数据的一致性和实时性需要权衡考虑；

解决：

1.  设置缓存失效时间（1 个小时，最终一致性）；
2.  数据版本号；

### 2.3. CND 架构参考

摘自《云宙视频 CDN 系统》

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062848590-1014999706.jpg"/></div><br>

### 2.4. CND 技术实践

​ 目前，中小型互联网公司，综合成本考虑，一般租用第三方 CDN 服务，大型互联网公司，采用自建或第三方结合的方式。比如淘宝刚开始使用第三方的，当流量很大后，第三方公司无法支撑其 CDN 流量，淘宝最后采用自建 CDN 的方式实现。

淘宝 CDN，如下图（来自网络）：

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062859808-1261244246.png"/></div><br>

## 3. 反向代理缓存

反向代理是指在网站服务器机房部署代理服务器，实现负载均衡，数据缓存，安全控制等功能。

### 3.1. 缓存原理

反向代理位于应用服务器机房，处理所有对 WEB 服务器的请求。如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062912886-1223701582.png"/></div><br>

​ 反向代理一般缓存静态资源，动态资源转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。

### 3.2. Squid 示例

Squid 反向代理一般只缓存静态资源，动态程序默认不缓存。根据从 WEB 服务器返回的 HTTP 头标记来缓冲静态页面。有四个最重要 HTTP 头标记：

- Last-Modified: 告诉反向代理页面什么时间被修改
- Expires: 告诉反向代理页面什么时间应该从缓冲区中删除
- Cache-Control: 告诉反向代理页面是否应该被缓冲
- Pragma: 用来包含实现特定的指令，最常用的是 Pragma:no-cache

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606062921683-1401924233.jpg"/></div><br>

Squid 反向代理加速网站实例

1.  通过 DNS 的轮询技术，将客户端的请求分发给其中一台 Squid 反向代理服务器处理；
2.  如果这台 Squid 缓存了用户的请求资源，则将请求的资源直接返回给用户；
3.  否则这台 Squid 将没有缓存的请求根据配置的规则发送给邻居 Squid 和后台的 WEB 服务器处理；
4.  这样既减轻后台 WEB 服务器的负载，又提高整个网站的性能和安全性。

### 3.3. 代理缓存比较

常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：

1.  Varnish 和 squid 是专业的 cache 服务，nginx 需要第三方模块支持；
2.  Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；
3.  Varnish 由于是内存 cache，所以对小文件如 css,js,小图片啥的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；
4.  Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 nginx 做负载均衡跑多个实例；
5.  Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 varnish，一般作为反向代理使用，可以实现简单的缓存。

## 4. 分布式缓存

CDN、反向代理缓存，主要解决静态文件，或用户请求资源的缓存，数据源一般为静态文件或动态生成的文件（有缓存头标识）。

分布式缓存，主要指缓存用户经常访问数据的缓存，数据源为数据库。一般起到热点数据访问和减轻数据库压力的作用。

目前分布式缓存设计，在大型网站架构中是必备的架构要素。常用的中间件有 Memcache，Redis。

### 4.1. Memcache

Memcache 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。

Memcache 特性：

- 使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcache 进程（不同端口）或者使用分布式 Memcache 进行缓存，将数据缓存到不同的物理机或者虚拟机上。
- 使用 key-value 的方式来存储数据，这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。
- 协议简单：基于文本行的协议，直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；
- 基于 libevent 高性能通信：Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。
- 内置的内存管理方式：所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过 LRU 算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。
- 分布式：各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcache 客户端。
- 缓存策略：Memcached 的缓存策略是 LRU（最近最少使用）到期失效策略。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。

### 4.2. Memcache 工作原理

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064023621-1066632858.png"/></div><br>

Memcache 的工作流程如下：

1.  先检查客户端的请求数据是否在 Memcached 中，如有，直接把请求数据返回，不再对数据库进行任何操作；
2.  如果请求的数据不在 Memcached 中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到 Memcached 中（Memcached 客户端不负责，需要程序实现）；
3.  每次更新数据库的同时更新 Memcached 中的数据，保证一致性；
4.  当分配给 Memcached 内存空间用完之后，会使用 LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。

### 4.3. Memcache 集群

Memcached 虽然称为 “ 分布式 ” 缓存服务器，但服务器端并没有 “ 分布式 ” 功能。每个服务器都是完全独立和隔离的服务。 Memcached 的分布式，是由客户端程序实现的。

当向 Memcached 集群存入/取出 key value 时，Memcached 客户端程序根据一定的算法计算存入哪台服务器，然后再把 key value 值存到此服务器中。

存取数据分二步走，第一步，选择服务器，第二步存取数据。

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064101183-532365936.png"/></div><br>

**分布式算法(Consistent Hashing)：**

选择服务器算法有两种，一种是根据余数来计算分布，另一种是根据散列算法来计算分布。

- 余数算法：
  先求得键的整数散列值，再除以服务器台数，根据余数确定存取服务器。
  - 优点：计算简单，高效；
  - 缺点：在 Memcached 服务器增加或减少时，几乎所有的缓存都会失效。
- 散列算法：（一致性 Hash）
  先算出 Memcached 服务器的散列值，并将其分布到 0 到 2 的 32 次方的圆上，然后用同样的方法算出存储数据的键的散列值并映射至圆上，最后从数据映射到的位置开始顺时针查找，将数据保存到查找到的第一个服务器上，如果超过 2 的 32 次方，依然找不到服务器，就将数据保存到第一台 Memcached 服务器上。

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064109965-1633058692.jpg"/></div><br>

如果添加了一台 Memcached 服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。

一致性 Hash 算法：解决了余数算法增加节点命中大幅额度降低的问题，理论上，插入一个实体节点，平均会影响到：虚拟节点数 /2 的节点数据的命中。

### 4.4. Redis

Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。

内置了 复制（replication），LUA 脚本（Lua scripting）， LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。

### 4.5. Redis 常用数据类型

1、String

常用命令：set,get,decr,incr,mget 。

应用场景：String 是最常用的一种数据类型，与 Memcache 的 key value 存储方式类似。

实现方式：String 在 Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr,decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为 int。

2、Hash

常用命令：hget,hset,hgetall 。

应用场景：以存储一个用户信息对象数据，为例：

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064128371-891992227.png"/></div><br>

实现方式：

Redis Hash 对应的 Value，内部实际就是一个 HashMap，实际这里会有 2 种不同实现。

（1） Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数 组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 value RedisObject 的 encoding 为 zipmap；

（2） 当成员数量增大时会自动转成真正的 HashMap,此时 encoding 为 ht。

3、List

常用命令：lpush,rpush,lpop,rpop,lrange。

应用场景：

Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现。

实现方式：

Redis list 的实现为一个双向链表，可以支持反向查找和遍历，方便操作。不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

4、Set

常用命令：sadd,spop,smembers,sunion。

应用场景：

Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。

实现方式：

set 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。

5、Sorted set

常用命令：zadd,zrange,zrem,zcard；

使用场景：

Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，可以选择 sorted set 数据结构，比如 twitter 的 public timeline 可以以发表时间作为 score 来存储，这样获取时就是自动按时间排好序的。

实现方式：

Redis sorted set 的内部使用 HashMap 和跳跃表(SkipList)来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的 是所有的成员，排序依据是 HashMap 里存的 score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

### 4.6. Redis 集群

（1）通过 keepalived 实现的高可用方案

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064149465-1648287265.png"/></div><br>

切换流程：

1.  当 Master 挂了后，VIP 漂移到 Slave；Slave 上 keepalived 通知 Redis 执行：slaveof no one ,开始提供业务
2.  当 Master 起来后，VIP 地址不变，Master 的 keepalived 通知 Redis 执行 slaveof slave IP host ，开始作为从同步数据
3.  依次类推

主从同时 Down 机情况：

- 非计划性，不做考虑，一般也不会存在这种问题
- 计划性重启，重启之前通过运维手段 SAVE DUMP 主库数据；需要注意顺序：
  1.  关闭其中一台机器上所有 Redis，使得 master 全部切到另外一台机器（多实例部署，单机上既有主又有从的情况）；并关闭机器。
  2.  依次 dump 主上 Redis 服务
  3.  关闭主
  4.  启动主，并等待数据 load 完毕
  5.  启动从
  6.  删除 DUMP 文件（避免重启加载慢）

（2）使用 Twemproxy 实现集群方案

由 twitter 开源的 c 版本 proxy，同时支持 Memcache 和 Redis，目前最新版本为：0.2.4，持续开发中;https://github.com/twitter/twemproxy .twitter 用它主要减少前端与缓存服务间网络连接数。

特点：快、轻量级、减少后端 Cache Server 连接数、易配置、支持 ketama、modula、random、常用 hash 分片算法。

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064241496-1034024146.png"/></div><br>

这里使用 keepalived 实现高可用主备方案，解决 proxy 单点问题；

优点：

- 对于客户端而言，Redis 集群是透明的，客户端简单，遍于动态扩容
- Proxy 为单点、处理一致性 hash 时，集群节点可用性检测不存在脑裂问题
- 高性能，CPU 密集型，而 Redis 节点集群多 CPU 资源冗余，可部署在 Redis 节点集群上，不需要额外设备

### 4.7. Memcache 与 Redis 的比较

- 数据结构：Memcache 只支持 key value 存储方式，Redis 支持更多的数据类型，比如 Key value，hash，list，set，zset；
- 多线程：Memcache 支持多线程，Redis 支持单线程；CPU 利用方面 Memcache 优于 Redis；
- 持久化：Memcache 不支持持久化，Redis 支持持久化；
- 内存利用率：Memcache 高，Redis 低（采用压缩的情况下比 Memcache 高）；
- 过期策略：Memcache 过期后，不删除缓存，会导致下次取数据数据的问题，Redis 有专门线程，清除缓存数据；

## 5. 本地缓存

本地缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。

### 5.1. 硬盘缓存

​ 将数据缓存到硬盘到，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。

### 5.2. 内存缓存

直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。

## 6. 缓存架构示例

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160606064322168-810312242.png"/></div><br>

职责划分：

- CDN：存放 HTML,CSS,JS 等静态资源；
- 反向代理：动静分离，只缓存用户请求的静态资源；
- 分布式缓存：缓存数据库中的热点数据；
- 本地缓存：缓存应用字典等常用数据；

请求过程：

1.  浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；
2.  如果 CDN 无缓存，则访问反向代理服务器；
3.  如果反向代理服务器有缓存则直接返回；
4.  如果反向代理服务器无缓存或动态请求，则访问应用服务器；
5.  应用服务器访问本地缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）
6.  如果本地缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；
7.  如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；

## 7. 数据一致性

缓存是在数据持久化之前的一个节点，主要是将热点数据放到离用户最近或访问速度更快的介质中，加快数据的访问，减小响应时间。

因为缓存属于持久化数据的一个副本，因此不可避免的会出现数据不一致问题。导致脏读或读不到数据的情况。数据不一致，一般是因为网络不稳定或节点故障导致。根据数据的操作顺序，主要有以下几种情况。

### 7.1. 场景介绍

（1）先写缓存，再写数据库

​ 如下图：

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110523914-514476589.jpg"/></div><br>

假如缓存写成功，但写数据库失败或响应延迟，则下次读取（并发读）缓存时，就出现脏读；

（2）先写数据库，再写缓存

​ 如下图：

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110532039-1008665032.jpg"/></div><br>

​ 假如写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据；

（3）缓存异步刷新

​ 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候。

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110540555-889329617.jpg"/></div><br>

​ 此种情况，主要考虑数据写入和缓存刷新的时效性。比如多久内刷新缓存，不影响用户对数据的访问。

### 7.2. 解决方法

第一个场景：

这个写缓存的方式，本身就是错误的，需要改为先写持久化介质，再写缓存的方式。

第二个场景：

（1）根据写入缓存的响应来进行判断，如果缓存写入失败，则回滚数据库操作；此种方法增加了程序的复杂度，不建议采用；

（2）缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现。

第三个场景：

（1）首先确定，哪些数据适合此类场景；

（2）根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔；

### 7.3. 其他方法

- 超时：设置合理的超时时间；
- 刷新：定时刷新一定范围内（根据时间，版本号）的数据；

​ 以上是简化数据读写场景，实际中会分为：

- 缓存与数据库之间的一致性；
- 多级缓存之间的一致性；
- 缓存副本之间的一致性。

## 8. 缓存高可用

业界有两种理论，第一套缓存就是缓存，临时存储数据的，不需要高可用。第二种缓存逐步演化为重要的存储介质，需要做高可用。

本人的看法是，缓存是否高可用，需要根据实际的场景而定。临界点是：是否对后端的数据库造成影响。

具体的决策依据需要根据，集群的规模（数据，缓存），成本（服务器，运维），系统性能（并发量，吞吐量，响应时间）等方面综合评价。

### 8.1. 解决方法

​ 缓存的高可用，一般通过分布式和复制实现。分布式实现数据的海量缓存，复制实现缓存数据节点的高可用。架构图如下：

<br><div align="center"><img src="https://images2015.cnblogs.com/blog/820332/201606/820332-20160619110556336-2133732642.jpg"/></div><br>

​ 其中，分布式采用一致性 Hash 算法，复制采用异步复制。

### 8.2. 其他方法

1.  复制双写：缓存节点的复制，由异步改为双写，只有两份都写成功，才算成功。
2.  虚拟层：一致性 Hash 存在，假如其中一个 HASH 环不可用，数据会写入临近的环，当 HASH 可用时，数据又写入正常的 HASH 环，会导致数据偏移问题。这种情况，可以考虑在 HASH 环前面加一个虚拟层实现。
3.  多级缓存：比如一级使用本地缓存，二级采用分布式 Cahce，三级采用分布式 Cache+本地持久化；

​ 方式很多，需要根据业务场景灵活选择。

## 9. 缓存问题

### 9.1. 缓存雪崩

缓存雪崩是指：在高并发场景下，由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

解决方案：

1.  合理规划缓存的失效时间；
2.  合理评估数据库的负载压力；
3.  对数据库进行过载保护或应用层限流；
4.  多级缓存设计，缓存高可用；

缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。

### 9.2. 缓存穿透

​ 缓存一般是 Key，value 方式存在，当某一个 Key 不存在时会查询数据库，假如这个 Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。

当在流量较大时，出现这样的情况，一直请求 DB，很容易导致服务挂掉。

解决方法：

1.  对结果为空的数据也进行缓存，当此 key 有数据后，清理缓存；
2.  一定不存在的 key，采用布隆过滤器，建立一个大的 Bitmap 中，查询时通过该 bitmap 过滤；

### 9.3. 缓存预热

缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决方案：

1.  直接写个缓存刷新页面，上线时手工操作下；
2.  数据量不大，可以在项目启动的时候自动进行加载；
3.  定时刷新缓存；

### 9.4. 缓存更新

除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

1.  定时去清理过期的缓存；
2.  当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。

### 9.5. 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。
