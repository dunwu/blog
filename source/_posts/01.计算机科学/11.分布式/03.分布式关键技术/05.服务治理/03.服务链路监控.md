---
title: 服务链路监控
date: 2022-04-20 09:08:29
categories:
  - 计算机科学
  - 分布式
  - 分布式关键技术
  - 服务治理
tags:
  - 分布式
  - 服务治理
  - 监控
  - APM
  - 链路追踪
permalink: /pages/b46249/
abbrlink: ec339fb7
---

# 服务追踪

## 什么是服务追踪

在微服务架构下，由于进行了服务拆分，一次请求往往需要涉及多个服务，每个服务可能是由不同的团队开发，使用了不同的编程语言，还有可能部署在不同的机器上，分布在不同的数据中心。如果请求失败了，要想查清楚到底是哪个应用导致，会是非常复杂的一件事情。

如果有一个系统，可以跟踪记录一次用户请求都发起了哪些调用，经过哪些服务处理，并且记录每一次调用所涉及的服务的详细信息，这时候如果发生调用失败，你就可以通过这个日志快速定位是在哪个环节出了问题，这个系统就是服务链路监控。

## 为什么需要服务追踪

- **优化系统瓶颈**：通过记录调用经过的每一条链路上的耗时，我们能快速定位整个系统的瓶颈点在哪里。比如你访问微博首页发现很慢，肯定是由于某种原因造成的，有可能是运营商网络延迟，有可能是网关系统异常，有可能是某个服务异常，还有可能是缓存或者数据库异常。通过服务追踪，可以从全局视角上去观察，找出整个系统的瓶颈点所在，然后做出针对性的优化。
- **优化链路调用**：通过服务追踪可以分析调用所经过的路径，然后评估是否合理。比如一个服务调用下游依赖了多个服务，通过调用链分析，可以评估是否每个依赖都是必要的，是否可以通过业务优化来减少服务依赖。还有就是，一般业务都会在多个数据中心都部署服务，以实现异地容灾，这个时候经常会出现一种状况就是服务 A 调用了另外一个数据中心的服务 B，而没有调用同处于一个数据中心的服务 B。根据我的经验，跨数据中心的调用视距离远近都会有一定的网络延迟，像北京和广州这种几千公里距离的网络延迟可能达到 30ms 以上，这对于有些业务几乎是不可接受的。通过对调用链路进行分析，可以找出跨数据中心的服务调用，从而进行优化，尽量规避这种情况出现。
- **生成网络拓扑**：通过服务追踪系统中记录的链路信息，可以生成一张系统的网络调用拓扑图，它可以反映系统都依赖了哪些服务，以及服务之间的调用关系是什么样的，可以一目了然。除此之外，在网络拓扑图上还可以把服务调用的详细信息也标出来，也能起到服务监控的作用。
- **透明传输数据**：除了服务追踪，业务上经常有一种需求，期望能把一些用户数据，从调用的开始一直往下传递，以便系统中的各个服务都能获取到这个信息。比如业务想做一些 A/B 测试，这时候就想通过服务追踪系统，把 A/B 测试的开关逻辑一直往下传递，经过的每一层服务都能获取到这个开关值，就能够统一进行 A/B 测试。

## 服务链路监控的原理

Google 发布的一篇的论文 [`Dapper, a Large-Scale Distributed Systems Tracing Infrastructure`](http://bigbully.github.io/Dapper-translation/)，里面详细讲解了服务追踪系统的实现原理。它的核心理念就是**调用链**：通过一个全局唯一的 ID 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。

可以说后面的诞生各种服务追踪系统都是基于 Dapper 衍生出来的，比较有名的有 Twitter 的[Zipkin](http://zipkin.io)、阿里的[鹰眼](http://www.slideshare.net/terryice/eagleeye-with-taobaojavaone)、美团的[MTrace](http://tech.meituan.com/mt_mtrace.html)等。

要理解服务追踪的原理，首先必须搞懂一些基本概念：traceId、spanId、annonation 等。Dapper 这篇论文讲得比较清楚，但对初学者来说理解起来可能有点困难，美团的 MTrace 的原理介绍理解起来相对容易一些，下面我就以 MTrace 为例，给你详细讲述服务追踪系统的实现原理。虽然原理有些晦涩，但却是你必须掌握的，只有理解了服务追踪的基本概念，才能更好地将其实现出来。

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220420092134.png)

- **Trace**：用于表示某一次具体的请求。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 **Trace ID**，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 **Trace ID** 就可以把一次用户请求在系统中调用的路径串联起来。
- **Span**：工作的基本单位。Span 用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 **Span ID** 初始值是 0，进入下一层 RPC 调用 B 的时候 **Span ID** 是 0.1，继续进入下一层 RPC 调用 C 时 **Span ID** 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 **Span ID** 是 0.2，这样的话通过 **Span ID** 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。
- **Annotation**：用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。

## 服务追踪系统实现

一个服务追踪系统可以分为三层：

- 数据采集层，负责数据埋点并上报。
- 数据处理层，负责数据的存储与计算。
- 数据展示层，负责数据的图形化展示。

### 数据采集层

数据采集层的作用就是在系统的各个不同模块中进行埋点，采集数据并上报给数据处理层进行处理。

那么该如何进行数据埋点呢？

一次 RPC 请求可以分为四个阶段。

- **CS（Client Send）**阶段 : 客户端发起请求，并生成调用的上下文。
- **SR（Server Recieve）**阶段 : 服务端接收请求，并生成上下文。
- **SS（Server Send）**阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38。
- **CR（Client Recieve）**阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38。

### 数据处理层

数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。

数据处理的需求一般分为两类，一类是实时计算需求，一类是离线计算需求。

实时计算需求对计算效率要求比较高，一般要求对收集的链路数据能够在秒级别完成聚合计算，以供实时查询。而离线计算需求对计算效率要求就没那么高了，一般能在小时级别完成链路数据的聚合计算即可，一般用作数据汇总统计。针对这两类不同的数据处理需求，采用的计算方法和存储也不相同。

- **实时数据处理**：针对实时数据处理，一般采用 Flink、Storm、Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。

- **离线数据处理**：针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。

### 数据展示层

数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。

实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。

#### 调用链路图

调用链路图一般展示服务总耗时、服务调用的网络深度、每一层经过的系统，以及多少次调用。调用链路图在实际项目中，主要是被用来做故障定位，比如某一次用户调用失败了，可以通过调用链路图查询这次用户调用经过了哪些环节，到底是哪一层的调用失败所导致。

下面是 Zipkin 的调用链路图：

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220420103316.png)

#### 调用拓扑图

调用拓扑图一般展示系统内都包含哪些应用，它们之间是什么关系，以及依赖调用的 QPS、平均耗时情况。调用拓扑图是一种全局视野图，在实际项目中，主要用作全局监控，用于发现系统中异常的点，从而快速做出决策。比如，某一个服务突然出现异常，那么在调用链路拓扑图中可以看出对这个服务的调用耗时都变高了，可以用红色的图样标出来，用作监控报警。

下面是 Pinpoint 的调用链路图：

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220420103528.png)

## 服务追踪技术选型

服务追踪的主流开源产品比较丰富，主要有

- [**Zipkin**](https://zipkin.io/)：Zipkin 是 Twitter 开源的调用链分析工具，目前基于 **[spring-cloud-sleuth](https://github.com/spring-cloud/spring-cloud-sleuth)** 得到了广泛的使用，特点是轻量，使用、部署简单。
- [**Pinpoint**](https://pinpoint-apm.gitbook.io/pinpoint/)：是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能强大，接入端无代码侵入。
- [**SkyWalking**](https://skywalking.apache.org/)：是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能较强，接入端无代码侵入。目前已加入 Apache 孵化器。
- [**CAT**](https://github.com/dianping/cat)：CAT 是美团点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。

## 参考资料

- [从 0 开始学微服务](https://time.geekbang.org/column/intro/100014401)
- [RPC 实战与核心原理](https://time.geekbang.org/column/intro/100046201)
- [微服务架构核心 20 讲](https://time.geekbang.org/course/intro/100003901)
