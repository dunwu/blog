<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6af68a7a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6af68a7a/" class="post-title-link" itemprop="url">分布式调度面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 16:51:30" itemprop="dateCreated datePublished" datetime="2024-12-26T16:51:30+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6/" itemprop="url" rel="index"><span itemprop="name">分布式调度</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式调度面试"><a href="#分布式调度面试" class="headerlink" title="分布式调度面试"></a>分布式调度面试</h1><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><h3 id="【基础】什么是服务注册和发现？"><a href="#【基础】什么是服务注册和发现？" class="headerlink" title="【基础】什么是服务注册和发现？"></a>【基础】什么是服务注册和发现？</h3><p>:::details 要点</p>
<p>服务定义是服务提供者和服务消费者之间的约定，但是在微服务架构中，如何达成这个约定呢？这就依赖于服务注册和发现机制。</p>
<p>在微服务架构下，服务注册和发现机制中主要有三种角色：</p>
<ul>
<li><strong>服务提供者</strong>（RPC Server &#x2F; Provider）</li>
<li><strong>服务消费者</strong>（RPC Client &#x2F; Consumer）</li>
<li><strong>服务注册中心</strong>（Registry）</li>
</ul>
<p>服务发现通常依赖于<strong>注册中心</strong>来协调服务发现的过程，其步骤如下：</p>
<ol>
<li>服务提供者将接口信息以注册到注册中心。</li>
<li>服务消费者从注册中心读取和订阅服务提供者的地址信息。</li>
<li>如果有可用的服务，注册中心会主动通知服务消费者。</li>
<li>服务消费者根据可用服务的地址列表，调用服务提供者的接口。</li>
</ol>
<p>这个过程很像是生活中的房屋租赁，房东将租房信息挂到中介公司，房客从中介公司查找租房信息。房客如果想要租房东的房子，通过中介公司牵线搭桥，联系上房东，双方谈妥签订协议，就可以正式建立起租赁关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220415171843.png" alt="img"></p>
<p>:::</p>
<h3 id="【中级】注册中心有哪些基本功能？"><a href="#【中级】注册中心有哪些基本功能？" class="headerlink" title="【中级】注册中心有哪些基本功能？"></a>【中级】注册中心有哪些基本功能？</h3><p>:::details 要点</p>
<p>从服务注册和发现的流程，可以看出，<strong>注册中心是服务发现的核心组件</strong>。常见的注册中心组件有：Nacos、Consul、Zookeeper 等。</p>
<p>注册中心的实现主要涉及几个问题：注册中心需要提供哪些接口，该如何部署；如何存储服务信息；如何监控服务提供者节点的存活；如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。</p>
<h4 id="元数据定义"><a href="#元数据定义" class="headerlink" title="元数据定义"></a>元数据定义</h4><p>构建微服务的首要问题是：服务提供者和服务消费者通信时，如何达成共识。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。</p>
<p>常见的定义服务元数据的方式有：</p>
<ul>
<li><strong>XML 文件</strong> - 如果只是企业内部之间的服务调用，并且都是 Java 语言的话，选择 XML 配置方式是最简单的。</li>
<li><strong>IDL 文件</strong> - 如果企业内部存在多个跨语言服务，建议使用 IDL 文件方式进行描述服务。</li>
<li><strong>REST API</strong> - 如果存在对外开放服务调用的情形的话，使用 REST API 方式则更加通用。</li>
</ul>
<h4 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h4><p>注册中心本质上是一个用于保存元数据的分布式存储。你如果明白了这一点，就会了解实现一个注册中心的所有要点都是围绕这个目标去构建的。</p>
<p>想要构建微服务，首先要解决的问题是，服务提供者如何发布一个服务，服务消费者如何引用这个服务。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。</p>
<p>服务的<strong>元数据信息</strong>通常有以下信息：</p>
<ul>
<li>服务节点信息，如 IP、端口等。</li>
<li>接口定义，如接口名、请求参数、响应参数等。</li>
<li>请求失败的重试次数</li>
<li>序列化方式</li>
<li>压缩方式</li>
<li>通信协议</li>
<li>等等</li>
</ul>
<p>在具体存储时，注册中心一般会按照“服务 - 分组 - 节点信息”的<strong>层次化的结构</strong>来存储。</p>
<h4 id="注册中心-API"><a href="#注册中心-API" class="headerlink" title="注册中心 API"></a>注册中心 API</h4><p>既然是分布式存储，势必要提供支持读写数据的接口，也就是 API，一般来说，需要支持以下功能：</p>
<ul>
<li><strong>服务注册接口</strong>：服务提供者通过调用服务注册接口来完成服务注册。</li>
<li><strong>服务反注册接口</strong>：服务提供者通过调用服务反注册接口来完成服务注销。</li>
<li><strong>心跳汇报接口</strong>：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</li>
<li><strong>服务订阅接口</strong>：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</li>
<li><strong>服务变更查询接口</strong>：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</li>
</ul>
<p>除此之外，为了便于管理，注册中心还必须提供一些后台管理的 API，例如：</p>
<ul>
<li><strong>服务查询接口</strong>：查询注册中心当前注册了哪些服务信息。</li>
<li><strong>服务修改接口</strong>：修改注册中心中某一服务的信息。</li>
</ul>
<h4 id="服务健康检测"><a href="#服务健康检测" class="headerlink" title="服务健康检测"></a>服务健康检测</h4><p>注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。<strong>注册中心通常使用长连接或心跳探测方式检查服务健康状态</strong>。</p>
<p>还是以 ZooKeeper 为例，它是基于 ZooKeeper 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。在 ZooKeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 Session ID。服务端和客户端维持的是一个长连接，在 SESSION_TIMEOUT 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 SESSION_TIMEOUT 时间。如果超过 SESSION_TIMEOUT 后服务端都没有收到客户端的心跳消息，则服务端认为这个 Session 就已经结束了，ZooKeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。</p>
<h4 id="服务状态变更通知"><a href="#服务状态变更通知" class="headerlink" title="服务状态变更通知"></a>服务状态变更通知</h4><p>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。注册中心通常基于服务状态订阅来实现服务状态变更通知。</p>
<p>继续以 ZooKeeper 为例，基于 ZooKeeper 的 Watcher 机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用 ZooKeeper 的 getData 方法订阅服务时，还可以通过监听器 Watcher 的 process 方法获取服务的变更，然后调用 getData 方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p>
<h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 理论</a>，三种特性无法同时达成，必须在可用性和一致性之间做取舍。于是，根据不同侧重点，注册中心可以分为 CP 和 AP 两个阵营：</p>
<ul>
<li><strong>CP 型注册中心</strong> - <strong>牺牲可用性来换取数据强一致性</strong>，最典型的例子就是 ZooKeeper，etcd，Consul 了。ZooKeeper 集群内只有一个 Leader，而且在 Leader 无法使用的时候通过算法选举出一个新的 Leader。这个 Leader 的目的就是保证写信息的时候只向这个 Leader 写入，Leader 会同步信息到 Followers，这个过程就可以保证数据的强一致性。但如果多个 ZooKeeper 之间网络出现问题，造成出现多个 Leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 Consul 集群内都是通过 Raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。</li>
<li><strong>AP 型注册中心</strong> - <strong>牺牲一致性（只保证最终一致性）来换取可用性</strong>，最典型的例子就是 Eureka、Nacos 了。对比下 Zookeeper，Eureka 不用选举一个 Leader，每个 Eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。</li>
</ul>
<p>:::</p>
<h3 id="【高级】注册中心有哪些扩展功能？"><a href="#【高级】注册中心有哪些扩展功能？" class="headerlink" title="【高级】注册中心有哪些扩展功能？"></a>【高级】注册中心有哪些扩展功能？</h3><p>:::details 要点</p>
<h4 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h4><p>对于服务消费者来说，要能够同时从多个注册中心订阅服务；</p>
<p>对于服务提供者来说，要能够同时向多个注册中心注册服务。</p>
<h4 id="并行订阅服务"><a href="#并行订阅服务" class="headerlink" title="并行订阅服务"></a>并行订阅服务</h4><p>如果只支持串行订阅，如果服务消费者订阅的服务较多，并且某些服务节点的初始化连接过程中出现连接超时的情况，则后续所有的服务节点的初始化连接都需要等待它完成，这就会导致消费者启动非常慢。</p>
<p>可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。</p>
<h4 id="批量注销服务"><a href="#批量注销服务" class="headerlink" title="批量注销服务"></a>批量注销服务</h4><p>在与注册中心的多次交互中，可能由于网络抖动、注册中心集群异常等原因，导致个别调用失败。对于注册中心来说，偶发的注册调用失败对服务调用基本没有影响，其结果顶多就是某一个服务少了一个可用的节点。但偶发的反注册调用失败会导致不可用的节点残留在注册中心中，变成“僵尸节点”。</p>
<p>需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。</p>
<h4 id="服务变更信息增量更新"><a href="#服务变更信息增量更新" class="headerlink" title="服务变更信息增量更新"></a>服务变更信息增量更新</h4><p>为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息。尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。</p>
<h4 id="心跳开关保护机制"><a href="#心跳开关保护机制" class="headerlink" title="心跳开关保护机制"></a>心跳开关保护机制</h4><p>在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。</p>
<p>所以针对这种情况，<strong>需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息</strong>。</p>
<p>我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1&#x2F;10。</p>
<p>当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。</p>
<h4 id="服务节点摘除保护机制"><a href="#服务节点摘除保护机制" class="headerlink" title="服务节点摘除保护机制"></a>服务节点摘除保护机制</h4><p>服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。</p>
<p>如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。</p>
<p><strong>这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点</strong>。</p>
<p>这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。</p>
<h4 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h4><p>在实际的微服务测试和部署时，通常包含多套环境，比如生产环境一套、测试环境一套。开发在进行业务自测、测试在进行回归测试时，一般都是用测试环境，部署的 RPC Server 节点注册到测试的注册中心集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中心集群，这样的话线上流量就会调用到测试环境下的 RPC Server 节点，可能会造成意想不到的后果。</p>
<p>为了防止这种情况发生，注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的 RPC Server 才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h4 id="静态注册中心"><a href="#静态注册中心" class="headerlink" title="静态注册中心"></a>静态注册中心</h4><p>因为服务提供者是向服务消费者提供服务的，服务是否可用，服务消费者应该比注册中心更清楚。因此，可以直接在服务消费者端，根据调用服务提供者是否成功来判定服务提供者是否可用。如果服务消费者调用某一个服务提供者节点连续失败超过一定次数，可以在本地内存中将这个节点标记为不可用。并且每隔一段固定时间，服务消费者都要向标记为不可用的节点发起保活探测，如果探测成功了，就将标记为不可用的节点再恢复为可用状态，重新发起调用。</p>
<p>:::</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="【基础】什么是负载均衡？为什么需要负载均衡？"><a href="#【基础】什么是负载均衡？为什么需要负载均衡？" class="headerlink" title="【基础】什么是负载均衡？为什么需要负载均衡？"></a>【基础】什么是负载均衡？为什么需要负载均衡？</h3><p>:::details 要点</p>
<p><strong>“负载均衡（Load Balance，简称 LB）”是一种技术，用来在多个计算机、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源利用率、最大化吞吐率、最小化响应时间、同时避免过载的目的</strong>。</p>
<p>负载均衡的主要作用如下：</p>
<ul>
<li><strong>高并发</strong>：负载均衡可以优化资源使用率，通过算法调整负载，尽力均匀的分配资源，以此提高资源利用率、从而提升整体吞吐量。</li>
<li><strong>伸缩性</strong>：发生增减资源时，负载均衡可以自动调整分发，使得应用集群具备伸缩性。</li>
<li><strong>高可用</strong>：负载均衡器可以监控候选机器，当某机器不可用时，自动跳过，将请求分发给可用的机器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护</strong>：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单、防火墙，防 DDos 攻击等。</li>
</ul>
<p>:::</p>
<h3 id="【中级】负载均衡技术有哪些分类？"><a href="#【中级】负载均衡技术有哪些分类？" class="headerlink" title="【中级】负载均衡技术有哪些分类？"></a>【中级】负载均衡技术有哪些分类？</h3><p>:::details 要点</p>
<p>支持负载均衡的技术很多，我们可以通过不同维度去进行分类。</p>
<h4 id="载体维度分类"><a href="#载体维度分类" class="headerlink" title="载体维度分类"></a>载体维度分类</h4><p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p>
<ul>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<h5 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h5><p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，<strong>价格昂贵，土豪专属</strong>。</p>
<p>硬件负载均衡的<strong>主流产品</strong>有：<a target="_blank" rel="noopener" href="https://f5.com/zh">F5</a> 和 <a target="_blank" rel="noopener" href="https://www.a10networks.com.cn/">A10</a>。</p>
<p>硬件负载均衡的<strong>优点</strong>：</p>
<ul>
<li><strong>功能强大</strong>：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li><strong>性能强悍</strong>：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li><strong>安全性高</strong>：往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>硬件负载均衡的<strong>缺点</strong>：</p>
<ul>
<li><strong>成本昂贵</strong>：购买和维护硬件负载均衡的成本都很高。</li>
<li><strong>扩展性差</strong>：当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h5 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h5><p>软件负载均衡，<strong>应用最广泛</strong>，无论大公司还是小公司都会使用。</p>
<p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>
<p>软件负载均衡的 <strong>主流产品</strong> 有：<a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a>、<a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS</a>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS</a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a>、<a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a> 可以作为四层或七层负载均衡器。</li>
</ul>
<p>软件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>扩展性好</strong>：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li><strong>成本低廉</strong>：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>软件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能略差</strong>：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<h4 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h4><p>软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p>
<ul>
<li>七层负载均衡：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。<ul>
<li>DNS 重定向</li>
<li>HTTP 重定向</li>
<li>反向代理</li>
</ul>
</li>
<li>四层负载均衡：基于 IP 地址和端口进行请求的转发。<ul>
<li>修改 IP 地址</li>
<li>修改 MAC 地址</li>
</ul>
</li>
</ul>
<h5 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h5><p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p>
<p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p>
<p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643409.png" alt="img"></p>
<p>DNS 重定向的 <strong>优点</strong>：</p>
<ul>
<li><strong>使用简单</strong>：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li><strong>提高性能</strong>：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li>
</ul>
<p>DNS 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>可用性差</strong>：DNS 解析是多级解析，新增&#x2F;修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性差</strong>：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong>：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<h5 id="HTTP-负载均衡"><a href="#HTTP-负载均衡" class="headerlink" title="HTTP 负载均衡"></a>HTTP 负载均衡</h5><p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643410.png" alt="img"></p>
<p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p>
<p>HTTP 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>额外的转发开销</strong>：每次访问需要两次请求服务器，增加了访问的延迟。</li>
<li><strong>降低搜索排名</strong>：使用重定向后，搜索引擎会视为 SEO 作弊。</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<h5 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h5><p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<p>反向代理服务的主流产品：<strong>Nginx</strong>、<strong>Apache</strong>。</p>
<p>正向代理与反向代理有什么区别？</p>
<ul>
<li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643411.png" alt="img"></p>
<p>反向代理是如何实现负载均衡的呢？以 Nginx 为例，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/web/nginx/nginx-load-balance.png" alt="img"></p>
<p>首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。</p>
<p>反向代理的 <strong>优点</strong>：</p>
<ul>
<li><strong>多种负载均衡算法</strong>：支持多种负载均衡算法，以应对不同的场景需求。</li>
<li><strong>可以监控服务器</strong>：基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
</ul>
<p>反向代理的 <strong>缺点</strong>：</p>
<ul>
<li><p><strong>额外的转发开销</strong>：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。</p>
</li>
<li><p><strong>增加系统复杂度</strong>：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p>
</li>
<li><p>反向代理服务如果自身宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</p>
<ul>
<li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li>
</ul>
</li>
</ul>
<h5 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h5><p>IP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643413.png" alt="img"></p>
<p>如上图所示，IP 均衡处理流程大致为：</p>
<ol>
<li>客户端请求 192.168.137.10，由负载均衡服务器接收到报文。</li>
<li>负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。</li>
<li>真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。</li>
<li>负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。</li>
</ol>
<p>IP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。</p>
<h5 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h5><p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643412.png" alt="img"></p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。</p>
<p>LVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p>
<p>LVS 的工作流程大致如下：</p>
<ul>
<li>当用户访问 <a target="_blank" rel="noopener" href="http://www.sina.com.cn/">www.sina.com.cn</a> 时，用户数据通过层层网络，最后通过交换机进入 LVS 服务器网卡，并进入内核网络层。</li>
<li>进入 PREROUTING 后经过路由查找，确定访问的目的 VIP 是本机 IP 地址，所以数据包进入到 INPUT 链上</li>
<li>IPVS 是工作在 INPUT 链上，会根据访问的 <code>vip+port</code> 判断请求是否 IPVS 服务，如果是则调用注册的 IPVS HOOK 函数，进行 IPVS 相关主流程，强行修改数据包的相关数据，并将数据包发往 POSTROUTING 链上。</li>
<li>POSTROUTING 上收到数据包后，根据目标 IP 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。</li>
</ul>
<p>开源 LVS 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：DR 模式、NAT 模式、Tunnel 模式。</p>
<p>:::</p>
<h3 id="【高级】负载均衡有哪些算法？"><a href="#【高级】负载均衡有哪些算法？" class="headerlink" title="【高级】负载均衡有哪些算法？"></a>【高级】负载均衡有哪些算法？</h3><p>:::details 要点</p>
<p>负载均衡器的实现可以分为两个部分：</p>
<ul>
<li>根据负载均衡算法在候选机器列表选出一个机器；</li>
<li>将请求数据发送到该机器上。</li>
</ul>
<p>负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p>
<p>负载均衡算法有很多种，分别适用于不同的应用场景。本章节将由浅入深的，逐一讲解各种负载均衡算法的策略和特性，并根据算法之间的互补关系将它们串联起来。</p>
<blockquote>
<p>注：负载均衡算法的实现，推荐阅读 <a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">Dubbo 官方负载均衡算法说明</a> ，源码讲解非常详细，非常值得借鉴。</p>
<p>下文中的各种算法的可执行示例已归档在 Github 仓库：<a target="_blank" rel="noopener" href="https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance">java-load-balance</a>，可以通过执行 <code>io.github.dunwu.javatech.LoadBalanceDemo</code> 查看各算法执行效果。</p>
</blockquote>
<h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p><strong>“轮询算法（Round Robin）”的策略是：将请求“依次”分发到候选机器</strong>。</p>
<p>如下图所示，轮询负载均衡器收到来自客户端的 6 个请求，编号为 1、4 的请求会被发送到服务端 0；编号为 2、5 的请求会被发送到服务端 1；编号为 3、6 的请求会被发送到服务端 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250648178.png" alt="img"></p>
<p><strong>轮询算法适合的场景需要满足：各机器处理能力相近，且每个请求工作量差异不大</strong>。</p>
<h4 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h4><p><strong>“随机算法（Random）” 将请求“随机”分发到候选机器</strong>。</p>
<p>如下图所示，随机负载均衡器收到来自客户端的 6 个请求，会随机分发请求，可能会出现：编号为 1、5 的请求会被发送到服务端 0；编号为 2、4 的请求会被发送到服务端 1；编号为 3、6 的请求会被发送到服务端 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250648899.png" alt="img"></p>
<p><strong>随机算法适合的场景需要满足：各机器处理能力相近，且每个请求工作量差异不大</strong>。</p>
<p>学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p>
<h4 id="加权轮询-随机算法"><a href="#加权轮询-随机算法" class="headerlink" title="加权轮询&#x2F;随机算法"></a>加权轮询&#x2F;随机算法</h4><p>轮询&#x2F;随机算法适合的场景都需要满足：各机器处理能力相近，且每个请求工作量差异不大。</p>
<p>在理想状况下，假设每个机器的硬件条件相同，如：CPU、内存、网络 IO 等配置都相同；并且每个请求的耗时一样（请求传输时间、请求访问数据时间、计算时间等），这时轮询算法才能真正做到负载均衡。显然，要满足以上条件都相同是几乎不可能的，更不要说实际的网络通信中还有更多复杂的情况。</p>
<p>以上，如果有一点不能满足，都无法做到真正的负载均衡。个体存在较大差异，当请求量较大时，处理较慢的机器可能会逐渐积压请求，从而导致过载甚至宕机。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>服务端 1 的处理能力远低于服务端 0 和服务端 2；</li>
<li>轮询&#x2F;随机算法可以保证将请求尽量均匀的分发给两个机器；</li>
<li>编号为 1、4 的请求被发送到服务端 0；编号为 3、6 的请求被发送到服务端 2；二者处理能力强，应对游刃有余；</li>
<li>编号为 2、5 的请求被发送到服务端 1，服务端 1 处理能力弱，应对捉襟见肘，导致过载。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250649920.png" alt="img"></p>
<blockquote>
<p>《蜘蛛侠》电影中有一句经典台词：<strong>能力越大，责任越大</strong>。显然，以上情况不符合这句话，处理能力强的机器并没有被分发到更多的请求，它的处理能力被闲置了。那么，如何解决这个问题呢？</p>
</blockquote>
<p>一种比较容易想到的思路是：引入权重属性，可以根据机器的硬件条件为其设置合理的权重值，负载均衡时，优先将请求分发到权重较高的机器。</p>
<p>“加权轮询算法（Weighted Round Robbin）” 和“加权随机算法（Weighted Random）” 都采用了加权的思路，在轮询&#x2F;随机算法的基础上，引入了权重属性，优先将请求分发到权重较高的机器。这样，就可以针对性能高、处理速度快的机器设置较高的权重，让其处理更多的请求；而针对性能低、处理速度慢的机器则与之相反。一言以蔽之，加权策略强调了——能力越大，责任越大。</p>
<p>如下图所示，服务端 0 设置权重为 3，服务端 1 设置权重为 1，服务端 2 设置权重为 2。负载均衡器收到来自客户端的 6 个请求，那么编号为 1、2、5 的请求会被发送到服务端 0，编号为 4 的请求会被发送到服务端 1，编号为 3、6 的请求会被发送到机器 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250649943.png" alt="img"></p>
<h4 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h4><p>加权轮询&#x2F;随机算法虽然一定程度上解决了机器处理能力不同时的负载均衡场景，但它最大的问题在于不能动态应对网络中负载不均的场景。加权的思路是在负载均衡处理的事前，预设好不同机器的权重，然后分发。然而，每个请求的连接时长不同，负载均衡器也不可能准确预估出请求的连接时长。因此，采用加权轮询&#x2F;随机算法算法，都无法动态应对连接时长不均的网络场景，可能会出现<strong>某些机器当前连接数过多，而另一些机器的连接过少</strong>的情况，即并非真正的流量负载均衡。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>3 个服务端的处理能力相同；</li>
<li>编号为 1、4 的请求被发送到服务端 0，但是 1 很快就断开连接，此时只有 4 请求连接服务端 0；</li>
<li>编号为 2、5 的请求被发送到服务端 1，但是 2 始终保持长连接；该系统继续运行时，服务端 1 发生过载；</li>
<li>编号为 3、6 的请求被发送到服务端 2，但是 3 很快就断开连接，此时只有 6 请求连接服务端 2；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650176.png" alt="img"></p>
<p>既然，请求的连接时长不同，会导致有的服务端处理慢，积压大量连接数；而有的服务端处理快，保持的连接数少。那么，我们不妨想一下，如果负载均衡器监控一下服务端当前所持有的连接数，优先将请求分发给连接数少的服务端，不就能有效提高分发效率了吗？最少连接数算法正是采用这个思路去设计的。</p>
<p><strong>“最少连接数算法（Least Connections）” 将请求分发到连接数&#x2F;请求数最少的候选机器</strong>。</p>
<p>要根据机器连接数分发，显然要先维护机器的连接数。因此，<strong>最少连接数算法需要实时追踪每个候选机器的活跃连接数；然后，动态选出连接数最少的机器，优先分发请求</strong>。最少连接数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应机器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p>
<p>由此可见，<strong>最少连接数算法适用于对系统负载较为敏感且请求连接时长相差较大的场景</strong>。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>服务端 0 和服务端 1 的处理能力相同；</li>
<li>编号为 1、3 的请求被发送到服务端 0，但是 1、3 很快就断开连接；</li>
<li>编号为 2、4 的请求被发送到服务端 1，但是 2、4 保持长连接；</li>
<li>由于服务端 0 当前连接数最少，编号为 5、6 的请求被分发到服务端 0。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650852.png" alt="img"></p>
<p>“加权最少连接数算法（Weighted Least Connection）”在最少连接数算法的基础上，根据机器的性能为每台机器分配权重，再根据权重计算出每台机器能处理的连接数。</p>
<h4 id="最少响应时间算法"><a href="#最少响应时间算法" class="headerlink" title="最少响应时间算法"></a>最少响应时间算法</h4><p><strong>“最少响应时间算法（Least Time）” 将请求分发到响应时间最短的候选机器</strong>。最少响应时间算法和最少连接数算法二者的目标其实是殊途同归，都是动态调整，将请求尽量分发到处理能力强的机器上。不同点在于，最少连接数关注的维度是机器持有的连接数，而最少响应时间关注的维度是机器上一次响应时间哪个最短。理论上来说，持有的连接数少，响应时间短，都可以表明机器潜在的处理能力比较强。</p>
<p><strong>最少响应时间算法具有高度的敏感性、自适应性</strong>。但是，由于它需要持续监控候选机器的响应时延，相比于监控候选机器的连接数，会显著增加监控的开销。此外，请求的响应时延并不一定能完全反应机器的处理能力，有可能某机器上一次处理的请求恰好是一个开销非常小的请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650334.png" alt="img"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>前面提到的负载均衡算法，都只适用于无状态应用。所谓无状态应用，意味着：请求无论分发到集群中的任意机器上，得到的响应都是相同的：然而，有状态服务则不然：请求分发到不同的机器上，得到的结果是不一样的。典型的无状态应用是普通的 Web 服务器；典型的有状态应用是各种分布式数据库（如：Redis、ElasticSearch 等），这些数据库存储了大量，乃至海量的数据，无法全部存储在一台机器上，为了提高整体容量以及吞吐量，采用了分区（分片）的设计，将数据化整为零的存储在不同机器上。</p>
<p>对于有状态应用，不仅仅需要保证负载的均衡，更为重要的是，需要保证针对相同数据的请求始终访问的是相同的机器，否则，就无法获取到正确的数据。</p>
<p>那么，如何解决有状态应用的负载均衡呢？有一种方案是哈希算法。</p>
<p><strong>“哈希算法（Hash）” 根据一个 key （可以是唯一 ID、IP、URL 等），通过哈希函数计算得到一个数值，用该数值在候选机器列表的进行取模运算，得到的结果便是选中的机器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250652913.png" alt="img"></p>
<p>这种算法可以保证，同一关键字（IP 或 URL 等）的请求，始终会被转发到同一台机器上。哈希负载均衡算法常被用于实现会话粘滞（Sticky Session）。</p>
<p>但是 ，哈希算法的问题是：当增减节点时，由于哈希取模函数的基数发生变化，会影响大部分的映射关系，从而导致之前的数据不可访问。要解决这个问题，就必须根据新的计算公式迁移数据。显然，如果数据量很大的情况下，迁移成本很高；并且，在迁移过程中，要保证业务平滑过渡，需要使用数据双写等较为复杂的技术手段。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653034.png" alt="img"></p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>哈希算法的缺点是：当集群中出现增减节点时，由于哈希取模函数的基数发生变化，会导致大量集群中的机器不可用；需要通过代价高昂的数据迁移，来解决问题。那么，我们自然会希望有一种更优化的方案，来尽量减少影响的机器数。一致性哈希算法就是为了这个目标而应运而生。</p>
<p>一致性哈希算法对哈希算法进行了改良。<strong>“一致性哈希算法（Consistent Hash）”，根据哈希算法将对应的 key 哈希到一个具有 2^32 个桶的空间，并且头尾相连（0 到 2^32-1），即一个闭合的环形，这个圆环被称为“哈希环”</strong>。哈希算法是对节点的数量进行取模运算；而一致性哈希算法则是对 2^32 进行取模运算。</p>
<p><strong>哈希环的空间是按顺时针方向组织的</strong>，需要对指定 key 的数据进行读写时，会执行两步：</p>
<ol>
<li>先对节点进行哈希计算，计算的关键字通常是 IP 或其他唯一标识（例：hash(ip)），然后对 2^32 取模，以确定节点在哈希环上的位置。</li>
<li>先对 key 进行哈希计算（hash(key)），然后对 2^32 取模，以确定 key 在哈希环上的位置。</li>
<li>然后根据 key 的位置，顺时针找到的第一个节点，就是 key 对应的节点。</li>
</ol>
<p>所以，<strong>一致性哈希是将“存储节点”和“数据”都映射到一个顺时针排序的哈希环上</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653412.png" alt="img"></p>
<p>一致性哈希算法会尽可能保证，相同的请求被分发到相同的机器上。<strong>当出现增减节点时，只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响，不会引起剧烈变动</strong>。</p>
<ul>
<li><strong>相同的请求</strong>是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：用户 ID、请求方 IP、请求服务名称，参数列表构成的串</li>
<li><strong>尽可能</strong>是指：哈希环上出现增减节点时，少数机器的变化不应该影响大多数的请求。</li>
</ul>
<p>（1）增加节点</p>
<p>如下图所示，假设，哈希环中新增了一个节点 S4，新增节点经过哈希计算映射到图中位置：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653974.png" alt="img"></p>
<p>此时，只有 K1 收到影响；而 K0、K2 均不受影响。</p>
<p>（2）减少节点</p>
<p>如下图所示，假设，哈希环中减少了一个节点 S0：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653207.png" alt="img"></p>
<p>此时，只有 K0 收到影响；而 K1、K2 均不受影响。</p>
<p><strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，由此而产生一个问题，哈希环上可能有大量的请求集中在一个节点上。从概率角度来看，<strong>哈希环上的节点越多，分布就越均匀</strong>。正因为如此，一致性哈希算法不适用于节点数过少的场景。</p>
<p>如下图所示：极端情况下，可能由于节点在哈希环上分布不均，有大量请求计算得到的 key 会被集中映射到少数节点，甚至某一个节点上。此外，节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，从而引发雪崩式的连锁反应。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250654770.png" alt="img"></p>
<h4 id="虚拟一致性哈希算法"><a href="#虚拟一致性哈希算法" class="headerlink" title="虚拟一致性哈希算法"></a>虚拟一致性哈希算法</h4><p>在一致性哈希算法中，如果节点数过少，可能会分布不均，从而导致负载不均衡。在实际生产环境中，一个分布式系统应该具备良好的伸缩性，既能从容的扩展到大规模的集群，也要能支持小规模的集群。为此，又产生了虚拟哈希算法，进一步对一致性哈希算法进行了改良。</p>
<p>虚拟哈希算法的解决思路是：虽然实际的集群可能节点数较少，但是在哈希环上引入大量的虚拟哈希节点。具体来说，<strong>“虚拟哈希算法”有二次映射：先将虚拟节点映射到哈希环上，再将虚拟节点映射到实际节点上。</strong></p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>分布式集群中有 4 个真实节点，分别是：S0、S1、S2、S3；</li>
<li>我们不妨先假定分配给哈希环 12 个虚拟节点，并将虚拟节点映射到真实节点上，映射关系如下：<ul>
<li>S0 - S0_0、S0_1、S0_2、S0_3</li>
<li>S1 - S1_0、S1_1、S1_2、S1_3</li>
<li>S2 - S2_0、S2_1、S2_2、S2_3</li>
<li>S3 - S3_0、S3_1、S3_2、S3_3</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250654220.png" alt="img"></p>
<p>通过引入虚拟哈希节点，是的哈希环上的节点分布相对均匀了。举例来说，假如此时，某请求的 key 哈希取模后，先映射到哈希环的 [S3_2, S0_0]、[S3_0, S0_1]、[S3_1, S0_2] 这三个区间的任意一点；接下来的二次映射都会匹配到真实节点 S0。</p>
<p>在实际应用中，虚拟哈希节点数一般都比较大（例如：Redis 的虚拟哈希槽有 16384 个），较大的数量保证了虚拟哈希环上的节点分布足够均匀。</p>
<p>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。例如，当某个节点被移除时，分配给该节点的多个虚拟节点会被一并移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p>
<p>此外，有了虚拟节点后，可以通过调整分配给真实节点的虚拟节点数，来达到设置权重一样的效果，使得负载均衡更加灵活。</p>
<p>综上所述，<strong>虚拟一致性哈希算法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p>
<p>:::</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="【基础】什么是流量控制？为什么需要流量控制？"><a href="#【基础】什么是流量控制？为什么需要流量控制？" class="headerlink" title="【基础】什么是流量控制？为什么需要流量控制？"></a>【基础】什么是流量控制？为什么需要流量控制？</h3><p>:::details 要点</p>
<p><strong>流量控制（Flow Control）</strong>，根据流量、并发线程数、响应时间等指标，把随机到来的流量调整成合适的形状，即<strong>流量塑形</strong>。避免应用被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>
<p>复杂的分布式系统架构中的应用程序往往具有数十个依赖项，每个依赖项都会不可避免地在某个时刻失败。 如果主机应用程序未与这些外部故障隔离开来，则可能会被波及。</p>
<p>例如，对于依赖于 30 个服务的应用程序，假设每个服务的正常运行时间为 99.99％，则可以期望：</p>
<blockquote>
<p>99.99<sup>30</sup> &#x3D; 99.7％ 的正常运行时间</p>
<p>10 亿个请求中的 0.3％&#x3D; 3,000,000 个失败</p>
<p>即使所有依赖项都具有出色的正常运行时间，每月也会有 2 个小时以上的停机时间。</p>
<p>然而，现实情况一般比这种估量情况更糟糕。</p>
</blockquote>
<hr>
<p>当一切正常时，整体系统如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401280931974.png" alt="img"></p>
<p>图片来自 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">Hystrix Wiki</a></p>
<p>在分布式系统架构下，这些强依赖的子服务稳定与否对系统的影响非常大。但是，依赖的子服务可能有很多不可控问题：如网络连接、资源繁忙、服务宕机等。例如：下图中有一个 QPS 为 50 的依赖服务 I 出现不可用，但是其他依赖服务是可用的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401280931939.png" alt="img"></p>
<p>图片来自 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">Hystrix Wiki</a></p>
<p>当流量很大的情况下，某个依赖的阻塞，会导致上游服务请求被阻塞。当这种级联故障愈演愈烈，就可能造成整个线上服务不可用的雪崩效应，如下图。这种情况若持续恶化，如果上游服务本身还被其他服务所依赖，就可能出现多米洛骨牌效应，导致多个服务都无法正常工作。</p>
<p><img src="https://github.com/Netflix/Hystrix/wiki/images/soa-3-640.png" alt="img"></p>
<p>图片来自 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">Hystrix Wiki</a></p>
<p>:::</p>
<h3 id="【基础】流量控制有哪些衡量指标？"><a href="#【基础】流量控制有哪些衡量指标？" class="headerlink" title="【基础】流量控制有哪些衡量指标？"></a>【基础】流量控制有哪些衡量指标？</h3><p>:::details 要点</p>
<p>:::</p>
<h3 id="【中级】流量控制有哪些保护机制？"><a href="#【中级】流量控制有哪些保护机制？" class="headerlink" title="【中级】流量控制有哪些保护机制？"></a>【中级】流量控制有哪些保护机制？</h3><p>:::details 要点</p>
<p>流量控制常见的手段就是限流、熔断、降级。</p>
<h4 id="什么是降级？"><a href="#什么是降级？" class="headerlink" title="什么是降级？"></a>什么是降级？</h4><p><strong>降级</strong>是保障服务能够稳定运行的一种保护方式：面对突增的流量，牺牲一些吞吐量以换取系统的稳定。常见的降级实现方式有：开关降级、限流降级、熔断降级。</p>
<h4 id="什么是限流？"><a href="#什么是限流？" class="headerlink" title="什么是限流？"></a>什么是限流？</h4><p>限流一般针对下游服务，当上游流量较大时，避免被上游服务的请求撑爆。</p>
<p><strong>限流</strong>就是限制系统的输入和输出流量，以达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
<p>限流规则包含三个部分：时间粒度，接口粒度，最大限流值。限流规则设置是否合理直接影响到限流是否合理有效。</p>
<h4 id="什么是熔断？"><a href="#什么是熔断？" class="headerlink" title="什么是熔断？"></a>什么是熔断？</h4><p>熔断一般针对上游服务，当下游服务超时&#x2F;异常较多时，避免被下游服务拖垮。</p>
<p>当调用链路中某个资源出现不稳定，例如，超时异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p>
<p>熔断尽最大的可能去完成所有的请求，容忍一些失败，熔断也能自动恢复。熔断的常见策略有：</p>
<ul>
<li>在每秒请求异常数超过多少时触发熔断降级</li>
<li>在每秒请求异常错误率超过多少时触发熔断降级</li>
<li>在每秒请求平均耗时超过多少时触发熔断降级</li>
</ul>
<p>:::</p>
<h3 id="流量控制有哪些衡量指标"><a href="#流量控制有哪些衡量指标" class="headerlink" title="流量控制有哪些衡量指标"></a>流量控制有哪些衡量指标</h3><p>:::details 要点</p>
<p>流量控制有以下几个角度：</p>
<ul>
<li>流量指标，例如 QPS、并发线程数等。</li>
<li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系，调用来源等。</li>
<li>控制效果，例如排队等待、直接拒绝、Warm Up（预热）等。</li>
</ul>
<p>:::</p>
<h3 id="【中级】流量控制有哪些隔离模式？"><a href="#【中级】流量控制有哪些隔离模式？" class="headerlink" title="【中级】流量控制有哪些隔离模式？"></a>【中级】流量控制有哪些隔离模式？</h3><p>:::details 要点</p>
<p>线程池隔离</p>
<p>信号量隔离</p>
<p>资源隔离</p>
<p>:::</p>
<h3 id="【高级】有哪些限流算法？"><a href="#【高级】有哪些限流算法？" class="headerlink" title="【高级】有哪些限流算法？"></a>【高级】有哪些限流算法？</h3><p>:::details 要点</p>
<p>常见的限流算法有：固定窗口限流算法、滑动窗口限流算法、漏桶限流算法、令牌桶限流算法。</p>
<h4 id="固定窗口限流算法"><a href="#固定窗口限流算法" class="headerlink" title="固定窗口限流算法"></a>固定窗口限流算法</h4><p><strong>固定窗口限流算法的原理</strong></p>
<p>固定窗口限流算法的<strong>基本策略</strong>是：</p>
<ol>
<li>设置一个固定时间窗口，以及这个固定时间窗口内的最大请求数；</li>
<li>为每个固定时间窗口设置一个计数器，用于统计请求数；</li>
<li>一旦请求数超过最大请求数，则请求会被拦截。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401230748006.png" alt="img"></p>
<p><strong>固定窗口限流算法的利弊</strong></p>
<p>固定窗口限流算法的<strong>优点</strong>是：实现简单。</p>
<p>固定窗口限流算法的<strong>缺点</strong>是：存在<strong>临界问题</strong>。所谓临界问题，是指：流量分别集中在一个固定时间窗口的尾部和一个固定时间窗口的头部。举例来说，假设限流规则为每分钟不超过 100 次请求。在第一个时间窗口中，起初没有任何请求，在最后 1 s，收到 100 次请求，由于没有达到阈值，所有请求都通过；在第二个时间窗口中，第 1 秒就收到 100 次请求，而后续没有任何请求。虽然，这两个时间窗口内的流量都符合限流要求，但是在两个时间窗口临界的这 2s 内，实际上有 200 次请求，显然是超过预期吞吐量的，存在压垮系统的可能。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401230748769.png" alt="img"></p>
<h4 id="滑动窗口限流算法"><a href="#滑动窗口限流算法" class="headerlink" title="滑动窗口限流算法"></a>滑动窗口限流算法</h4><p><strong>滑动窗口限流算法的原理</strong></p>
<p>滑动窗口限流算法是对固定窗口限流算法的改进，解决了临界问题。</p>
<p>滑动窗口限流算法的<strong>基本策略</strong>是：</p>
<ul>
<li>将固定时间窗口分片为多个子窗口，每个子窗口的访问次数独立统计；</li>
<li>当请求时间大于当前子窗口的最大时间时，则将当前子窗口废弃，并将计时窗口向前滑动，并将下一个子窗口置为当前窗口。</li>
<li>要保证所有子窗口的统计数之和不能超过阈值。</li>
</ul>
<p>滑动窗口限流算法就是针对固定窗口限流算法的更细粒度的控制，分片越多，则限流越精准。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401230748277.png" alt="img"></p>
<p><strong>滑动窗口限流算法的利弊</strong></p>
<p>滑动窗口限流算法的<strong>优点</strong>是：在滑动窗口限流算法中，临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题。</p>
<p>滑动窗口限流算法的<strong>缺点</strong>是：</p>
<ul>
<li><strong>额外的内存开销</strong> - 滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，所以存在额外的内存开销。</li>
<li><strong>限流的控制粒度受限于窗口分片粒度</strong> - 滑动窗口限流算法，<strong>只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制</strong>。但是，由于每个分片窗口都有额外的内存开销，所以也并不是分片数越多越好的。</li>
</ul>
<h4 id="漏桶限流算法"><a href="#漏桶限流算法" class="headerlink" title="漏桶限流算法"></a>漏桶限流算法</h4><p><strong>漏桶限流算法的原理</strong></p>
<p>漏桶限流算法的<strong>基本策略</strong>是：</p>
<ul>
<li>水（请求）以任意速率由入口进入到漏桶中；</li>
<li>水以固定的速率由出口出水（请求通过）；</li>
<li>漏桶的容量是固定的，如果水的流入速率大于流出速率，最终会导致漏桶中的水溢出（这意味着请求拒绝）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401230749486.png" alt="img"></p>
<p><strong>漏桶限流算法的利弊</strong></p>
<p>漏桶限流算法的<strong>优点</strong>是：<strong>流量速率固定</strong>——即无论流量多大，即便是突发的大流量，处理请求的速度始终是固定的。</p>
<p>漏桶限流算法的<strong>缺点</strong>是：不能灵活的调整流量。例如：一个集群通过增减节点的方式，弹性伸缩了其吞吐能力，漏桶限流算法无法随之调整。</p>
<p><strong>漏桶策略适用于间隔性突发流量且流量不用即时处理的场景</strong>。</p>
<h4 id="令牌桶限流算法"><a href="#令牌桶限流算法" class="headerlink" title="令牌桶限流算法"></a>令牌桶限流算法</h4><p><strong>令牌桶限流算法的原理</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202401230750231.png" alt="img"></p>
<p>令牌桶算法的<strong>原理</strong>：</p>
<ol>
<li>接口限制 T 秒内最大访问次数为 N，则每隔 T&#x2F;N 秒会放一个 token 到桶中</li>
<li>桶内最多存放 M 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 就会被丢弃</li>
<li>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则进行限流处理</li>
</ol>
<p><strong>令牌桶限流算法的利弊</strong></p>
<p>因为令牌桶存放了很多令牌，那么大量的突发请求会被执行，但是它不会出现临界问题，在令牌用完之后，令牌是以一个恒定的速率添加到令牌桶中的，因此不能再次发送大量突发请求。</p>
<p>规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除，如果桶中没有 token 不能请求。</p>
<p><strong>令牌桶算法适用于有突发特性的流量，且流量需要即时处理的场景</strong>。</p>
<blockquote>
<p><strong>扩展</strong></p>
<p>Guava 的 RateLimiter 工具类就是基于令牌桶算法实现，其源码分析可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/forezp/article/details/100060686">RateLimiter 基于漏桶算法，但它参考了令牌桶算法</a></p>
</blockquote>
<p>:::</p>
<h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><h3 id="【基础】什么是服务路由？路由有什么用？"><a href="#【基础】什么是服务路由？路由有什么用？" class="headerlink" title="【基础】什么是服务路由？路由有什么用？"></a>【基础】什么是服务路由？路由有什么用？</h3><p>:::details 要点</p>
<p><strong>服务路由</strong>是指通过一定的规则从集群中选择合适的节点。</p>
<p>负载均衡的作用和服务路由的功能看上去很近似，二者有什么区别呢？</p>
<p>负载均衡的目标是提供服务分发而不是解决路由问题，常见的<strong>静态、动态负载均衡算法无法实现精细化的路由管理</strong>，但是负载均衡也可以简单看做是路由方案的一种。</p>
<p>服务路由通常用于以下场景，目的在于实现流量隔离：</p>
<ul>
<li><strong>分组调用</strong>：一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。</li>
<li><strong>蓝绿发布</strong>：蓝绿发布场景中，一共有两套服务群组：一套是提供旧版功能的服务群组，标记为<strong>绿色</strong>；另一套是提供新版功能的服务群组，标记为<strong>蓝色</strong>。两套服务群组都是功能完善的，并且正在运行的系统，只是服务版本和访问流量不同。新版群组（蓝色）通常是为了做内部测试、验收，不对外部用户暴露。<ul>
<li>如果新版群组（蓝色）运行稳定，并测试、验收通过后，则通过服务路由、负载均衡等手段逐步将外部用户流量导向新版群组（蓝色）。</li>
<li>如果新版群组（蓝色）运行不稳定，或测试、验收不通过，则排查、解决问题后，再继续测试、验收。</li>
</ul>
</li>
<li><strong>灰度发布</strong>：灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行 A&#x2F;B 测试，即让一部分用户使用特性 A，一部分用户使用特性 B：如果用户对 B 没有什么反对意见，那么逐步扩大发布范围，直到把所有用户都迁移到 B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。要支持灰度发布，就要求服务能够根据一定的规则，将流量隔离。</li>
<li><strong>流量切换</strong>：在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。</li>
<li><strong>线下测试联调</strong>：线下测试时，可能会缺少相应环境。可以将测试应用注册到线上，然后开启路由规则，在本地进行测试。</li>
<li><strong>读写分离</strong>。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。</li>
</ul>
<p>:::</p>
<h3 id="服务路由有哪些常见规则？"><a href="#服务路由有哪些常见规则？" class="headerlink" title="服务路由有哪些常见规则？"></a>服务路由有哪些常见规则？</h3><p>:::details 要点</p>
<h4 id="条件路由"><a href="#条件路由" class="headerlink" title="条件路由"></a>条件路由</h4><p><strong>条件路由是基于条件表达式的路由规则</strong>。各个 RPC 框架的条件路由表达式各不相同。</p>
<p>我们不妨参考一下 Dubbo 的条件路由。Dubbo 的条件路由有两种配置粒度，如下：</p>
<ul>
<li><p><strong>应用粒度</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app1 的消费者只能消费所有端口为 20880 的服务实例</span></span><br><span class="line"><span class="comment"># app2 的消费者只能消费所有端口为 20881 的服务实例</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">scope:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">force:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runtime:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">governance-conditionrouter-consumer</span></span><br><span class="line"><span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">application=app1</span> <span class="string">=&gt;</span> <span class="string">address=*:20880</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">application=app2</span> <span class="string">=&gt;</span> <span class="string">address=*:20881</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务粒度</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DemoService 的 sayHello 方法只能消费所有端口为 20880 的服务实例</span></span><br><span class="line"><span class="comment"># DemoService 的 sayHi 方法只能消费所有端口为 20881 的服务实例</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">scope:</span> <span class="string">service</span></span><br><span class="line"><span class="attr">force:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runtime:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">org.apache.dubbo.samples.governance.api.DemoService</span></span><br><span class="line"><span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">method=sayHello</span> <span class="string">=&gt;</span> <span class="string">address=*:20880</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">method=sayHi</span> <span class="string">=&gt;</span> <span class="string">address=*:20881</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>其中，<code>conditions</code> 定义具体的路由规则内容。<code>conditions</code> 部分是规则的主体，由 1 到任意多条规则组成。详见：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/routing-rule/">Dubbo 路由规则</a></p>
</blockquote>
<p>Dubbo 的条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。条件路由规则的格式如下：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[服务消费者匹配条件]</span> =&gt; <span class="comment">[服务提供者匹配条件]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>服务消费者匹配条件：所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li>
<li>服务提供者匹配条件：所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。</li>
</ul>
<p><code>condition://</code> 代表了这是一段用条件表达式编写的路由规则，下面是一个条件路由规则示例：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.10</span> <span class="operator">=</span>&gt; host <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.11</span></span><br></pre></td></tr></table></figure>

<p>该条规则表示 IP 为 <code>10.20.153.10</code> 的服务消费者<strong>只可</strong>调用 IP 为 <code>10.20.153.11</code> 机器上的服务，不可调用其他机器上的服务。</p>
<p>下面列举一些 Dubbo 条件路由的典型应用场景：</p>
<ul>
<li>如果服务消费者的匹配条件为空，就表示<strong>所有的服务消费者都可以访问</strong>，就像下面的表达式一样。</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host != <span class="number">10.20</span>.<span class="number">153.11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果服务提供者的过滤条件为空，就表示<strong>禁止所有的服务消费者访问</strong>，就像下面的表达式一样。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.10</span> <span class="operator">=</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>排除某个服务节点</strong></li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host != <span class="number">172.22</span>.<span class="number">3.91</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>白名单</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register.ip != 10.20.153.10,10.20.153.11 =&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>黑名单</strong></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">register</span>.ip = <span class="number">10.20.153.10</span>,<span class="number">10.20.153.11</span> =&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只暴露部分机器节点</strong></li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host = <span class="number">172.22</span>.<span class="number">3.1</span>*,<span class="number">172.22</span>.<span class="number">3.2</span>*</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为重要应用提供额外的机器节点</strong></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">application</span> != kylin =&gt; host != <span class="number">172.22.3.95</span>,<span class="number">172.22.3.96</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读写分离</strong></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method</span> = <span class="title function_">find</span>*,<span class="title function_">list</span>*,<span class="title function_">get</span>*,<span class="title function_">is</span>* =&gt; <span class="title function_">host</span> = 172.22.3.94,172.22.3.95,172.22.3.96</span><br><span class="line"><span class="title function_">method</span> != <span class="title function_">find</span>*,<span class="title function_">list</span>*,<span class="title function_">get</span>*,<span class="title function_">is</span>* =&gt; <span class="title function_">host</span> = 172.22.3.97,172.22.3.98</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前后台分离</strong></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">application</span> = bops =&gt; host = <span class="number">172.22.3.91</span>,<span class="number">172.22.3.92</span>,<span class="number">172.22.3.93</span></span><br><span class="line"><span class="attribute">application</span> != bops =&gt; host = <span class="number">172.22.3.94</span>,<span class="number">172.22.3.95</span>,<span class="number">172.22.3.96</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隔离不同机房网段</strong></li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> != <span class="number">172</span>.<span class="number">22</span>.<span class="number">3</span>.* =&gt; host != <span class="number">172</span>.<span class="number">22</span>.<span class="number">3</span>.*</span><br></pre></td></tr></table></figure>

<ul>
<li>提供者与消费者部署在同集群内，<strong>本机只访问本机的服务</strong></li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host = $host</span><br></pre></td></tr></table></figure>

<h4 id="脚本路由"><a href="#脚本路由" class="headerlink" title="脚本路由"></a>脚本路由</h4><p><strong>脚本路由</strong>是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;script://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&#x27;</span> +</span><br><span class="line">  <span class="variable constant_">URL</span>.<span class="title function_">encode</span>(<span class="string">&#x27;（function route(invokers) &#123; ... &#125; (invokers)）&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里面 <code>script://</code> 就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 <code>10.20.153.10</code> 的服务消费者可以发起服务调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">route</span>(<span class="params">invokers</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">ArrayList</span>(invokers.<span class="title function_">size</span>());</span><br><span class="line">  <span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; invokers.<span class="title function_">size</span>(); i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;10.20.153.10&quot;</span>.<span class="title function_">equals</span>(invokers.<span class="title function_">get</span>(i).<span class="title function_">getUrl</span>().<span class="title function_">getHost</span>()))&#123;</span><br><span class="line">       result.<span class="title function_">add</span>(invokers.<span class="title function_">get</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125; (invokers)）;</span><br></pre></td></tr></table></figure>

<h4 id="标签路由"><a href="#标签路由" class="headerlink" title="标签路由"></a>标签路由</h4><p><strong>标签路由</strong>通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p>
<p>标签主要是指对服务提供者的分组，目前有两种方式可以完成实例分组，分别是<strong>动态规则打标</strong>和<strong>静态规则打标</strong>。一般，动态规则优先级比静态规则更高，当两种规则同时存在且出现冲突时，将以动态规则为准。</p>
<p>以 Dubbo 的标签路由用法为例</p>
<p>（1）<strong>动态规则打标</strong>，可随时在<strong>服务治理控制台</strong>下发标签归组规则</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># governance-tagrouter-provider 应用增加了两个标签分组 tag1 和 tag2</span></span><br><span class="line"><span class="comment"># tag1 包含一个实例 127.0.0.1:20880</span></span><br><span class="line"><span class="comment"># tag2 包含一个实例 127.0.0.1:20881</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">runtime:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">governance-tagrouter-provider</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tag1</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="string">&quot;127.0.0.1:20880&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tag2</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="string">&quot;127.0.0.1:20881&quot;</span>]</span><br><span class="line"> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>（2）<strong>静态规则打标</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">tag</span>=<span class="string">&quot;tag1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">tag</span>=<span class="string">&quot;tag1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx-provider.jar -Ddubbo.provider.tag=&#123;the tag you want, may come from OS ENV&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>服务消费者指定标签路由</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,<span class="string">&quot;tag1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>请求标签的作用域为每一次 invocation，使用 <code>attachment</code> 来传递请求标签，注意保存在 <code>attachment</code> 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p>
<h3 id="路由规则获取方式"><a href="#路由规则获取方式" class="headerlink" title="路由规则获取方式"></a>路由规则获取方式</h3><p>路由规则的获取方式主要有三种：</p>
<ul>
<li><strong>本地静态配置</strong>：顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。</li>
<li><strong>配置中心管理</strong>：这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。</li>
<li><strong>注册中心动态下发</strong>：这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。</li>
</ul>
<p>一般来讲，<strong>服务路由最好是存储在配置中心</strong>，由配置中心来统一管理。这样的话，所有的服务消费者就不需要在本地管理服务路由，因为大部分的服务消费者并不关心服务路由的问题，或者说也不需要去了解其中的细节。通过配置中心，统一给各个服务消费者下发统一的服务路由，节省了沟通和管理成本。</p>
<p>但也不排除某些服务消费者有特定的需求，需要定制自己的路由规则，这个时候就适合通过本地配置来定制。</p>
<p>而动态下发可以理解为一种高级功能，它能够动态地修改路由规则，在某些业务场景下十分有用。比如某个数据中心存在问题，需要把调用这个数据中心的服务消费者都切换到其他数据中心，这时就可以通过动态下发的方式，向配置中心下发一条路由规则，将所有调用这个数据中心的请求都迁移到别的地方。</p>
<p>:::</p>
<h2 id="分布式任务"><a href="#分布式任务" class="headerlink" title="分布式任务"></a>分布式任务</h2><h3 id="【中级】在-Java-中，实现一个进程内定时任务有哪些方案？"><a href="#【中级】在-Java-中，实现一个进程内定时任务有哪些方案？" class="headerlink" title="【中级】在 Java 中，实现一个进程内定时任务有哪些方案？"></a>【中级】在 Java 中，实现一个进程内定时任务有哪些方案？</h3><p>:::details 要点</p>
<p>定时器有非常多的使用场景，例如生成年&#x2F;月&#x2F;周&#x2F;日统计报表、财务对账、会员积分结算、邮件推送等，都是定时器的使用场景。定时器一般有三种表现形式：按固定周期定时执行、延迟一定时间后执行、指定某个时刻执行。</p>
<p>定时器的本质是设计一种数据结构，能够存储和调度任务集合，而且 deadline 越近的任务拥有更高的优先级。那么定时器如何知道一个任务是否到期了呢？定时器需要通过轮询的方式来实现，每隔一个时间片去检查任务是否到期。</p>
<p>所以定时器的内部结构一般需要一个任务队列和一个异步轮询线程，并且能够提供三种基本操作：</p>
<ul>
<li>Schedule 新增任务至任务集合；</li>
<li>Cancel 取消某个任务；</li>
<li>Run 执行到期的任务。</li>
</ul>
<p>JDK 原生提供了三种常用的定时器实现方式，分别为 <code>Timer</code>、<code>DelayedQueue</code> 和 <code>ScheduledThreadPoolExecutor</code>。</p>
<p>JDK 内置的三种实现定时器的方式，实现思路都非常相似，都离不开<strong>任务</strong>、<strong>任务管理</strong>、<strong>任务调度</strong>三个角色。三种定时器新增和取消任务的时间复杂度都是 <code>O(logn)</code>，面对海量任务插入和删除的场景，这三种定时器都会遇到比较严重的性能瓶颈。<strong>对于性能要求较高的场景，一般都会采用时间轮算法来实现定时器</strong>。</p>
<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 属于 JDK 比较早期版本的实现，它可以实现固定周期的任务，以及延迟任务。<code>Timer</code> 会启动一个异步线程去执行到期的任务，任务可以只被调度执行一次，也可以周期性反复执行多次。我们先来看下 <code>Timer</code> 是如何使用的，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="number">1000</span>);  <span class="comment">// 10s 后调度一个周期为 1s 的定时任务</span></span><br></pre></td></tr></table></figure>

<p>可以看出，任务是由 <code>TimerTask</code> 类实现，<code>TimerTask</code> 是实现了 <code>Runnable</code> 接口的抽象类，<code>Timer</code> 负责调度和执行 <code>TimerTask</code>。接下来我们看下 <code>Timer</code> 的内部构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskQueue</code> 是由数组结构实现的小根堆，deadline 最近的任务位于堆顶端，<code>queue[1]</code> 始终是最优先被执行的任务。所以使用小根堆的数据结构，<code>Run</code> 操作时间复杂度 <code>O(1)</code>，新增（<code>Schedule</code>）和取消（<code>Cancel</code>）操作的时间复杂度都是 <code>O(logn)</code>。</p>
<p><code>Timer</code> 内部启动了一个 <code>TimerThread</code> 异步线程，不论有多少任务被加入数组，始终都是由 <code>TimerThread</code> 负责处理。<code>TimerThread</code> 会定时轮询 <code>TaskQueue</code> 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 <code>TaskQueue</code> 中删除。</p>
<p><code>Timer</code> 只使用一个线程来执行任务意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。</p>
<p><strong>不推荐使用 <code>Timer</code></strong> ，因为 Timer 存在以下设计缺陷：</p>
<ul>
<li>Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</li>
<li>Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</li>
<li>TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</li>
</ul>
<h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p>为了解决 <code>Timer</code> 的设计缺陷，JDK 提供了功能更加丰富的 <code>ScheduledThreadPoolExecutor</code>。<code>ScheduledThreadPoolExecutor</code> 提供了周期执行任务和延迟执行任务的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledExecutorServiceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">         <span class="comment">// 1s 延迟后开始执行任务，每 2s 重复执行一次</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>), <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ScheduledThreadPoolExecutor</code> 继承于 <code>ThreadPoolExecutor</code>，因此它具备线程池异步处理任务的能力。线程池主要负责管理创建和管理线程，并从自身的阻塞队列中不断获取任务执行。线程池有两个重要的角色，分别是任务和阻塞队列。<code>ScheduledThreadPoolExecutor</code> 在 <code>ThreadPoolExecutor</code> 的基础上，重新设计了任务 <code>ScheduledFutureTask</code> 和阻塞队列 <code>DelayedWorkQueue</code>。<code>ScheduledFutureTask</code> 继承于 <code>FutureTask</code>，并重写了 <code>run()</code> 方法，使其具备周期执行任务的能力。<code>DelayedWorkQueue</code> 内部是优先级队列，deadline 最近的任务在队列头部。对于周期执行的任务，在执行完会重新设置时间，并再次放入队列中。</p>
<h4 id="DelayedQueue"><a href="#DelayedQueue" class="headerlink" title="DelayedQueue"></a>DelayedQueue</h4><p><code>DelayedQueue</code> 是 JDK 中一种可以延迟获取对象的阻塞队列，其内部是采用优先级队列 <code>PriorityQueue</code> 存储对象。<code>DelayQueue</code> 中的每个对象都必须实现 <code>Delayed</code> 接口，并重写 <code>compareTo</code> 和 <code>getDelay</code> 方法。<code>DelayedQueue</code> 的使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;SampleTask&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> <span class="title class_">SampleTask</span>(now + <span class="number">1000</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> <span class="title class_">SampleTask</span>(now + <span class="number">2000</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> <span class="title class_">SampleTask</span>(now + <span class="number">3000</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(delayQueue.take().getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SampleTask</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SampleTask</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS), o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DelayQueue</code> 提供了 <code>put()</code> 和 <code>take()</code> 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 <code>DelayQueue</code> 后，会根据 <code>compareTo()</code> 方法进行优先级排序。<code>getDelay()</code> 方法用于计算消息延迟的剩余时间，只有 <code>getDelay &lt;=0</code> 时，该对象才能从 <code>DelayQueue</code> 中取出。</p>
<p><code>DelayQueue</code> 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 <code>DelayQueue</code>，通过一个异步线程 <code>take()</code> 取出对象然后继续进行重试。如果还是请求失败，继续放回 <code>DelayQueue</code>。为了限制重试的频率，可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。</p>
<p>相比于 <code>Timer</code>，<code>DelayQueue</code> 只实现了任务管理的功能，需要与异步线程配合使用。<code>DelayQueue</code> 使用优先级队列实现任务的优先级排序，新增（<code>Schedule</code>）和取消（<code>Cancel</code>）操作的时间复杂度也是 <code>O(logn)</code>。</p>
<h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><p>JDK 内置的三种实现定时器的方式，实现思路都非常相似，都离不开<strong>任务</strong>、<strong>任务管理</strong>、<strong>任务调度</strong>三个角色。三种定时器新增和取消任务的时间复杂度都是 <code>O(logn)</code>，面对海量任务插入和删除的场景，这三种定时器都会遇到比较严重的性能瓶颈。<strong>对于性能要求较高的场景，一般都会采用时间轮算法来实现定时器</strong>。</p>
<p>时间轮（Timing Wheel）是 George Varghese 和 Tony Lauck 在 1996 年的论文 <a target="_blank" rel="noopener" href="https://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a> 实现的，它在 Linux 内核中使用广泛，是 Linux 内核定时器的实现方法和基础之一。</p>
<p>时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/assets/CgpVE1_okKiAGl0gAAMLshtTq-M933.png" alt="图片 22.png"></p>
<p>任务是如何添加到时间轮当中的呢？可以根据任务的到期时间进行取模，然后将任务分布到不同的 slot 中。如上图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 <code>2+3=5</code> 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 <code>(2+12)%8=6</code> 个 slot。</p>
<p>那么当时针走到第 6 个 slot 时，怎么区分每个任务是否需要立即执行，还是需要等待下一圈 round，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round&#x3D;0，需要立即执行；第二个任务 round&#x3D;1，需要等待 <code>1*8=8s</code> 后执行；第三个任务 round&#x3D;2，需要等待 <code>2*8=8s</code> 后执行。所以当时针转动到对应 slot 时，只执行 round&#x3D;0 的任务，slot 中其余任务的 round 应当减 1，等待下一个 round 之后执行。</p>
<p>上面介绍了时间轮算法的基本理论，可以看出时间轮有点类似 HashMap，如果多个任务如果对应同一个 slot，处理冲突的方法采用的是拉链法。在任务数量比较多的场景下，适当增加时间轮的 slot 数量，可以减少时针转动时遍历的任务个数。</p>
<p>时间轮定时器最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。</p>
<p>HashedWheelTimer 是 Netty 中时间轮算法的实现类。</p>
<p>:::</p>
<h3 id="【中级】分布式定时任务有哪些方案？"><a href="#【中级】分布式定时任务有哪些方案？" class="headerlink" title="【中级】分布式定时任务有哪些方案？"></a>【中级】分布式定时任务有哪些方案？</h3><p>:::details 要点</p>
<p>分布式定时任务常见方案有：</p>
<ul>
<li>Quartz</li>
<li>XXL-Job</li>
<li>ElasticJob</li>
</ul>
<h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>Quartz 是一个经典的开源定时调度框架。它支持进程内调度和分布式调度。</p>
<p>Quartz 提供两种基本作业存储类型：</p>
<ul>
<li><strong>RAMJobStore</strong> - 在默认情况下 Quartz 将任务调度的运行信息保存在内存中，这种方法提供了最佳的性能，因为内存中数据访问最快。不足之处是缺乏数据的持久性，当程序路途停止或系统崩溃时，所有运行的信息都会丢失。</li>
<li><strong>JobStoreTX</strong> - 所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</li>
</ul>
<h4 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h4><p><a target="_blank" rel="noopener" href="https://github.com/xuxueli/xxl-job">xxl-job</a> 是一个分布式任务调度平台。</p>
<p><strong>设计思想</strong></p>
<p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p>
<p>将任务抽象成分散的 JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的 JobHandler 中业务逻辑。</p>
<p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p>
<p><strong>系统组成</strong></p>
<ul>
<li><strong>调度模块（调度中心）</strong>：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE 开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器 Failover。</li>
<li><strong>执行模块（执行器）</strong>：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等。</li>
</ul>
<p><img src="https://www.xuxueli.com/doc/static/xxl-job/images/img_Qohm.png" alt="输入图片说明"></p>
<h4 id="ElasticJob"><a href="#ElasticJob" class="headerlink" title="ElasticJob"></a>ElasticJob</h4><p>两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。 它通过弹性调度、资源管控、以及作业治理的功能，打造一个适用于互联网场景的分布式调度解决方案，并通过开放的架构设计，提供多元化的作业生态。 它的各个产品使用统一的作业 API，开发者仅需一次开发，即可随意部署。</p>
<p>ElasticJob 采用去中心化架构，没有作业调度中心。它以框架的形式，集成到应用中，提供调度服务。</p>
<p>ElasticJob-Lite 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。</p>
<p><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/elasticjob/current/img/architecture/elasticjob_lite.png"><img src="https://shardingsphere.apache.org/elasticjob/current/img/architecture/elasticjob_lite.png" alt="ElasticJob Architecture"></a></p>
<p>ElasticJob-Cloud 采用自研 Mesos Framework 的解决方案，额外提供资源治理、应用分发以及进程隔离等功能。</p>
<p><img src="https://shardingsphere.apache.org/elasticjob/current/img/architecture/elasticjob_cloud.png" alt="ElasticJob-Cloud Architecture"></p>
<p>ElasticJob-Lite 和 ElasticJob-Cloud 对比：</p>
<table>
<thead>
<tr>
<th align="left">ElasticJob-Lite</th>
<th align="left">ElasticJob-Cloud</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">无中心化</td>
<td align="left">是</td>
<td><code>否</code></td>
</tr>
<tr>
<td align="left">资源分配</td>
<td align="left">不支持</td>
<td><code>支持</code></td>
</tr>
<tr>
<td align="left">作业模式</td>
<td align="left">常驻</td>
<td><code>常驻 + 瞬时</code></td>
</tr>
<tr>
<td align="left">部署依赖</td>
<td align="left">ZooKeeper</td>
<td><code>ZooKeeper + Mesos</code></td>
</tr>
</tbody></table>
<p>ElasticJob-Cloud 的优势在于对资源细粒度治理，适用于需要削峰填谷的大数据系统。</p>
<p>:::</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/372a9cc0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/372a9cc0/" class="post-title-link" itemprop="url">分布式协同面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-16 23:57:04" itemprop="dateCreated datePublished" datetime="2024-12-16T23:57:04+08:00">2024-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式协同面试"><a href="#分布式协同面试" class="headerlink" title="分布式协同面试"></a>分布式协同面试</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="【基础】什么是复制？复制有什么作用？"><a href="#【基础】什么是复制？复制有什么作用？" class="headerlink" title="【基础】什么是复制？复制有什么作用？"></a>【基础】什么是复制？复制有什么作用？</h3><p>:::details 要点</p>
<p><strong>复制主要指通过网络在多台机器上保存相同数据的副本</strong>。</p>
<p>复制数据，可能出于各种各样的原因：</p>
<ul>
<li><strong>提高可用性</strong> - 当部分组件出现位障，系统依然可以继续工作，系统依然可以继续工作。</li>
<li><strong>降低访问延迟</strong> - 使数据在地理位置上更接近用户。</li>
<li><strong>提高读吞吐量</strong> - 扩展至多台机器以同时提供数据访问服务。</li>
</ul>
<p>:::</p>
<h3 id="【中级】复制有哪些模式？"><a href="#【中级】复制有哪些模式？" class="headerlink" title="【中级】复制有哪些模式？"></a>【中级】复制有哪些模式？</h3><p>:::details 要点</p>
<p>复制的模式有以下几种：</p>
<ul>
<li><strong>主从复制</strong> - <strong>所有的写入操作都发送到主节点</strong>，由主节点负责将数据更改事件发送到从节点。每个从节点都可以接收读请求，但内容可能是过期值。支持主从复制的系统：<ul>
<li>数据库：Mysql、PostgreSQL、MongoDB 等</li>
<li>消息队列：Kafka、RabbitMQ 等</li>
</ul>
</li>
<li><strong>多主复制</strong> - <strong>系统存在多个主节点，每个都可以接收写请求</strong>，客户端将写请求发送到其中的一个主节点上，由该主节点负责将数据更改事件同步到其他主节点和自己的从节点。</li>
<li><strong>无主复制</strong> - <strong>系统中不存在主节点，每一个节点都能接受客户端的写请求</strong>。此外，<strong>读取时从多个节点上并行读取，以此检测和纠正某些过期数据</strong>。支持无主复制的系统：<ul>
<li>数据库：Cassandra</li>
</ul>
</li>
</ul>
<p>此外，复制还需要考虑以下问题：</p>
<ul>
<li><strong>同步还是异步</strong></li>
<li><strong>如何处理失败的副本</strong></li>
<li><strong>如何保证数据一致</strong></li>
</ul>
<p>:::</p>
<h3 id="【中级】主从复制是如何工作的？"><a href="#【中级】主从复制是如何工作的？" class="headerlink" title="【中级】主从复制是如何工作的？"></a>【中级】主从复制是如何工作的？</h3><p>:::details 要点</p>
<p>最常见的解决方案就是主从复制，其原理如下：</p>
<p>主从复制模式中只有一个主副本（或称为主节点） ，其余称为从副本（或称为从节点）。</p>
<ol>
<li>所有的写请求只能发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>然后，主副本将数据更改作为复制的日志或更新流发送给所有从副本。每个从副本获得更新数据之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>读请求既可以在主副本上，也可以在从副本上执行。</li>
</ol>
<p>再次强调，<strong>只有主副本才可以接受写请求</strong>：从客户端的角度来看，从副本都是只读的。如果由于某种原因，例如与主节点之间的网络中断而导致主节点无法连接，主从复制方案就会影响所有的写入操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220302202101.png" alt="主从复制系统"></p>
<p>:::</p>
<h3 id="【中级】同步复制、半同步复制、异步复制有什么差异？"><a href="#【中级】同步复制、半同步复制、异步复制有什么差异？" class="headerlink" title="【中级】同步复制、半同步复制、异步复制有什么差异？"></a>【中级】同步复制、半同步复制、异步复制有什么差异？</h3><p>:::details 要点</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220302202158.png" alt="主从复制——同步和异步"></p>
<p>一般，复制速度会非常快；但是，系统不能保证复制多久能完成。有些情况下，从节点可能落后主节点几分钟甚至更长时间，例如：从节点刚从故障中恢复；或系统已经接近最大设计上限；或节点之间的网络出现问题。</p>
<p><strong>全同步复制</strong>的优缺点：</p>
<ul>
<li><strong>优点</strong>：只有所有从节点都完成复制，才视为成功，因此是<strong>强一致的</strong>。</li>
<li><strong>缺点</strong>：即使只有一个从节点未完成复制，写入都不能视为成功。所有从节点完成复制过程之前，主节点会<strong>阻塞</strong>后续所有的写操作。</li>
</ul>
<p>因此，<strong>把所有从节点都配置为同步复制有些不切实际</strong>。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。</p>
<p><strong>全异步复制</strong>的优缺点：</p>
<ul>
<li><strong>优点</strong>：不管从节点上数据多么滞后，主节点总是可以继续响应写请求，<strong>系统的性能更好</strong>。</li>
<li><strong>缺点</strong>：如果主节点发生故障且不可恢复，则<strong>所有尚未复制到从节点的写请求都会丢失</strong>。</li>
</ul>
<p>还有一种折中的方案——<strong>半同步复制</strong>：<strong>只要有一个从节点或半数以上的从节点同步成功，就视为同步，直接返回结果；剩下的节点都通过异步方式同步</strong>。万一同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模式。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。</p>
<p>:::</p>
<h3 id="【中级】新的从节点如何复制主节点数据？"><a href="#【中级】新的从节点如何复制主节点数据？" class="headerlink" title="【中级】新的从节点如何复制主节点数据？"></a>【中级】新的从节点如何复制主节点数据？</h3><p>:::details 要点</p>
<p>两种不可行的方案：</p>
<ul>
<li>由于主节点会源源不断接受新的写入数据，数据始终处于变化中，因此<strong>一次性从主节点复制数据到从节点是无法保证数据一致的</strong>。</li>
<li>另一种思路是：考虑<strong>锁定数据库</strong>（使其不可写）来使磁盘上的文件保持一致，但这会<strong>违反高可用的设计目标</strong>。</li>
</ul>
<p>可行的方案：</p>
<ol>
<li>生成主节点某时刻的快照，避免长时间锁定数据库。</li>
<li>将快照复制到从节点。</li>
<li>从节点复制主节点快照过程中，所有的数据变更写入一个日志中（这个数据变更日志在不同数据库中有着不同的称呼，Mysql 称其为 binlog；Redis 称其为 AOF）。</li>
<li>从节点复制完主节点的快照后，请求数据变更日志中的数据，并基于此补全数据，这个过程称为<strong>追赶</strong>，直至主从数据一致。井重复步骤 1 ～步骤 4 。</li>
</ol>
<p>:::</p>
<h3 id="【高级】如何通过主从复制技术来实现系统高可用呢？"><a href="#【高级】如何通过主从复制技术来实现系统高可用呢？" class="headerlink" title="【高级】如何通过主从复制技术来实现系统高可用呢？"></a>【高级】如何通过主从复制技术来实现系统高可用呢？</h3><p>:::details 要点</p>
<h4 id="从节点失效：追赶式恢复"><a href="#从节点失效：追赶式恢复" class="headerlink" title="从节点失效：追赶式恢复"></a>从节点失效：追赶式恢复</h4><p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点从故障中恢复，可以和主节点对比数据变更日志的偏移量，从而确认数据是否滞后。如果数据存在滞后，则向主节点请求数据变更日志，并补全数据。这个过程称为<strong>追赶</strong>。</p>
<h4 id="主节点失效：节点切换"><a href="#主节点失效：节点切换" class="headerlink" title="主节点失效：节点切换"></a>主节点失效：节点切换</h4><p>主节点失效后，需要选举出新主节点。然后，客户端需要更新路由，将所有写请求发送给新的主节点；其他从节点要接受来自新的主节点上的变更数据。这个过程称之为<strong>切换</strong>。</p>
<p>主节点切换可以手动或自动进行。自动切换的步骤通常如下：</p>
<ol>
<li><strong>确认主节点失效</strong>。有很多种出错可能性，很难准确检测出问题的原因。所以，大多数系统都基于超时机制来确认主节点是否失效：节点间频繁地互相发生发送心跳存活悄息，如果发现某一个节点在一段比较长时间内没有响应，即认为该节点发生失效。</li>
<li><strong>选举新的主节点</strong>。基于多数派共识选主。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。</li>
<li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。原主节点若恢复，需降级处理，避免脑裂。</li>
</ol>
<p>:::</p>
<h3 id="【高级】复制日志如何实现？"><a href="#【高级】复制日志如何实现？" class="headerlink" title="【高级】复制日志如何实现？"></a>【高级】复制日志如何实现？</h3><p>:::details 要点</p>
<p>复制日志的视线方式：</p>
<ul>
<li><strong>基于语句的复制</strong> - 将数据写操作写入日志。主要缺点是<strong>必须完全按照相同顺序执行</strong>，否则可能会产生不同的结果。</li>
<li><strong>基于预写日志（WAL）传输</strong> - 通常每个写操作都是以追加写的方式写入到日志中。主要缺点是<strong>日志描述的数据结果非常底层</strong>，如果数据库不同版本的存储格式存在差异，就可能无法兼容。<ul>
<li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li>
<li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩溃，通过索引更新的方式迅速恢复到此前一致状态。</li>
</ul>
</li>
<li><strong>基于行的逻辑日志复制</strong> - 如果复制和存储引擎采用不同的日志格式，这样复制与存储的逻辑就可以剥离。这种复制日志称为逻辑日志，以区分物理存储引擎的数据表示。</li>
<li><strong>基于触发器的复制</strong> - 这种方式<strong>很灵活</strong>，可以定制化控制复制逻辑。主要缺点是复制<strong>开销更高，也更容易出错</strong>。</li>
</ul>
<p>:::</p>
<h3 id="【高级】多主复制是如何工作的？"><a href="#【高级】多主复制是如何工作的？" class="headerlink" title="【高级】多主复制是如何工作的？"></a>【高级】多主复制是如何工作的？</h3><p>:::details 要点</p>
<p>对主从复制模型进行自然的扩展，则可以配置多个主节点，每个主节点都可以接受写操作，后面复制的流程类似：处理写的每个主节点都必须将该数据更改转发到所有其他节点。这就是多主节点（ 也称为主－主，或主动／主动）复制。此时，每个主节点还同时扮演其他主节点的从节点。</p>
<p>在一个数据中心内部使用多主节点基本没有太大意义，其复杂性已经超过所能带来的好处。</p>
<p>但是，以下场景这种配置则是合理的：</p>
<ul>
<li>多数据中心</li>
<li>离线客户端操作</li>
<li>协作编辑</li>
</ul>
<h4 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h4><p>有了多主节点复制模型，则可以在每个数据中心都配置主节点。在每个数据中心内，采用常规的主从复制方案；而在数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405122221705.png" alt="img"></p>
<p>部署单主节点的主从复制方案与多主复制方案之间的差异</p>
<ul>
<li><strong>性能</strong>：对于主从复制，每个写请求都必须经由广域网传送至主节点所在的数据中心。这会大大增加写入延迟，井基本偏离了采用多数据中心的初衷（即就近访问）。而在多主节点模型中，每个写操作都可以在本地数据中心快速响应，然后采用异步复制方式将变化同步到其他数据中心。因此，对上层应用有效屏蔽了数据中心之间的网络延迟，使得终端用户所体验到的性能更好。</li>
<li><strong>容忍数据中心失效</strong>：对于主从复制，如果主节点所在的数据中心发生故障，必须切换至另一个数据中心，将其中的一个从节点被提升为主节点。在多主节点模型中，每个数据中心则可以独立于其他数据中心继续运行，发生故障的数据中心在恢复之后更新到最新状态。</li>
<li><strong>容忍网络问题</strong>：数据中心之间的通信通常经由广域网，它往往不如数据中心内的本地网络可靠。对于主从复制模型，由于写请求是同步操作，对数据中心之间的网络性能和稳定性等更加依赖。多主节点模型则通常采用异步复制，可以更好地容忍此类问题，例如临时网络闪断不会妨碍写请求最终成功。</li>
</ul>
<p>:::</p>
<h3 id="【高级】无主复制是如何工作的？"><a href="#【高级】无主复制是如何工作的？" class="headerlink" title="【高级】无主复制是如何工作的？"></a>【高级】无主复制是如何工作的？</h3><p>:::details 要点</p>
<p>无主复制模式，<strong>系统中不存在主节点，每一个节点都能接受客户端的写请求</strong>。此外，<strong>读取时从多个节点上并行读取，以此检测和纠正某些过期数据</strong>。</p>
<h4 id="读修复和反熵"><a href="#读修复和反熵" class="headerlink" title="读修复和反熵"></a>读修复和反熵</h4><p>复制模型应确保所有数据最终复制到所有的副本。当一个失效的节点重新上线之后，如何赶上中间错过的那些写请求呢？</p>
<p>有以下两种机制：</p>
<ul>
<li><strong>读修复</strong> - 客户端并行读取多个副本，根据版本识别过期返回值并更新最新值到相应副本。这种方法主要适合那些被频繁读取的场景。</li>
<li><strong>反熵</strong> - 利用后台进程不断查找副本间的数据差异，将任何缺少的数据从一个副本复制到另一个副本。与基于主节点复制的复制日志不同，反熵过程并不保证以特定的顺序复制写入，并且会引入明显的同步滞后。</li>
</ul>
<h4 id="QuorumNWR-算法"><a href="#QuorumNWR-算法" class="headerlink" title="QuorumNWR 算法"></a>QuorumNWR 算法</h4><p>无主复制模式中，究竟多少个副本完成才可以认为写成功？</p>
<p>如果有 n 个副本，写人需要 w 个节点确认，读取必须至少查询 r 个节点， 则只要 <code>w+r&gt;n</code> ，读取的节点中一定会包含最新值。</p>
<h4 id="并发写冲突"><a href="#并发写冲突" class="headerlink" title="并发写冲突"></a>并发写冲突</h4><p>无主模式中，并发向多副本写操作，以及读时修复或数据回传都会导致并发写冲突。如何解决冲突呢？有以下几种机制：</p>
<ul>
<li>最后写入者获胜（丢弃并发写入） - 每个副本总是保存最新值，允许覆盖井丢弃旧值。</li>
<li>Happens Before - 利用全序的逻辑时钟来确定事件发生的前后顺序。</li>
<li>向量时钟、版本向量时钟 - 本质上是将全序的逻辑时钟改造为维护所有副本版本号的合集，基于此合集可以进行偏序比较。</li>
</ul>
<p>:::</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="【基础】什么是分区？为什么要分区？"><a href="#【基础】什么是分区？为什么要分区？" class="headerlink" title="【基础】什么是分区？为什么要分区？"></a>【基础】什么是分区？为什么要分区？</h3><p>:::details 要点</p>
<p>分区通常是这样定义的，即每一条数据（或者每条记录，每行或每个文档）只属于某个特定分区。实际上，每个分区都可以视为一个完整的小型数据库，虽然数据库可能存在一些跨分区的操作。</p>
<p>在不同系统中，分区有着不同的称呼，例如它对应于 MongoDB, Elasticsearch 和 SolrCloud 中的 shard, HBase 的 region, Bigtable 中的 tablet, Cassandra 和 Riak 中的 vnode ，以及 Couch base 中的 vBucket。总体而言，分区是最普遍的术语。</p>
<p>数据量如果太大，单台机器进行存储和处理就会成为瓶颈，因此需要引入数据分区机制。</p>
<p>分区的目地是通过多台机器均匀分布数据和查询负载，避免出现热点。这需要选择合适的数据分区方案，在节点添加或删除时重新动态平衡分区。</p>
<p>:::</p>
<h3 id="【中级】分区有哪些模式？"><a href="#【中级】分区有哪些模式？" class="headerlink" title="【中级】分区有哪些模式？"></a>【中级】分区有哪些模式？</h3><p>:::details 要点</p>
<p>分区通常与复制结合使用，即每个分区在多个节点都存有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。</p>
<p>一个节点上可能存储了多个分区。每个分区都有自己的主副本，例如被分配给某节点，而从副本则分配在其他一些节点。一个节点可能既是某些分区的主副本，同时又是其他分区的从副本。</p>
<p>分区主要有两种模式：</p>
<ul>
<li><strong>基于关键字区间的分区</strong> - 先对关键字进行排序，每个分区只负责一段包含最小到最大关键字范围的一段关键字。对关键字排序的优点是可以支持高效的区间查询，但是如果应用程序经常访问与排序一致的某段关键字，就会存在热点的风险。采用这种方怯，当分区太大时，通常将其分裂为两个子区间，从而动态地再平衡分区。典型代表：HBase</li>
<li><strong>哈希分区</strong> - 将哈希函数作用于每个关键字，每个分区负责一定范围的哈希值。这种方法打破了原关键字的顺序关系，它的区间查询效率比较低，但可以更均匀地分配负载。采用哈希分区时，通常事先创建好足够多（但固定数量）的分区， 让每个节点承担多个分区，当添加或删除节点时将某些分区从一个节点迁移到另一个节点，也可以支持动态分区。典型代表：Elasticsearch、Redis。</li>
</ul>
<p>:::</p>
<h3 id="【高级】二级索引如何分区？"><a href="#【高级】二级索引如何分区？" class="headerlink" title="【高级】二级索引如何分区？"></a>【高级】二级索引如何分区？</h3><p>:::details 要点</p>
<p>二级索引是关系数据库的必备特性，在文档数据库中应用也非常普遍。但考虑到其复杂性，许多键值存储（如 HBase 和 Voldemort）并不支持二级索引。此外， 二级索引技术也是 Solr 和 Elasticsearch 等搜索引擎数据库存在之根本。</p>
<p>分区不仅仅是针对数据，二级索引也需要分区。通常有两种方法：</p>
<p><strong>基于文档来分区二级索引（本地索引）</strong> - 二级索引存储在与关键字相同的分区中，这意味着写入时我们只需要更新一个分区，但缺点是读取二级索引时需要在所有分区上并行执行。它广泛用于实践： MongoDB 、Riak、Cassandra、Elasticsearch 、SolrCloud 和 VoltDB 都支持基于文档分区二级索引。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220303111528.png" alt="img"></p>
<p><strong>基于词条来分区二级索引（全局索引）</strong> - 它是基于索引的值而进行的独立分区。二级索引中的条目可能包含来自关键字的多个分区里的记录。在写入时，不得不更新二级索引的多个分区；但读取时，则可以从单个分区直接快速提取数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220303112708.png" alt="img"></p>
<p>:::</p>
<h3 id="【基础】什么是分区再均衡？"><a href="#【基础】什么是分区再均衡？" class="headerlink" title="【基础】什么是分区再均衡？"></a>【基础】什么是分区再均衡？</h3><p>:::details 要点</p>
<p>集群节点数变化，数据规模增长等情况，都会导致分区的分布不均。要保持分区的均衡，势必要将数据和请求进行迁移，这样一个迁移负载的过程称为<strong>分区再均衡</strong>。</p>
<p>:::</p>
<h3 id="【高级】分区再均衡有哪些策略？"><a href="#【高级】分区再均衡有哪些策略？" class="headerlink" title="【高级】分区再均衡有哪些策略？"></a>【高级】分区再均衡有哪些策略？</h3><p>:::details 要点</p>
<h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建远超实际节点数的分区数，然后为每个节点分配多个分区。接下来， 如果集群中添加了一个新节点，该新节点可以从每个现有的节点上匀走几个分区，直到分区再次达到全局平衡。</p>
<p>选中的整个分区会在节点之间迁移，但分区的总数量仍维持不变，也不会改变关键字到分区的映射关系。这里唯一要调整的是分区与节点的对应关系。考虑到节点间通过网络传输数据总是需要些时间，这样调整可以逐步完成，在此期间，旧分区仍然可以接收读写请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405122231579.png"></p>
<p>原则上，也可以将集群中的不同的硬件配置因素考虑进来，即性能更强大的节点将分配更多的分区，从而分担更多的负载。</p>
<p>目前，Riak、Elasticsearch、Couchbase 和 Voldemort 都支持这种动态平衡方法。</p>
<p>使用该策略时，分区的数量往往在数据库创建时就确定好，之后不会改变。原则上也可以拆分和合并分区（稍后介绍），但固定数量的分区使得相关操作非常简单，因此许多采用固定分区策略的数据库决定不支持分区拆分功能。所以，在初始化时，已经充分考虑将来扩容增长的需求（未来可能拥有的最大节点数），设置一个足够大的分区数。而每个分区也有些额外的管理开销，选择过高的数字可能会有副作用。</p>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>对于采用关键宇区间分区的数据库，如果边界设置有问题，最终可能会出现所有数据都挤在一个分区而其他分区基本为空，那么设定固定边界、固定数量的分区将非常不便：而手动去重新配置分区边界又非常繁琐。</p>
<p>因此， 一些数据库如 HBase 和 RethinkDB 等采用了动态创建分区。当分区的数据增长超过一个可配的参数阔值（HBase 上默认值是 10GB），它就拆分为两个分区，每个承担一半的数据量。相反，如果大量数据被删除，并且分区缩小到某个阈值以下，则将其与相邻分区进行合井。该过程类似于 B 树的分裂操作。</p>
<p>每个分区总是分配给一个节点，而每个节点可以承载多个分区，这点与固定数量的分区一样。当一个大的分区发生分裂之后，可以将其中的一半转移到其他某节点以平衡负载。对于 HBase，分区文件的传输需要借助 HDFS。</p>
<p>动态分区的一个优点是分区数量可以自动适配数据总量。如果只有少量的数据，少量的分区就足够了，这样系统开销很小；如果有大量的数据，每个分区的大小则被限制在一个可配的最大值。</p>
<p>但是，需要注意的是，对于一个空的数据库， 因为没有任何先验知识可以帮助确定分区的边界，所以会从一个分区开始。可能数据集很小，但直到达到第一个分裂点之前，所有的写入操作都必须由单个节点来处理， 而其他节点则处于空闲状态。为了缓解这个问题，HBase 和 MongoDB 允许在一个空的数据库上配置一组初始分区（这被称为预分裂）。对于关键字区间分区，预分裂要求已经知道一些关键字的分布情况。</p>
<p>动态分区不仅适用于关键字区间分区，也适用于基于哈希的分区策略。MongoDB 从版本 2.4 开始，同时支持二者，井且都可以动态分裂分区。</p>
<h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>采用动态分区策略，拆分和合并操作使每个分区的大小维持在设定的最小值和最大值之间，因此分区的数量与数据集的大小成正比关系。另一方面，对于固定数量的分区方式，其每个分区的大小也与数据集的大小成正比。两种情况，分区的数量都与节点数无关。</p>
<p>Cassandra 和 Ketama 则采用了第三种方式，使分区数与集群节点数成正比关系。换句话说，每个节点具有固定数量的分区。此时， 当节点数不变时，每个分区的大小与数据集大小保持正比的增长关系； 当节点数增加时，分区则会调整变得更小。较大的数据量通常需要大量的节点来存储，因此这种方法也使每个分区大小保持稳定。</p>
<p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一半数据量，将另一半数据留在原节点。随机选择可能会带来不太公平的分区分裂，但是当平均分区数量较大时（Cassandra 默认情况下，每个节点有 256 个分区），新节点最终会从现有节点中拿走相当数量的负载。Cassandra 在 3.0 时推出了改进算洁，可以避免上述不公平的分裂。</p>
<p>随机选择分区边界的前提要求采用基于哈希分区（可以从哈希函数产生的数字范围里设置边界）。这种方法也最符合本章开头所定义一致性哈希。一些新设计的哈希函数也可以以较低的元数据开销达到类似的效果。</p>
<p>:::</p>
<h3 id="【高级】如何确定读写请求发往哪个节点？"><a href="#【高级】如何确定读写请求发往哪个节点？" class="headerlink" title="【高级】如何确定读写请求发往哪个节点？"></a>【高级】如何确定读写请求发往哪个节点？</h3><p>:::details 要点</p>
<p>当数据集分布到多个节点上，需要解决一个问题：当客户端发起请求时，如何知道应该连接哪个节点？如果发生了分区再平衡，分区与节点的对应关系随之还会变化。</p>
<p>这其实属于一类典型的服务发现问题，任何通过网络访问的系统都有这样的需求，尤其是当服务目标支持高可用时（在多台机器上有冗余配置）。</p>
<p>服务发现有以下处理策略：</p>
<ol>
<li>允许客户端链接任意的节点（例如，采用循环式的负载均衡器）。如果某节点恰好拥有所请求的分区，则直接处理该请求：否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。</li>
<li>将所有客户端的请求都发送到一个路由层，由后者负责将请求转发到对应的分区节点上。路由层本身不处理任何请求，它仅充一个分区感知的负载均衡器。</li>
<li>客户端感知分区和节点分配关系。此时，客户端可以直接连接到目标节点，而不需要任何中介。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220304120137.png" alt="img"></p>
<p>许多分布式数据系统依靠独立的协调服务（如 ZooKeeper ）跟踪集群范围内的元数据。每个节点都向 ZooKeeper 中注册自己， ZooKeeper 维护了分区到节点的最终映射关系。其他参与者（如路由层或分区感知的客户端）可以向 ZooKeeper 订阅此信息。一旦分区发生了改变，或者添加、删除节点， ZooKeeper 就会主动通知路由层，这样使路由信息保持最新状态。</p>
<p>例如，HBase、SolrCloud 和 Kafka 也使用 ZooKeeper 来跟踪分区分配情况。MongoDB 有类似的设计，但它依赖于自己的配置服务器和 mongos 守护进程来充当路由层。</p>
<p>Cassandra 和 Redis 则采用了不同的方法，它们在节点之间使用 gossip 协议来同步群集状态的变化。请求可以发送到任何节点，由该节点负责将其转发到目标分区节点。这种方式增加了数据库节点的复杂性，但是避免了对 ZooKeeper 之类的外部协调服务的依赖。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220304163629.png" alt="img"></p>
<p>:::</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903734753886216?searchId=2024121710293693FB283CD941B5B19BE2">理解分布式事务</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/f293688d/">分布式事务</a></li>
</ul>
</blockquote>
<h3 id="【基础】什么是事务？什么是分布式事务？"><a href="#【基础】什么是事务？什么是分布式事务？" class="headerlink" title="【基础】什么是事务？什么是分布式事务？"></a>【基础】什么是事务？什么是分布式事务？</h3><p>:::details 要点</p>
<p><strong>事务将多个读、写操作捆绑在一起成为一个逻辑操作单元</strong>。<strong>事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）</strong>。</p>
<p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为<strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>:::</p>
<h3 id="【基础】什么是-ACID？什么是-BASE？二者有何区别？"><a href="#【基础】什么是-ACID？什么是-BASE？二者有何区别？" class="headerlink" title="【基础】什么是 ACID？什么是 BASE？二者有何区别？"></a>【基础】什么是 ACID？什么是 BASE？二者有何区别？</h3><p>:::details 要点</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>ACID 是数据库事务正确执行的四个基本要素的单词缩写：</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>原子是指不可分解为更小粒度的东西。事务的原子性意味着：<strong>事务中的所有操作要么全部成功，要么全部失败</strong>。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>ACID 中的原子性并不关乎多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，后者其实是由 ACID 的隔离性所定义。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li><strong>同时运行的事务互不干扰</strong>。换句话说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>BASE 是 <strong><code>基本可用（Basically Available）</code><strong>、</strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。</p>
<p>BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<ul>
<li><strong>基本可用（Basically Available）</strong>分布式系统在出现故障的时候，<strong>保证核心可用，允许损失部分可用性</strong>。例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</li>
<li><strong>软状态（Soft State）</strong>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即<strong>允许系统不同节点的数据副本之间进行同步的过程存在延时</strong>。</li>
<li><strong>最终一致性（Eventually Consistent）</strong>强调的是<strong>系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态</strong>。</li>
</ul>
<h4 id="BASE-vs-ACID"><a href="#BASE-vs-ACID" class="headerlink" title="BASE vs. ACID"></a>BASE vs. ACID</h4><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过<strong>牺牲强一致性来达到可用性</strong>，通常运用在大型分布式系统中。BASE 唯一可以确定的是“它不是 ACID”，此外它几乎没有承诺任何东西。</p>
<p>:::</p>
<h3 id="【基础】什么是一致性？什么是最终一致性？"><a href="#【基础】什么是一致性？什么是最终一致性？" class="headerlink" title="【基础】什么是一致性？什么是最终一致性？"></a>【基础】什么是一致性？什么是最终一致性？</h3><p>:::details 要点</p>
<p>一致性（Consistency）指的是<strong>多个数据副本是否能保持一致</strong>的特性。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li><strong>强一致性</strong> - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li><strong>最终一致性</strong> - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<p>在分布式领域，要实现强一致性，代价非常高昂。因此，有人基于 CAP 理论以及 BASE 理论，有人就提出了<strong>柔性事务</strong>的概念。柔性事务是指：在不影响系统整体可用性的情况下 (Basically Available 基本可用），允许系统存在数据不一致的中间状态 (Soft State 软状态），在经过数据同步的延时之后，达到<strong>最终一致性</strong>。<strong>并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<p>:::</p>
<h3 id="【中级】有哪些分布式事务解决方案？各有什么利弊？"><a href="#【中级】有哪些分布式事务解决方案？各有什么利弊？" class="headerlink" title="【中级】有哪些分布式事务解决方案？各有什么利弊？"></a>【中级】有哪些分布式事务解决方案？各有什么利弊？</h3><p>:::details 要点</p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong><ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>消息事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案对比：</p>
<ul>
<li>2PC&#x2F;3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表&#x2F;消息事务都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。</li>
<li>Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>2PC</th>
<th>3PC</th>
<th>TCC</th>
<th>本地消息表</th>
<th>MQ 事务</th>
<th>SAGA</th>
</tr>
</thead>
<tbody><tr>
<td>数据一致性</td>
<td>强</td>
<td>强</td>
<td>若</td>
<td>弱</td>
<td>弱</td>
<td>弱</td>
</tr>
<tr>
<td>容错性</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>复杂性</td>
<td>中</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>低</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>维护成本</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>高</td>
</tr>
</tbody></table>
<p>:::</p>
<h3 id="【中级】2PC-是如何工作的？"><a href="#【中级】2PC-是如何工作的？" class="headerlink" title="【中级】2PC 是如何工作的？"></a>【中级】2PC 是如何工作的？</h3><p>:::details 要点</p>
<p>二阶段提交协议（Two-phase Commit，即 2PC）<strong>将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段</strong>。事务的发起者称协调者，事务的执行者称参与者。二阶段提交的思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈，决定提交或回滚</strong>。</p>
<p><strong>阶段 1：准备阶段</strong></p>
<ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。</li>
</ol>
<p><strong>阶段 2：提交阶段</strong></p>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚 (rollback) 消息；否则，发送提交 (commit) 消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。（注意：必须在最后阶段释放锁资源） 接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况 1，当所有参与者均反馈 yes，提交事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140719760.png" alt="img"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。</li>
<li>参与者执行 commit 请求，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack（应答）完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2，当任何阶段 1 一个参与者反馈 no，中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140723628.png" alt="img"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出回滚请求（即 rollback 请求）。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<p>方案总结：</p>
<p>2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li><strong>性能问题</strong> - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li><strong>可靠性问题</strong> - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li><strong>数据一致性问题</strong> - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<p>:::</p>
<h3 id="【中级】3PC-是如何工作的？"><a href="#【中级】3PC-是如何工作的？" class="headerlink" title="【中级】3PC 是如何工作的？"></a>【中级】3PC 是如何工作的？</h3><p>:::details 要点</p>
<p>三阶段提交协议（Three-phase Commit，3PC），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p><strong>阶段 1：canCommit</strong></p>
<p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应（参与者不执行事务操作），否则返回 no 响应：</p>
<ol>
<li>协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li>
</ol>
<p><strong>阶段 2：preCommit</strong></p>
<p>协调者根据阶段 1 canCommit 参与者的反应情况来决定是否可以基于事务的 preCommit 操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140724776.png" alt="img"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 preCommit 请求，进入准备阶段。</li>
<li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li>
</ol>
</blockquote>
<p><strong>情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140725035.png" alt="img"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 abort 请求。</li>
<li>无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ol>
</blockquote>
<p><strong>阶段 3：doCommit</strong></p>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140725296.png" alt="img"></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，则向所有参与者发出 doCommit 请求。</li>
<li>参与者收到 doCommit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140726693.png" alt="img"></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，向所有参与者发出 abort 请求。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<p>注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<p><strong>方案总结</strong>：</p>
<ul>
<li><p>优点：<strong>相比二阶段提交，三阶段降低了阻塞范围</strong>，在<strong>等待超时后协调者或参与者会中断事务</strong>。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</p>
</li>
<li><p>缺点：<strong>数据不一致问题依然存在</strong>，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p>
</li>
</ul>
<p>:::</p>
<h3 id="【中级】TCC-是如何工作的？"><a href="#【中级】TCC-是如何工作的？" class="headerlink" title="【中级】TCC 是如何工作的？"></a>【中级】TCC 是如何工作的？</h3><p>:::details 要点</p>
<p>TCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现；</p>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
<p>TCC 事务的 Try、Confirm、Cancel 可以理解为 SQL 事务中的 Lock、Commit、Rollback。</p>
<p><strong>Try 阶段</strong></p>
<p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查（一致性）</li>
<li>预留必须业务资源（准隔离性）</li>
<li>Try 尝试执行业务 TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
</ul>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<p><strong>Confirm &#x2F; Cancel 阶段</strong></p>
<p>根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p><strong>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140726821.png" alt="img"></p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p><strong>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140726904.png" alt="img"></p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<p><strong>方案总结</strong></p>
<p>TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：</p>
<ul>
<li><strong>性能提升</strong> - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li><strong>数据最终一致性</strong> - 基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li><strong>可靠性</strong> - 解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点： TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，<strong>业务耦合度较高</strong>，提高了开发成本。</p>
<p>:::</p>
<h3 id="【高级】本地消息表是如何工作的？"><a href="#【高级】本地消息表是如何工作的？" class="headerlink" title="【高级】本地消息表是如何工作的？"></a>【高级】本地消息表是如何工作的？</h3><p>:::details 要点</p>
<p>本地消息表的核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>“，或”<strong>业务处理失败 + 事务消息发送成功</strong>“的棘手情况出现，保证 2 个系统事务的数据一致性。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140809614.png" alt="img"></p>
<blockquote>
<ol>
<li><strong>步骤 1、事务主动方处理本地事务。</strong> 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表（图中 1、2)。</li>
<li><strong>步骤 2、事务主动方通过 MQ 通知事务被动方处理事务</strong>。 消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。</li>
<li><strong>步骤 3、事务被动方通过 MQ 返回处理结果。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成（图中 6 - 8)</li>
</ol>
</blockquote>
<p>为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<ul>
<li>当步骤 1 处理出错，事务回滚，相当于什么都没发生。</li>
<li>当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询超时 d 的消息数据，再次发送消息到 MQ 进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ul>
</blockquote>
<p><strong>方案总结</strong></p>
<p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，<strong>消息数据的可靠性不依赖于消息中间件</strong>，弱化了对 MQ 中间件特性的依赖。</li>
<li><strong>方案简单</strong>，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，<strong>耦合性高，不可复用</strong>。</li>
<li>需要额外维护消息数据的传输，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<p>:::</p>
<h3 id="【高级】消息事务是如何工作的？"><a href="#【高级】消息事务是如何工作的？" class="headerlink" title="【高级】消息事务是如何工作的？"></a>【高级】消息事务是如何工作的？</h3><p>:::details 要点</p>
<p>MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p>
<ul>
<li><strong>Kafka</strong> 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。</li>
<li><strong>RocketMQ</strong> 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</li>
</ul>
<h4 id="RocketMQ-事务消息实现"><a href="#RocketMQ-事务消息实现" class="headerlink" title="RocketMQ 事务消息实现"></a>RocketMQ 事务消息实现</h4><p>事务消息是 Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p>
<p><strong>事务消息处理流程</strong></p>
<p>事务消息交互流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405140759853.png" alt="img"></p>
<ol>
<li>生产者将消息发送至 Apache RocketMQ 服务端。</li>
<li>Apache RocketMQ 服务端将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为半事务消息。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit 或是 Rollback），服务端收到确认结果后处理逻辑如下：<ul>
<li>二次确认结果为 Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为 Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
</li>
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 <strong>说明</strong> 服务端回查的间隔时间和最大回查次数，请参见 <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半事务消息进行处理。</li>
</ol>
<p><strong>MQ 事务方案总结</strong></p>
<p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li><strong>业务解耦</strong> - 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li><strong>吞吐量优于本地消息表</strong>方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li><strong>一次消息发送需要两次网络请求</strong> (half 消息 + commit&#x2F;rollback 消息）</li>
<li><strong>业务处理服务需要实现消息状态回查接口</strong></li>
</ul>
<p>:::</p>
<h3 id="【高级】SAGA-事务是如何工作的？"><a href="#【高级】SAGA-事务是如何工作的？" class="headerlink" title="【高级】SAGA 事务是如何工作的？"></a>【高级】SAGA 事务是如何工作的？</h3><p>:::details 要点</p>
<p>Saga 事务的核心思想是：将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序依次调用补偿操作。</p>
<p><strong>Saga 事务基本协议如下</strong>：</p>
<ul>
<li><strong>将长事务拆分为多个有序子事务</strong> - 每个 Saga 事务由一系列幂等的有序子事务 (sub-transaction) Ti 组成。</li>
<li><strong>每个子事务 Ti 都有对应的幂等补偿动作 Ci</strong>，补偿动作用于撤销 Ti 造成的结果。</li>
</ul>
<p>可以看到，和 TCC 相比，Saga 没有“预留”动作，它的 Ti 就是直接提交到库。</p>
<p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga 的执行顺序有两种：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405150751202.png" alt="img"></p>
<ul>
<li>事务正常执行完成 T1, T2, T3, …, Tn，例如：扣减库存 (T1)，创建订单 (T2)，支付 (T3)，依次有序完成整个事务。</li>
<li>事务回滚 T1, T2, …, Tj, Cj,…, C2, C1，其中 0 &lt; j &lt; n，例如：扣减库存 (T1)，创建订单 (T2)，支付 (T3，支付失败），支付回滚 (C3)，订单回滚 (C2)，恢复库存 (C1)。</li>
</ul>
<p>恢复策略</p>
<p>Saga 定义了两种恢复策略：</p>
<ul>
<li>向前恢复 (forward recovery)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405150752176.png" alt="img"></p>
<p>对应于上面第一种执行顺序，<strong>适用于必须要成功的场景</strong>，<strong>失败需要进行重试</strong>，执行顺序是类似于这样的：T1, T2, …, Tj（失败）, Tj（重试）,…, Tn，其中 j 是发生错误的子事务 (sub-transaction)。该情况下不需要 Ci。</p>
<ul>
<li>向后恢复 (backward recovery)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405150752372.png" alt="img"></p>
<p>对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务 (sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p>
<p>Saga 事务常见的有两种不同的实现方式：命令协调和事件编排。</p>
<p><strong>命令协调</strong></p>
<ul>
<li><strong>命令协调 (Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></li>
</ul>
<p>中央协调器（Orchestrator，简称 OSO）以命令&#x2F;回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405150752580.png" alt="img"></p>
<p>以电商订单的例子为例：</p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务。</li>
<li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ol>
</blockquote>
<p>中央协调器必须事先知道执行整个订单事务所需的流程（例如通过读取配置）。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<p><strong>事件编排</strong></p>
<ul>
<li><strong>事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</li>
</ul>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p>以电商订单的例子为例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405150753776.png" alt="img"></p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑发布开始订单事件</li>
<li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件</li>
<li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件</li>
<li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件</li>
<li>主业务逻辑监听订单已支付事件并处理。</li>
</ol>
</blockquote>
<p>事件编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p>
<p><strong>方案总结</strong></p>
<p><strong>命令协调设计的优点和缺点：</strong></p>
<p>优点如下：</p>
<ul>
<li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器</li>
<li>程序开发简单，只需要执行命令&#x2F;回复（其实回复消息也是一种事件消息），降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p><strong>事件&#x2F;编排设计的优点和缺点</strong></p>
<p>优点如下：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<p>值得补充的是，由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性，当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<p>:::</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a20cd8bf265da43163cdd9a">分布式锁实现汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JzCHpIOiFVmBoAko58ZuGw">分布式锁实现原理与最佳实践 - 阿里云开发者</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-N4x6EkxwAYDGdJhwvmZLw">聊聊分布式锁 - 字节跳动技术团队</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yZC6VJGxt1ANZkn0SljZBg">Redis、ZooKeeper、Etcd，谁有最好用的分布式锁？ - 腾讯云开发者</a></li>
</ul>
</blockquote>
<h3 id="【初级】什么是分布式锁？为什么需要分布式锁？"><a href="#【初级】什么是分布式锁？为什么需要分布式锁？" class="headerlink" title="【初级】什么是分布式锁？为什么需要分布式锁？"></a>【初级】什么是分布式锁？为什么需要分布式锁？</h3><p>:::details 要点</p>
<p>在计算机科学中，<strong>锁是在并发场景下用于强行限制资源访问的一种同步机制</strong>，即用于在并发控制中通过互斥手段来保证数据同步安全。</p>
<p>在 Java 进程中，可以使用 Lock、synchronized 等来支持并发锁。如果是同一台机器的不同进程，想要同时操作一个共享资源（例如修改同一个文件），可以使用操作系统提供的「文件锁」或「信号量」来做互斥。这些发生在同一台机器上的互斥操作，可以称为<strong>本地锁</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190814629.png"></p>
<p>本地锁无法协同不同机器间的互斥操作。为了解决这个问题，需要引入分布式锁。</p>
<p><strong>分布式锁</strong>，顾名思义，应用于分布式场景下，它和单进程中的锁并没有本质上的不同，只是控制对象由一个进程中的多个线程变成了多个进程中的多个线程。此外，临界区的资源也由进程内共享资源变成了分布式系统内部共享资源。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190815373.png"></p>
<p>:::</p>
<h3 id="【高级】实现分布式锁有哪些要点？"><a href="#【高级】实现分布式锁有哪些要点？" class="headerlink" title="【高级】实现分布式锁有哪些要点？"></a>【高级】实现分布式锁有哪些要点？</h3><p>:::details 要点</p>
<p>分布式锁的实现要点如下：</p>
<ul>
<li><strong>互斥</strong> - <strong>分布式锁必须是独一无二的</strong>，表现形式为：向数据存储插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。<ul>
<li>保证 key 唯一性的最简单的方式是使用 UUID。</li>
<li>此外，可以参考 Snowflake ID（雪花算法），将机器地址（IP 地址、机器 ID、MAC 地址）、Jvm 进程 ID（应用 ID、服务 ID）、时间戳等关键信息拼接起来作为唯一标识。</li>
</ul>
</li>
<li><strong>避免死锁</strong> - 在分布式锁的场景中，部分失败和异步网络这两个问题是同时存在的。如果一个进程获得了锁，但是这个进程与锁服务之间的网络出现了问题，导致无法通信，那么这个情况下，如果锁服务让它一直持有锁，就会导致死锁的发生。常见的解决思路都是引入<strong>超时机制</strong>，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。</li>
<li><strong>可重入</strong> - <strong>可重入</strong>指的是：<strong>同一个线程在没有释放锁之前，能否再次获得该锁</strong>。其实现方案是：只需在加锁的时候，<strong>记录好当前获取锁的节点 + 线程组合的唯一标识</strong>，然后在后续的加锁请求时，如果当前请求的节点 + 线程的唯一标识和当前持有锁的相同，那么就直接返回加锁成功；如果不相同，则按正常加锁流程处理。</li>
<li><strong>公平性</strong> - 当多个线程请求同一锁时，它们必须按照请求的顺序来获取锁，即先来先得的原则。锁的公平性的实现也非常简单，对于被阻塞的加锁请求，我们只要先记录好它们的顺序，在锁被释放后，按顺序颁发就可以了。</li>
<li><strong>重试</strong> - 有时候，加锁失败可能只是由于网络波动、请求超时等原因，稍候就可以成功获取锁。为了应对这种情况，加锁操作需要支持重试机制。常见的做法是，设置一个加锁超时时间，在该时间范围内，不断自旋重试加锁操作，超时后再判定加锁失败。</li>
<li><strong>容错</strong> - 分布式锁若存储在单一节点，一旦该节点宕机或失联，就会导致锁失效。将分布式锁存储在多数据库实例中，加锁时并发写入 <code>N</code> 个节点，只要 <code>N / 2 + 1</code> 个节点写入成功即视为加锁成功。</li>
</ul>
<p>:::</p>
<h3 id="【中级】数据库分布式锁如何实现？"><a href="#【中级】数据库分布式锁如何实现？" class="headerlink" title="【中级】数据库分布式锁如何实现？"></a>【中级】数据库分布式锁如何实现？</h3><p>:::details 要点</p>
<h4 id="数据库分布式锁原理"><a href="#数据库分布式锁原理" class="headerlink" title="数据库分布式锁原理"></a>数据库分布式锁原理</h4><p>（1）创建锁表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `distributed_lock` (</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">	`resource` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;资源&#x27;</span>,</span><br><span class="line">	`count` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;锁次数，统计可重入锁&#x27;</span>,</span><br><span class="line">	`<span class="keyword">desc</span>` TEXT <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">	`create_time` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	`update_time` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY `uniq_resource`(`resource`)</span><br><span class="line">)</span><br><span class="line">	ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> `utf8mb4`;</span><br></pre></td></tr></table></figure>

<p>（2）获取锁</p>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>

<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<p>（3）释放锁</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="数据库分布式锁小结"><a href="#数据库分布式锁小结" class="headerlink" title="数据库分布式锁小结"></a>数据库分布式锁小结</h4><p>数据库分布式锁的<strong>问题</strong>：</p>
<ul>
<li><strong>死锁</strong>：一旦释放锁操作失败，或持有锁的机器宕机、断连，就会导致锁记录一直存在，其他线程无法再获得锁。解决办法：为锁增加失效时间字段，启动一个定时任务，隔一段时间清除一次过期的数据。</li>
<li><strong>非阻塞</strong>：因为 <code>insert</code> 操作一旦失败就会报错，因此未获得锁的线程并不会进入排队队列，要想获得锁就要再次触发加锁操作。解决办法：循环重试，直到插入成功，这么做会产生一定额外开销。</li>
<li><strong>非重入</strong>：同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。解决办法：在数据库表中加个字段，记录当前获得锁的节点信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
<li><strong>单点问题</strong>：如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。解决办法：单点问题可以用多数据库实例，同时写入 <code>N</code> 个节点，<code>N / 2 + 1</code> 个成功就加锁成功。</li>
</ul>
<p>数据库分布式锁的<strong>利弊</strong>：</p>
<ul>
<li><strong>优点</strong>：直接借助数据库，简单易懂。</li>
<li><strong>缺点</strong>：会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。此外，数据库性能易成为瓶颈。</li>
</ul>
<p>:::</p>
<h3 id="【高级】ZooKeeper-分布式锁如何实现？"><a href="#【高级】ZooKeeper-分布式锁如何实现？" class="headerlink" title="【高级】ZooKeeper 分布式锁如何实现？"></a>【高级】ZooKeeper 分布式锁如何实现？</h3><p>:::details 要点</p>
<h4 id="ZooKeeper-分布式锁实现原理"><a href="#ZooKeeper-分布式锁实现原理" class="headerlink" title="ZooKeeper 分布式锁实现原理"></a>ZooKeeper 分布式锁实现原理</h4><p>ZooKeeper 分布式锁的实现基于 ZooKeeper 的两个重要特性：</p>
<ul>
<li><strong>顺序临时节点</strong>：ZooKeeper 的存储类似于 DNS 那样的具有层级的命名空间。ZooKeeper 节点类型可以分为持久节点（<code>PERSISTENT</code>）、临时节点（<code>EPHEMERAL</code>），每个节点还能被标记为有序性（<code>SEQUENTIAL</code>），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。</li>
<li><strong>Watch 机制</strong>：ZooKeeper 允许用户在指定节点上注册一些 <code>Watcher</code>，并且在特定事件触发的时候，ZooKeeper 服务端会将事件通知给用户。</li>
</ul>
<p>下面是 ZooKeeper 分布式锁的工作流程：</p>
<ol>
<li>创建一个目录节点，比如叫做 <code>/locks</code>；</li>
<li>线程 A 想获取锁，就在 <code>/locks</code> 目录下创建临时顺序 zk 节点；</li>
<li>获取 <code>/locks</code>目录下所有的子节点，检查是否存在比自己顺序更小的节点：若不存在，则说明当前线程创建的节点顺序最小，获取锁成功；</li>
<li>此时，线程 B 试图获取锁，发现自己的节点顺序不是最小，设置监听锁号在自己前一位的节点；</li>
<li>线程 A 处理完，删除自己的节点。线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="ZooKeeper-分布式锁小结"><a href="#ZooKeeper-分布式锁小结" class="headerlink" title="ZooKeeper 分布式锁小结"></a>ZooKeeper 分布式锁小结</h4><p>ZooKeeper 分布式锁的<strong>优点</strong>是较为<strong>可靠</strong>：</p>
<ul>
<li><strong>避免死锁</strong>：ZooKeeper 通过临时节点 + 监听机制，可以保证：如果持有临时节点的线程主动解锁或断连，Zk 会自动删除临时节点，这意味着锁的释放。所以，不存在锁永久不释放从而导致死锁的问题。</li>
<li><strong>单点问题</strong>：ZooKeeper 采用主从架构，并确保主从同步是强一致的，因此不会出现单点问题。</li>
</ul>
<p>ZooKeeper 分布式锁的<strong>缺点</strong>是：加锁、解锁操作，本质上是对 ZooKeeper 的写操作，全部由 ZooKeeper 主节点负责。如果加锁、解锁的吞吐量很大，容易出现单点写入瓶颈。</p>
<p>:::</p>
<h3 id="【高级】Redis-分布式锁如何实现？"><a href="#【高级】Redis-分布式锁如何实现？" class="headerlink" title="【高级】Redis 分布式锁如何实现？"></a>【高级】Redis 分布式锁如何实现？</h3><p>:::details 要点</p>
<h4 id="Redis-分布式锁实现原理"><a href="#Redis-分布式锁实现原理" class="headerlink" title="Redis 分布式锁实现原理"></a>Redis 分布式锁实现原理</h4><h5 id="极简版本"><a href="#极简版本" class="headerlink" title="极简版本"></a>极简版本</h5><p>我们先来看一下，如何实现一个极简版本的 Redis 分布式锁。</p>
<p>（1）加锁</p>
<p>Redis 中的 <code>setnx</code> 命令，表示当且仅当 key 不存在时，才会写入 key。由于其互斥性，所以可以基于此来实现分布式锁。</p>
<p>执行 <code>setnx key val</code>，若返回 1，表示写入成功，即加锁成功；若返回 0，表示该 key 已存在，写入失败，即加锁失败。</p>
<p>（2）解锁</p>
<p>Redis 分布式锁如何解锁呢？</p>
<p>很简单，删除 key 就意味着释放锁，即执行 <code>del key</code> 命令。</p>
<h5 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h5><p>极简版本的解决方案有一个很大的问题：<strong>存在死锁的可能</strong>。持有锁的节点如果执行业务过程中出现异常或机器宕机，都可能导致无法释放锁。这种情况下，其他节点永远也无法再获取锁。</p>
<p>对于异常，在 Java 中，可以通过 <code>try...catch...finally</code> 来保证：最终一定会释放锁，其他编程语言也有相似的语法特性。</p>
<p>对于机器宕机这种情况，如何处理呢？通常的对策是：为锁加上<strong>超时机制，过期自动删除</strong>。</p>
<p>在 Redis 中，<code>expire</code> 命令可以为 key 设置一个超时时间，一旦过期，Redis 会自动删除 key。如此看来，<code>setnx</code> + <code>expire</code> 组合使用，就能解决死锁问题了。可惜，没那么简单。Redis 只能保证单一命令的原子性，不保证组合命令的原子性。</p>
<p>那么，Redis 中有没有一条命令可以实现 setnx + expire 的组合语义呢？还真有，可以通过下面的命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面两条命令是等价的</span></span><br><span class="line">SET key val NX PX 30000</span><br><span class="line">SET key val NX EX 30</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>NX</code>：该参数表示当且仅当 key 不存在，才能写入成功</li>
<li><code>PX</code>：超时时间，单位毫秒</li>
<li><code>EX</code>：超时时间，单位秒</li>
</ul>
<h5 id="超时续期"><a href="#超时续期" class="headerlink" title="超时续期"></a>超时续期</h5><p>为了避免死锁，我们为锁添加了超时时间。但这里有一个问题，如果应用加锁时，对于操作共享资源的时长估计不足，可能会出现：操作尚未执行完，但是锁没了的尴尬情况。为了解决这个问题，很自然会想到，时间不够，就续期呗。</p>
<p>具体来说，如何续期呢？一种方案是：加锁后，启动一个定时任务，周期性检测锁是否快要过期，如果快要过期并且操作尚未结束，就对锁进行自动续期。自行实现这个方案似乎有点繁琐，好在开源 Redis 客户端 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 中已经为锁的<strong>超时续期</strong>提供了一个成熟的机制——WatchDog（看门狗）。我们可以直接拿来主义即可。</p>
<h5 id="安全解锁"><a href="#安全解锁" class="headerlink" title="安全解锁"></a>安全解锁</h5><p>前文提到了，解锁的操作，实际上就是 <code>del key</code>。这里存在一个问题：因为没有任何判断，任何节点都可以随意删除 key，换句话说，锁可能会被其他节点释放。如何避免这个问题呢？解决方法就是：为锁添加<strong>唯一性标识</strong>来进行互斥。唯一性标识可以是 UUID，可以是雪花算法 ID 等。</p>
<p>在 Redis 分布式锁中，唯一性标识的具体实现就是在 <code>set key val</code> 时，将唯一性标识 id 作为 <code>val</code> 写入。<strong>解锁前，先判断 key 的 value，必须和 set 时写入的 id 值保持一致，以此确认锁归属于自己</strong>。解锁的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.get(<span class="string">&quot;key&quot;</span>) == id)</span><br><span class="line">	redis.del(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里依然存在一个问题，由于需要在 Redis 中，先 <code>get</code>，后 <code>del</code> 操作，所以无法保证操作的原子性。为了保证原子性，可以将这段伪代码用 lua 脚本来实现，这么做的理由是 Redis 中支持原子性的执行 lua 脚本。下面是安全解锁的 lua 脚本代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="自旋重试"><a href="#自旋重试" class="headerlink" title="自旋重试"></a>自旋重试</h5><p>有时候，加锁失败可能只是由于网络波动、请求超时等原因，稍候就可以成功获取锁。为了应对这种情况，加锁操作需要支持重试机制。常见的做法是，设置一个加锁超时时间，在该时间范围内，不断自旋重试加锁操作，超时后再判定加锁失败。</p>
<p>下面是一个自旋重试获取锁的伪代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, uniqId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功，执行业务操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - begin;</span><br><span class="line">        <span class="keyword">if</span> (time &gt;= timeout) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-分布式锁小结"><a href="#Redis-分布式锁小结" class="headerlink" title="Redis 分布式锁小结"></a>Redis 分布式锁小结</h4><p>在前文中，为了实现一个靠谱的 Redis 分布式锁，我们讨论了避免死锁、超时续期、安全解锁几个问题以及应对策略。但是，依然存在一些其他问题：</p>
<ul>
<li><strong>不可重入</strong> - 同一个线程无法多次获取同一把锁。</li>
<li><strong>单点问题</strong> - Redis 主从同步存在延迟，有可能导致锁冲突。举例来说：线程一在主节点加锁，如果主节点尚未同步给从节点就发生宕机；此时，Redis 集群会选举一个从节点作为新的主节点。此时，新的主节点没有锁的数据，若有其他线程试图加锁，就可以成功获取锁，即出现同时有多个线程持有锁的情况。解决这个问题，可以使用 RedLock 算法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 是一个流行的 Redis Java 客户端，它基于 Netty 开发，并提供了丰富的扩展功能，如：<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/counters/">分布式计数器</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/collections/">分布式集合</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/locks-and-synchronizers/">分布式锁</a> 等。</p>
<p>Redisson 支持的分布式锁有多种：Lock, FairLock, MultiLock, RedLock, ReadWriteLock, Semaphore, PermitExpirableSemaphore, CountDownLatch，可以根据场景需要去选择，非常方面。一般而言，使用 Redis 分布式锁，推荐直接使用 Redisson 提供的 API，功能全面且较为可靠。</p>
<p>:::</p>
<h3 id="【中级】RedLock-分布式锁如何实现？"><a href="#【中级】RedLock-分布式锁如何实现？" class="headerlink" title="【中级】RedLock 分布式锁如何实现？"></a>【中级】RedLock 分布式锁如何实现？</h3><p>:::details 要点</p>
<p>RedLock 分布式锁，是 Redis 的作者 Antirez 提出的一种解决方案。</p>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/develop/use/patterns/distributed-locks/">RedLock 官方文档</a></p>
</blockquote>
<h4 id="RedLock-分布式锁原理"><a href="#RedLock-分布式锁原理" class="headerlink" title="RedLock 分布式锁原理"></a>RedLock 分布式锁原理</h4><p>RedLock 分布式锁在普通 Redis 分布式锁的基础上，进行了扩展，其要点在于：</p>
<ul>
<li>（1）加锁操作不是写入单一节点，而是同时写入多个主节点，官方推荐集群中至少有 5 个主节点。</li>
<li>（2）只要半数以上的主节点写入成功，即视为加锁成功。</li>
<li>（3）大多数节点加锁的总耗时，要小于锁设置的过期时间。</li>
<li>（4）解锁时，要向所有节点发起请求。</li>
</ul>
<p>下面来逐一解释以上各要点的用意：</p>
<p>（1）RedLock 加锁时，为什么要同时写入多个主节点？</p>
<p>这是为了避免单点问题，即使有部分实例出现异常，依然可以正常提供加锁、解锁能力。</p>
<p>（2）为什么要半数以上的主节点写入成功，才视为加锁成功？</p>
<p>在分布式系统中，为了达成共识，常常采用“多数派”策略来进行决策：大多数节点认可的行为，就视为整体通过。</p>
<p>（3）为什么加锁成功后，还要计算加锁的累计耗时？</p>
<p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久。而且，网络情况是复杂的，可能存在延迟、丢包、超时等情况。网络请求越多，异常发生的概率就越大。所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经<strong>超过</strong>了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p>
<p>（4）解锁时，为什么要向所有节点发起请求？</p>
<p>因为网络环境的复杂性，可能会存在这种情况：向某主节点写入锁信息，实际写入成功，但是响应超时或丢包。</p>
<p>所以，释放锁时，不管之前有没有加锁成功，需要释放<strong>所有节点</strong>的锁，以保证清理节点上<strong>残留</strong>的锁。</p>
<h4 id="RedLock-分布式锁小结"><a href="#RedLock-分布式锁小结" class="headerlink" title="RedLock 分布式锁小结"></a>RedLock 分布式锁小结</h4><p>（1）<strong>RedLock 不能完全保证安全性</strong></p>
<p>分布式系统会遇到三座大山：<strong>NPC</strong></p>
<ul>
<li>N：Network Delay，<strong>网络延迟</strong>；</li>
<li>P：Process Pause，进程暂停（<strong>GC</strong>）；</li>
<li>C：Clock Drift，<strong>时钟漂移</strong>。</li>
</ul>
<p>RedLock 在遇到以上情况时，不能保证安全性。</p>
<p>（2）RedLock 加锁、解锁需要处理多个节点，代价太高</p>
<blockquote>
<p>总结来说，<strong>已知的分布式锁，无论采用什么解决方案，在极端情况下，都无法保证百分百的安全。</strong></p>
</blockquote>
<p>:::</p>
<h3 id="【高级】分布式锁如何进行技术选型？"><a href="#【高级】分布式锁如何进行技术选型？" class="headerlink" title="【高级】分布式锁如何进行技术选型？"></a>【高级】分布式锁如何进行技术选型？</h3><p>:::details 要点</p>
<p>下面是主流分布式锁技术方案的对比，可以在技术选型时作为参考：</p>
<table>
<thead>
<tr>
<th></th>
<th>数据库分布式锁</th>
<th>Redis 分布式锁</th>
<th>ZooKeeper 分布式锁</th>
</tr>
</thead>
<tbody><tr>
<td>方案要点</td>
<td>1. 维护一张锁表，为锁的唯一标识字段添加唯一性约束。<br/>2. 只要 insert 成功，即视为加锁成功。</td>
<td><code>set lockKey randomValue NX PX/EX time</code> 当且仅当 key 不存在时才可以写入，并且设定超时时间，以避免死锁。</td>
<td>加锁本质上是在 zk 中指定目录创建<strong>顺序临时接节点</strong>，序号最小即加锁成功。节点删除时，有监听通知机制告知申请锁的线程。</td>
</tr>
<tr>
<td>方案难度</td>
<td>实现简单、易于理解</td>
<td>较为简单，但要使其更可靠，需要有一些完善策略</td>
<td>应用简单，但 zk 内部机制并不简单</td>
</tr>
<tr>
<td>性能</td>
<td>性能最差，易成为瓶颈</td>
<td>性能最高</td>
<td>性能弱于 Redis</td>
</tr>
<tr>
<td>可靠性</td>
<td>有锁表的风险</td>
<td>较为可靠（需要一些完善策略）</td>
<td>可靠性最高</td>
</tr>
<tr>
<td>适用场景</td>
<td>一般不采用</td>
<td>适用于高并发的场景</td>
<td>适用于要求可靠，但并发量不高的场景</td>
</tr>
<tr>
<td>开源实现</td>
<td>无</td>
<td><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a></td>
<td><a target="_blank" rel="noopener" href="https://curator.apache.org/docs/about/">Apache Curator</a></td>
</tr>
</tbody></table>
<p>:::</p>
<h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bb0217ef265da0ac2567b42">如果再有人问你分布式 ID，这篇文章丢给他</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011282426">理解分布式 id 生成算法 SnowFlake</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式 ID 生成系统</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc4122.txt">UUID 规范</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">百度分布式 ID</a></li>
<li><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/">ShardingSphere 分布式主键</a></li>
</ul>
</blockquote>
<h3 id="【初级】什么是分布式-ID？为什么需要分布式-ID？"><a href="#【初级】什么是分布式-ID？为什么需要分布式-ID？" class="headerlink" title="【初级】什么是分布式 ID？为什么需要分布式 ID？"></a>【初级】什么是分布式 ID？为什么需要分布式 ID？</h3><p>:::details 要点</p>
<p>ID是Identity的缩写，用于唯一的标识一条数据。<strong>分布式 ID</strong>，顾名思义，是<strong>用于在分布式系统中唯一标识数据的ID</strong>。</p>
<p>传统数据库基本都支持针对单表生成唯一性的自增主键。随着数据的膨胀，单机成为了性能和容量的瓶颈。为了解决这个问题，有了分库分表技术。分库分表所要面临的第一个问题是：数据分布在不同机器上，数据库无法保证多个节点上产生的主键唯一。 这就需要用到分布式 ID 了，它起到了分布式系统中<strong>全局 ID</strong> 的作用。</p>
<p>:::</p>
<h3 id="【中级】有哪些生成分布式-ID-的方式？"><a href="#【中级】有哪些生成分布式-ID-的方式？" class="headerlink" title="【中级】有哪些生成分布式 ID 的方式？"></a>【中级】有哪些生成分布式 ID 的方式？</h3><p>:::details 要点</p>
<p>生成分布式 ID 主要有以下方式：</p>
<ul>
<li><strong>UUID</strong> - UUID 是通用唯一识别码（Universally Unique Identifier）的缩写，是一种 128 位的标识符，用 16 进制表示，需要 32 个字符。<strong>UUID 会根据运行应用的计算机网卡 MAC 地址、时间戳、命令空间等元素，通过一定的随机算法产生</strong>。<ul>
<li>UUID 存在 5 个版本。</li>
<li>UUID 不保证全局唯一性，我们需要小心 ID 冲突（尽管这种可能性很小）。</li>
<li><strong>优点</strong>：实现简单、生成速度较快（本地生成，不依赖其他服务）。</li>
<li><strong>缺点</strong>：无序、长度过长、不安全（基于 MAC 地址生成 UUID 的算法，可能会造成 MAC 地址泄露）。</li>
</ul>
</li>
<li><strong>数据库自增主键</strong> - 大多数数据库都支持自增主键。基于此特性，可以利用事务管理控制生成唯一 ID。<ul>
<li><strong>优点</strong>：实现简单、有序、长度较小</li>
<li><strong>缺点</strong>：性能差、存在单点问题、不安全（可以通过 ID 递增规律推算出数据量）</li>
</ul>
</li>
<li><strong>数据库号段</strong> - 一次批量生成一个 segment（号段），号段的大小由 step（步长）控制。用完之后再去数据库获取新的号段。</li>
<li><strong>原子计数器</strong> - 一些 NoSQL 数据库提供了原子性的计数器原子计数器 - 利用一些 NoSQL 数据库提供的原子性计数器，来实现分布式 ID。<ul>
<li><strong>Redis <code>incr</code> &#x2F; <code>incrby</code></strong> - Redis 的 String 类型提供 <code>INCR</code> 和 <code>INCRBY</code> 命令将 key 中储存的数字<strong>原子递增</strong>。<ul>
<li><strong>优点</strong>：高性能、有序</li>
<li><strong>缺点</strong>：和数据库自增序列方案的缺点类似</li>
</ul>
</li>
<li><strong>ZooKeeper 顺序节点</strong> - 利用 ZooKeeper 数据模型中的顺序节点作为分布式 ID。<ul>
<li><strong>优点</strong>：简单、可靠性高</li>
<li><strong>缺点</strong>：性能不高</li>
</ul>
</li>
</ul>
</li>
<li><strong>Snowflak（雪花算法）</strong> - Snowflake ID 生成过程包含多个组件：时间戳、机器 ID 和序列号。第一位未使用，以确保 ID 正确。此生成器不需要通过网络与 ID 生成器通信，因此速度快且可扩展。Snowflake 的实现各不相同。例如，可以将数据中心 ID 添加到“MachineID”组件中，以保证全局唯一性。</li>
</ul>
<p>:::</p>
<h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><h3 id="【初级】Cookie-和-Session-有什么区别？"><a href="#【初级】Cookie-和-Session-有什么区别？" class="headerlink" title="【初级】Cookie 和 Session 有什么区别？"></a>【初级】Cookie 和 Session 有什么区别？</h3><p>:::details 要点</p>
<p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p>
<p><strong>Cookie</strong> 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。生成 Cookie 后，用户后续每次请求都会携带 Cookie。</p>
<p>Cookie 通常有大小限制（4KB）。用户可以选择在浏览器中禁用 Cookie。</p>
<p>一个简单的 cookie 设置如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>&lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>Session 是在服务器端创建和存储的。服务器上通常会生成一个唯一的会话 ID（sessionId），sessionId 附加到特定的用户会话。sessionId 以 Cookie 的形式返回到客户端。Session 可以容纳大量数据。由于 Session 数据不直接由客户端访问，因此 Session 提供了更高的安全性。</p>
<p>Cookie 和 Session 的主要区别可以参考以下表格：</p>
<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用范围</strong></td>
<td>保存在客户端（浏览器）</td>
<td>保存在服务器端</td>
</tr>
<tr>
<td><strong>隐私策略</strong></td>
<td>存储在客户端，比较容易遭到非法获取</td>
<td>存储在服务端，安全性相对 Cookie 要好一些</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>只能保存 ASCII</td>
<td>可以保存任意数据类型。<br/>一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</td>
</tr>
<tr>
<td><strong>存储大小</strong></td>
<td>不能超过 4K</td>
<td>存储大小远高于 Cookie</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可设置为永久保存<br/>比如我们经常使用的默认登录（记住我）功能</td>
<td>一般失效时间较短<br/>客户端关闭或者 Session 超时都会失效。</td>
</tr>
</tbody></table>
<p>:::</p>
<h3 id="【中级】如果禁用了-Cookie-怎么办？"><a href="#【中级】如果禁用了-Cookie-怎么办？" class="headerlink" title="【中级】如果禁用了 Cookie 怎么办？"></a>【中级】如果禁用了 Cookie 怎么办？</h3><p>:::details 要点</p>
<p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<ul>
<li><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
</li>
<li><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
</li>
</ul>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<p>:::</p>
<h3 id="【中级】分布式-Session-有几种实现方案？"><a href="#【中级】分布式-Session-有几种实现方案？" class="headerlink" title="【中级】分布式 Session 有几种实现方案？"></a>【中级】分布式 Session 有几种实现方案？</h3><p>:::details 要点</p>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于缓存的 session 共享 ✅</li>
</ol>
<blockquote>
<p>推荐：基于缓存的 session 共享</p>
</blockquote>
<h4 id="粘性-Session"><a href="#粘性-Session" class="headerlink" title="粘性 Session"></a>粘性 Session</h4><p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：<strong>当服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>

<h4 id="Session-复制共享"><a href="#Session-复制共享" class="headerlink" title="Session 复制共享"></a>Session 复制共享</h4><p>Session 复制共享（Session Replication）<strong>在服务器节点之间进行 Session 同步操作</strong>，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>

<h4 id="基于缓存的-session-共享"><a href="#基于缓存的-session-共享" class="headerlink" title="基于缓存的 session 共享"></a>基于缓存的 session 共享</h4><p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>

<p>:::</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/"><strong>数据密集型应用系统设计</strong></a> - 这可能是目前最好的分布式存储书籍，强力推荐【进阶】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/62e44ef3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/62e44ef3/" class="post-title-link" itemprop="url">Dubbo 面试之架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-12 08:18:57" itemprop="dateCreated datePublished" datetime="2024-12-12T08:18:57+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo-面试之架构"><a href="#Dubbo-面试之架构" class="headerlink" title="Dubbo 面试之架构"></a>Dubbo 面试之架构</h1><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><h3 id="【简单】Dubbo-支持哪些序列化方式？"><a href="#【简单】Dubbo-支持哪些序列化方式？" class="headerlink" title="【简单】Dubbo 支持哪些序列化方式？"></a>【简单】Dubbo 支持哪些序列化方式？</h3><ul>
<li><strong>Hessian（默认）</strong><ul>
<li><strong>特点</strong>：二进制格式，速度较快，体积较小</li>
<li><strong>适用场景</strong>：通用 RPC 调用（Dubbo 默认方案）</li>
<li><strong>缺点</strong>：对复杂对象支持有限</li>
</ul>
</li>
<li><strong>JSON</strong><ul>
<li><strong>特点</strong>：文本格式，可读性强，跨语言支持好</li>
<li><strong>适用场景</strong>：前后端交互、多语言系统</li>
<li><strong>缺点</strong>：性能较差，数据体积大</li>
</ul>
</li>
<li><strong>Java 原生序列化</strong><ul>
<li><strong>特点</strong>：JDK 内置，使用简单</li>
<li><strong>适用场景</strong>：Java 单体应用调试</li>
<li><strong>缺点</strong>：性能差，体积大，仅限 Java</li>
</ul>
</li>
<li><strong>Kryo</strong><ul>
<li><strong>特点</strong>：高性能二进制，速度极快，体积小</li>
<li><strong>适用场景</strong>：高并发、低延迟场景</li>
<li><strong>缺点</strong>：API 复杂，需注册类</li>
</ul>
</li>
<li><strong>Protobuf（推荐）</strong><ul>
<li><strong>特点</strong>：Google 出品，高效跨语言，可扩展</li>
<li><strong>适用场景</strong>：微服务跨语言通信</li>
<li><strong>缺点</strong>：需预定义。proto 文件</li>
</ul>
</li>
<li><strong>FST</strong><ul>
<li><strong>特点</strong>：类似 Kryo，高性能二进制</li>
<li><strong>适用场景</strong>：替代 Hessian 的高性能需求</li>
<li><strong>缺点</strong>：兼容性较弱</li>
</ul>
</li>
</ul>
<p><strong>选型建议</strong></p>
<table>
<thead>
<tr>
<th>序列化方式</th>
<th>性能</th>
<th>体积</th>
<th>跨语言</th>
<th>易用性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Hessian</strong></td>
<td>中</td>
<td>小</td>
<td>部分</td>
<td>高</td>
<td>默认 RPC 调用</td>
</tr>
<tr>
<td><strong>JSON</strong></td>
<td>低</td>
<td>大</td>
<td>是</td>
<td>高</td>
<td>前后端交互</td>
</tr>
<tr>
<td><strong>Java</strong></td>
<td>低</td>
<td>大</td>
<td>否</td>
<td>高</td>
<td>调试&#x2F;兼容旧系统</td>
</tr>
<tr>
<td><strong>Kryo</strong></td>
<td>高</td>
<td>小</td>
<td>否</td>
<td>中</td>
<td>纯 Java 高性能场景</td>
</tr>
<tr>
<td><strong>Protobuf</strong></td>
<td>高</td>
<td>小</td>
<td>是</td>
<td>中</td>
<td>跨语言微服务（推荐）</td>
</tr>
<tr>
<td><strong>FST</strong></td>
<td>高</td>
<td>小</td>
<td>否</td>
<td>中</td>
<td>替代 Hessian 优化性能</td>
</tr>
</tbody></table>
<p><strong>推荐选择</strong></p>
<ul>
<li><strong>默认场景</strong> → Hessian</li>
<li><strong>跨语言微服务</strong> → Protobuf</li>
<li><strong>纯 Java 高性能</strong> → Kryo&#x2F;FST</li>
<li><strong>调试&#x2F;兼容</strong> → Java 原生</li>
<li><strong>前后端交互</strong> → JSON</li>
</ul>
<h3 id="【简单】Dubbo-支持哪些通信协议？"><a href="#【简单】Dubbo-支持哪些通信协议？" class="headerlink" title="【简单】Dubbo 支持哪些通信协议？"></a>【简单】Dubbo 支持哪些通信协议？</h3><p>Dubbo 框架提供了自定义的高性能 RPC 通信协议：基于 HTTP&#x2F;2 的 Triple 协议 和 基于 TCP 的 Dubbo2 协议。除此之外，Dubbo 框架支持任意第三方通信协议，如官方支持的 gRPC、Thrift、REST、JsonRPC、Hessian2 等，更多协议可以通过自定义扩展实现。这对于微服务实践中经常要处理的多协议通信场景非常有用。</p>
<p><strong>Dubbo 框架不绑定任何通信协议，在实现上 Dubbo 对多协议的支持也非常灵活，它可以让你在一个应用内发布多个使用不同协议的服务，并且支持用同一个 port 端口对外发布所有协议。</strong></p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/protocols/protocol1.png" alt="protocols"></p>
<p>Dubbo 官方支持的协议如下：</p>
<ul>
<li><strong>HTTP&#x2F;2 (Triple)</strong> - Dubbo3 新增，基于 HTTP&#x2F;2 并且完全兼容 gRPC 协议，原生支持 Streaming 通信语义，Triple 可同时运行在 HTTP&#x2F;1 和 HTTP&#x2F;2 传输协议之上，让你可以直接使用 curl、浏览器访问后端 Dubbo 服务。自 Triple 协议开始，Dubbo 还支持基于 Protocol Buffers 的服务定义与数据传输，但 Triple 实现并不绑定 IDL。Triple 具备更好的网关、代理穿透性，因此非常适合于跨网关、代理通信的部署架构，如服务网格等。更多详情见：Triple 协议详情见 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/tasks/protocols/triple/">Triple 协议开发任务</a>、<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/triple/">Triple 设计思路与协议规范</a>。</li>
<li><strong>Dubbo2</strong> - Dubbo2 协议是基于 TCP 传输层协议之上构建的一套 RPC 通信协议，具有紧凑、灵活、高性能等特点。它是 Dubbo 的默认通信协议，采用单一长连接和 NIO 异步通信，基于 hessian 作为序列化协议。Dubbo2 协议适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。Dubbo 协议详情见 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/tasks/protocols/dubbo/">Dubbo2 协议开发任务</a>、<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/tcp/">Dubbo2 设计思路与协议规范</a>。</li>
<li><strong>gRPC</strong> - gRPC 是谷歌开源的基于 HTTP&#x2F;2 的通信协议。gRPC 的定位是通信协议与实现，是一款纯粹的 RPC 框架，而 Dubbo 定位是一款微服务框架，为微服务实践提供解决方案。在 Dubbo 体系下使用 gRPC 协议是一个非常高效和轻量的选择，它让你既能使用原生的 gRPC 协议通信，又避免了基于 gRPC 进行二次定制与开发的复杂度。gRPC 协议详情见 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/tasks/protocols/grpc/">gRPC over Dubbo 示例</a>。</li>
<li><strong>REST</strong> - 微服务领域常用的一种通信模式是 HTTP + JSON，包括 Spring Cloud、Microprofile 等一些主流的微服务框架都默认使用的这种通信模式，Dubbo 同样提供了对基于 HTTP 的编程、通信模式的支持。REST 协议详情见 <a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/tasks/protocols/web/">HTTP over Dubbo 示例</a>、<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/tasks/protocols/springcloud/">Dubbo 与 Spring Cloud 体系互通</a>。</li>
<li><strong>Hessian</strong> - <a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/hessian.html">hessian</a> 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：<ul>
<li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li>
<li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li>
</ul>
</li>
<li><strong>Thrift</strong> - dubbo 支持的 <a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/thrift.html">thrift</a> 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码。</li>
</ul>
<p>扩展：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/core-features/protocols/">Dubbo 官方文档之通信协议</a></p>
<h3 id="【困难】动态代理在-Dubbo-中有哪些应用？"><a href="#【困难】动态代理在-Dubbo-中有哪些应用？" class="headerlink" title="【困难】动态代理在 Dubbo 中有哪些应用？"></a>【困难】动态代理在 Dubbo 中有哪些应用？</h3><p>Dubbo 广泛使用 <strong>动态代理</strong> 技术来实现 <strong>远程调用（RPC）</strong>、<strong>延迟加载（Lazy Loading）</strong> 和 <strong>AOP 增强（如负载均衡、容错等）</strong>，主要涉及 <strong>JDK 动态代理</strong> 和 <strong>CGLIB</strong> 两种方式。</p>
<p><strong>核心应用场景</strong></p>
<p><strong>（1）远程调用（RPC）</strong></p>
<p>Dubbo 的 <strong>核心 RPC 调用</strong> 依赖动态代理。<strong>消费者（Consumer）</strong> 调用服务时，Dubbo 生成一个 <strong>代理对象</strong>（<code>Proxy</code>），代理负责：</p>
<ul>
<li><strong>封装网络通信</strong>（序列化&#x2F;反序列化、TCP 传输）。</li>
<li><strong>负载均衡</strong>（从多个 Provider 中选择一个）。</li>
<li><strong>容错机制</strong>（失败重试、熔断降级）。</li>
</ul>
<p><strong>示例代码</strong>（消费者调用远程服务）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>  <span class="comment">// Dubbo 自动生成代理</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    orderService.create();  <span class="comment">// 实际调用的是代理对象，代理处理远程通信</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层实现</strong>：</p>
<ul>
<li>如果服务是 <strong>接口</strong> → 使用 <strong>JDK 动态代理</strong>（基于 <code>InvocationHandler</code>）。</li>
<li>如果服务是 <strong>类</strong>（无接口）→ 使用 <strong>CGLIB</strong> 生成子类代理。</li>
</ul>
<p><strong>（2）延迟加载（Lazy Loading）</strong></p>
<p>Dubbo 支持 <strong>懒初始化</strong>，即服务 <strong>首次调用时才实例化</strong>，减少启动时间。</p>
<ul>
<li><strong>代理拦截</strong>：Dubbo 返回代理对象，<strong>真正调用时才初始化真实服务</strong>。</li>
<li><strong>适用场景</strong>：初始化成本高的服务（如数据库连接、大数据计算）。</li>
</ul>
<p><strong>配置方式</strong>（XML&#x2F;注解）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.UserService&quot;</span> <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@org</span>.apache.dubbo.config.annotation.Service(lazy = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）AOP 增强（Filter 机制）</strong></p>
<p>Dubbo 的 <strong>Filter 链</strong>（如监控、日志、权限校验）基于动态代理实现：</p>
<ul>
<li><strong>代理包装真实服务</strong>，在调用前后插入逻辑（类似 Spring AOP）。</li>
<li><strong>示例</strong>：<ul>
<li><code>MonitorFilter</code>：统计调用耗时。</li>
<li><code>TokenFilter</code>：权限校验。</li>
</ul>
</li>
</ul>
<p><strong>实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before RPC call&quot;</span>);</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke(invocation);  <span class="comment">// 真实调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After RPC call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 会通过 <strong>代理机制</strong> 自动应用这些 Filter。</p>
<ol start="2">
<li>JDK 动态代理 vs. CGLIB</li>
</ol>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>JDK 动态代理</strong></th>
<th><strong>CGLIB</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用场景</strong></td>
<td>代理接口（如 Dubbo 的 <code>@Reference</code>）</td>
<td>代理类（无接口）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较快（基于反射）</td>
<td>略慢（生成子类）</td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td>无需额外库</td>
<td>需引入 <code>cglib</code> 依赖</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>Proxy.newProxyInstance()</code></td>
<td><code>Enhancer.create()</code></td>
</tr>
</tbody></table>
<p>Dubbo <strong>默认优先使用 JDK 动态代理</strong>，如果目标类没有接口，则降级为 CGLIB。</p>
<p><strong>动态代理的底层实现</strong></p>
<p><strong>（1）JDK 动态代理（接口代理）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (OrderService) Proxy.newProxyInstance(</span><br><span class="line">            OrderService.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;OrderService.class&#125;,</span><br><span class="line">            (proxyObj, method, args1) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟远程调用</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;Mock Result&quot;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        proxy.createOrder();  <span class="comment">// 调用代理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）CGLIB（类代理）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args1);</span><br><span class="line">            System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br><span class="line">        proxy.getUser();  <span class="comment">// 调用代理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>应用场景</strong></th>
<th><strong>动态代理的作用</strong></th>
<th><strong>实现方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>远程调用（RPC）</strong></td>
<td>封装网络通信、负载均衡、容错</td>
<td>JDK&#x2F;CGLIB</td>
</tr>
<tr>
<td><strong>延迟加载</strong></td>
<td>首次调用时才初始化服务</td>
<td>JDK&#x2F;CGLIB</td>
</tr>
<tr>
<td><strong>AOP（Filter）</strong></td>
<td>实现日志、监控、权限等增强逻辑</td>
<td>JDK&#x2F;CGLIB</td>
</tr>
</tbody></table>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="【中等】Dubbo-的工作原理是什么？"><a href="#【中等】Dubbo-的工作原理是什么？" class="headerlink" title="【中等】Dubbo 的工作原理是什么？"></a>【中等】Dubbo 的工作原理是什么？</h3><p>Dubbo 通过 <strong>注册中心解耦</strong> + <strong>动态代理透明化调用</strong> + <strong>集群容错保障可用性</strong>，实现高效 RPC 通信。</p>
<p><strong>核心架构</strong></p>
<ul>
<li><strong>Provider</strong>：暴露服务接口，注册到注册中心</li>
<li><strong>Consumer</strong>：从注册中心订阅服务，发起远程调用</li>
<li><strong>Registry</strong>：服务发现与元数据管理（如 Zookeeper&#x2F;Nacos）</li>
<li><strong>Monitor</strong> ：统计调用次数和耗时</li>
</ul>
<p><strong>调用流程</strong></p>
<ol>
<li><strong>服务注册</strong>：Provider 启动 → 注册服务到 Registry</li>
<li><strong>服务发现</strong>：Consumer 启动 → 从 Registry 订阅 Provider 列表</li>
<li><strong>远程调用</strong>：Consumer 通过 <strong>动态代理</strong> 发起调用 → 经负载均衡选择 Provider → 网络传输（Netty&#x2F;HTTP）</li>
<li><strong>结果返回</strong>：Provider 处理请求 → 返回结果给 Consumer</li>
</ol>
<p><strong>关键机制</strong></p>
<ul>
<li><strong>动态代理</strong>：生成接口代理类，屏蔽远程调用细节</li>
<li><strong>负载均衡</strong>：内置随机&#x2F;轮询&#x2F;最少活跃调用等算法</li>
<li><strong>集群容错</strong>：失败自动切换（Failover）&#x2F;快速失败（Failfast）等策略</li>
<li><strong>异步通信</strong>：基于 Netty 的 NIO 长连接，支持异步调用</li>
<li><strong>SPI 机制</strong>：可插拔式扩展（如替换注册中心&#x2F;协议）</li>
<li><strong>Filter 链</strong>：支持 AOP 式拦截（日志&#x2F;限流&#x2F;鉴权）</li>
</ul>
<p><strong>性能优化设计</strong></p>
<ul>
<li><strong>元数据缓存</strong>：Consumer 本地缓存 Provider 列表</li>
<li><strong>长连接复用</strong>：减少 TCP 握手开销</li>
<li><strong>线程池隔离</strong>：业务逻辑与 IO 线程分离</li>
</ul>
<h3 id="【简单】Dubbo-有哪些核心组件？"><a href="#【简单】Dubbo-有哪些核心组件？" class="headerlink" title="【简单】Dubbo 有哪些核心组件？"></a>【简单】Dubbo 有哪些核心组件？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png"></p>
<p>Dubbo 是一个高性能分布式服务框架，它有<strong>三个核心组件</strong>：</p>
<ul>
<li><strong>Provider</strong>：服务提供者。<ul>
<li>启动时，向注册中心注册自己提供的服务。</li>
<li>接收 Consumer 的远程调用请求并返回结果。</li>
</ul>
</li>
<li><strong>Consumer</strong>：服务消费者。<ul>
<li>启动时，向注册中心订阅自己所需的服务，获取 Provider 地址列表。</li>
<li>通过负载均衡策略选择 Provider 发起远程调用。</li>
</ul>
</li>
<li><strong>Registry</strong>：注册中心。<ul>
<li>负责服务的注册与发现（如 Zookeeper、Nacos）。</li>
<li>动态维护 Provider 和 Consumer 的映射关系。</li>
</ul>
</li>
</ul>
<p><strong>扩展组件</strong></p>
<ul>
<li><strong>Monitor</strong>：监控中心。统计服务调用次数、耗时、成功率等指标，便于运维和优化。</li>
<li><strong>Container</strong>：服务容器。管理服务生命周期（如 Spring 容器），提供依赖注入和环境支持。</li>
<li><strong>Protocol</strong>：通信协议。定义数据传输方式（如 Dubbo 协议、HTTP、REST），影响性能和兼容性。</li>
<li><strong>Cluster</strong>：集群容错。提供故障转移（Failover）、快速失败（Failfast）等机制，保障高可用。</li>
</ul>
<p><strong>重要知识点总结</strong></p>
<ul>
<li>注册中心负责服务地址的注册与查找，相当于元数据管理服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示。</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外。</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用。</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。</li>
</ul>
<h3 id="【困难】Dubbo-框架整体如何设计的？"><a href="#【困难】Dubbo-框架整体如何设计的？" class="headerlink" title="【困难】Dubbo 框架整体如何设计的？"></a>【困难】Dubbo 框架整体如何设计的？</h3><p>Dubbo 的整体设计原则如下：</p>
<ul>
<li>采用 Microkernel + Plugin 模式，Microkernel 只负责组装 Plugin，Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换。</li>
<li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。</li>
</ul>
<p>::: info 整体设计</p>
<p>:::</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1.jpg" alt="总设计图"></p>
<ul>
<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>
<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>
<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>
<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>
</ul>
<p>::: info 分层架构</p>
<p>:::</p>
<ul>
<li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>、<code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 Spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton，以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code>。</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>、<code>Registry</code>、<code>RegistryService</code>。</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>、<code>Directory</code>、<code>Router</code>、<code>LoadBalance</code>。</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>、<code>Monitor</code>、<code>MonitorService</code>。</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>、<code>Result</code> 为中心，扩展接口为 <code>Protocol</code>、<code>Invoker</code>、<code>Exporter</code>。</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>、<code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>、<code>ExchangeChannel</code>、<code>ExchangeClient</code>、<code>ExchangeServer</code>。</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>、<code>Transporter</code>、<code>Client</code>、<code>Server</code>、<code>Codec</code>。</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>、<code>ObjectInput</code>、<code>ObjectOutput</code>、<code>ThreadPool</code>。</li>
</ul>
<p>::: info 组件间的关系</p>
<p>:::</p>
<ul>
<li>在 RPC 中，**<code>Protocol</code> 是核心层，也就是只要有 <code>Protocol</code> + <code>Invoker</code> + <code>Exporter</code> 就可以完成非透明的 RPC 调用**，然后在 <code>Invoker</code> 的主过程上设置拦截点（Filter）。</li>
<li>图中的 <code>Consumer</code> 和 <code>Provider</code> 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 <code>Provider</code>、<code>Consumer</code>、Registry、<code>Monitor</code> 划分逻辑拓普节点，保持统一概念。</li>
<li>而 Cluster 是外围概念，所以 <strong>Cluster 的目的是将多个 Invoker 伪装成一个 Invoker</strong>，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>
<li><strong>Proxy 层封装了所有接口的透明化代理</strong>。在其它层都以 <code>Invoker</code> 为中心，只有到了暴露给用户使用时，才用 <code>Proxy</code> 将 <code>Invoker</code> 转成接口，或将接口实现转成 <code>Invoker</code>，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，<strong>Transport 层只负责单向消息传输</strong>，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 <strong>Exchange 层是在传输层之上封装了 Request-Response 语义</strong>。</li>
<li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>
</ul>
<p>::: info 核心组件交互</p>
<p>:::</p>
<p><img src="https://cn.dubbo.apache.org/imgs/dev/dubbo-relation.jpg" alt="依赖关系"></p>
<ul>
<li>图中小方块 Protocol, Cluster, Proxy, Service, Container, Registry, Monitor 代表层或模块，蓝色的表示与业务有交互，绿色的表示只对 Dubbo 内部交互。</li>
<li>图中背景方块 Consumer, Provider, Registry, Monitor 代表部署逻辑拓扑节点。</li>
<li>图中蓝色虚线为初始化时调用，红色虚线为运行时异步调用，红色实线为运行时同步调用。</li>
<li>图中只包含 RPC 的层，不包含 Remoting 的层，Remoting 整体都隐含在 Protocol 中。</li>
</ul>
<p>::: info 调用链路</p>
<p>:::</p>
<p>展开总设计图的红色调用链，如下：</p>
<p><img src="https://cn.dubbo.apache.org/imgs/dev/dubbo-extension.jpg" alt="总设计图的红色调用链"></p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/design/">Dubbo 框架设计</a></p>
</blockquote>
<h3 id="【中等】Dubbo-中用到哪些设计模式？"><a href="#【中等】Dubbo-中用到哪些设计模式？" class="headerlink" title="【中等】Dubbo 中用到哪些设计模式？"></a>【中等】Dubbo 中用到哪些设计模式？</h3><p><strong>单例模式</strong></p>
<p>Dubbo 中大量使用单例模式来确保一些特定类在整个应用中只有一个实例。举例来说，<code>ExtensionLoader</code> 是 Dubbo SPI 加载器，负责管理 Dubbo 中的扩展点。<code>ExtensionLoader</code> 使用了单例模式来确保 <code>ExtensionLoader</code> 在整个应用中只有一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>责任链模式</strong></p>
<p>Dubbo 的调用链是基于责任链模式组织起来的。责任链中的每个节点实现 <code>Filter</code> 接口，然后由 <code>ProtocolFilterWrapper</code> 将所有 <code>Filter</code> 串连起来。Dubbo 的许多功能都是通过 <code>Filter</code> 扩展实现的，比如监控、日志、缓存、安全等。</p>
<p><strong>装饰器模式</strong></p>
<p>Dubbo 中大量用到了修饰器模式。比如 <code>ProtocolFilterWrapper</code> 类是对 <code>Protocol</code> 类的修饰。在 <code>export</code> 和 <code>refer</code> 方法中，配合责任链模式，把 <code>Filter</code> 组装成责任链，实现对 <code>Protocol</code> 功能的修饰。其他还有 <code>ProtocolListenerWrapper</code>、 <code>ListenerInvokerWrapper</code>、<code>InvokerWrapper</code> 等。</p>
<p><strong>策略模式</strong></p>
<p>Dubbo 中的负载均衡器采用了策略模式，以便灵活的替换算法。在 Dubbo 中，<code>LoadBalance</code> 接口定义了负载均衡的策略接口，它有以下具体实现：<code>AdaptiveLoadBalance</code>、<code>ConsistentHashLoadBalance</code>、<code>LeastActiveLoadBalance</code>、<code>RandomLoadBalance</code>、<code>RoundRobinLoadBalance</code>、<code>ServerCpuLoadBalance2</code>、<code>ShortestResponseLoadBalance</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂模式</strong></p>
<p>Dubbo 中的 <code>ProxyFactory</code> 采用了<strong>抽象工厂模式</strong>。<code>AbstractProxyFactory</code> 实现了 <code>ProxyFactory</code> 接口，并且有 <code>JdkProxyFactory</code> 和 <code>JavassistProxyFactory</code> 两个子类，可以分别生产不同序列化方式的 <code>Proxy</code> 和 <code>Invoke</code>。</p>
<p><strong>代理模式</strong></p>
<p>Dubbo 使用代理模式隐藏远程调用的细节。<code>ProxyFactory</code> 接口及其实现类负责为服务创建代理对象，使得调用者无需关心实际的服务调用过程。</p>
<p><strong>适配器模式</strong></p>
<p>Dubbo 中 <code>RegistryProtocol</code> 类负责将不同的注册中心协议适配到统一的接口 <code>Protocol</code> 中，以便在不同的注册中心下工作。<code>RegistryProtocol</code> 通过适配不同的注册中心实现，使得 Dubbo 能够在多种注册中心协议下工作，而不必修改客户端代码。</p>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7126675470107541534#heading-24">长文详解：DUBBO 源码使用了哪些设计模式</a></p>
</blockquote>
<h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="【困难】Dubbo-如何保证服务的高可用性？"><a href="#【困难】Dubbo-如何保证服务的高可用性？" class="headerlink" title="【困难】Dubbo 如何保证服务的高可用性？"></a>【困难】Dubbo 如何保证服务的高可用性？</h3><p>Dubbo 高可用设计核心思想：</p>
<ul>
<li><strong>冗余</strong>：多注册中心、多服务节点</li>
<li><strong>故障检测</strong>：心跳检测 + 主动剔除</li>
<li><strong>容错处理</strong>：超时 + 重试 + 容错处理策略</li>
<li><strong>流量控制</strong>：限流 + 熔断 + 降级</li>
<li><strong>隔离</strong>：线程&#x2F;协议&#x2F;分组隔离避免连锁故障</li>
</ul>
<p>实际生产中需结合 <strong>压测</strong> 和 <strong>监控</strong> 持续调优参数（如超时时间、重试次数）。</p>
<p>Dubbo 通过 <strong>多级容错设计</strong> 确保服务高可用，主要依赖以下机制：</p>
<p><strong>注册中心容错</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>说明</strong></th>
<th><strong>配置示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>多注册中心</strong></td>
<td>同时接入多个注册中心（如 Zookeeper + Nacos），避免单点故障。</td>
<td><code>&lt;dubbo:registry address=&quot;zookeeper://ip1:2181,nacos://ip2:8848&quot; /&gt;</code></td>
</tr>
<tr>
<td><strong>心跳检测</strong></td>
<td>注册中心定时检测服务存活状态，自动剔除失效节点（默认 30 秒）。</td>
<td><code>&lt;dubbo:provider heartbeat=&quot;60000&quot; /&gt;</code></td>
</tr>
<tr>
<td><strong>本地缓存</strong></td>
<td>消费者缓存服务列表，即使注册中心宕机仍能调用服务。</td>
<td>默认启用，无需配置</td>
</tr>
</tbody></table>
<p><strong>服务调用容错</strong></p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>说明</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>集群容错</strong></td>
<td>- <code>failover</code>（默认）：失败自动切换其他节点<br>- <code>failfast</code>：快速失败<br>- <code>failsafe</code>：忽略异常</td>
<td><code>&lt;dubbo:reference cluster=&quot;failover&quot; retries=&quot;2&quot; /&gt;</code></td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>- <code>random</code>（默认随机）<br>- <code>roundrobin</code>（轮询）<br>- <code>leastactive</code>（最少活跃调用）</td>
<td><code>&lt;dubbo:reference loadbalance=&quot;leastactive&quot; /&gt;</code></td>
</tr>
<tr>
<td><strong>限流、熔断、降级</strong></td>
<td>集成 Sentinel&#x2F;Hystrix，在服务异常时触发熔断或返回降级结果。</td>
<td>需额外引入依赖并配置规则</td>
</tr>
</tbody></table>
<p><strong>通信容错</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>长连接复用</strong></td>
<td>默认复用 TCP 长连接，减少握手开销，通过心跳保活（<code>heartbeat</code> 参数控制）。</td>
</tr>
<tr>
<td><strong>多协议支持</strong></td>
<td>支持 Dubbo&#x2F;HTTP&#x2F;gRPC 等协议，根据网络环境选择最优协议。</td>
</tr>
<tr>
<td><strong>IO 线程隔离</strong></td>
<td>业务逻辑与网络 IO 线程分离，避免阻塞导致雪崩。</td>
</tr>
</tbody></table>
<p><strong>运维级保障</strong></p>
<table>
<thead>
<tr>
<th><strong>措施</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>灰度发布</strong></td>
<td>通过路由规则（如 <code>tag</code>）逐步切流，避免全量发布风险。</td>
</tr>
<tr>
<td><strong>压力测试</strong></td>
<td>使用 JMeter 模拟高并发，提前暴露性能瓶颈。</td>
</tr>
<tr>
<td><strong>日志监控</strong></td>
<td>对接 Prometheus + Grafana 监控 QPS&#x2F;RT&#x2F;错误率，实时告警。</td>
</tr>
</tbody></table>
<p><strong>典型配置示例</strong></p>
<p>服务提供者（超时与重试）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.UserService&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务消费者（熔断降级）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(version = &quot;1.0.0&quot;,</span></span><br><span class="line"><span class="meta">           timeout = 2000,</span></span><br><span class="line"><span class="meta">           cluster = &quot;failfast&quot;,</span></span><br><span class="line"><span class="meta">           mock = &quot;com.example.UserServiceMock&quot;)</span> <span class="comment">// 降级实现类</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>

<h2 id="性能优化设计"><a href="#性能优化设计" class="headerlink" title="性能优化设计"></a>性能优化设计</h2><h3 id="【困难】Dubbo-有哪些性能优化设计？"><a href="#【困难】Dubbo-有哪些性能优化设计？" class="headerlink" title="【困难】Dubbo 有哪些性能优化设计？"></a>【困难】Dubbo 有哪些性能优化设计？</h3><p>Dubbo 作为一款高性能的 Java RPC 框架，在性能优化方面做了许多设计，主要包括以下几个方面：</p>
<p><strong>通信</strong></p>
<ul>
<li><strong>Netty NIO 异步通信</strong>：默认使用 Netty 作为通信框架，基于 NIO 实现异步非阻塞通信。</li>
<li><strong>长连接复用</strong>：避免频繁建立和断开连接的开销。</li>
<li><strong>支持多种协议</strong>：（Dubbo2、Http2、Thrift等）</li>
<li><strong>序列化优化</strong>：<ul>
<li>支持多种高性能序列化协议（Hessian2、Kryo、FST、Protobuf等）</li>
<li>提供序列化缓存机制</li>
</ul>
</li>
</ul>
<p><strong>线程模型</strong></p>
<ul>
<li><strong>Dispatcher 线程派发策略</strong>：提供多种线程派发策略(all, direct, message, execution, connection)。</li>
<li><strong>线程池配置</strong>：可配置不同业务使用不同线程池，避免相互影响。</li>
<li><strong>IO线程与业务线程分离</strong>：Netty的IO线程只负责编解码，业务逻辑交给业务线程池。</li>
<li><strong>异步调用</strong>：使用<code>CompletableFuture</code>或回调避免线程阻塞，提升吞吐量。</li>
</ul>
<p><strong>路由与负载均衡</strong></p>
<ul>
<li><strong>支持多种负载均衡算法</strong>：随机(Random)、轮询(RoundRobin)、最少活跃(LeastActive)、一致性哈希(ConsistentHash)等，可以根据业务场景灵活选择。</li>
<li><strong>服务路由、分组</strong>：可以根据业务模块进行隔离</li>
<li><strong>服务预热</strong>：新上线的服务提供者逐步增加流量权重</li>
</ul>
<p><strong>其他优化</strong></p>
<ul>
<li><strong>流量控制</strong>：可以集成 Hystrix&#x2F;Sentinel，实现限流、熔断、降级。</li>
<li><strong>参数回调</strong>：支持参数级别的回调，减少不必要的数据传输</li>
<li><strong>本地存根</strong>：客户端生成服务存根，部分逻辑可在本地执行</li>
<li><strong>本地伪装</strong>：服务降级时返回本地Mock数据</li>
<li><strong>动态代理</strong>：支持 JDK 动态代理和 CGLIB 动态代理</li>
<li><strong>服务引用缓存</strong>：避免重复创建代理对象</li>
<li><strong>结果缓存</strong>：支持方法级结果缓存，减少重复调用</li>
</ul>
<h3 id="【中等】Dubbo-如何支持异步调用？"><a href="#【中等】Dubbo-如何支持异步调用？" class="headerlink" title="【中等】Dubbo 如何支持异步调用？"></a>【中等】Dubbo 如何支持异步调用？</h3><p>建议对耗时超过 100ms 的接口采用异步调用，同时做好超时控制和异常处理。</p>
<p><strong>不关心返回值异步调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务接口声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    CompletableFuture&lt;User&gt; <span class="title function_">getUserAsync</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者调用（自动识别Future返回类型）</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ...;</span><br><span class="line">CompletableFuture&lt;User&gt; future = userService.getUserAsync(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不阻塞主线程，继续其他操作</span></span><br></pre></td></tr></table></figure>

<p><strong>关心返回值异步调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启异步模式（需配置）</span></span><br><span class="line">RpcContext.getContext().setAttachment(<span class="string">&quot;async&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起调用（立即返回null）</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ...;</span><br><span class="line">userService.getUser(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Future对象</span></span><br><span class="line">Future&lt;User&gt; future = RpcContext.getContext().getFuture();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调</span></span><br><span class="line">future.whenComplete((user, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注解配置方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务提供方接口定义</span></span><br><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@AsyncFor(interfaceClass = OrderService.class)</span></span><br><span class="line">    CompletableFuture&lt;Order&gt; <span class="title function_">createOrderAsync</span><span class="params">(OrderReq req)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置注意事项</strong></p>
<p>服务端配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">threadpool</span>=<span class="string">&quot;cached&quot;</span> <span class="attr">threads</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">async</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>性能调优参数：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步线程池配置</span></span><br><span class="line"><span class="attr">dubbo.consumer.threadpool</span>=<span class="string">fixed</span></span><br><span class="line"><span class="attr">dubbo.consumer.threads</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>

<p><strong>关键特性对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>同步调用</th>
<th>异步调用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用方式</strong></td>
<td>阻塞等待返回结果</td>
<td>立即返回 Future 对象</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>吞吐量较低</td>
<td>高吞吐量</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>短耗时接口</td>
<td>长耗时&#x2F;高并发接口</td>
</tr>
</tbody></table>
<p><strong>实现原理</strong></p>
<ul>
<li>基于 Netty 的 NIO 非阻塞通信</li>
<li>消费方发起请求后立即返回 Future</li>
<li>服务方处理完成后通过回调通知结果</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>高并发且响应时间较长的服务</li>
<li>需要并行调用多个服务的场景</li>
<li>不要求严格顺序执行的业务逻辑</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>异步方法需返回<code>CompletableFuture</code>类型</li>
<li>避免在回调中执行阻塞操作</li>
<li>超时时间需合理设置（建议比同步调用略长）</li>
</ul>
<h3 id="【困难】Dubbo-中的线程模型是如何设计的？"><a href="#【困难】Dubbo-中的线程模型是如何设计的？" class="headerlink" title="【困难】Dubbo 中的线程模型是如何设计的？"></a>【困难】Dubbo 中的线程模型是如何设计的？</h3><p>:::info Consumer 线程模型</p>
<p>:::</p>
<p>对 2.7.5 版本之前的 Dubbo 应用，尤其是一些消费端应用，当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题，具体问题讨论可参见 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/issues/2013">Need a limited Threadpool in consumer side #2013</a></p>
<p>改进后的消费端线程池模型，通过复用业务端被阻塞的线程，很好的解决了这个问题。</p>
<p><strong>老的线程池模型</strong></p>
<p><img src="https://cn.dubbo.apache.org/imgs/user/consumer-threadpool0.png" alt="消费端线程池.png"></p>
<p>我们重点关注 Consumer 部分：</p>
<ol>
<li>业务线程发出请求，拿到一个 <code>Future</code> 实例。</li>
<li>业务线程紧接着调用 <code>future.get</code> 阻塞等待业务结果返回。</li>
<li>当业务数据返回后，交由独立的 <code>Consumer</code> 端线程池进行反序列化等处理，并调用 <code>future.set</code> 将反序列化后的业务结果置回。</li>
<li>业务线程拿到结果直接返回</li>
</ol>
<p><strong>当前线程池模型</strong></p>
<p><img src="https://cn.dubbo.apache.org/imgs/user/consumer-threadpool1.png" alt="消费端线程池新.png"></p>
<ol>
<li>业务线程发出请求，拿到一个 <code>Future</code> 实例。</li>
<li>在调用 <code>future.get()</code> 之前，先调用 <code>ThreadlessExecutor.wait()</code>，<code>wait</code> 会使业务线程在一个阻塞队列上等待，直到队列中被加入元素。</li>
<li>当业务数据返回后，生成一个 <code>Runnable Task</code> 并放入 <code>ThreadlessExecutor</code> 队列</li>
<li>业务线程将 <code>Task</code> 取出并在本线程中执行：反序列化业务数据并 <code>set</code> 到 <code>Future</code>。</li>
<li>业务线程拿到结果直接返回</li>
</ol>
<p>这样，相比于老的线程池模型，由业务线程自己负责监测并解析返回结果，免去了额外的消费端线程池开销。</p>
<p>:::info Provider 线程模型</p>
<p>:::</p>
<p>Dubbo 协议的和 Triple 协议目前的线程模型还并没有对齐。</p>
<p>Dubbo 对 channel 上的操作抽象成了五种行为：</p>
<ul>
<li><strong>建立连接（connected）</strong> - 主要是的职责是在 channel 记录 read、write 的时间，以及处理建立连接后的回调逻辑，比如 dubbo 支持在断开后自定义回调的 hook（onconnect），即在该操作中执行。</li>
<li><strong>断开连接（disconnected）</strong> - 主要是的职责是在 channel 移除 read、write 的时间，以及处理端开连接后的回调逻辑，比如 dubbo 支持在断开后自定义回调的 hook（ondisconnect），即在该操作中执行。</li>
<li><strong>发送消息（sent）</strong> - 包括发送请求和发送响应。记录 write 的时间。</li>
<li><strong>接收消息（received）</strong> - 包括接收请求和接收响应。记录 read 的时间。</li>
<li><strong>异常捕获（caught）</strong> - 用于处理在 channel 上发生的各类异常。</li>
</ul>
<p>Dubbo 框架的线程模型与以上这五种行为息息相关，Dubbo 协议 Provider 线程模型可以分为五类，也就是 AllDispatcher、DirectDispatcher、MessageOnlyDispatcher、ExecutionDispatcher、ConnectionOrderedDispatcher。</p>
<p><strong>All Dispatcher</strong></p>
<p>所有消息都派发到 Dubbo 线程池。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/performance/threading-model/dubbo-provider-alldispatcher.png" alt="dubbo-provider-alldispatcher"></p>
<p>在 IO 线程中执行的操作有：</p>
<ol>
<li><code>sent</code> 操作在 IO 线程上执行。</li>
<li>序列化响应在 IO 线程上执行。</li>
</ol>
<p>在 Dubbo 线程中执行的操作有：</p>
<ol>
<li><code>received</code>、<code>connected</code>、<code>disconnected</code>、<code>caught</code> 都是在 Dubbo 线程上执行的。</li>
<li>反序列化请求的行为在 Dubbo 中做的。</li>
</ol>
<p><strong>Direct Dispatcher</strong></p>
<p>所有消息都不派发到 Dubbo 线程池，全部在 IO 线程上直接执行。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/performance/threading-model/dubbo-provider-directDispatcher.png" alt="dubbo-provider-directDispatcher"></p>
<p>在 IO 线程中执行的操作有：</p>
<ol>
<li><code>received</code>、<code>connected</code>、<code>disconnected</code>、<code>caught</code>、<code>sent</code> 操作在 IO 线程上执行。</li>
<li>反序列化请求和序列化响应在 IO 线程上执行。</li>
</ol>
<p>并没有在 Dubbo 线程操作的行为。</p>
<p><strong>Execution Dispatcher</strong></p>
<p>只有请求消息派发到 Dubbo 线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/performance/threading-model/dubbo-provider-executionDispatcher.png" alt="dubbo-provider-ExecutionDispatcher"></p>
<p>在 IO 线程中执行的操作有：</p>
<ol>
<li><code>sent</code>、<code>connected</code>、<code>disconnected</code>、<code>caught</code> 操作在 IO 线程上执行。</li>
<li>序列化响应在 IO 线程上执行。</li>
</ol>
<p>在 Dubbo 线程中执行的操作有：</p>
<ol>
<li><code>received</code> 都是在 Dubbo 线程上执行的。</li>
<li>反序列化请求的行为在 Dubbo 中做的。</li>
</ol>
<p><strong>Message Only Dispatcher</strong></p>
<p>在 Provider 端，Message Only Dispatcher 和 Execution Dispatcher 的线程模型是一致的，所以下图和 Execution Dispatcher 的图一致，区别在 Consumer 端。见下方 Consumer 端的线程模型。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/performance/threading-model/dubbo-provider-executionDispatcher.png" alt="dubbo-provider-ExecutionDispatcher"></p>
<p>在 IO 线程中执行的操作有：</p>
<ol>
<li><code>sent</code>、<code>connected</code>、<code>disconnected</code>、<code>caught</code> 操作在 IO 线程上执行。</li>
<li>序列化响应在 IO 线程上执行。</li>
</ol>
<p>在 Dubbo 线程中执行的操作有：</p>
<ol>
<li><code>received</code> 都是在 Dubbo 线程上执行的。</li>
<li>反序列化请求的行为在 Dubbo 中做的。</li>
</ol>
<p><strong>Connection Ordered Dispatcher</strong></p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/performance/threading-model/dubbbo-provider-connectionOrderedDispatcher.png" alt="dubbbo-provider-connectionOrderedDispatcher"></p>
<p>在 IO 线程中执行的操作有：</p>
<ol>
<li><code>sent</code> 操作在 IO 线程上执行。</li>
<li>序列化响应在 IO 线程上执行。</li>
</ol>
<p>在 Dubbo 线程中执行的操作有：</p>
<ol>
<li><code>received</code>、<code>connected</code>、<code>disconnected</code>、<code>caught</code> 都是在 Dubbo 线程上执行的。但是 <code>connected</code> 和 <code>disconnected</code> 两个行为是与其他两个行为通过线程池隔离开的。并且在 Dubbo connected thread pool 中提供了链接限制、告警灯能力。</li>
<li>反序列化请求的行为在 Dubbo 中做的。</li>
</ol>
<h3 id="【中等】Dubbo-中的连接数过多如何处理？"><a href="#【中等】Dubbo-中的连接数过多如何处理？" class="headerlink" title="【中等】Dubbo 中的连接数过多如何处理？"></a>【中等】Dubbo 中的连接数过多如何处理？</h3><p><strong>核心优化手段</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>配置示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>限制最大连接数</strong></td>
<td><code>&lt;dubbo:protocol accepts=&quot;100&quot;/&gt;</code></td>
<td>防止服务端过载</td>
</tr>
<tr>
<td><strong>共享连接池</strong></td>
<td><code>&lt;dubbo:protocol threadpool=&quot;cached&quot;/&gt;</code></td>
<td>提高连接复用率</td>
</tr>
<tr>
<td><strong>连接数控制</strong></td>
<td><code>&lt;dubbo:reference connections=&quot;10&quot;/&gt;</code></td>
<td>限制单服务连接数</td>
</tr>
<tr>
<td><strong>超时设置</strong></td>
<td><code>&lt;dubbo:reference timeout=&quot;3000&quot;/&gt;</code></td>
<td>避免僵死连接</td>
</tr>
<tr>
<td><strong>重试策略</strong></td>
<td><code>&lt;dubbo:reference retries=&quot;2&quot;/&gt;</code></td>
<td>控制失败重试次数</td>
</tr>
</tbody></table>
<p><strong>关键配置详解</strong></p>
<p>（1）<strong>服务端配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 限制单服务最大连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> <span class="attr">accepts</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置 IO 线程数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">threads</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）<strong>客户端配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 限制单服务连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.xx.Service&quot;</span> <span class="attr">connections</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置连接超时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">timeout</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>高级优化方案</strong></p>
<ul>
<li><p><strong>连接池选择</strong></p>
<ul>
<li>默认使用 Netty 连接池</li>
<li>可集成第三方连接池（如 HikariCP）</li>
</ul>
</li>
<li><p><strong>动态调整策略</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时动态调整连接数</span></span><br><span class="line">ReferenceConfig.cacheConnections(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>熔断保护</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failfast&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>监控与治理</strong></p>
<table>
<thead>
<tr>
<th>工具</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dubbo-Admin</strong></td>
<td>实时监控连接数</td>
</tr>
<tr>
<td><strong>Prometheus+Grafana</strong></td>
<td>可视化监控</td>
</tr>
<tr>
<td><strong>Skywalking</strong></td>
<td>调用链分析</td>
</tr>
</tbody></table>
<p><strong>最佳实践建议</strong></p>
<ul>
<li><p><strong>生产环境配置</strong></p>
<ul>
<li>服务端 accepts&#x3D;CPU 核心数、*2</li>
<li>客户端 connections&#x3D;2~5</li>
<li>超时时间≥3000ms</li>
</ul>
</li>
<li><p><strong>异常处理</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    service.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e.isTimeout()) &#123;</span><br><span class="line">        <span class="comment">// 超时处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>压测建议</strong><ul>
<li>使用 JMeter 模拟高并发</li>
<li>逐步增加连接数观察性能拐点</li>
</ul>
</li>
</ul>
<p><strong>典型问题排查流程</strong>：</p>
<ol>
<li>监控发现连接数异常</li>
<li>分析调用链路定位问题服务</li>
<li>调整连接池参数</li>
<li>增加服务实例水平扩展</li>
</ol>
<h3 id="【困难】Dubbo-中的时钟轮机制是如何设计的？"><a href="#【困难】Dubbo-中的时钟轮机制是如何设计的？" class="headerlink" title="【困难】Dubbo 中的时钟轮机制是如何设计的？"></a>【困难】Dubbo 中的时钟轮机制是如何设计的？</h3><p>::: info JDK 中定时任务的实现</p>
<p>:::</p>
<p>在很多开源框架中，都需要定时任务的管理功能，例如 ZooKeeper、Netty、Quartz、Kafka 以及 Linux 操作系统。</p>
<p>定时器的本质是设计一种数据结构，能够存储和调度任务集合，而且 deadline 越近的任务拥有更高的优先级。那么定时器如何知道一个任务是否到期了呢？定时器需要通过轮询的方式来实现，每隔一个时间片去检查任务是否到期。</p>
<p>所以定时器的内部结构一般需要一个任务队列和一个异步轮询线程，并且能够提供三种基本操作：</p>
<ul>
<li>Schedule 新增任务至任务集合；</li>
<li>Cancel 取消某个任务；</li>
<li>Run 执行到期的任务。</li>
</ul>
<p>JDK 原生提供了三种常用的定时器实现方式，分别为 <code>Timer</code>、<code>DelayedQueue</code> 和 <code>ScheduledThreadPoolExecutor</code>。</p>
<p>JDK 内置的三种实现定时器的方式，实现思路都非常相似，都离不开<strong>任务</strong>、<strong>任务管理</strong>、<strong>任务调度</strong>三个角色。三种定时器新增和取消任务的时间复杂度都是 <code>O(logn)</code>，面对海量任务插入和删除的场景，这三种定时器都会遇到比较严重的性能瓶颈。</p>
<p><strong>对于性能要求较高的场景，一般都会采用时间轮算法来实现定时器</strong>。时间轮（Timing Wheel）是 George Varghese 和 Tony Lauck 在 1996 年的论文 <a target="_blank" rel="noopener" href="https://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a> 实现的，它在 Linux 内核中使用广泛，是 Linux 内核定时器的实现方法和基础之一。</p>
<p>::: info 时间轮的基本原理</p>
<p>:::</p>
<p><strong>时间轮是一种高效的、批量管理定时任务的调度模型</strong>。时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/assets/CgpVE1_okKiAGl0gAAMLshtTq-M933.png" alt="图片 22.png"></p>
<p>任务是如何添加到时间轮当中的呢？可以根据任务的到期时间进行取模，然后将任务分布到不同的 slot 中。如上图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 <code>2+3=5</code> 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 <code>(2+12)%8=6</code> 个 slot。</p>
<p>那么当时针走到第 6 个 slot 时，怎么区分每个任务是否需要立即执行，还是需要等待下一圈，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round&#x3D;0，需要立即执行；第二个任务 round&#x3D;1，需要等待 <code>1*8=8s</code> 后执行；第三个任务 round&#x3D;2，需要等待 <code>2*8=8s</code> 后执行。所以当时针转动到对应 slot 时，只执行 round&#x3D;0 的任务，slot 中其余任务的 round 应当减 1，等待下一个 round 之后执行。</p>
<p>上面介绍了时间轮算法的基本理论，可以看出时间轮有点类似 HashMap，如果多个任务如果对应同一个 slot，处理冲突的方法采用的是拉链法。在任务数量比较多的场景下，适当增加时间轮的 slot 数量，可以减少时针转动时遍历的任务个数。</p>
<p>时间轮定时器最大的优势就是，任务的新增和取消都是 <code>O(1)</code> 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。</p>
<p>::: info Dubbo 中的时间轮</p>
<p>:::</p>
<p><code>org.apache.dubbo.common.timer.HashedWheelTimer</code> 是 Dubbo 中时间轮的算法实现。它主要应用于以下方面：</p>
<ul>
<li><strong>失败重试，</strong> 例如，Provider 向注册中心进行注册失败时的重试操作，或是 Consumer 向注册中心订阅时的失败重试等。</li>
<li><strong>周期性定时任务，</strong> 例如，定期发送心跳请求，请求超时的处理，或是网络连接断开后的重连机制。</li>
</ul>
<h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><h3 id="【困难】Dubbo-架构是如何实现高度可扩展的？"><a href="#【困难】Dubbo-架构是如何实现高度可扩展的？" class="headerlink" title="【困难】Dubbo 架构是如何实现高度可扩展的？"></a>【困难】Dubbo 架构是如何实现高度可扩展的？</h3><p>::: info 微内核+插件架构</p>
<p>:::</p>
<p>Dubbo 的架构设计采用<strong>微内核+插件</strong>架构，高度支持可扩展。</p>
<p>基于扩展点，用户完全可以基于自身需求，替换 Dubbo 原生实现，来满足自身业务需求。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/advantages/extensibility.png" alt="Admin 效果图"></p>
<ul>
<li><strong>协议与编码扩展</strong>。通信协议、序列化编码协议等</li>
<li><strong>流量管控扩展</strong>。集群容错策略、路由规则、负载均衡、限流降级、熔断策略等</li>
<li><strong>服务治理扩展</strong>。注册中心、配置中心、元数据中心、分布式事务、全链路追踪、监控系统等</li>
<li><strong>诊断与调优扩展</strong>。流量统计、线程池策略、日志、QoS 运维命令、健康检查、配置加载等</li>
</ul>
<p>::: info 基于扩展的生态</p>
<p>:::</p>
<p>Dubbo 调用链路中几乎所有核心节点都被定义为扩展点。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/extensibility/arc.png" alt="extensibility-echosystem.png"></p>
<p>以上是按架构层次划分的 Dubbo 内的一些核心扩展点定义及实现，可以从三个层次来展开：</p>
<p><strong>（1）协议通信层</strong></p>
<ul>
<li><strong>Protocol</strong> - Protocol 定义了 RPC 协议，利用这个扩展点可以实现灵活切换通信协议。Dubbo 官方提供了 Triple、gRPC、Dubbo2、REST 等 RPC 协议。</li>
<li><strong>Serialization</strong> - Serialization 定义了序列化协议，利用这个扩展点可以实现灵活切换序列化协议。Dubbo 官方提供了 Fastjson、Protobuf、Hessian2、Kryo、FST 等序列化协议。</li>
</ul>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/extensibility/protocol.png" alt="协议与编码原理图"></p>
<p><strong>（2）流量管控层</strong></p>
<p>Dubbo 在服务调用链路上预置了大量扩展点，通过这些扩展点用户可以控制运行态的流量走向、改变运行时调用行为等，包括 Dubbo 内置的一些负载均衡策略、流量路由策略、超时等很多流量管控能力都是通过这类扩展点实现的。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/feature/extensibility/traffic.png" alt="协议与编码原理图"></p>
<ul>
<li><strong>Filter</strong> - Filter 流量拦截器是 Dubbo 服务调用之上的 AOP 设计模式，Filter 用来对每次服务调用做一些预处理、后处理动作，使用 Filter 可以完成访问日志、加解密、流量统计、参数验证等任务，Dubbo 中的很多生态适配如限流降级 Sentinel、全链路追踪 Tracing 等都是通过 Fitler 扩展实现的。Filter 以链式串联工作，彼此独立。<ul>
<li>从消费端视角，它在请求发起前基于请求参数等做一些预处理工作，在接收到响应后，对响应结果做一些后置处理；</li>
<li>从提供者视角则，在接收到访问请求后，在返回响应结果前做一些预处理，</li>
</ul>
</li>
<li><strong>Router</strong> - Router 将符合一定条件的流量转发到特定分组的地址子集，是 Dubbo 中一些关键能力如按比例流量转发、流量隔离等的基础。每次服务调用请求都会流经一组路由器 （路由链），每个路由器根据预先设定好的规则、全量地址列表以及当前请求上下文计算出一个地址子集，再传给下一个路由器，重复这一过程直到最后得出一个有效的地址子集。</li>
<li><strong>Load Balance</strong> - 在 Dubbo 中，Load Balance 负载均衡工作在 Router 之后，对于每次服务调用，负载均衡负责在 Router 链输出的地址子集中选择一台机器实例进行访问，保证一段时间内的调用都均匀的分布在地址子集的所有机器上。Dubbo 官方提供了加权随机、加权轮询、一致性哈希、最小活跃度优先、最短响应时间优先等负载均衡策略，还提供了根据集群负载自适应调度的负载均衡算法。</li>
</ul>
<p><strong>（3）服务治理层</strong></p>
<p>Dubbo3 由注册中心 （服务发现）、配置中心和元数据中心构成了整个服务治理的核心。</p>
<p><img src="https://cn.dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="服务治理架构图"></p>
<p>Dubbo 很多服务治理的核心能力都是通过上图描述的几个关键组件实现的。用户通过控制面或者 Admin 下发的各种规则与配置、各类微服务集群状态的展示等都是直接与注册中心、配置中心和元数据中心交互。在具体实现或者部署上，注册中心、配置中心和元数据中心可以是同一组件，比如 Zookeeper 可同时作为注册、配置和元数据中心，Nacos 也是如此。因此，三个中心只是从架构职责上的划分，你甚至可以用同一个 Zookeeper 集群来承担所有三个职责，只需要在应用里将他们设置为同一个集群地址就可以了。</p>
<ul>
<li><strong>Registry</strong> - <strong>注册中心是 Dubbo 实现服务发现能力的基础</strong>。Dubbo 官方支持 Zookeeper、Nacos、Etcd、Consul、Eureka 等注册中心。通过对 Consul、Eureka 的支持，Dubbo 也实现了与 Spring Cloud 体系在地址和通信层面的互通，让用户同时部署 Dubbo 与 Spring Cloud，或者从 Spring Cloud 迁移到 Dubbo 变得更容易。</li>
<li><strong>Config Center</strong> - <strong>配置中心是用户实现动态控制 Dubbo 行为的关键组件</strong>。Dubbo 所有的路由规则，都是先下发到配置中心保存起来，进而 Dubbo 实例通过监听配置中心的变化，收到路由规则并达到控制流量的行为。Dubbo 官方支持 Zookeeper、Nacos、Etcd、Redis、Apollo 等配置中心实现。</li>
<li><strong>Metadata Center</strong> - 与配置中心相反，从用户视角来看元数据中心是只读的，元数据中心唯一的写入方是 Dubbo 进程实例，Dubbo 实例会在启动之后将一些内部状态（如服务列表、服务配置、服务定义格式等）上报到元数据中心，供一些治理能力作为数据来源，如服务测试、文档管理、服务状态展示等。Dubbo 官方支持 Zookeeper、Nacos、Etcd、Redis 等元数据中心实现。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/core-features/extensibility/">Dubbo 官方文档之扩展适配</a></p>
</blockquote>
<h3 id="【中等】如何自定义一个-Dubbo-的-SPI-扩展？"><a href="#【中等】如何自定义一个-Dubbo-的-SPI-扩展？" class="headerlink" title="【中等】如何自定义一个 Dubbo 的 SPI 扩展？"></a>【中等】如何自定义一个 Dubbo 的 SPI 扩展？</h3><p><strong>核心开发步骤</strong></p>
<p>（1）<strong>定义SPI接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;default&quot;)</span>  <span class="comment">// 指定默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFilter</span> &#123;</span><br><span class="line">    Result <span class="title function_">filter</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>实现扩展类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">MyFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">filter</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>注册扩展实现</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--</span> <span class="string">文件位置：META-INF/dubbo/com.xxx.MyFilter</span></span><br><span class="line"><span class="attr">log</span>=<span class="string">com.xxx.LogFilter</span></span><br><span class="line"><span class="attr">cache</span>=<span class="string">com.xxx.CacheFilter</span></span><br></pre></td></tr></table></figure>

<p>（4）<strong>加载使用扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFilter</span> <span class="variable">filter</span> <span class="operator">=</span> ExtensionLoader</span><br><span class="line">    .getExtensionLoader(MyFilter.class)</span><br><span class="line">    .getExtension(<span class="string">&quot;log&quot;</span>);  <span class="comment">// 指定扩展名</span></span><br></pre></td></tr></table></figure>

<p><strong>高级特性</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>实现方式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自适应扩展</strong></td>
<td><code>@Adaptive</code>注解方法&#x2F;类</td>
<td>运行时动态选择实现</td>
</tr>
<tr>
<td><strong>自动激活</strong></td>
<td><code>@Activate(group=&#123;&quot;provider&quot;&#125;, order=1)</code></td>
<td>根据条件自动激活扩展</td>
</tr>
<tr>
<td><strong>Wrapper类</strong></td>
<td>实现类构造函数包含扩展接口参数</td>
<td>AOP增强</td>
</tr>
</tbody></table>
<p><strong>关键注解详解</strong></p>
<ul>
<li><strong>@SPI</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span>  <span class="comment">// 默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    Server <span class="title function_">bind</span><span class="params">(URL url, ChannelHandler handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Adaptive</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法级适配</span></span><br><span class="line"><span class="meta">@Adaptive(&quot;transport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    Server <span class="title function_">bind</span><span class="params">(URL url, ChannelHandler handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Activate</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &quot;consumer&quot;, order = 100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// 消费者端自动激活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型扩展点</strong></p>
<ul>
<li><strong>协议扩展</strong> (<code>Protocol</code>)</li>
<li><strong>过滤器扩展</strong> (<code>Filter</code>)</li>
<li><strong>负载均衡扩展</strong> (<code>LoadBalance</code>)</li>
<li><strong>序列化扩展</strong> (<code>Serialization</code>)</li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li><p><strong>配置建议</strong></p>
<ul>
<li>扩展点命名全小写，多个单词用<code>.</code>分隔</li>
<li>每个扩展点单独建立配置文件</li>
</ul>
</li>
<li><p><strong>调试技巧</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看所有已注册扩展</span></span><br><span class="line">Set&lt;String&gt; exts = ExtensionLoader</span><br><span class="line">    .getExtensionLoader(MyFilter.class)</span><br><span class="line">    .getSupportedExtensions();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意事项</strong><ul>
<li>避免扩展类循环依赖</li>
<li>线程安全需自行保证</li>
<li>生产环境建议禁用动态编译（<code>-Ddubbo.compiler.disable=true</code>）</li>
</ul>
</li>
</ul>
<p><strong>示例项目结构</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src</span></span><br><span class="line">├── <span class="selector-tag">main</span></span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── xxx</span><br><span class="line">│   │           ├── MyFilter<span class="selector-class">.java</span></span><br><span class="line">│   │           └── <span class="attribute">filter</span></span><br><span class="line">│   │               ├── LogFilter<span class="selector-class">.java</span></span><br><span class="line">│   │               └── CacheFilter<span class="selector-class">.java</span></span><br><span class="line">│   └── resources</span><br><span class="line">│       └── META-INF</span><br><span class="line">│           └── dubbo</span><br><span class="line">│               └── com<span class="selector-class">.xxx</span>.MyFilter</span><br></pre></td></tr></table></figure>

<h3 id="【困难】Dubbo-的-SPI-机制是如何设计的？"><a href="#【困难】Dubbo-的-SPI-机制是如何设计的？" class="headerlink" title="【困难】Dubbo 的 SPI 机制是如何设计的？"></a>【困难】Dubbo 的 SPI 机制是如何设计的？</h3><p><strong>SPI</strong> 全称 Service Provider Interface，<strong>旨在由第三方实现或扩展的 API，它是一种用于动态加载服务的机制</strong>。SPI 的本质是<strong>将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类</strong>。这样可以在运行时，动态为接口替换实现类。</p>
<p>Java 中提供了 SPI 机制，但是由于存在一些不足，Dubbo 自行实现了一套 Dubbo SPI 机制。</p>
<p>::: info Java SPI</p>
<p>:::</p>
<p>Java 中 SPI 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
<p>Java SPI 有四个要素：</p>
<ul>
<li><strong>SPI 接口</strong>：为服务提供者实现类约定的的接口或抽象类。</li>
<li><strong>SPI 实现类</strong>：实际提供服务的实现类。</li>
<li><strong>SPI 配置</strong>：Java SPI 机制约定的配置文件，提供查找服务实现类的逻辑。配置文件必须置于 <code>META-INF/services</code> 目录中，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称。</li>
<li>**<code>ServiceLoader</code>**：Java SPI 的核心类，用于加载 SPI 实现类。 <code>ServiceLoader</code> 中有各种实用方法来获取特定实现、迭代它们或重新加载服务。</li>
</ul>
<p>Java SPI 存在一些不足：</p>
<ul>
<li><strong>不能按需加载</strong>，需要遍历所有的实现并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，<strong>只能通过 <code>Iterator</code> 形式获取</strong>，不能根据某个参数来获取对应的实现类。</li>
<li>并发多线程使用 <code>ServiceLoader</code> 类的实例是<strong>不安全</strong>的。</li>
</ul>
<p>::: info Dubbo SPI</p>
<p>:::</p>
<p>正是有 Java SPI 存在以上不足点，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。</p>
<p>Dubbo SPI 所需的配置文件需放置在 <code>META-INF/dubbo</code> 路径下。配置内容形式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optimusPrime</span> = <span class="string">org.apache.spi.OptimusPrime</span></span><br><span class="line"><span class="attr">bumblebee</span> = <span class="string">org.apache.spi.Bumblebee</span></span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是<strong>通过键值对的方式进行配置</strong>，这样可以<strong>按需加载</strong>指定的实现类。Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性。</p>
<p>Dubbo SPI 的相关逻辑被封装在了 <code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code>，可以加载指定的实现类。<code>ExtensionLoader</code> 的 <code>getExtension</code> 方法是其入口方法。</p>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/overview/">Dubbo SPI 概述</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/8f3dccd5/">源码级深度理解 Java SPI</a></li>
</ul>
</blockquote>
<h3 id="【中等】什么是-Dubbo-的-Filter-机制？"><a href="#【中等】什么是-Dubbo-的-Filter-机制？" class="headerlink" title="【中等】什么是 Dubbo 的 Filter 机制？"></a>【中等】什么是 Dubbo 的 Filter 机制？</h3><p>Filter 是 Dubbo 的核心扩展点之一，通过拦截 RPC 调用实现横切逻辑（如日志、鉴权、监控），其设计遵循 <strong>责任链模式</strong>，与 Spring AOP 理念相似但更轻量级。</p>
<p>通过 Filter 机制，Dubbo 实现了业务逻辑与横切关注点的解耦，结合 SPI 扩展能力，可灵活适应各类微服务治理需求。</p>
<p><strong>核心工作原理</strong></p>
<ul>
<li><strong>拦截链路</strong>：请求和响应会依次通过所有激活的 Filter，形成双向处理链。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  Consumer --&gt;|Request| Filter1 --&gt; Filter2 --&gt; ... --&gt; FilterN --&gt; Provider</span><br><span class="line">  Provider --&gt;|Response| FilterN --&gt; ... --&gt; Filter2 --&gt; Filter1 --&gt; Consumer</span><br></pre></td></tr></table></figure>

<ul>
<li>每个 Filter 可通过 <code>invoker.invoke()</code> 决定是否继续传递或中断调用。</li>
<li><strong>内置 Filter</strong>： Dubbo 默认包含多个 Filter（如 <code>ActiveLimitFilter</code> 限流、<code>TokenFilter</code> 鉴权），可通过 <code>&lt;dubbo:provider filter=&quot;-default&quot; /&gt;</code> 禁用默认链。</li>
</ul>
<p><strong>自定义 Filter 开发</strong></p>
<p>步骤 1：实现 Filter 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &#123;Constants.PROVIDER, Constants.CONSUMER&#125;)</span> <span class="comment">// 自动激活条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceIdFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 请求前：生成TraceID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        RpcContext.getContext().setAttachment(<span class="string">&quot;traceId&quot;</span>, traceId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[TRACE] Start call %s#%s, traceId=%s\n&quot;</span>,</span><br><span class="line">                invoker.getInterface().getSimpleName(),</span><br><span class="line">                invocation.getMethodName(),</span><br><span class="line">                traceId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行后续调用链</span></span><br><span class="line">            <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应后：记录耗时</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;[TRACE] End call, traceId=%s, cost=%dms\n&quot;</span>,</span><br><span class="line">                traceId, System.currentTimeMillis() - startTime);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">            System.err.printf(<span class="string">&quot;[TRACE] Call failed, traceId=%s, error=%s\n&quot;</span>, traceId, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤 2：注册 Filter</p>
<ul>
<li>方式1：SPI 自动加载<br>在 <code>META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</code> 文件中添加：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">traceIdFilter</span>=<span class="string">com.your.package.TraceIdFilter</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：XML 显式配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">filter</span>=<span class="string">&quot;traceIdFilter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">filter</span>=<span class="string">&quot;traceIdFilter&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单个服务生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.UserService&quot;</span> <span class="attr">filter</span>=<span class="string">&quot;traceIdFilter&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>高级配置技巧</strong></p>
<ul>
<li><strong>Filter 执行顺序</strong>：通过 <code>@Activate(order = -100)</code> 指定优先级（值越小越早执行）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(order = -100, group = Constants.PROVIDER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>条件生效</strong>：使用 <code>@Activate</code> 的 <code>group</code> 和 <code>value</code> 参数控制生效场景：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅当消费者指定参数validation=true时激活</span></span><br><span class="line"><span class="meta">@Activate(group = Constants.CONSUMER, value = &quot;validation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>异步支持</strong>：Filter 默认兼容异步调用（如 <code>CompletableFuture</code>），可通过 <code>RpcContext.isAsync()</code> 判断当前调用模式。</li>
</ul>
<p><strong>典型应用场景</strong></p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>实现方案</strong></th>
<th><strong>相关 Filter</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分布式链路追踪</strong></td>
<td>透传 TraceID 和 SpanID</td>
<td>自定义 TraceIdFilter</td>
</tr>
<tr>
<td><strong>接口鉴权</strong></td>
<td>校验 RpcContext 中的 Token</td>
<td>AuthFilter + TokenManager</td>
</tr>
<tr>
<td><strong>限流熔断</strong></td>
<td>统计 QPS 并触发限流逻辑</td>
<td>结合 Sentinel&#x2F;Dubbo 限流插件</td>
</tr>
<tr>
<td><strong>参数校验</strong></td>
<td>使用 JSR-303 校验方法参数</td>
<td>ValidationFilter</td>
</tr>
<tr>
<td><strong>日志脱敏</strong></td>
<td>拦截请求&#x2F;响应数据，过滤敏感字段</td>
<td>SensitiveDataFilter</td>
</tr>
</tbody></table>
<p><strong>常见问题排查</strong></p>
<ul>
<li><strong>Filter 未生效</strong><ul>
<li>检查是否配置了 <code>&lt;dubbo:provider filter=&quot;-default&quot; /&gt;</code> 覆盖了默认链。</li>
<li>确认 SPI 文件路径和内容是否正确。</li>
</ul>
</li>
<li><strong>执行顺序异常</strong>：通过 <code>@Activate(order=1)</code> 显式指定优先级，避免依赖默认顺序。</li>
<li><strong>性能瓶颈</strong>：避免在 Filter 中执行阻塞 IO 操作，异步场景推荐使用 <code>CompletableFuture</code>。</li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li><strong>生产建议</strong>：<ul>
<li>为关键 Filter 添加 <code>@SPI</code> 注解，支持动态替换实现。</li>
<li>使用 <code>RpcContext.getContext().get()</code> 传递跨调用参数，而非 ThreadLocal。</li>
</ul>
</li>
<li><strong>调试技巧</strong>：<ul>
<li>启用 Dubbo QOS（<code>telnet 127.0.0.1 22222</code>）实时查看 Filter 链：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">ls</span> filter</span><br><span class="line">traceIdFilter</span><br><span class="line">authFilter</span><br><span class="line">&gt; invoke traceIdFilter status</span><br></pre></td></tr></table></figure>

<h2 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h2><h3 id="【困难】Dubbo-中如何实现分布式事务？"><a href="#【困难】Dubbo-中如何实现分布式事务？" class="headerlink" title="【困难】Dubbo 中如何实现分布式事务？"></a>【困难】Dubbo 中如何实现分布式事务？</h3><p>在 Dubbo 分布式系统中实现事务，主要面临跨服务数据一致性问题。以下是主流解决方案：</p>
<p><strong>事务消息</strong></p>
<p><strong>适用场景</strong>：异步解耦场景（如订单创建后通知库存）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    参与者 订单服务-&gt;&gt;MQ: 1.发送预备消息（半事务消息）</span><br><span class="line">    MQ--&gt;&gt;订单服务: 2.返回发送成功</span><br><span class="line">    订单服务-&gt;&gt;DB: 3.执行本地事务</span><br><span class="line">    订单服务-&gt;&gt;MQ: 4.提交/回滚消息</span><br><span class="line">    MQ-&gt;&gt;库存服务: 5.投递消息</span><br><span class="line">    库存服务-&gt;&gt;DB: 6.执行库存操作</span><br></pre></td></tr></table></figure>

<p><strong>实现步骤</strong>：</p>
<ol>
<li>集成 RocketMQ 事务消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单服务</span></span><br><span class="line"><span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;order_group&quot;</span>);</span><br><span class="line">producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">LocalTransactionListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderDao.createOrder(); <span class="comment">// 本地事务</span></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Seata AT（推荐）</strong></p>
<p><strong>架构原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    TC(Seata Server)</span><br><span class="line">    A[订单服务] --&gt;|1.注册分支| TC</span><br><span class="line">    B[库存服务] --&gt;|2.注册分支| TC</span><br><span class="line">    TC --&gt;|3.全局事务管理| A</span><br><span class="line">    TC --&gt;|3.全局事务管理| B</span><br></pre></td></tr></table></figure>

<p><strong>集成方式</strong>：</p>
<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置全局事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(OrderDTO order)</span> &#123;</span><br><span class="line">    orderService.create(order);  <span class="comment">// 本地事务</span></span><br><span class="line">    stockService.reduce(order.getProductId());  <span class="comment">// 远程Dubbo调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据源代理配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_tx_group</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_tx_group:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p><strong>TCC（两阶段提交）</strong></p>
<p>适用于复杂业务。</p>
<p><strong>阶段划分</strong>：</p>
<ol>
<li>Try：预留资源</li>
<li>Confirm：确认操作</li>
<li>Cancel：取消预留</li>
</ol>
<p><strong>Dubbo 服务定义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;reduceStock&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryReduceStock</span><span class="params">(BusinessActionContext context, Long productId, <span class="type">int</span> count)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SAGA（长事务）</strong></p>
<p><strong>适用场景</strong>：跨多服务的业务流程（如旅行订票）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[订机票] --&gt; B[订酒店]</span><br><span class="line">    B --&gt; C[租车]</span><br><span class="line">    C --&gt; D[支付]</span><br></pre></td></tr></table></figure>

<p><strong>实现方案</strong>：</p>
<ol>
<li>使用 Apache ServiceComb Saga</li>
<li>定义补偿方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SagaStart</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bookTravel</span><span class="params">(TravelOrder order)</span> &#123;</span><br><span class="line">    flightService.book(order);</span><br><span class="line">    hotelService.reserve(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Compensate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelFlight</span><span class="params">(TravelOrder order)</span> &#123;</span><br><span class="line">    flightService.cancel(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方案对比</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>一致性</th>
<th>性能</th>
<th>复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>事务消息</td>
<td>最终</td>
<td>高</td>
<td>低</td>
<td>异步通知场景</td>
</tr>
<tr>
<td>Seata AT</td>
<td>强一致</td>
<td>中</td>
<td>中</td>
<td>常规分布式事务</td>
</tr>
<tr>
<td>TCC</td>
<td>强一致</td>
<td>较高</td>
<td>高</td>
<td>资金类高敏感业务</td>
</tr>
<tr>
<td>SAGA</td>
<td>最终</td>
<td>低</td>
<td>高</td>
<td>跨多服务长流程</td>
</tr>
</tbody></table>
<p><strong>生产建议</strong></p>
<ol>
<li><strong>Seata AT 模式</strong>作为默认选择，平衡易用性与一致性</li>
<li>重要资金操作采用 <strong>TCC 模式</strong>，如支付、转账</li>
<li>配合 Dubbo 的 <strong>集群容错</strong> 策略：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>必须实现 <strong>幂等接口</strong> 应对重试场景</li>
</ol>
<p><strong>监控配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">registry-type:</span> <span class="string">compact</span></span><br><span class="line">    <span class="attr">exporter-list:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure>

<p>通过以上方案，Dubbo 系统可在保证性能的同时实现不同级别的事务一致性。实际选型需根据业务特点权衡。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo Github</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/design/">Dubbo 框架设计</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3f525850/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3f525850/" class="post-title-link" itemprop="url">Elasticsearch 架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-25 07:42:18" itemprop="dateCreated datePublished" datetime="2024-11-25T07:42:18+08:00">2024-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-架构"><a href="#Elasticsearch-架构" class="headerlink" title="Elasticsearch 架构"></a>Elasticsearch 架构</h1><h2 id="存储流程"><a href="#存储流程" class="headerlink" title="存储流程"></a>存储流程</h2><p>ES 存储数据的流程可以从三个角度来阐述：</p>
<ul>
<li>从<strong>集群</strong>的角度来看，数据写入会先路由到主分片，在主分片上写入成功后，会并发写副本分片，最后响应给客户端。</li>
<li>从<strong>分片</strong>的角度来看，数据到达分片后需要对内容进行格式校验、分词处理然后再索引数据。</li>
<li>从<strong>节点</strong>的角度来看，ES 数据持久化的步骤可归纳为：<strong>Refresh、写 Translog、Flush、Merge。</strong></li>
</ul>
<h3 id="文档分布式存储流程"><a href="#文档分布式存储流程" class="headerlink" title="文档分布式存储流程"></a>文档分布式存储流程</h3><p>ES 的索引有一个或者多个分片，而分片又分为主分片和副本分片两种。将要写入的数据存储在哪个分片是第一个要考虑的问题。</p>
<p>首先需要找到存储文档的主分片，并在主分片的节点上写入对应数据，<strong>数据在主分片写入成功后再将数据分发到副分片进行存储</strong>。文档的新增、更新、删除等操作都属于写入操作。</p>
<p>从集群层面来看，存储数据的流程如下：</p>
<ol>
<li><strong>请求</strong> - 客户端选择一个 node（示例中是 node1）发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li>
<li><strong>路由转发</strong> - <code>coordinating node</code> 根据文档 ID 或 routing key 计算出文档应该被保存到哪个分片（这里是分片 3），并且从集群状态的路由表信息中获取分片 3 的主分片所在的节点为 node3。<code>coordinating node</code> 将请求转发给 node3。</li>
<li><strong>复制</strong> - node3 存储数据后，将请求并发转发到 分片 3 的所有副本分片，即数据复制。</li>
<li><strong>响应</strong> - 当所有副分片都写入成功后，node3 会向 <code>coordinating node</code> 返回写入成功的消息，<code>coordinating node</code> 再将响应返回给客户端。</li>
</ol>
<h3 id="数据索引流程"><a href="#数据索引流程" class="headerlink" title="数据索引流程"></a>数据索引流程</h3><p>文档分布式存储流程中的描述，隐藏了一个细节：如果是全文本数据，ES 需要使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><strong>analyzer（分析器）</strong></a> 先对内容进行分析（如果数据是精确值，如实体 ID、日期等，则无需处理）。</p>
<p>在 Elasticsearch 中，分析器是用于对文本进行分词的组件。分析器用于将文本分解为更小的单元，称为分词。然后，这些分词用于索引和搜索文本。分析器的主要目标是将原始文本转换为可以有效搜索和分析的结构化格式 （分词）。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><strong>analyzer（分析器）</strong></a> 由三个组件组成：零个或多个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">Character Filters（字符过滤器）</a>、有且仅有一个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">Tokenizer（分词器）</a>、零个或多个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">Token Filters（分词过滤器）</a>。分析的执行顺序为：<code>character filters -&gt; tokenizer -&gt; token filters</code>。</p>
<p>对全文本数据来说，数据索引时会对文本内容进行分析处理，分析器的处理流程如下：</p>
<ol>
<li>character flters 先对字符进行过滤，例如：把一些 HTML 元素、转义标签清除；</li>
<li>tokenizer 会将字符串按不同的策略进行切分，分割得到的单词称为 token（词条）；</li>
<li>token filters 对 token 再进行过滤，例如：删除停用词（and、is 等），转换近义词等；</li>
</ol>
<p>经过以上一系列处理后，ES 会将数据存储到名为倒排索引的结构中。</p>
<p>当需要全文检索存储数据时，需要先使用搜索分析器对搜索内容进行分析，这个处理过程和存储时使用的分析器相似。通过分析得到的分词列表，再去和倒排索引中的数据去进行匹配，最后返回匹配度最高的数据。</p>
<h3 id="数据持久化流程"><a href="#数据持久化流程" class="headerlink" title="数据持久化流程"></a>数据持久化流程</h3><p>ES 的数据持久化流程主要有以下几个过程：<strong>Refresh、写 Translog、Flush、Merge。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503110726542.png"></p>
<h4 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h4><p>在文档写入的时候，ES 会将文档先写入到 <strong>Index Buffer</strong> 中。</p>
<p>当 Index Buffer 大小达到阈值（默认为 JVM 的 10%），或间隔一段时间（默认每秒执行一次，可以通过 <code>index.refresh_interval</code> 进行设置），ES 会将 Index Buffer 中的数据写入到一个新的 Segment 文件中。此时的 Segment 文件存在于 OS Cache 中。这个过程称为 <strong>Refresh</strong>。</p>
<p>refresh 写完 segment 后，会更新 shard 的 commit point。commit point 在 shard 中以 <code>segments_xxx</code> 形式名字的文件存在，用来记录每个 shard 中 segment 相关的信息。</p>
<p>此外，ES 也支持通过 API 手动触发 Refresh 操作。</p>
<p>Refresh 过程有几点需要注意：</p>
<ul>
<li>在 Index Buffer 中的数据是搜索不到的；Refresh 后，数据进入 <strong>OS Cache</strong>，这时数据就可以搜索了。由于，刷新默认间隔一秒，写入的数据需要一秒后才可见，因此，ES 被称为近实时搜索数据库。</li>
<li>Index Buffer 的设计是为了通过批量写入，提高写入效率。但是，这种设计也带来了新的问题：一旦 ES 节点发生断点，Index Buffer 中的数据就丢失了。为了避免数据丢失，ES 的解决方案就是下文要提到的 <strong>Translog</strong>。</li>
<li>Index Buffer 每次 Refresh 时，都会创建一个新的 Segment 文件。随着时间推移，Segment 文件会越来越多。这些 Segment 都要消耗文件句柄和内存，每次搜索都要检查每个 Segment 然后再合并结果。因此，Segment 越多、搜索也越慢。为了减少 Segment 文件数，ES 的解决方案就是下文要提到的 <strong>Merge</strong> 操作。</li>
</ul>
<h4 id="写-Translog"><a href="#写-Translog" class="headerlink" title="写 Translog"></a>写 Translog</h4><p><strong>ES 通过 Translog（事务日志）来保证数据不丢失</strong>。</p>
<p>数据写入 Index Buffer 后，ES 会将数据也写入 Translog，写入完毕后即可以返回客户端写入成功。<strong>Translog 只允许追加写入</strong>，并且默认是调用 fsync 进行刷盘的。<strong>每个分片都会有自己的 Translog，在 Refresh 的时候系统会清空 Index Buffer，但不会清空 Translog</strong>。一旦机器宕机，再次重启的时候， ES 会自动读取 Translog 中的数据，恢复到 Index Buffer 和 OS Cache 中。</p>
<p>Translog 其实也是先写入 OS Cache 的，默认每 5 秒刷一次到磁盘中去（由 <code>index.translog.interval</code> 控制）。所以，如果机器宕机，可能会丢失 5 秒的数据。这样设计的目的，还是基于写入效率的考虑。如果每条数据都直接写入磁盘，开销是比较高的，所以这里设计为延时批量写入。</p>
<blockquote>
<p>通过 Refresh 和 写 Translog 两节的内容，我们可以总结为：</p>
<ul>
<li>ES 之所以被称为<strong>近实时查询</strong>，是由于数据写入后，需要刷新（默认间隔 1 秒）后，才可以搜索到；</li>
<li>ES 虽然有 Translog 机制，但依然有丢失数据的风险——有 5 秒的数据，是暂存在 index buffer、translog(os cache)、segment file(os cache) 中，此时尚未保存到磁盘。如果此时发生宕机或断电，会<strong>丢失 5 秒的数据</strong>。</li>
</ul>
</blockquote>
<h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><p>Flush 操作本质上就是 commit 操作，即 ES 的数据持久化操作。</p>
<ol>
<li>Flush 操作的第一步，就是将 index buffer 中现有数据 <code>refresh</code> 到 <code>OS Cache</code> 中去，清空 buffer。</li>
<li>然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 Segment 文件。同时，强行将 <code>OS Cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘中去。</li>
<li>最后，删除当前的 translog，新建一个 translog，此时 commit 操作完成。</li>
</ol>
<p>以下两个条件满足任意一个，就会触发 Flush 操作：</p>
<ul>
<li>默认每 30 分钟触发执行一次（由 <code>index.translog.flush_threshold_period</code> 控制）</li>
<li>Translog 写满时触发执行，默认容量为 512M（由 <code>index.translog.flush_threshold_size</code> 控制）。</li>
</ul>
<h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p>Elasticsearch 的 document 的物理存储是 Luncene segment，而 segment 不允许变更。那么，如何处理删除和更新呢？</p>
<ul>
<li><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p>
</li>
<li><p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p>
</li>
</ul>
<p>Index Buffer 每次 Refresh 时，都会创建一个新的 Segment 文件。随着时间推移，Segment 文件会越来越多。这些 Segment 都要消耗文件句柄和内存，每次搜索都要检查每个 Segment 然后再合并结果。因此，Segment 越多、搜索也越慢。</p>
<p>Elasticsearch 会定期执行 merge 操作，将多个 <code>segment file</code> 合并成一个。合并时会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p>
<h2 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h2><p>在 Elasticsearch 中，搜索一般分为两个阶段，query 和 fetch 阶段。可以简单的理解，query 阶段确定要取哪些 doc，fetch 阶段取出具体的 doc。</p>
<h3 id="Query-阶段"><a href="#Query-阶段" class="headerlink" title="Query 阶段"></a>Query 阶段</h3><p>Query 阶段会根据搜索条件遍历每个分片（主分片或者副分片中的其一）中的数据，返回符合条件的前 N 条数据的 ID 和排序值，然后在协调节点中对所有分片的数据进行排序，获取前 N 条数据的 ID。</p>
<p>Query 阶段的流程如下：</p>
<ol>
<li>客户端选择一个节点发送请求，这个 node 成为 coordinate node（协调节点）。coordinate node 创建一个大小为 from + size 的优先级队列用来存放结果。</li>
<li>coordinate node 将请求转发到索引的每个主分片或者副分片中。</li>
<li>每个分片在本地执行搜索请求，并将查询结果打分排序，然后将结果保存到 from + size 大小的有序队列中。</li>
<li>接着，每个分片将结果返回给 coordinate node，coordinate node 对数据进行汇总处理：合并、排序、分页，将汇总数据存到一个大小为 from + size 的全局有序队列。</li>
</ol>
<p>需要注意的是，在协调节点转发搜索请求的时候，如果有 N 个 Shard 位于同一个节点时，并不会合并这些请求，而是发生 N 次请求！</p>
<h3 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h3><p>在 Fetch 阶段，协调节点会从 Query 阶段产生的全局排序列表中确定需要取回的文档 ID 列表，然后通过路由算法计算出各个文档对应的分片，并且用 multi get 的方式到对应的分片上获取文档数据。</p>
<p>Fetch 阶段的流程如下：</p>
<ol>
<li>coordinate node 确定需要获取哪些文档，然后向相关节点发起 multi get 请求；</li>
<li>分片所在节点读取文档数据，并且进行 <code>_source</code> 字段过滤、处理高亮参数等，然后把处理后的文档数据返回给协调节点；</li>
<li>coordinate node 汇总所有数据后，返回给客户端。</li>
</ol>
<h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>在 Elasticsearch 中，支持三种分页查询方式：</p>
<ul>
<li>from + size - 可以使用 <code>from</code> 和 <code>size</code> 参数分别指定查询的起始页和每页记录数。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after"><code>search_after</code></a> - 不支持指定页数，只能向下翻页；并且需要指定 sort，并保证值是唯一的。然后，可以反复使用上次结果中最后一个文档的 sort 值进行查询。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results">scroll</a> - 类似于 RDBMS 中的游标，只允许向下翻页。每次下一页查询后，使用返回结果的 scroll id 来作为下一次翻页的标记。scroll 查询会在搜索初始化阶段会生成快照，后续数据的变化无法及时体现在查询结果，因此更加适合一次性批量查询或非实时数据的分页查询。</li>
</ul>
<p>前文中，我们已经了解了 ES 两阶段搜索流程（Query 和 Fetch）。从中不难发现，这种搜索方式在分页查询时会出现以下情况：</p>
<ul>
<li>每个 shard 要扫描 <code>from + size</code> 条数据；</li>
<li>coordinate node 需要接收并处理 <code>(from + size) * primary_shard_num</code> 条数据。</li>
</ul>
<p><strong>如果 from 或 size 很大，需要处理的数据量也会很大，代价很高，这就是深分页产生的原因</strong>。为了避免深分页，ES 默认限制 <code>from + size</code> 不能超过 10000，可以通过 <code>index.max_result_window</code> 设置。</p>
<p>如何解决 Elasticsearch 深分页问题？</p>
<p>ES 官方提供了另外两种分页查询方式 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after"><code>search_after</code></a> + PIT 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results">scroll</a>（注意：官方已不再推荐） 来避免深分页问题。</p>
<h3 id="计算偏差"><a href="#计算偏差" class="headerlink" title="计算偏差"></a>计算偏差</h3><p>在 ES 中，不仅仅是普通搜索，相关性计算（评分）和聚合计算也是先在每个 shard 的本地进行计算，再由 coordinate node 进行汇总。由于分片的本地计算是独立的，只能基于数据子集来进行计算，所以难免出现数据偏差。</p>
<p>解决这个问题的方式也有多种：</p>
<ul>
<li>当数据量不大的情况下，<strong>设置主分片数为 1</strong>，这意味着在数据全集上进行聚合。 但这种方案不太现实。</li>
<li><strong>设置 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-shard-size"><code>shard_size</code></a> 参数</strong>，将计算数据范围变大，<strong>牺牲整体性能，提高精准度</strong>。shard_size 的默认值是 <code>size * 1.5 + 10</code>。</li>
<li><strong>使用 DFS Query Then Fetch</strong>， 在 URL 参数中指定：<code>_search?search_type=dfs_query_then_fetch</code>。这样设定之后，系统先会把每个分片的词频和文档频率的数据汇总到协调节点进行处理，然后再进行相关性算分。这样的话会消耗更多的 CPU 和内存资源，效率低下！</li>
<li>尽量保证数据均匀地分布在各个分片中。</li>
</ul>
<h3 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h3><p>为了避免出现数据倾斜，系统需要一种高效的方式把数据均匀分散到各个节点上<strong>存储</strong>，并且<strong>在检索的时候可以快速找到</strong>文档所在的节点与分片。这就需要确立路由算法，使得数据可以映射到指定的节点上。</p>
<p>常见的路由方式如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>算法</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">随机算法</td>
<td align="left">写数据时，随机写入到一个节点中；读数据时，由于不知道查询数据存在于哪个节点，所以需要遍历所有节点。</td>
</tr>
<tr>
<td align="left">路由表</td>
<td align="left">由中心节点统一维护数据的路由表，以保证唯一性；但是，中心化产生了新的问题：单点故障、数据越大，路由表越大、单点容易称为性能瓶颈、数据迁移复杂等。</td>
</tr>
<tr>
<td align="left">哈希取模</td>
<td align="left">对 key 值进行哈希计算，然后根据节点数取模，以确定节点。</td>
</tr>
</tbody></table>
<p>ES 的数据路由算法是根据文档 ID 和 routing key 来确定 Shard ID 的过程。<strong>默认的情况下 routing key 为文档 ID</strong>，路由算法一般情况下的计算公式如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shard_number</span> = hash(_routing) % numer_of_primary_shards</span><br></pre></td></tr></table></figure>

<p>也可以在请求中指定 routing key，下面是新增数据的时候指定 routing 的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT &lt;index&gt;/_doc/&lt;<span class="built_in">id</span>&gt;?routing=routing_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;field1&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;field2&quot;</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加数据时，如果不指定文档 ID，ES 会自动分片一个随机 ID。这种情况下，结合 Hash 算法，可以保证数据被均匀分布到各个分片中。如果指定文档 ID，或指定 routing key，Hash 计算得出的值可能会不够随机，从而导致数据倾斜。</p>
<p><strong>index 一旦设置了主分片数就不能修改，如果要修改就需要 reindex（即数据迁移）</strong>。之所以如此，就是因为：一旦修改了主分片数，即等于修改了原 Hash 计算中的变量，无法再通过 Hash 计算正确路由到数据存储的分片。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/359.html">Elasticsearch 从入门到实践之分布式文档的存储流程</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/es-write-query-search.md">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/es-write-query-search.md</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/blog/found-elasticsearch-top-down">https://www.elastic.co/blog/found-elasticsearch-top-down</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/preload-data-to-file-system-cache.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/preload-data-to-file-system-cache.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f">https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/731f829b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/731f829b/" class="post-title-link" itemprop="url">Elasticsearch 搜索（上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-22 07:37:46" itemprop="dateCreated datePublished" datetime="2024-11-22T07:37:46+08:00">2024-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-搜索（上）"><a href="#Elasticsearch-搜索（上）" class="headerlink" title="Elasticsearch 搜索（上）"></a>Elasticsearch 搜索（上）</h1><h2 id="搜索简介"><a href="#搜索简介" class="headerlink" title="搜索简介"></a>搜索简介</h2><p>Elasticsearch 支持多种搜索：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html"><strong>精确搜索（词项搜索）</strong></a>：搜索数值、日期、IP 或字符串的精确值或范围。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html"><strong>全文搜索</strong></a>：搜索非结构化文本数据并查找与查询项最匹配的文档。</li>
<li><strong>向量搜索</strong>：存储向量，并使用 ANN 或 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/knn-search.html">KNN</a> 搜索来查找相似的向量，从而支持 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/semantic-search.html">语义搜索</a> 等场景。</li>
</ul>
<p>可以使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html"><code>_search API</code></a> 来搜索和聚合 Elasticsearch 数据流或索引中的数据。API 的 <code>query</code> 请求采用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">DSL</a> 语义来进行查询。</p>
<p>Elasticsearch 支持两种搜索方式：URI Query 和 Request Body Query（DSL）</p>
<p>::: details URI Query 示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?q=customer_first_name:Eddie</span><br><span class="line">GET /kibana*/_search?q=customer_first_name:Eddie</span><br><span class="line">GET /_all/_search?q=customer_first_name:Eddie</span><br></pre></td></tr></table></figure>

<p>:::</p>
<p>::: details Request Body Query（DSL）示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;match_all&quot;: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<p>当文档存储在 Elasticsearch 中时，它会在 1 秒内近乎实时地被索引和完全搜索。</p>
<p>Elasticsearch 基于 Lucene 开发，并引入了分段搜索的概念。分段类似于倒排索引，但 Lucene 中的单词 <code>index</code> 表示“段的集合加上提交点”。提交后，将向提交点添加新分段并清除缓冲区。</p>
<p>位于 Elasticsearch 和磁盘之间的是文件系统缓存。内存中索引缓冲区的文档会被写入新的分段，然后写入文件系统缓存，然后才刷新到磁盘。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503110724002.png"></p>
<p>Lucene 允许写入和打开新分段，使其包含的文档对搜索可见，而无需执行完全提交。这是一个比提交到磁盘要轻松得多的过程，并且可以频繁地完成而不会降低性能。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503110725002.png"></p>
<p>在 Elasticsearch 中，写入和打开新分段的这一过程称为刷新。刷新使自上次刷新以来对索引执行的所有操作都可用于搜索。</p>
<p>默认情况下，Elasticsearch 每秒定期刷新一次索引，但仅限于在过去 30 秒内收到一个或多个搜索请求的索引。这就是我们说 Elasticsearch 具有近实时搜索能力的原因：文档更改不会立即对搜索可见，但会在此时间范围内变得可见。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>在 Elasticsearch 中，默认排序是<strong>按照相关性的评分（<code>_score</code>）</strong>进行降序排序。<code>_score</code> 是浮点数类型，<code>_score</code> 评分越高，相关性越高。评分模型的选择可以通过 <code>similarity</code> 参数在映射中指定。</p>
<p>在 5.4 版本以前，默认的相关性算法是 TF-IDF。TF 是<strong>词频</strong>（term frequency），IDF 是<strong>逆文档频率</strong>（inverse document frequency）。一个简短的解释是，一个词条出现在某个文档中的次数越多，它就越相关；但是，如果该词条出现在不同的文档的次数越多，它就越不相关。5.4 版本以后，默认的相关性算法 BM25。</p>
<p>此外，也可以通过 <code>sort</code> 自定排序规则，如：按照字段的值排序、多级排序、多值字段排序、基于 geo（地理位置）排序以及自定义脚本排序。</p>
<p>::: details 排序示例</p>
<p>单字段排序</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;order_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>多字段排序</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;order_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;_doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">Sort search results</a></p>
</blockquote>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>默认情况下，Elasticsearch 搜索会返回前 10 个匹配的匹配项。</p>
<p>Elasticsearch 支持三种分页查询方式。</p>
<ul>
<li>from + size</li>
<li>search after</li>
<li>scroll</li>
</ul>
<h3 id="from-size"><a href="#from-size" class="headerlink" title="from + size"></a>from + size</h3><p>可以使用 <code>from</code> 和 <code>size</code> 参数分别指定起始页和每页记录数。</p>
<p>当一个查询：from &#x3D; 990, size &#x3D; 10，会在每个分片上先获取 1000 个文档。然后，通过协调节点聚合所有结果。最后，再通过排序选取前 1000 个文档。</p>
<p>页数越深，占用内存越多。为了避免<strong>深分页</strong>问题，ES 默认限定最多搜索 10000 个文档，可以通过 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-max-result-window"><code>index.max_result_window</code></a> 进行设置。</p>
<p>::: details from + size 分页查询示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h3><p>scroll 搜索方式类似于 RDBMS 中的游标，只允许向下翻页。每次下一页查询后，使用返回结果的 scroll id 来作为下一次翻页的标记。</p>
<p>scroll 在搜索初始化阶段会生成快照，后续数据的变化无法及时体现在查询结果，因此更加适合一次性批量查询或非实时数据的分页查询。</p>
<p>启用游标查询时，需要注意设定期望的过期时间（scroll &#x3D; 1m），以降低维持游标查询窗口所需消耗的资源。</p>
<blockquote>
<p>注意：Elasticsearch 官方不再建议使用 scroll 查询方式进行深分页，而是推荐使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after"><code>search_after</code></a> 和时间点（PIT）一起使用。</p>
</blockquote>
<p>::: details scroll 分页查询示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;currency&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EUR&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>响应结果</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAmTkWRTMzNmxBYmZUbUdsdFNqMnJoTl84Zw==&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">4675</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span> <span class="comment">// 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">Paginate search results</a></p>
</blockquote>
<h3 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h3><p>search after 搜索方式不支持指定页数，只能向下翻页；并且需要指定 sort，并保证值是唯一的。然后，可以反复使用上次结果中最后一个文档的 sort 值进行查询。</p>
<p>search after 实现的思路同 scroll 方式基本一致，通过记录上一次分页的位置标识，来进行下一次分页查询。相比于 scroll 方式，它的优点是可以实时获取数据的变化，解决了查询快照导致的查询结果延迟问题。</p>
<p>::: details search after 分页查询示例</p>
<p>第一次查询</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;order_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应结果</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">2609</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">4675</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="comment">// 略多条记录</span></span><br><span class="line">      <span class="comment">// 最后一条记录</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1642893235000</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上次查询的响应中获取 <code>sort</code> 值，然后将 sort 值插入 search after 数组：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="number">1642893235000</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;order_date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="限定字段"><a href="#限定字段" class="headerlink" title="限定字段"></a>限定字段</h2><p>默认情况下，搜索响应中的每个点击都包含 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html"><code>_source</code></a>，该字段保存了原始文本的 JSON 对象。有两种推荐的方法可以从搜索查询中检索所选字段：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html#search-fields-param"><code>fields</code></a> 选项指定响应结果中返回的值。</li>
<li>如果需要在查询时返回原始文本数据，可以使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html#source-filtering"><code>_source</code></a> 选项。</li>
</ul>
<h2 id="折叠搜索结果"><a href="#折叠搜索结果" class="headerlink" title="折叠搜索结果"></a>折叠搜索结果</h2><p>Elasticsearch 中，可以通过 collapse 对搜索结果进行分组，且每个分组只显示该分组的一个代表文档。</p>
<p>::: details collapse 查询示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;day_of_week&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">106</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">4675</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yZUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Monday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ypUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Sunday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1JUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Tuesday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1ZUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Wednesday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2JUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Saturday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2ZUtBX4BU8KXl1YJRBrH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Thursday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kibana_sample_data_ecommerce&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;35UtBX4BU8KXl1YJRBrI&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;day_of_week&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Friday&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="过滤搜索结果"><a href="#过滤搜索结果" class="headerlink" title="过滤搜索结果"></a>过滤搜索结果</h2><p>使用带有 <code>filter</code> 子句的布尔查询，可以过滤搜索和聚合的结果。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/filter-search-results.html#post-filter"><code>post_filter</code></a> 可以过滤搜索的结果，但不能过滤聚合结果。</p>
<p>:::details filter 示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;taxful_total_price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>Elasticsearch 的高亮（highlight）可以从搜索结果中的一个或多个字段中获取突出显示的摘要，以便向用户显示查询匹配的位置。当请求突出显示（即高亮）时，响应结果的 <code>highlight</code> 字段中包括高亮的字段和高亮的片段。Elasticsearch 默认会用 <code>&lt;em&gt;&lt;/em&gt;</code> 标签标记关键字。</p>
<p>Elasticsearch 提供了三种高亮器，分别是<strong>默认的 highlighter 高亮器</strong>、<strong>postings-highlighter 高亮器</strong> 和 <strong>fast-vector-highlighter 高亮器</strong>。</p>
<p>::: details 高亮结果示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;&lt;strong&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;&lt;/strong&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html">Highlighting</a></p>
</blockquote>
<h2 id="分片路由搜索"><a href="#分片路由搜索" class="headerlink" title="分片路由搜索"></a>分片路由搜索</h2><p>Elasticsearch 可以在多个节点上的多个分片中存储索引数据的副本。在运行搜索请求时，Elasticsearch 会选择包含索引数据副本的节点，并将搜索请求转发到该节点的分片。此过程称为<strong>路由</strong>。</p>
<p>默认情况下，Elasticsearch 使用自适应副本选择来路由搜索请求。默认情况下，自适应副本选择从所有符合条件的节点和分片中进行选择。如果要限制符合搜索请求条件的节点和分片集，可以使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html#search-preference"><code>preference</code></a> 查询参数。</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shard-routing.html">Search shard routing</a></p>
</blockquote>
<h2 id="查询规则"><a href="#查询规则" class="headerlink" title="查询规则"></a>查询规则</h2><p>Elasticsearch 允许自定义查询规则来进行搜索。</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-using-query-rules.html">Searching with query rules</a></p>
</blockquote>
<h2 id="搜索模板"><a href="#搜索模板" class="headerlink" title="搜索模板"></a>搜索模板</h2><p>搜索模板是可以使用不同变量运行的存储搜索。</p>
<blockquote>
<p>详情参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html">Search templates</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/detail/100030501-102659">极客时间教程 - Elasticsearch 核心技术与实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-with-elasticsearch.html">Elasticsearch 官方文档之搜索数据</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/5399bd35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/5399bd35/" class="post-title-link" itemprop="url">《极客时间教程 - Elasticsearch 核心技术与实战》笔记二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-12 07:58:46" itemprop="dateCreated datePublished" datetime="2024-11-12T07:58:46+08:00">2024-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Elasticsearch-核心技术与实战》笔记二"><a href="#《极客时间教程-Elasticsearch-核心技术与实战》笔记二" class="headerlink" title="《极客时间教程 - Elasticsearch 核心技术与实战》笔记二"></a>《极客时间教程 - Elasticsearch 核心技术与实战》笔记二</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/detail/100030501-102659">极客时间教程 - Elasticsearch 核心技术与实战</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/5399bd35/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/007adf25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/007adf25/" class="post-title-link" itemprop="url">《极客时间教程 - Elasticsearch 核心技术与实战》笔记一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-07 07:36:23" itemprop="dateCreated datePublished" datetime="2024-11-07T07:36:23+08:00">2024-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Elasticsearch-核心技术与实战》笔记一"><a href="#《极客时间教程-Elasticsearch-核心技术与实战》笔记一" class="headerlink" title="《极客时间教程 - Elasticsearch 核心技术与实战》笔记一"></a>《极客时间教程 - Elasticsearch 核心技术与实战》笔记一</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/detail/100030501-102659">极客时间教程 - Elasticsearch 核心技术与实战</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/007adf25/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/0449a431/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/0449a431/" class="post-title-link" itemprop="url">《Elasticsearch 实战》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-05 07:02:10" itemprop="dateCreated datePublished" datetime="2024-11-05T07:02:10+08:00">2024-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《Elasticsearch-实战》笔记"><a href="#《Elasticsearch-实战》笔记" class="headerlink" title="《Elasticsearch 实战》笔记"></a>《Elasticsearch 实战》笔记</h1><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30380439/">《Elasticsearch 实战》</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/0449a431/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/112e2d41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/112e2d41/" class="post-title-link" itemprop="url">《极客时间教程 - MongoDB 高手课》笔记一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-17 07:19:53" itemprop="dateCreated datePublished" datetime="2024-10-17T07:19:53+08:00">2024-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-MongoDB-高手课》笔记一"><a href="#《极客时间教程-MongoDB-高手课》笔记一" class="headerlink" title="《极客时间教程 - MongoDB 高手课》笔记一"></a>《极客时间教程 - MongoDB 高手课》笔记一</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/100040001">极客时间教程 - MongoDB 高手课</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/112e2d41/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/525edb57/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/525edb57/" class="post-title-link" itemprop="url">《极客时间教程 - MongoDB 高手课》笔记二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-17 07:19:53" itemprop="dateCreated datePublished" datetime="2024-10-17T07:19:53+08:00">2024-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-MongoDB-高手课》笔记二"><a href="#《极客时间教程-MongoDB-高手课》笔记二" class="headerlink" title="《极客时间教程 - MongoDB 高手课》笔记二"></a>《极客时间教程 - MongoDB 高手课》笔记二</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/100040001">极客时间教程 - MongoDB 高手课</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/525edb57/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"2f77a1d950319325283ec38ac290a654"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
