<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/34/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/34/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/34/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8dea5b95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8dea5b95/" class="post-title-link" itemprop="url">Java 容器之 Queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-21 16:26:21" itemprop="dateCreated datePublished" datetime="2020-02-21T16:26:21+08:00">2020-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-容器之-Queue"><a href="#Java-容器之-Queue" class="headerlink" title="Java 容器之 Queue"></a>Java 容器之 Queue</h1><h2 id="Queue-简介"><a href="#Queue-简介" class="headerlink" title="Queue 简介"></a>Queue 简介</h2><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/Queue-diagrams.png" />
</div>

<h3 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p><code>Queue</code> 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<h3 id="AbstractQueue-抽象类"><a href="#AbstractQueue-抽象类" class="headerlink" title="AbstractQueue 抽象类"></a>AbstractQueue 抽象类</h3><p><strong><code>AbstractQueue</code> 类提供 <code>Queue</code> 接口的核心实现</strong>，以最大限度地减少实现 <code>Queue</code> 接口所需的工作。</p>
<p><code>AbstractQueue</code> 抽象类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h3><p>Deque 接口是 double ended queue 的缩写，即<strong>双端队列</strong>。Deque 继承 Queue 接口，并扩展支持<strong>在队列的两端插入和删除元素</strong>。</p>
<p>所以提供了特定的方法，如:</p>
<ul>
<li>尾部插入时需要的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#addLast-E-">addLast(e)</a>、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#offerLast-E-">offerLast(e)</a>。</li>
<li>尾部删除所需要的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#removeLast--">removeLast()</a>、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#pollLast--">pollLast()</a>。</li>
</ul>
<p>大多数的实现对元素的数量没有限制，但这个接口既支持有容量限制的 deque，也支持没有固定大小限制的。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p><code>ArrayDeque</code> 是 <code>Deque</code> 的顺序表实现。</p>
<p><code>ArrayDeque</code> 用一个动态数组实现了栈和队列所需的所有操作。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><code>LinkedList</code> 是 <code>Deque</code> 的链表实现。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//add()和remove()方法在失败的时候会抛出异常(不推荐)</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="string">&quot;a&quot;</span>); <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="string">&quot;b&quot;</span>); <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="string">&quot;c&quot;</span>); <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span> (String q : queue) &#123;</span><br><span class="line">            System.out.println(q);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;poll=&quot;</span> + queue.poll()); <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">for</span> (String q : queue) &#123;</span><br><span class="line">            System.out.println(q);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;element=&quot;</span> + queue.element()); <span class="comment">//返回第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (String q : queue) &#123;</span><br><span class="line">            System.out.println(q);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;peek=&quot;</span> + queue.peek()); <span class="comment">//返回第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (String q : queue) &#123;</span><br><span class="line">            System.out.println(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p><code>PriorityQueue</code> 类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>PriorityQueue</code> 要点：</p>
<ul>
<li><code>PriorityQueue</code> 实现了 <code>Serializable</code>，支持序列化。</li>
<li><code>PriorityQueue</code> 类是无界优先级队列。</li>
<li><code>PriorityQueue</code> 中的元素根据自然顺序或 <code>Comparator</code> 提供的顺序排序。</li>
<li><code>PriorityQueue</code> 不接受 null 值元素。</li>
<li><code>PriorityQueue</code> 不是线程安全的。</li>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/28053.html">解读 Java 并发队列 BlockingQueue</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/cfd35751/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/cfd35751/" class="post-title-link" itemprop="url">Java NIO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-19 18:54:21" itemprop="dateCreated datePublished" datetime="2020-02-19T18:54:21+08:00">2020-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h2><p>在传统的 Java I&#x2F;O 模型（BIO）中，I&#x2F;O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I&#x2F;O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>
<p>为了解决此问题，在 Java 1.4 中引入了非阻塞的 I&#x2F;O 模型——NIO（New IO，也称为 Non-blocking IO）。NIO 对应 <code>java.nio</code> 包，提供了 <code>Channel</code> 、<code>Selector</code>、<code>Buffer</code> 等抽象。它支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。</p>
<p>NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I&#x2F;O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<blockquote>
<p>注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p>
</blockquote>
<h3 id="NIO-的基本流程"><a href="#NIO-的基本流程" class="headerlink" title="NIO 的基本流程"></a>NIO 的基本流程</h3><p>通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。</p>
<ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
<h3 id="NIO-核心组件"><a href="#NIO-核心组件" class="headerlink" title="NIO 核心组件"></a>NIO 核心组件</h3><p>NIO 包含下面几个核心的组件：</p>
<ul>
<li><strong>Channel（通道）</strong> - Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>
<li><strong>Buffer（缓冲区）</strong> - NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>
<li><strong>Selector（选择器）</strong> - 允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>
</ul>
<h2 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a>Channel（通道）</h2><p>通道（<code>Channel</code>）是对 BIO 中的流的模拟，可以通过它读写数据。</p>
<p>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。</p>
<p>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p>
<p>通道与流的不同之处在于：</p>
<ul>
<li><strong>流是单向的</strong> - 一个流只能单纯的负责读或写。</li>
<li><strong>通道是双向的</strong> - 一个通道可以同时用于读写。</li>
</ul>
<p>通道包括以下类型：</p>
<ul>
<li><code>FileChannel</code>：从文件中读写数据；</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li>
<li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li>
<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h2 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h2><p>**BIO 面向流 (Stream oriented)，而 NIO 面向缓冲区 (Buffer oriented)**。</p>
<p>在 NIO 中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读缓冲区中的数据；在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p>
<p><strong>向 <code>Channel</code> 读写的数据都必须先置于缓冲区中</strong>。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>
<p>BIO 和 NIO 已经很好地集成了，<code>java.io.*</code> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，<code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<p>事实上，每一种 Java 基本类型（除了 Boolean 类型）都对应有一种缓冲区：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>ShortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>DoubleBuffer</code></li>
</ul>
<h3 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h3><ul>
<li><code>capacity</code>：最大容量；</li>
<li><code>position</code>：当前已经读写的字节数；</li>
<li><code>limit</code>：还可以读写的字节数。</li>
<li><code>mark</code>：记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须<br>的。</li>
</ul>
<p>缓冲区状态变量的改变过程举例：</p>
<ol>
<li>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit &#x3D; capacity &#x3D; 8。capacity 变量不会改变，下面的讨论会忽略它。</li>
<li>从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</li>
<li>在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</li>
<li>从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</li>
<li>最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</li>
</ol>
<h3 id="文件-NIO-示例"><a href="#文件-NIO-示例" class="headerlink" title="文件 NIO 示例"></a>文件 NIO 示例</h3><p>以下展示了使用 NIO 快速复制文件的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcin</span> <span class="operator">=</span> fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcout</span> <span class="operator">=</span> fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h3><p>NIO 还提供了一个可以直接访问物理内存的类 <code>DirectBuffer</code>。普通的 <code>Buffer</code> 分配的是 JVM 堆内存，而 <code>DirectBuffer</code> 是直接分配物理内存。</p>
<p>数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 <code>DirectBuffer</code> 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。</p>
<p>这里拓展一点，由于 <code>DirectBuffer</code> 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。<code>DirectBuffer</code> 申请的内存并不是直接由 JVM 负责垃圾回收，但在 <code>DirectBuffer</code> 包装类被回收时，会通过 Java 引用机制来释放该内存块。</p>
<h2 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p><code>Selector</code> 是 Java NIO 编程的基础。用于检查一个或多个 NIO <code>Channel</code> 的状态是否处于可读、可写。</p>
<p><strong>NIO 实现了 IO 多路复用中的 Reactor 模型</strong>：</p>
<ul>
<li><p>一个线程（<code>Thread</code>）使用一个<strong>选择器 <code>Selector</code> 通过轮询的方式去监听多个通道 <code>Channel</code> 上的事件（<code>accpet</code>、<code>read</code>）</strong>，如果某个 <code>Channel</code> 上面发生监听事件，这个 <code>Channel</code> 就处于就绪状态，然后进行 I&#x2F;O 操作。</p>
</li>
<li><p>通过<strong>配置监听的通道 <code>Channel</code> 为非阻塞</strong>，那么当 <code>Channel</code> 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 <code>Channel</code>，找到 IO 事件已经到达的 <code>Channel</code> 执行。</p>
</li>
<li><p>因为创建和切换线程的开销很大，因此使用<strong>一个线程来处理多个事件</strong>而不是一个线程处理一个事件具有更好的性能。</p>
</li>
</ul>
<p>需要注意的是，只有 <code>SocketChannel</code> 才能配置为非阻塞，而 <code>FileChannel</code> 不能，因为 <code>FileChannel</code> 配置非阻塞也没有意义。</p>
<blockquote>
<p>目前操作系统的 I&#x2F;O 多路复用机制都使用了 epoll，相比传统的 select 机制，epoll 没有最大连接句柄 1024 的限制。所以 Selector 在理论上可以轮询成千上万的客户端。</p>
</blockquote>
<h3 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<h3 id="将通道注册到选择器上"><a href="#将通道注册到选择器上" class="headerlink" title="将通道注册到选择器上"></a>将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li><code>SelectionKey.OP_CONNECT</code></li>
<li><code>SelectionKey.OP_ACCEPT</code></li>
<li><code>SelectionKey.OP_READ</code></li>
<li><code>SelectionKey.OP_WRITE</code></li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 <code>select()</code> 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="获取到达的事件"><a href="#获取到达的事件" class="headerlink" title="获取到达的事件"></a>获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套接字-NIO-示例"><a href="#套接字-NIO-示例" class="headerlink" title="套接字 NIO 示例"></a>套接字 NIO 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ssChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">            <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="type">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>内存映射文件 I&#x2F;O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I&#x2F;O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">mbb</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="NIO-vs-BIO"><a href="#NIO-vs-BIO" class="headerlink" title="NIO vs. BIO"></a>NIO vs. BIO</h2><p>BIO 与 NIO 最重要的区别是数据打包和传输的方式。**BIO 面向流 (Stream oriented)，而 NIO 面向缓冲区 (Buffer oriented)**。</p>
<ul>
<li><strong>面向流的 BIO 一次处理一个字节数据</strong>：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</li>
<li><strong>面向块的 NIO 一次处理一个数据块</strong>，按块处理数据比按流处理数据要快得多。但是面向块的 NIO 缺少一些面向流的 BIO 所具有的优雅性和简单性。</li>
</ul>
<p>BIO 模式：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630212345.png" alt="img"></p>
<p>NIO 模式：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630212248.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23488863">Java NIO 浅析</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html">JavaNIO Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">IBM: NIO 入门</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/60751347/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/60751347/" class="post-title-link" itemprop="url">监控工具对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 17:48:32" itemprop="dateCreated datePublished" datetime="2020-02-11T17:48:32+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/" itemprop="url" rel="index"><span itemprop="name">监控诊断</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>126</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="监控工具对比"><a href="#监控工具对比" class="headerlink" title="监控工具对比"></a>监控工具对比</h1><h2 id="监控工具发展史"><a href="#监控工具发展史" class="headerlink" title="监控工具发展史"></a>监控工具发展史</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211165813.png" alt="img"></p>
<h2 id="监控工具比对"><a href="#监控工具比对" class="headerlink" title="监控工具比对"></a>监控工具比对</h2><h3 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211171551.png" alt="img"></p>
<h3 id="生态对比"><a href="#生态对比" class="headerlink" title="生态对比"></a>生态对比</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211172631.png" alt="img"></p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>Zipkin 欠缺 APM 报表能力，不推荐。</li>
<li>企业级，推荐 CAT</li>
<li>关注和试点 SkyWalking。</li>
</ul>
<p>用好调用链监控，需要订制化、自研能力。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/dailylesson/detail/100028416">CAT、Zipkin 和 SkyWalking 该如何选型？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/48726db7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/48726db7/" class="post-title-link" itemprop="url">CAT 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 17:48:32" itemprop="dateCreated datePublished" datetime="2020-02-11T17:48:32+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/" itemprop="url" rel="index"><span itemprop="name">监控诊断</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CAT-快速入门"><a href="#CAT-快速入门" class="headerlink" title="CAT 快速入门"></a>CAT 快速入门</h1><h2 id="CAT-简介"><a href="#CAT-简介" class="headerlink" title="CAT 简介"></a>CAT 简介</h2><p>CAT（Central Application Tracking），是基于 Java 开发的分布式实时监控系统。CAT 在基础存储、高性能通信、大规模在线访问、服务治理、实时监控、容器化及集群智能调度等领域提供业界领先的、统一的解决方案。CAT 目前在美团的产品定位是应用层的统一监控组件，基本接入了美团所有核心应用，在中间件（RPC、数据库、缓存、MQ 等）框架中得到广泛应用，为各业务线提供系统的性能指标、健康状况、实时告警等。</p>
<h3 id="CAT-的优势"><a href="#CAT-的优势" class="headerlink" title="CAT 的优势"></a>CAT 的优势</h3><ul>
<li>实时处理：信息的价值会随时间锐减，尤其是事故处理过程中</li>
<li>全量数据：最开始的设计目标就是全量采集，全量的好处有很多</li>
<li>高可用：所有应用都倒下了，需要监控还站着，并告诉工程师发生了什么，做到故障还原和问题定位</li>
<li>故障容忍：CAT 本身故障不应该影响业务正常运转，CAT 挂了，应用不该受影响，只是监控能力暂时减弱</li>
<li>高吞吐：要想还原真相，需要全方位地监控和度量，必须要有超强的处理吞吐能力</li>
<li>可扩展：支持分布式、跨 IDC 部署，横向扩展的监控系统</li>
</ul>
<h3 id="支持的消息类型"><a href="#支持的消息类型" class="headerlink" title="支持的消息类型"></a>支持的消息类型</h3><p>CAT 监控系统将每次 URL、Service 的请求内部执行情况都封装为一个完整的消息树、消息树可能包括 Transaction、Event、Heartbeat、Metric 等信息。</p>
<ul>
<li><strong>Transaction</strong> 适合记录跨越系统边界的程序访问行为,比如远程调用，数据库调用，也适合执行时间较长的业务逻辑监控，Transaction 用来记录一段代码的执行时间和次数</li>
<li><strong>Event</strong> 用来记录一件事发生的次数，比如记录系统异常，它和 transaction 相比缺少了时间的统计，开销比 transaction 要小</li>
<li><strong>Heartbeat</strong> 表示程序内定期产生的统计信息, 如 CPU 利用率, 内存利用率, 连接池状态, 系统负载等</li>
<li><strong>Metric</strong> 用于记录业务指标、指标可能包含对一个指标记录次数、记录平均值、记录总和，业务指标最低统计粒度为 1 分钟</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211174235.png" alt="img"></p>
<h2 id="CAT-部署"><a href="#CAT-部署" class="headerlink" title="CAT 部署"></a>CAT 部署</h2><p>Cat 部署可以参考 <a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/readme_server">官方 Wiki - 服务端部署</a> ，非常详细，不赘述。</p>
<h2 id="CAT-报表"><a href="#CAT-报表" class="headerlink" title="CAT 报表"></a>CAT 报表</h2><p>与其他监控工具（如 Zipkin、SkyWalking）相比，CAT 的报表功能最丰富。支持以下报表类型：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/transaction">Transaction 报表</a></strong> - 一段代码运行时间、次数，比如 URL、Cache、SQL 执行次数和响应时间</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/event">Event 报表</a></strong> - 一行代码运行次数，比如出现一个异常</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/problem">Problem 报表</a></strong> - 根据 Transaction&#x2F;Event 数据分析出来系统可能出现的异常，包括访问较慢的程序等</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/heartbeat">Heartbeat 报表</a></strong> - JVM 内部一些状态信息，比如 Memory，Thread 等</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/business">Business 报表</a></strong> - 业务监控报表，比如订单指标，支付等业务指标</li>
</ul>
<h2 id="CAT-配置"><a href="#CAT-配置" class="headerlink" title="CAT 配置"></a>CAT 配置</h2><p>CAT 提供了以下配置：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/project">项目配置</a></strong> 包括项目基本信息、机器分组配置</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/alarm">告警配置</a></strong> 包括基本告警配置、告警规则、以及具体告警配置</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/global">全局配置</a></strong> 包括服务端配置、消息采样配置、客户端路由</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dianping/cat/wiki/business">业务指标</a></strong> 包括业务监控配置、业务标签配置</li>
</ul>
<h2 id="CAT-架构"><a href="#CAT-架构" class="headerlink" title="CAT 架构"></a>CAT 架构</h2><p>CAT 主要分为三个模块：</p>
<ul>
<li><strong>cat-client</strong> - 提供给业务以及中间层埋点的底层 SDK。</li>
<li><strong>cat-consumer</strong> - 用于实时分析从客户端的提供的数据。</li>
<li><strong>cat-home</strong> - 作为用户提供给用户的展示的控制端。</li>
</ul>
<p>在实际开发和部署中，cat-consumer 和 cat-home 是部署在一个 jvm 内部，每个 CAT 服务端都可以作为 consumer 也可以作为 home，这样既能减少整个 CAT 层级结构，也可以增加整个系统稳定性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211174001.png" alt="img"></p>
<p>上图是 CAT 目前多机房的整体结构图：</p>
<ul>
<li>路由中心是根据应用所在机房信息来决定客户端上报的 CAT 服务端地址</li>
<li>每个机房内部都有的独立的原始信息存储集群 HDFS</li>
<li>cat-home 可以部署在一个机房也可以部署在多个机房，在做报表展示的时候，cat-home 会从 cat-consumer 中进行跨机房的调用，将所有的数据合并展示给用户</li>
<li>实际过程中，cat-consumer、cat-home 以及路由中心都是部署在一起，每个服务端节点都可以充当任何一个角色</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dianping/cat">CAT Github</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/7607f70f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/7607f70f/" class="post-title-link" itemprop="url">时间服务器 - NTP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 13:11:00" itemprop="dateCreated datePublished" datetime="2020-02-11T13:11:00+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="时间服务器-NTP"><a href="#时间服务器-NTP" class="headerlink" title="时间服务器 - NTP"></a>时间服务器 - NTP</h1><h2 id="NTP-简介"><a href="#NTP-简介" class="headerlink" title="NTP 简介"></a>NTP 简介</h2><p>网络时间协议（英语：Network Time Protocol，缩写：NTP）是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills（英语：David L. Mills）设计。</p>
<p><strong>NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内</strong>。</p>
<p>NTP 要点：</p>
<ul>
<li>地球共有 24 个时区，而以格林威治时间 (GMT) 为标准时间；</li>
<li>中国本地时间为 GMT +8 小时；</li>
<li>最准确的时间为使用原子钟 (Atomic clock) 所计算的，例如 UTC (Coordinated Universal Time) 就是一例；</li>
<li>Linux 系统本来就有两种时间，一种是 Linux 以 <code>1970/01/01</code> 开始计数的系统时间，一种则是 BIOS 记载的硬件时间；</li>
<li>Linux 可以透过网络校时，最常见的网络校时为使用 NTP 服务器，这个服务启动在 <code>udp port 123</code>；</li>
<li>时区档案主要放置于 <code>/usr/share/zoneinfo/</code> 目录下，而本地时区则参考 <code>/etc/localtime</code>；</li>
<li>NTP 服务器为一种阶层式的服务，所以 NTP 服务器本来就会与上层时间服务器作时间的同步化， 因此 <code>nptd</code> 与 <code>ntpdate</code> 两个指令不可同时使用；</li>
<li>NTP 服务器的联机状态可以使用 <code>ntpstat</code> 及 <code>ntpq -p</code> 来查询；</li>
<li>NTP 提供的客户端软件为 <code>ntpdate</code> 这个指令；</li>
<li>在 Linux 下想要手动处理时间时，需以 <code>date</code> 设定时间后，以 <code>hwclock -w</code> 来写入 BIOS 所记录的时间。</li>
<li>NTP 服务器之间的时间误差不可超过 1000 秒，否则 NTP 服务会自动关闭。</li>
</ul>
<blockquote>
<p>更多 NTP 详情可以参考：<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_server/0440ntp.php">鸟哥的 Linux 私房菜– NTP 时间服务器</a></p>
</blockquote>
<h2 id="ntpd-服务"><a href="#ntpd-服务" class="headerlink" title="ntpd 服务"></a>ntpd 服务</h2><blockquote>
<p>环境：CentOS</p>
</blockquote>
<h3 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h3><p>CentOS 安装 NTP 很简单，执行以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure>

<h3 id="ntpd-配置"><a href="#ntpd-配置" class="headerlink" title="ntpd 配置"></a>ntpd 配置</h3><p>ntp 的配置文件路径为： <code>/etc/ntp.conf</code> ，参考配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 先处理权限方面的问题，包括放行上层服务器以及开放区网用户来源：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">restrict default kod nomodify notrap nopeer noquery     <span class="comment"># 拒绝 IPv4 的用户</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">restrict -6 default kod nomodify notrap nopeer noquery  <span class="comment"># 拒绝 IPv6 的用户</span></span></span><br><span class="line">restrict default nomodify notrap nopeer noquery</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">restrict 192.168.100.0 mask 255.255.255.0 nomodify <span class="comment"># 放行同局域网来源（根据网关和子网掩码决定）</span></span></span><br><span class="line">restrict 127.0.0.1   # 默认值，放行本机 IPv4 来源</span><br><span class="line">restrict ::1         # 默认值，放行本机 IPv6 来源</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 设定 NTP 主机来源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释掉默认 NTP 来源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置国内 NTP 来源</span></span><br><span class="line">server cn.pool.ntp.org prefer # 以这个主机为优先</span><br><span class="line">server ntp1.aliyun.com</span><br><span class="line">server ntp.sjtu.edu.cn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 预设时间差异分析档案与暂不用到的 keys 等，不需要更改它：</span></span><br><span class="line">driftfile /var/lib/ntp/drift</span><br><span class="line">keys /etc/ntp/keys</span><br><span class="line">includefile /etc/ntp/crypto/pw</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果更改配置，必须重启 NTP 服务（<code>systemctl restart ntpd</code>）才能生效。</p>
</blockquote>
<h3 id="放开防火墙限制"><a href="#放开防火墙限制" class="headerlink" title="放开防火墙限制"></a>放开防火墙限制</h3><p>NTP 服务的端口是 <code>123</code>，使用的是 udp 协议，所以 NTP 服务器的防火墙必须对外开放 udp 123 这个端口。</p>
<p>如果防火墙使用 **<code>iptables</code>**，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p UDP -i eth0 -s 192.168.0.0/24 --dport 123 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>如果防火墙使用 **<code>firewalld</code>**，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=123/udp --permanent</span><br></pre></td></tr></table></figure>

<h3 id="ntpd-服务命令"><a href="#ntpd-服务命令" class="headerlink" title="ntpd 服务命令"></a>ntpd 服务命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable ntpd.service  # 开启服务（开机自动启动服务）</span><br><span class="line">systemctl disable ntpd.service # 关闭服务（开机不会自动启动服务）</span><br><span class="line">systemctl start ntpd.service   # 启动服务</span><br><span class="line">systemctl stop ntpd.service    # 停止服务</span><br><span class="line">systemctl restart ntpd.service # 重启服务</span><br><span class="line">systemctl reload ntpd.service  # 重新载入配置</span><br><span class="line">systemctl status ntpd.service  # 查看服务状态</span><br></pre></td></tr></table></figure>

<h3 id="查看-ntp-服务状态"><a href="#查看-ntp-服务状态" class="headerlink" title="查看 ntp 服务状态"></a>查看 ntp 服务状态</h3><h4 id="验证-NTP-服务正常工作"><a href="#验证-NTP-服务正常工作" class="headerlink" title="验证 NTP 服务正常工作"></a>验证 NTP 服务正常工作</h4><p>执行 <code>ntpstat</code> 可以查看 ntp 服务器有无和上层 ntp 连通，，如果成功，可以看到类似以下的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ntpstat</span></span><br><span class="line">synchronised to NTP server (5.79.108.34) at stratum 3</span><br><span class="line">   time correct to within 1129 ms</span><br><span class="line">   polling server every 64 s</span><br></pre></td></tr></table></figure>

<h4 id="查看-ntp-服务器与上层-ntp-的状态"><a href="#查看-ntp-服务器与上层-ntp-的状态" class="headerlink" title="查看 ntp 服务器与上层 ntp 的状态"></a>查看 ntp 服务器与上层 ntp 的状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p</span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line">*ntp1.ams1.nl.le 130.133.1.10     2 u   36   64  367  230.801    5.271   2.791</span><br><span class="line"> 120.25.115.20   10.137.53.7      2 u   33   64  377   25.930   15.908   3.168</span><br><span class="line"> time.cloudflare 10.21.8.251      3 u   31   64  367  251.109   16.976   3.264</span><br></pre></td></tr></table></figure>

<h2 id="ntpdate-命令"><a href="#ntpdate-命令" class="headerlink" title="ntpdate 命令"></a>ntpdate 命令</h2><blockquote>
<p>注意：NTP 服务器为一种阶层式的服务，所以 NTP 服务器本来就会与上层时间服务器作时间的同步化， 因此 <code>nptd</code> 与 <code>ntpdate</code> 两个指令不可同时使用。</p>
</blockquote>
<h3 id="手动执行时间同步"><a href="#手动执行时间同步" class="headerlink" title="手动执行时间同步"></a>手动执行时间同步</h3><p><code>ntpdate</code> 命令是 NTP 的客户端软件，它可以用于请求时间同步。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/ntpdate &lt;ntp_server&gt;</span><br></pre></td></tr></table></figure>

<p><code>ntp_server</code> 可以从 [国内 NTP 服务器](#国内 NTP 服务器) 中选择。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ntpdate cn.pool.ntp.org</span></span><br><span class="line">11 Feb 10:47:12 ntpdate[30423]: step time server 84.16.73.33 offset -49.894774 sec</span><br></pre></td></tr></table></figure>

<h3 id="自动定时同步时间"><a href="#自动定时同步时间" class="headerlink" title="自动定时同步时间"></a>自动定时同步时间</h3><p>如果需要自动定时同步时间，可以利用 <a href="#crontab">Crontab</a> 工具。本质就是用 crontab 定时执行一次手动时间同步命令 ntp。</p>
<p>示例：执行如下命令，就可以在每天凌晨 3 点同步系统时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;0 3 * * * /usr/sbin/ntpdate cn.pool.ntp.org&quot; &gt;&gt; /etc/crontab # 修改 crond 服务配置</span><br><span class="line">systemctl restart crond # 重启 crond 服务以生效</span><br></pre></td></tr></table></figure>

<h2 id="四、国内-NTP-服务器"><a href="#四、国内-NTP-服务器" class="headerlink" title="四、国内 NTP 服务器"></a>四、国内 NTP 服务器</h2><p>以下 NTP 服务器搜集自网络：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cn.pool.ntp.org  # 最常用的国内NTP服务器，参考：https://www.ntppool.org/zh/use.html</span><br><span class="line">cn.ntp.org.cn    # 中国</span><br><span class="line">edu.ntp.org.cn   # 中国教育网</span><br><span class="line">ntp1.aliyun.com  # 阿里云</span><br><span class="line">ntp2.aliyun.com  # 阿里云</span><br><span class="line">ntp.sjtu.edu.cn  # 上海交通大学</span><br><span class="line">s1a.time.edu.cn  # 北京邮电大学</span><br><span class="line">s1b.time.edu.cn  # 清华大学</span><br><span class="line">s1c.time.edu.cn  # 北京大学</span><br><span class="line">s1d.time.edu.cn  # 东南大学</span><br><span class="line">s1e.time.edu.cn  # 清华大学</span><br><span class="line">s2a.time.edu.cn  # 清华大学</span><br><span class="line">s2b.time.edu.cn  # 清华大学</span><br><span class="line">s2c.time.edu.cn  # 北京邮电大学</span><br><span class="line">s2d.time.edu.cn  # 西南地区网络中心</span><br><span class="line">s2e.time.edu.cn  # 西北地区网络中心</span><br><span class="line">s2f.time.edu.cn  # 东北地区网络中心</span><br><span class="line">s2g.time.edu.cn  # 华东南地区网络中心</span><br><span class="line">s2h.time.edu.cn  # 四川大学网络管理中心</span><br><span class="line">s2j.time.edu.cn  # 大连理工大学网络中心</span><br><span class="line">s2k.time.edu.cn  # CERNET桂林主节点</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_server/0440ntp.php">鸟哥的 Linux 私房菜– NTP 时间服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/quchunhui/p/7658853.html">Linux 配置 ntp 时间服务器</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/17292e63/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/17292e63/" class="post-title-link" itemprop="url">firewalld</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 13:11:00" itemprop="dateCreated datePublished" datetime="2020-02-11T13:11:00+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>951</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="防火墙-Firewalld"><a href="#防火墙-Firewalld" class="headerlink" title="防火墙 - Firewalld"></a>防火墙 - Firewalld</h1><h2 id="firewalld-服务命令"><a href="#firewalld-服务命令" class="headerlink" title="firewalld 服务命令"></a>firewalld 服务命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld.service  # 开启服务（开机自动启动服务）</span><br><span class="line">systemctl disable firewalld.service # 关闭服务（开机不会自动启动服务）</span><br><span class="line">systemctl start firewalld.service   # 启动服务</span><br><span class="line">systemctl stop firewalld.service    # 停止服务</span><br><span class="line">systemctl restart firewalld.service # 重启服务</span><br><span class="line">systemctl reload firewalld.service  # 重新载入配置</span><br><span class="line">systemctl status firewalld.service  # 查看服务状态</span><br></pre></td></tr></table></figure>

<h2 id="firewall-cmd-命令"><a href="#firewall-cmd-命令" class="headerlink" title="firewall-cmd 命令"></a>firewall-cmd 命令</h2><p><code>firewall-cmd</code> 命令用于配置防火墙。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --version                    # 查看版本</span><br><span class="line">firewall-cmd --help                       # 查看帮助</span><br><span class="line">firewall-cmd --state                      # 显示状态</span><br><span class="line">firewall-cmd --reload                     # 更新防火墙规则</span><br><span class="line">firewall-cmd --get-active-zones           # 查看区域信息</span><br><span class="line">firewall-cmd --get-zone-of-interface=eth0 # 查看指定接口所属区域</span><br><span class="line">firewall-cmd --panic-on                   # 拒绝所有包</span><br><span class="line">firewall-cmd --panic-off                  # 取消拒绝状态</span><br><span class="line">firewall-cmd --query-panic                # 查看是否拒绝</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --list-ports   # 查看所有打开的端口</span><br><span class="line">firewall-cmd --zone=public --query-port=80/tcp # 查看是否有开放的 80 TCP 端口</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent # 添加开放端口（--permanent永久生效，没有此参数重启后失效）</span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent # 永久删除开放的 80 TCP 端口</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moxiaoan/p/5683743.html">CentOS7 使用 firewalld 打开关闭防火墙与端口</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/0c6af703/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/0c6af703/" class="post-title-link" itemprop="url">crontab</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 13:11:00" itemprop="dateCreated datePublished" datetime="2020-02-11T13:11:00+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定时任务-crontab"><a href="#定时任务-crontab" class="headerlink" title="定时任务 - crontab"></a>定时任务 - crontab</h1><blockquote>
<p>环境：CentOS</p>
</blockquote>
<p>通过 <code>crontab</code> 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<h2 id="crond-服务"><a href="#crond-服务" class="headerlink" title="crond 服务"></a>crond 服务</h2><p>Linux 通过 crond 服务来支持 crontab。</p>
<h3 id="检查-crond-服务"><a href="#检查-crond-服务" class="headerlink" title="检查 crond 服务"></a>检查 <code>crond</code> 服务</h3><p>使用 <code>systemctl list-unit-files</code> 命令确认 <code>crond</code> 服务是否已安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl list-unit-files | grep crond</span></span><br><span class="line">crond.service                               enabled</span><br></pre></td></tr></table></figure>

<p>如果为 enabled，表示服务正运行。</p>
<h3 id="crond-服务命令"><a href="#crond-服务命令" class="headerlink" title="crond 服务命令"></a>crond 服务命令</h3><p>开机自动启动 crond 服务：<code>chkconfig crond on</code></p>
<p>或者，按以下命令手动启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable crond.service  # 开启服务（开机自动启动服务）</span><br><span class="line">systemctl disable crond.service # 关闭服务（开机不会自动启动服务）</span><br><span class="line">systemctl start crond.service   # 启动服务</span><br><span class="line">systemctl stop crond.service    # 停止服务</span><br><span class="line">systemctl restart crond.service # 重启服务</span><br><span class="line">systemctl reload crond.service  # 重新载入配置</span><br><span class="line">systemctl status crond.service  # 查看服务状态</span><br></pre></td></tr></table></figure>

<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><h3 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h3><p>crontab 命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>-u user</code>：用来设定某个用户的 crontab 服务；</li>
<li><code>file</code>：file 是命令文件的名字，表示将 file 做为 crontab 的任务列表文件并载入 crontab。如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入 crontab。</li>
<li><code>-e</code>：编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。</li>
<li><code>-l</code>：显示某个用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容。</li>
<li><code>-r</code>：从&#x2F;var&#x2F;spool&#x2F;cron 目录中删除某个用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件。</li>
<li><code>-i</code>：在删除用户的 crontab 文件时给确认提示。</li>
</ul>
<p>有两种方法写入定时任务：</p>
<ul>
<li>在命令行输入：<code>crontab -e</code> 然后添加相应的任务，存盘退出。</li>
<li>直接编辑 <code>/etc/crontab</code> 文件，即 <code>vi /etc/crontab</code>，添加相应的任务。</li>
</ul>
<h3 id="crontab-文件"><a href="#crontab-文件" class="headerlink" title="crontab 文件"></a>crontab 文件</h3><p>crontab 要执行的定时任务都被保存在 <code>/etc/crontab</code> 文件中。</p>
<p>crontab 的文件格式如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211113339.png" alt="img"></p>
<h4 id="标准字段"><a href="#标准字段" class="headerlink" title="标准字段"></a>标准字段</h4><p><strong>逗号</strong>用于分隔列表。例如，在第 5 个字段(星期几)中使用 <code>MON,WED,FRI</code> 表示周一、周三和周五。</p>
<p><strong>连字符</strong>定义范围。例如，<code>2000-2010</code> 表示 2000 年至 2010 年期间的每年，包括 2000 年和 2010 年。</p>
<p>除非用反斜杠()转义，否则命令中的**百分号(%)**会被替换成换行符，第一个百分号后面的所有数据都会作为标准输入发送给命令。</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">是否必填</th>
<th align="left">允许值</th>
<th align="left">允许特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Minutes</td>
<td align="left">是</td>
<td align="left">0–59</td>
<td align="left"><code>*</code>,<code>-</code></td>
</tr>
<tr>
<td align="left">Hours</td>
<td align="left">是</td>
<td align="left">0–23</td>
<td align="left"><code>*</code>,<code>-</code></td>
</tr>
<tr>
<td align="left">Day of month</td>
<td align="left">是</td>
<td align="left">1–31</td>
<td align="left"><code>*</code>,<code>-</code></td>
</tr>
<tr>
<td align="left">Month</td>
<td align="left">是</td>
<td align="left">1–12 or JAN–DEC</td>
<td align="left"><code>*</code>,<code>-</code></td>
</tr>
<tr>
<td align="left">Day of week</td>
<td align="left">是</td>
<td align="left">0–6 or SUN–SAT</td>
<td align="left"><code>*</code>,<code>-</code></td>
</tr>
</tbody></table>
<p><code>/etc/crontab</code> 文件示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For details see man 4 crontabs</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name  <span class="built_in">command</span> to be executed</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每两个小时以root身份执行 /home/hello.sh 脚本</span></span><br><span class="line">0 */2 * * * root /home/hello.sh</span><br></pre></td></tr></table></figure>

<h3 id="crontab-实例"><a href="#crontab-实例" class="headerlink" title="crontab 实例"></a>crontab 实例</h3><h4 id="实例-1：每-1-分钟执行一次-myCommand"><a href="#实例-1：每-1-分钟执行一次-myCommand" class="headerlink" title="实例 1：每 1 分钟执行一次 myCommand"></a>实例 1：每 1 分钟执行一次 myCommand</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure>

<h4 id="实例-2：每小时的第-3-和第-15-分钟执行"><a href="#实例-2：每小时的第-3-和第-15-分钟执行" class="headerlink" title="实例 2：每小时的第 3 和第 15 分钟执行"></a>实例 2：每小时的第 3 和第 15 分钟执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure>

<h4 id="实例-3：在上午-8-点到-11-点的第-3-和第-15-分钟执行"><a href="#实例-3：在上午-8-点到-11-点的第-3-和第-15-分钟执行" class="headerlink" title="实例 3：在上午 8 点到 11 点的第 3 和第 15 分钟执行"></a>实例 3：在上午 8 点到 11 点的第 3 和第 15 分钟执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br></pre></td></tr></table></figure>

<h4 id="实例-4：每隔两天的上午-8-点到-11-点的第-3-和第-15-分钟执行"><a href="#实例-4：每隔两天的上午-8-点到-11-点的第-3-和第-15-分钟执行" class="headerlink" title="实例 4：每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行"></a>实例 4：每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br></pre></td></tr></table></figure>

<h4 id="实例-5：每周一上午-8-点到-11-点的第-3-和第-15-分钟执行"><a href="#实例-5：每周一上午-8-点到-11-点的第-3-和第-15-分钟执行" class="headerlink" title="实例 5：每周一上午 8 点到 11 点的第 3 和第 15 分钟执行"></a>实例 5：每周一上午 8 点到 11 点的第 3 和第 15 分钟执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br></pre></td></tr></table></figure>

<h4 id="实例-6：每晚的-21-30-重启-smb"><a href="#实例-6：每晚的-21-30-重启-smb" class="headerlink" title="实例 6：每晚的 21:30 重启 smb"></a>实例 6：每晚的 21:30 重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-7：每月-1、10、22-日的-4-45-重启-smb"><a href="#实例-7：每月-1、10、22-日的-4-45-重启-smb" class="headerlink" title="实例 7：每月 1、10、22 日的 4 : 45 重启 smb"></a>实例 7：每月 1、10、22 日的 4 : 45 重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-8：每周六、周日的-1-10-重启-smb"><a href="#实例-8：每周六、周日的-1-10-重启-smb" class="headerlink" title="实例 8：每周六、周日的 1 : 10 重启 smb"></a>实例 8：每周六、周日的 1 : 10 重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-9：每天-18-00-至-23-00-之间每隔-30-分钟重启-smb"><a href="#实例-9：每天-18-00-至-23-00-之间每隔-30-分钟重启-smb" class="headerlink" title="实例 9：每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 smb"></a>实例 9：每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-10：每星期六的晚上-11-00-pm-重启-smb"><a href="#实例-10：每星期六的晚上-11-00-pm-重启-smb" class="headerlink" title="实例 10：每星期六的晚上 11 : 00 pm 重启 smb"></a>实例 10：每星期六的晚上 11 : 00 pm 重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-11：每一小时重启-smb"><a href="#实例-11：每一小时重启-smb" class="headerlink" title="实例 11：每一小时重启 smb"></a>实例 11：每一小时重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h4 id="实例-12：晚上-11-点到早上-7-点之间，每隔一小时重启-smb"><a href="#实例-12：晚上-11-点到早上-7-点之间，每隔一小时重启-smb" class="headerlink" title="实例 12：晚上 11 点到早上 7 点之间，每隔一小时重启 smb"></a>实例 12：晚上 11 点到早上 7 点之间，每隔一小时重启 smb</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23-7 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html">crontab 定时任务</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/z_yong_cool/article/details/79288397">linux 定时执行脚本</a></li>
</ul>
</li>
<li><strong>在线工具</strong><ul>
<li><a target="_blank" rel="noopener" href="https://tool.lu/crontab/">https://tool.lu/crontab/</a></li>
<li><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/bbab00f1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/bbab00f1/" class="post-title-link" itemprop="url">效率提升方法论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T16:00:00+08:00">2020-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">工作</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E4%BD%9C/%E6%95%88%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">效能</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%B7%A5%E4%BD%9C/%E6%95%88%E8%83%BD/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="效率提升方法论"><a href="#效率提升方法论" class="headerlink" title="效率提升方法论"></a>效率提升方法论</h1><p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p>
<p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p>
<p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p>
<blockquote>
<p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p>
<p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p>
<p>——莎士比亚</p>
</blockquote>
<h2 id="做计划常用方法"><a href="#做计划常用方法" class="headerlink" title="做计划常用方法"></a>做计划常用方法</h2><table>
<thead>
<tr>
<th>名称</th>
<th>图示</th>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>时间法</td>
<td></td>
<td>时间顺序</td>
<td>清晰明确<br/>操作性强</td>
<td>时间分配不合理或<br/>突出情况容易打乱计划</td>
</tr>
<tr>
<td>清单法</td>
<td></td>
<td>重要程度</td>
<td>要事优先<br/>事无遗漏</td>
<td>未完成容易形成压力；<br/>容易造成形式主义，为打卡而完成</td>
</tr>
<tr>
<td>三段法</td>
<td></td>
<td>完成状态</td>
<td>态度明了<br/>有条不紊</td>
<td>灵活性差，只能电子版或软件实现编辑，<br/>纸质版事项会重复</td>
</tr>
<tr>
<td>OKR 法</td>
<td></td>
<td>目标分解</td>
<td>目标导向<br/>高效成事</td>
<td>适合复杂事情或大项目的分解执行跟进</td>
</tr>
<tr>
<td>分类法</td>
<td></td>
<td>八个方面</td>
<td>事事周全<br/>面面俱到</td>
<td>越是想顾周全，越难周全，<br/>面面俱到，也会事事难完成</td>
</tr>
<tr>
<td>四象限法</td>
<td><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200210173335.png" alt="img" style="zoom:25%;" /></td>
<td>轻重缓急</td>
<td>要事优先<br/>忽略次要</td>
<td>被要事牵着走，忽略了<br/>人生应该适度娱乐的重要性</td>
</tr>
<tr>
<td>甘特图法</td>
<td></td>
<td>日期进度</td>
<td>进度直观<br/>易于理解</td>
<td>进度条只能反映时间进度，<br/>无法反映事项具体完成情况的进度</td>
</tr>
<tr>
<td>PDCA 法</td>
<td></td>
<td>流程顺序</td>
<td>流程推进<br/>循环解决</td>
<td>流程化容易形成思维惯性，<br/>并且缺乏压力难以形成创造性</td>
</tr>
</tbody></table>
<h2 id="W2H"><a href="#W2H" class="headerlink" title="W2H"></a>W2H</h2><p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p>
<p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200210161837.png" alt="5W2H"></p>
<ul>
<li><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</li>
<li><strong>what</strong> - 是什么？目的是什么？作什么工作？</li>
<li><strong>where</strong> - 何处？在哪里做？从哪里入手？</li>
<li><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</li>
<li><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</li>
<li><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</li>
<li><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</li>
</ul>
<h2 id="四象限原则"><a href="#四象限原则" class="headerlink" title="四象限原则"></a>四象限原则</h2><p><strong>四象限原则是一种时间管理方式</strong>。</p>
<p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p>
<p>事情、任务太多，时间太少，分身乏术。</p>
<p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200210173335.png" alt="img"></p>
<ul>
<li><p><strong>第一象限（重要而紧急</strong>）</p>
<ul>
<li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li>
<li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li>
<li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li>
</ul>
</li>
<li><p><strong>第二象限（重要但不紧急）</strong></p>
<ul>
<li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li>
<li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li>
<li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li>
</ul>
</li>
<li><p><strong>第三象限（紧急但不重要）</strong></p>
<ul>
<li>案例：电话、会议、突发的访客都属于这一类。</li>
<li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li>
</ul>
</li>
<li><p><strong>第四象限（不紧急也不重要）</strong></p>
<ul>
<li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li>
<li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/85483ea6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/85483ea6/" class="post-title-link" itemprop="url">HBase 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-快速入门"><a href="#HBase-快速入门" class="headerlink" title="HBase 快速入门"></a>HBase 快速入门</h1><h2 id="HBase-简介"><a href="#HBase-简介" class="headerlink" title="HBase 简介"></a>HBase 简介</h2><h3 id="为什么需要-HBase"><a href="#为什么需要-HBase" class="headerlink" title="为什么需要 HBase"></a>为什么需要 HBase</h3><p>在介绍 HBase 之前，我们不妨先了解一下为什么需要 HBase，或者说 HBase 是为了达到什么目的而产生。</p>
<p>在 HBase 诞生之前，Hadoop 可以通过 HDFS 来存储结构化、半结构甚至非结构化的数据，它是传统数据库的补充，是海量数据存储的最佳方法，它针对大文件的存储，批量访问和流式访问都做了优化，同时也通过多副本解决了容灾问题。</p>
<p>Hadoop 的缺陷在于：它只能执行批处理，并且只能以顺序方式访问数据。这意味着即使是最简单的工作，也必须搜索整个数据集，即：<strong>Hadoop 无法实现对数据的随机访问</strong>。实现数据的随机访问是传统的关系型数据库所擅长的，但它们却不能用于海量数据的存储。在这种情况下，必须有一种新的方案来<strong>同时解决海量数据存储和随机访问的问题</strong>，HBase 就是其中之一 (HBase，Cassandra，CouchDB，Dynamo 和 MongoDB 都能存储海量数据并支持随机访问)。</p>
<blockquote>
<p>注：数据结构分类：</p>
<ul>
<li>结构化数据：即以关系型数据库表形式管理的数据；</li>
<li>半结构化数据：非关系模型的，有基本固定结构模式的数据，例如日志文件、XML 文档、JSON 文档、Email 等；</li>
<li>非结构化数据：没有固定模式的数据，如 WORD、PDF、PPT、EXL，各种格式的图片、视频等。</li>
</ul>
</blockquote>
<h3 id="什么是-HBase"><a href="#什么是-HBase" class="headerlink" title="什么是 HBase"></a>什么是 HBase</h3><p><strong>HBase 是一个构建在 HDFS（Hadoop 文件系统）之上的列式数据库</strong>。</p>
<p>HBase 是一种类似于 <code>Google’s Big Table</code> 的数据模型，它是 Hadoop 生态系统的一部分，它将数据存储在 HDFS 上，客户端可以通过 HBase 实现对 HDFS 上数据的随机访问。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601170449.png" alt="img"></p>
<p>HBase 的<strong>核心特性</strong>如下：</p>
<ul>
<li><strong>分布式</strong><ul>
<li><strong>伸缩性</strong>：支持通过增减机器进行水平扩展，以提升整体容量和性能</li>
<li><strong>高可用</strong>：支持 RegionServers 之间的自动故障转移</li>
<li><strong>自动分区</strong>：Region 分散在集群中，当行数增长的时候，Region 也会自动的分区再均衡</li>
</ul>
</li>
<li><strong>超大数据集</strong>：HBase 被设计用来读写超大规模的数据集（数十亿行至数百亿行的表）</li>
<li><strong>支持结构化、半结构化和非结构化的数据</strong>：由于 HBase 基于 HDFS 构建，所以和 HDFS 一样，支持结构化、半结构化和非结构化的数据</li>
<li><strong>非关系型数据库</strong><ul>
<li><strong>不支持标准 SQL 语法</strong></li>
<li><strong>没有真正的索引</strong></li>
<li><strong>不支持复杂的事务</strong>：只支持行级事务，即单行数据的读写都是原子性的</li>
</ul>
</li>
</ul>
<p>HBase 的其他特性</p>
<ul>
<li>读写操作遵循强一致性</li>
<li>过滤器支持谓词下推</li>
<li>易于使用的 Java 客户端 API</li>
<li>它支持线性和模块化可扩展性。</li>
<li>HBase 表支持 Hadoop MapReduce 作业的便捷基类</li>
<li>很容易使用 Java API 进行客户端访问</li>
<li>为实时查询提供块缓存 BlockCache 和布隆过滤器</li>
<li>它通过服务器端过滤器提供查询谓词下推</li>
</ul>
<h3 id="什么时候使用-HBase"><a href="#什么时候使用-HBase" class="headerlink" title="什么时候使用 HBase"></a>什么时候使用 HBase</h3><p>根据上一节对于 HBase 特性的介绍，我们可以梳理出 HBase 适用、不适用的场景：</p>
<p>HBase <strong>不适用场景</strong>：</p>
<ul>
<li>需要索引</li>
<li>需要复杂的事务</li>
<li>数据量较小（比如：数据量不足几百万行）</li>
</ul>
<p>HBase <strong>适用场景</strong>：</p>
<ul>
<li>能存储海量数据并支持随机访问（比如：数据量级达到十亿级至百亿级）</li>
<li>存储结构化、半结构化数据</li>
<li>硬件资源充足</li>
</ul>
<blockquote>
<p>一言以蔽之——HBase 适用的场景是：<strong>实时地随机访问超大数据集</strong>。</p>
</blockquote>
<p>HBase 的典型应用场景</p>
<ul>
<li>存储监控数据</li>
<li>存储用户&#x2F;车辆 GPS 信息</li>
<li>存储用户行为数据</li>
<li>存储各种日志数据，如：访问日志、操作日志、推送日志等。</li>
<li>存储短信、邮件等消息类数据</li>
<li>存储网页数据</li>
</ul>
<h3 id="HBase-数据模型简介"><a href="#HBase-数据模型简介" class="headerlink" title="HBase 数据模型简介"></a>HBase 数据模型简介</h3><p>前面已经提及，HBase 是一个列式数据库，其数据模型和关系型数据库有所不同。其数据模型的关键术语如下：</p>
<ul>
<li><strong>Table</strong> - HBase 表由多行组成。</li>
<li><strong>Row</strong> - HBase 中的一行由一个行键和一个或多个列以及与之关联的值组成。 行在存储时按行键的字母顺序排序。 为此，行键的设计非常重要。 目标是以相关行彼此靠近的方式存储数据。 常见的行键模式是网站域。 如果您的行键是域，您应该将它们反向存储（org.apache.www、org.apache.mail、org.apache.jira）。 这样，所有 Apache 域在表中彼此靠近，而不是根据子域的第一个字母展开。</li>
<li><strong>Column</strong> - HBase 中的列由列族和列限定符组成，它们由 :（冒号）字符分隔。</li>
<li><strong>Column Family</strong> - 通常出于性能原因，列族在物理上将一组列及其值放在一起。 每个列族都有一组存储属性，例如它的值是否应该缓存在内存中，它的数据是如何压缩的，它的行键是如何编码的，等等。 表中的每一行都有相同的列族，尽管给定的行可能不在给定的列族中存储任何内容。</li>
<li><strong>列限定符</strong> - 将列限定符添加到列族以提供给定数据片段的索引。 给定列族内容，列限定符可能是 content:html，另一个可能是 content:pdf。 尽管列族在表创建时是固定的，但列限定符是可变的，并且行之间可能有很大差异。</li>
<li><strong>Cell</strong> - 单元格是行、列族和列限定符的组合，包含一个值和一个时间戳，代表值的版本。</li>
<li><strong>Timestamp</strong> - 时间戳写在每个值旁边，是给定版本值的标识符。 默认情况下，时间戳表示写入数据时 RegionServer 上的时间，但您可以在将数据放入单元格时指定不同的时间戳值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551164224778.png" alt="img"></p>
<h3 id="特性比较"><a href="#特性比较" class="headerlink" title="特性比较"></a>特性比较</h3><h4 id="HBase-vs-RDBMS"><a href="#HBase-vs-RDBMS" class="headerlink" title="HBase vs. RDBMS"></a>HBase vs. RDBMS</h4><table>
<thead>
<tr>
<th>RDBMS</th>
<th>HBase</th>
</tr>
</thead>
<tbody><tr>
<td>RDBMS 有它的模式，描述表的整体结构的约束</td>
<td>HBase 无模式，它不具有固定列模式的概念；仅定义列族</td>
</tr>
<tr>
<td>支持的文件系统有 FAT、NTFS 和 EXT</td>
<td>支持的文件系统只有 HDFS</td>
</tr>
<tr>
<td>使用提交日志来存储日志</td>
<td>使用预写日志 (WAL) 来存储日志</td>
</tr>
<tr>
<td>使用特定的协调系统来协调集群</td>
<td>使用 ZooKeeper 来协调集群</td>
</tr>
<tr>
<td>存储的都是中小规模的数据表</td>
<td>存储的是超大规模的数据表，并且适合存储宽表</td>
</tr>
<tr>
<td>通常支持复杂的事务</td>
<td>仅支持行级事务</td>
</tr>
<tr>
<td>适用于结构化数据</td>
<td>适用于半结构化、结构化数据</td>
</tr>
<tr>
<td>使用主键</td>
<td>使用 row key</td>
</tr>
</tbody></table>
<h4 id="HBase-vs-HDFS"><a href="#HBase-vs-HDFS" class="headerlink" title="HBase vs. HDFS"></a>HBase vs. HDFS</h4><table>
<thead>
<tr>
<th>HDFS</th>
<th>HBase</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS 提供了一个用于分布式存储的文件系统。</td>
<td>HBase 提供面向表格列的数据存储。</td>
</tr>
<tr>
<td>HDFS 为大文件提供优化存储。</td>
<td>HBase 为表格数据提供了优化。</td>
</tr>
<tr>
<td>HDFS 使用块文件。</td>
<td>HBase 使用键值对数据。</td>
</tr>
<tr>
<td>HDFS 数据模型不灵活。</td>
<td>HBase 提供了一个灵活的数据模型。</td>
</tr>
<tr>
<td>HDFS 使用文件系统和处理框架。</td>
<td>HBase 使用带有内置 Hadoop MapReduce 支持的表格存储。</td>
</tr>
<tr>
<td>HDFS 主要针对一次写入多次读取进行了优化。</td>
<td>HBase 针对读&#x2F;写许多进行了优化。</td>
</tr>
</tbody></table>
<h4 id="行式数据库-vs-列式数据库"><a href="#行式数据库-vs-列式数据库" class="headerlink" title="行式数据库 vs. 列式数据库"></a>行式数据库 vs. 列式数据库</h4><table>
<thead>
<tr>
<th>行式数据库</th>
<th>列式数据库</th>
</tr>
</thead>
<tbody><tr>
<td>对于添加&#x2F;修改操作更高效</td>
<td>对于读取操作更高效</td>
</tr>
<tr>
<td>读取整行数据</td>
<td>仅读取必要的列数据</td>
</tr>
<tr>
<td>最适合在线事务处理系统（OLTP）</td>
<td>不适合在线事务处理系统（OLTP）</td>
</tr>
<tr>
<td>将行数据存储在连续的页内存中</td>
<td>将列数据存储在非连续的页内存中</td>
</tr>
</tbody></table>
<p>列式数据库的优点：</p>
<ul>
<li>支持数据压缩</li>
<li>支持快速数据检索</li>
<li>简化了管理和配置</li>
<li>有利于聚合查询（例如 COUNT、SUM、AVG、MIN 和 MAX）的高性能</li>
<li>分区效率很高，因为它提供了自动分片机制的功能，可以将较大的区域分配给较小的区域</li>
</ul>
<p>列式数据库的缺点：</p>
<ul>
<li>JOIN 查询和来自多个表的数据未优化</li>
<li>必须为频繁的删除和更新创建拆分，因此降低了存储效率</li>
<li>由于非关系数据库的特性，分区和索引的设计非常困难</li>
</ul>
<h2 id="HBase-安装"><a href="#HBase-安装" class="headerlink" title="HBase 安装"></a>HBase 安装</h2><p>HBase 安装可以参考以下文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html#quickstart">独立模式</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html#quickstart_pseudo">伪分布式模式</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html#quickstart_fully_distributed">全分布式模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/big-data-europe/docker-hbase">Docker 部署</a></li>
</ul>
<h2 id="HBase-Hello-World-示例"><a href="#HBase-Hello-World-示例" class="headerlink" title="HBase Hello World 示例"></a>HBase Hello World 示例</h2><p>（1）连接 HBase</p>
<p>在 HBase 安装目录的 <code>/bin</code> 目录下执行 <code>hbase shell</code> 命令进入 HBase 控制台。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/hbase shell</span></span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure>

<p>（2）输入 <code>help</code> 可以查看 HBase Shell 命令。</p>
<p>（3）创建表</p>
<p>可以使用 <code>create</code> 命令创建一张新表。必须要指定表名和 Column Family。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &#x27;test&#x27;, &#x27;cf&#x27;</span><br><span class="line">0 row(s) in 0.4170 seconds</span><br><span class="line"></span><br><span class="line">=&gt; Hbase::Table - test</span><br></pre></td></tr></table></figure>

<p>（4）列出表信息</p>
<p>使用 <code>list</code> 命令来确认新建的表已存在。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; list &#x27;test&#x27;</span><br><span class="line">TABLE</span><br><span class="line">test</span><br><span class="line">1 row(s) in 0.0180 seconds</span><br><span class="line"></span><br><span class="line">=&gt; [&quot;test&quot;]</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>describe</code> 命令可以查看表的细节信息，包括配置信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; describe &#x27;test&#x27;</span><br><span class="line">Table test is ENABLED</span><br><span class="line">test</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;cf&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt;</span><br><span class="line">&#x27;false&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;f</span><br><span class="line">alse&#x27;, IN_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE</span><br><span class="line"> =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.9998 seconds</span><br></pre></td></tr></table></figure>

<p>（5）向表中写数据</p>
<p>可以使用 <code>put</code> 命令向 HBase 表中写数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; put &#x27;test&#x27;, &#x27;row1&#x27;, &#x27;cf:a&#x27;, &#x27;value1&#x27;</span><br><span class="line">0 row(s) in 0.0850 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):004:0&gt; put &#x27;test&#x27;, &#x27;row2&#x27;, &#x27;cf:b&#x27;, &#x27;value2&#x27;</span><br><span class="line">0 row(s) in 0.0110 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):005:0&gt; put &#x27;test&#x27;, &#x27;row3&#x27;, &#x27;cf:c&#x27;, &#x27;value3&#x27;</span><br><span class="line">0 row(s) in 0.0100 seconds</span><br></pre></td></tr></table></figure>

<p>（6）一次性扫描表的所有数据</p>
<p>使用 <code>scan</code> 命令来扫描表数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):006:0&gt; scan &#x27;test&#x27;</span><br><span class="line">ROW                                      COLUMN+CELL</span><br><span class="line"> row1                                    column=cf:a, timestamp=1421762485768, value=value1</span><br><span class="line"> row2                                    column=cf:b, timestamp=1421762491785, value=value2</span><br><span class="line"> row3                                    column=cf:c, timestamp=1421762496210, value=value3</span><br><span class="line">3 row(s) in 0.0230 seconds</span><br></pre></td></tr></table></figure>

<p>（7）查看一行数据</p>
<p>使用 <code>get</code> 命令可以查看一行表数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):007:0&gt; get &#x27;test&#x27;, &#x27;row1&#x27;</span><br><span class="line">COLUMN                                   CELL</span><br><span class="line"> cf:a                                    timestamp=1421762485768, value=value1</span><br><span class="line">1 row(s) in 0.0350 seconds</span><br></pre></td></tr></table></figure>

<p>（8）禁用表</p>
<p>如果想要删除表或修改表设置，必须先使用 <code>disable</code> 命令禁用表。如果想再次启用表，可以使用 <code>enable</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&gt; disable &#x27;test&#x27;</span><br><span class="line">0 row(s) in 1.1820 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):009:0&gt; enable &#x27;test&#x27;</span><br><span class="line">0 row(s) in 0.1770 seconds</span><br></pre></td></tr></table></figure>

<p>（9）删除表</p>
<p>使用 <code>drop</code> 命令可以删除表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):011:0&gt; drop &#x27;test&#x27;</span><br><span class="line">0 row(s) in 0.1370 seconds</span><br></pre></td></tr></table></figure>

<p>（10）退出 HBase Shell</p>
<p>使用 <code>quit</code> 命令，就能退出 HBase Shell 控制台。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://hbase.apache.org/">HBase 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html">HBase 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://abloz.com/hbase/book.html">HBase 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27600204/">Hadoop 权威指南</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a target="_blank" rel="noopener" href="https://mapr.com/blog/in-depth-look-hbase-architecture">An In-Depth Look at the HBase Architecture</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cloudduggu.com/hbase/introduction/">https://www.cloudduggu.com/hbase/introduction/</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c02058fe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c02058fe/" class="post-title-link" itemprop="url">Nosql 技术选型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-09 02:18:58" itemprop="dateCreated datePublished" datetime="2020-02-09T02:18:58+08:00">2020-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">数据库综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Nosql-技术选型"><a href="#Nosql-技术选型" class="headerlink" title="Nosql 技术选型"></a>Nosql 技术选型</h1><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209020702.png" alt="img"></p>
<h2 id="Nosql-简介"><a href="#Nosql-简介" class="headerlink" title="Nosql 简介"></a>Nosql 简介</h2><p>传统的关系型数据库存在以下缺点：</p>
<ul>
<li><strong>大数据场景下 I&#x2F;O 较高</strong> - 因为数据是按行存储，即使只针对其中某一列进行运算，关系型数据库也会将整行数据从存储设备中读入内存，导致 I&#x2F;O 较高。</li>
<li>存储的是行记录，<strong>无法存储数据结构</strong>。</li>
<li><strong>表结构 schema 扩展不方便</strong> - 如要需要修改表结构，需要执行执行 DDL(data definition language)，语句修改，修改期间会导致锁表，部分服务不可用。</li>
<li><strong>全文搜索功能较弱</strong> - 关系型数据库下只能够进行子字符串的匹配查询，当表的数据逐渐变大的时候，<code>LIKE</code> 查询的匹配会非常慢，即使在有索引的情况下。况且关系型数据库也不应该对文本字段进行索引。</li>
<li><strong>存储和处理复杂关系型数据功能较弱</strong> - 许多应用程序需要了解和导航高度连接数据之间的关系，才能启用社交应用程序、推荐引擎、欺诈检测、知识图谱、生命科学和 IT&#x2F;网络等用例。然而传统的关系数据库并不善于处理数据点之间的关系。它们的表格数据模型和严格的模式使它们很难添加新的或不同种类的关联信息。</li>
</ul>
<p>随着大数据时代的到来，越来越多的网站、应用系统需要支撑海量数据存储，高并发请求、高可用、高可扩展性等特性要求。传统的关系型数据库在应付这些调整已经显得力不从心，暴露了许多能以克服的问题。由此，各种各样的 NoSQL（Not Only SQL）数据库作为传统关系型数据的一个有力补充得到迅猛发展。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209005228.png" alt="nosql-history"></p>
<p><strong>NoSQL，泛指非关系型的数据库</strong>，可以理解为 SQL 的一个有力补充。</p>
<p>在 NoSQL 许多方面性能大大优于非关系型数据库的同时，往往也伴随一些特性的缺失，比较常见的，是事务库事务功能的缺失。 数据库事务正确执行的四个基本要素：ACID 如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">Atomicity （原子性）</td>
<td align="center">一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。 事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">Consistency 一致性</td>
<td align="center">在事务开始之前和事务结束以后，数据的数据的一致性约束没有被破坏。</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">Isolation 隔离性</td>
<td align="center">数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">Durability 持久性</td>
<td align="center">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td>
</tr>
</tbody></table>
<p>下面介绍 5 大类 NoSQL 数据针对传统关系型数据库的缺点提供的解决方案：</p>
<h2 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h2><p>列式数据库是以列相关存储架构进行数据存储的数据库，主要<strong>适合于批量数据处理和即时查询</strong>。</p>
<p>相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。</p>
<p>基于列式数据库的列列存储特性，可以<strong>解决某些特定场景下关系型数据库 I&#x2F;O 较高的问题</strong>。</p>
<h3 id="列式数据库原理"><a href="#列式数据库原理" class="headerlink" title="列式数据库原理"></a>列式数据库原理</h3><p>传统关系型数据库是按照行来存储数据库，称为“行式数据库”，而列式数据库是按照列来存储数据。</p>
<p>将表放入存储系统中有两种方法，而我们绝大部分是采用行存储的。 行存储法是将各行放入连续的物理位置，这很像传统的记录和文件系统。 列存储法是将数据按照列存储到数据库中，与行存储类似，下图是两种存储方法的图形化解释：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209005316.png" alt="按行存储和按列存储模式"></p>
<h3 id="列式数据库产品"><a href="#列式数据库产品" class="headerlink" title="列式数据库产品"></a>列式数据库产品</h3><ul>
<li><p>HBase</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e88bddc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HBase"></p>
<p>HBase 是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的 BigTable 建模，实现的编程语言为 Java。它是 Apache 软件基金会的 Hadoop 项目的一部分，运行于 HDFS 文件系统之上，为 Hadoop 提供类似于 BigTable 规模的服务。因此，它可以容错地存储海量稀疏的数据。</p>
</li>
<li><p>BigTable</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e9147edf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>BigTable 是一种压缩的、高性能的、高可扩展性的，基于 Google 文件系统（Google File System，GFS）的数据存储系统，用于存储大规模结构化数据，适用于云端计算。</p>
</li>
</ul>
<h3 id="列式数据库特性"><a href="#列式数据库特性" class="headerlink" title="列式数据库特性"></a>列式数据库特性</h3><p>优点如下：</p>
<ul>
<li><strong>高效的储存空间利用率</strong></li>
</ul>
<p>列式数据库由于其针对不同列的数据特征而发明的不同算法，使其<strong>往往有比行式数据库高的多的压缩率</strong>，普通的行式数据库一般压缩率在 3：1 到 5：1 左右，而列式数据库的压缩率一般在 8：1 到 30：1 左右。 比较常见的，通过字典表压缩数据： 下面中才是那张表本来的样子。经过字典表进行数据压缩后，表中的字符串才都变成数字了。正因为每个字符串在字典表里只出现一次了，所以达到了压缩的目的（有点像规范化和非规范化 Normalize 和 Denomalize)</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209005406.png" alt="通过字典表压缩数据"></p>
<ul>
<li><strong>查询效率高</strong></li>
</ul>
<p>读取多条数据的同一列效率高，因为这些列都是存储在一起的，一次磁盘操作可以数据的指定列全部读取到内存中。 下图通过一条查询的执行过程说明列式存储（以及数据压缩）的优点</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209005611.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行步骤如下：</span><br><span class="line"><span class="selector-tag">i</span>. 去字典表里找到字符串对应数字（只进行一次字符串比较）。</span><br><span class="line">ii. 用数字去列表里匹配，匹配上的位置设为 <span class="number">1</span>。</span><br><span class="line">iii. 把不同列的匹配结果进行位运算得到符合所有条件的记录下标。</span><br><span class="line">iv. 使用这个下标组装出最终的结果集。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>适合做聚合操作</strong></li>
<li><strong>适合大量的数据而不是小数据</strong></li>
</ul>
<p>缺点如下：</p>
<ul>
<li>不适合扫描小量数据</li>
<li>不适合随机的更新</li>
<li>不适合做含有删除和更新的实时操作</li>
<li>单行的数据是 ACID 的，多行的事务时，不支持事务的正常回滚，支持 I(Isolation) 隔离性（事务串行提交），D(Durability) 持久性，不能保证 A(Atomicity) 原子性， C(Consistency) 一致性</li>
</ul>
<h3 id="列式数据库使用场景"><a href="#列式数据库使用场景" class="headerlink" title="列式数据库使用场景"></a>列式数据库使用场景</h3><p>以 HBase 为例说明：</p>
<ul>
<li><strong>大数据量</strong> （100s TB 级数据） 且有快速随机访问的需求。增长量无法预估的应用，需要进行优雅的数据扩展的 HBase 支持在线扩展，即使在一段时间内数据量呈井喷式增长，也可以通过 HBase 横向扩展来满足功能。</li>
<li><strong>写密集型</strong>应用，每天写入量巨大，而相对读数量较小的应用 比如 IM 的历史消息，游戏的日志等等</li>
<li><strong>不需要复杂查询条件</strong>来查询数据的应用 HBase 只支持基于 rowkey 的查询，对于 HBase 来说，单条记录或者小范围的查询是可以接受的，大范围的查询由于分布式的原因，可能在性能上有点影响，HBase 不适用于有 join，多级索引，表关系复杂的数据模型。</li>
<li><strong>对性能和可靠性要求非常高</strong>的应用，由于 HBase 本身没有单点故障，可用性非常高。</li>
<li><strong>存储结构化和半结构化的数据</strong>。</li>
</ul>
<h2 id="K-V-数据库"><a href="#K-V-数据库" class="headerlink" title="K-V 数据库"></a>K-V 数据库</h2><p><strong>K-V 数据库指的是使用键值 (key-value) 存储的数据库，其数据按照键值对的形式进行组织、索引和存储</strong>。</p>
<p>KV 存储非常适合存储<strong>不涉及过多数据关系业务关系的数据</strong>，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够<strong>解决关系型数据库无法存储数据结构的问题</strong>。</p>
<h3 id="K-V-数据库产品"><a href="#K-V-数据库产品" class="headerlink" title="K-V 数据库产品"></a>K-V 数据库产品</h3><ul>
<li><p>Redis</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209010410.png" alt="img"></p>
<p>Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从 2015 年 6 月开始，Redis 的开发由 Redis Labs 赞助，而 2013 年 5 月至 2015 年 6 月期间，其开发由 Pivotal 赞助。在 2013 年 5 月之前，其开发由 VMware 赞助。根据月度排行网站 DB-Engines.com 的数据显示，Redis 是最流行的键值对存储数据库。</p>
</li>
<li><p>Cassandra</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209010451.png" alt="img"></p>
<p>Apache Cassandra（社区内一般简称为 C*）是一套开源分布式 NoSQL 数据库系统。它最初由 Facebook 开发，用于储存收件箱等简单格式数据，集 Google BigTable 的数据模型与 Amazon Dynamo 的完全分布式架构于一身。Facebook 于 2008 将 Cassandra 开源，此后，由于 Cassandra 良好的可扩展性和性能，被 Apple, Comcast,Instagram, Spotify, eBay, Rackspace, Netflix 等知名网站所采用，成为了一种流行的分布式结构化数据存储方案。</p>
</li>
<li><p>LevelDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209011140.png" alt="img"></p>
<p>LevelDB 是一个由 Google 公司所研发的键／值对（Key&#x2F;Value Pair）嵌入式数据库管理系统编程库， 以开源的 BSD 许可证发布。</p>
</li>
</ul>
<h3 id="K-V-数据库特性"><a href="#K-V-数据库特性" class="headerlink" title="K-V 数据库特性"></a>K-V 数据库特性</h3><p>以 Redis 为例：</p>
<p>优点如下：</p>
<ul>
<li><strong>性能极高</strong> - Redis 能支持超过 10W 的 TPS。</li>
<li><strong>丰富的数据类型</strong> - Redis 支持包括 String，Hash，List，Set，Sorted Set，Bitmap 和 hyperloglog。</li>
<li><strong>丰富的特性</strong> - Redis 还支持 publish&#x2F;subscribe、通知、key 过期等等特性。</li>
</ul>
<p>缺点如下： 针对 ACID，Redis 事务不能支持原子性和持久性 (A 和 D)，只支持隔离性和一致性 (I 和 C) 特别说明一下，这里所说的无法保证原子性，是针对 Redis 的事务操作，因为事务是不支持回滚（roll back），而因为 Redis 的单线程模型，<strong>Redis 的普通操作是原子性的</strong>。</p>
<p>大部分业务不需要严格遵循 ACID 原则，例如游戏实时排行榜，粉丝关注等场景，即使部分数据持久化失败，其实业务影响也非常小。因此在设计方案时，需要根据业务特征和要求来做选择</p>
<h3 id="K-V-数据库使用场景"><a href="#K-V-数据库使用场景" class="headerlink" title="K-V 数据库使用场景"></a>K-V 数据库使用场景</h3><ul>
<li><p><strong>适用场景</strong> - 储存用户信息（比如会话）、配置文件、参数、购物车等等。这些信息一般都和 ID（键）挂钩。</p>
</li>
<li><p><strong>不适用场景</strong></p>
<ul>
<li>需要通过值来查询，而不是键来查询。Key-Value 数据库中根本没有通过值查询的途径。</li>
<li>需要储存数据之间的关系。在 Key-Value 数据库中不能通过两个或以上的键来关联数据</li>
<li>需要事务的支持。在 Key-Value 数据库中故障产生时不可以进行回滚。</li>
</ul>
</li>
</ul>
<h2 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h2><p>文档数据库（也称为文档型数据库）是<strong>旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题</strong>。文档数据库<strong>通常以 JSON 或 XML 格式存储数据</strong>。</p>
<p>由于文档数据库的 no-schema 特性，可以存储和读取任意数据。由于使用的数据格式是 JSON 或者 XML，无需在使用前定义字段，读取一个 JSON 中不存在的字段也不会导致 SQL 那样的语法错误。</p>
<h3 id="文档数据库产品"><a href="#文档数据库产品" class="headerlink" title="文档数据库产品"></a>文档数据库产品</h3><ul>
<li><p>MongoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209012320.png" alt="img"></p>
<p>**MongoDB **是一种面向文档的数据库管理系统，由 C++ 撰写而成，以此来解决应用程序开发社区中的大量现实问题。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。</p>
</li>
<li><p>CouchDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209012418.png" alt="img"></p>
<p>Apache CouchDB 是一个开源数据库，专注于易用性和成为”<strong>完全拥抱 web 的数据库</strong>“。它是一个使用 JSON 作为存储格式，JavaScript 作为查询语言，MapReduce 和 HTTP 作为 API 的 NoSQL 数据库。其中一个显著的功能就是多主复制。CouchDB 的第一个版本发布在 2005 年，在 2008 年成为了 Apache 的项目。</p>
</li>
</ul>
<h3 id="文档数据库特性"><a href="#文档数据库特性" class="headerlink" title="文档数据库特性"></a>文档数据库特性</h3><p>以 MongoDB 为例进行说明</p>
<p>优点如下：</p>
<ul>
<li><strong>容易存储复杂数据结构</strong> - JSON 是一种强大的描述语言，能够描述复杂的数据结构。</li>
<li><strong>容易变更数据结构</strong> - 无需像关系型数据库一样先执行 DDL 语句修改表结构，程序代码直接读写即可。</li>
<li><strong>容易兼容历史数据</strong> - 对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码兼容处理即可。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong><ul>
<li>Atomicity（原子性） 仅支持单行&#x2F;文档级原子性，不支持多行、多文档、多语句原子性。</li>
<li>Isolation（隔离性） 隔离级别仅支持已提交读（Read committed）级别，可能导致不可重复读，幻读的问题。</li>
</ul>
</li>
<li><strong>不支持复杂查询</strong> - 例如 join 查询，如果需要 join 查询，需要多次操作数据库。</li>
</ul>
<p>MongonDB 还是支持多文档事务的 Consistency（一致性）和 Durability（持久性）</p>
<p>虽然官方宣布 MongoDB 将在 4.0 版本中正式推出多文档 ACID 事务支持，最后落地情况还有待见证。</p>
<h3 id="文档数据库使用场景"><a href="#文档数据库使用场景" class="headerlink" title="文档数据库使用场景"></a>文档数据库使用场景</h3><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>大数据量，且未来数据增长很快</strong></li>
<li><strong>表结构不明确，且字段在不断增加</strong>，例如内容管理系统，信息管理系统</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>支持事务</strong> - 在不同的文档上需要添加事务。Document-Oriented 数据库并不支持文档间的事务</li>
<li><strong>支持复杂查询</strong> - 多个文档直接需要复杂查询，例如 join</li>
</ul>
<h2 id="全文搜索引擎"><a href="#全文搜索引擎" class="headerlink" title="全文搜索引擎"></a>全文搜索引擎</h2><p>传统关系型数据库主要通过索引来达到快速查询的目的，在全文搜索的业务下，索引也无能为力，主要体现在：</p>
<ul>
<li>全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量非常多</li>
<li>全文搜索的模糊匹配方式，索引无法满足，只能用 <code>LIKE</code> 查询，而 <code>LIKE</code> 查询是整表扫描，效率非常低</li>
</ul>
<p>而全文搜索引擎的出现，正是<strong>解决关系型数据库全文搜索功能较弱的问题</strong>。</p>
<h3 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h3><p>全文搜索引擎的技术原理称为 **<code>倒排索引（inverted index）</code>**，是一种索引方法，其基本原理是建立单词到文档的索引。与之相对是，是“正排索引”，其基本原理是建立文档到单词的索引。</p>
<p>现在有如下文档集合：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209014530.png" alt="img"></p>
<p>正排索引得到索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209014723.png" alt="img"></p>
<p>可见，正排索引适用于根据文档名称查询文档内容</p>
<p>简单的倒排索引如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2750634bc?imageslim" alt="img"></p>
<p>带有单词频率信息的倒排索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209014842.png" alt="img"></p>
<p>可见，倒排索引适用于根据关键词来查询文档内容</p>
<h3 id="搜索引擎产品"><a href="#搜索引擎产品" class="headerlink" title="搜索引擎产品"></a>搜索引擎产品</h3><ul>
<li><p>Elasticsearch</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a27ea53fae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Elasticsearch 是一个基于 Lucene 的搜索引擎。它提供了一个分布式，多租户 -能够全文搜索与发动机 HTTP Web 界面和无架构 JSON 文件。Elasticsearch 是用 Java 开发的，并根据 Apache License 的条款作为开源发布。根据 DB-Engines 排名，Elasticsearch 是最受欢迎的企业搜索引擎，后面是基于 Lucene 的 Apache Solr。</p>
</li>
<li><p>Solr</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209014947.png" alt="img"></p>
<p>Solr 是 Apache Lucene 项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如 Word、PDF）的处理。Solr 是高度可扩展的，并提供了分布式搜索和索引复制</p>
</li>
</ul>
<h3 id="搜索引擎特性"><a href="#搜索引擎特性" class="headerlink" title="搜索引擎特性"></a>搜索引擎特性</h3><p>以 Elasticsearch 为例： 优点如下：</p>
<ul>
<li><strong>查询效率高</strong> - 对海量数据进行近实时的处理</li>
<li><strong>可扩展性</strong> - 基于集群环境可以方便横向扩展，可以承载 PB 级数据</li>
<li><strong>高可用</strong> - Elasticsearch 集群弹性-他们将发现新的或失败的节点，重组和重新平衡数据，确保数据是安全的和可访问的</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong> - 单一文档的数据是 ACID 的，包含多个文档的事务时不支持事务的正常回滚，支持 I(Isolation) 隔离性（基于乐观锁机制的），D(Durability) 持久性，<strong>不支持 A(Atomicity) 原子性，C(Consistency) 一致性</strong></li>
<li>对类似数据库中通过外键的复杂的多表关联操作支持较弱。</li>
<li><strong>读写有一定延时</strong>，写入的数据，最快 1s 中能被检索到</li>
<li><strong>更新性能较低</strong>，底层实现是先删数据，再插入新数据</li>
<li><strong>内存占用大</strong>，因为 Lucene 将索引部分加载到内存中</li>
</ul>
<h3 id="搜索引擎场景"><a href="#搜索引擎场景" class="headerlink" title="搜索引擎场景"></a>搜索引擎场景</h3><p>适用场景如下：</p>
<ul>
<li><strong>搜索引擎和数据分析引擎</strong> - 全文检索，结构化检索，数据分析</li>
<li><strong>对海量数据进行近实时的处理</strong> - 可以将海量数据分散到多台服务器上去存储和检索</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li><strong>数据需要频繁更新</strong></li>
<li><strong>需要复杂关联查询</strong></li>
</ul>
<h2 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209015751.png" alt="img"></p>
<p><strong>图形数据库应用图论存储实体之间的关系信息</strong>。最常见例子就是社会网络中人与人之间的关系。关系型数据库用于存储“关系型”数据的效果并不好，其查询复杂、缓慢、超出预期，而图形数据库的独特设计恰恰弥补了这个缺陷，解决关系型数据库存储和处理复杂关系型数据功能较弱的问题。</p>
<h3 id="图数据库产品"><a href="#图数据库产品" class="headerlink" title="图数据库产品"></a>图数据库产品</h3><ul>
<li><p>Neo4j</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209015817.png" alt="img"></p>
<p>Neo4j 是由 Neo4j，Inc。开发的图形数据库管理系统。由其开发人员描述为具有原生图存储和处理的符合 ACID 的事务数据库，根据 DB-Engines 排名， Neo4j 是最流行的图形数据库。</p>
</li>
<li><p>ArangoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209015858.png" alt="img"></p>
<p>ArangoDB 是由 triAGENS GmbH 开发的原生多模型数据库系统。数据库系统支持三个重要的数据模型（键&#x2F;值，文档，图形），其中包含一个数据库核心和统一查询语言 AQL（ArangoDB 查询语言）。查询语言是声明性的，允许在单个查询中组合不同的数据访问模式。ArangoDB 是一个 NoSQL 数据库系统，但 AQL 在很多方面与 SQL 类似。</p>
</li>
<li><p>Titan</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200209015923.png" alt="img"></p>
<p>Titan 是一个可扩展的图形数据库，针对存储和查询包含分布在多机群集中的数百亿个顶点和边缘的图形进行了优化。Titan 是一个事务性数据库，可以支持数千个并发用户实时执行复杂的图形遍历。</p>
</li>
</ul>
<h3 id="图数据库特性"><a href="#图数据库特性" class="headerlink" title="图数据库特性"></a>图数据库特性</h3><p>以 Neo4j 为例：</p>
<p>Neo4j 使用数据结构中图（graph）的概念来进行建模。 Neo4j 中两个最基本的概念是节点和边。节点表示实体，边则表示实体之间的关系。节点和边都可以有自己的属性。不同实体通过各种不同的关系关联起来，形成复杂的对象图。</p>
<p>针对关系数据，2 种 2 数据库的存储结构不同：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b2cebaf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="2 种存储结构"></p>
<p>Neo4j 中，存储节点时使用了”index-free adjacency”，即每个节点都有指向其邻居节点的指针，可以让我们在 O(1) 的时间内找到邻居节点。另外，按照官方的说法，在 Neo4j 中边是最重要的，是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b3a0f7b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如下优点：</p>
<ul>
<li><strong>高性能</strong> - 图的遍历是图数据结构所具有的独特算法，即从一个节点开始，根据其连接的关系，可以快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索</li>
<li><strong>设计的灵活性</strong> - 数据结构的自然伸展特性及其非结构化的数据格式，让图数据库设计可以具有很大的伸缩性和灵活性。因为随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用</li>
<li><strong>开发的敏捷性</strong> - 直观明了的数据模型，从需求的讨论开始，到程序开发和实现，以及最终保存在数据库中的样子，它的模样似乎没有什么变化，甚至可以说本来就是一模一样的</li>
<li><strong>完全支持 ACID</strong> - 不像别的 NoSQL 数据库 Neo4j 还具有完全事务管理特性，完全支持 ACID 事务管理</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>存在支持节点，关系和属性的数量的限制。</li>
<li>不支持拆分。</li>
</ul>
<h3 id="图数据库场景"><a href="#图数据库场景" class="headerlink" title="图数据库场景"></a>图数据库场景</h3><p>适用场景如下：</p>
<ul>
<li>关系性强的数据中，如社交网络</li>
<li>推荐引擎。如果我们将数据以图的形式表现，那么将会非常有益于推荐的制定</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li>记录大量基于事件的数据（例如日志条目或传感器数据）</li>
<li>对大规模分布式数据进行处理</li>
<li>保存在关系型数据库中的结构化数据</li>
<li>二进制数据存储</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关系型数据库和 NoSQL 数据库的选型，往往需要考虑几个指标：</p>
<ul>
<li>数据量</li>
<li>并发量</li>
<li>实时性</li>
<li>一致性要求</li>
<li>读写分布和类型</li>
<li>安全性</li>
<li>运维成本</li>
</ul>
<p>常见软件系统数据库选型参考如下：</p>
<ul>
<li><strong>中后台管理型系统</strong> - 如运营系统，数据量少，并发量小，首选关系型数据库。</li>
<li><strong>大流量系统</strong> - 如电商单品页，后台考虑选关系型数据库，前台考虑选内存型数据库。</li>
<li><strong>日志型系统</strong> - 原始数据考虑选列式数据库，日志搜索考虑选搜索引擎。</li>
<li><strong>搜索型系统</strong> - 例如站内搜索，非通用搜索，如商品搜索，后台考虑选关系型数据库，前台考虑选搜索引擎。</li>
<li><strong>事务型系统</strong> - 如库存，交易，记账，考虑选关系型数据库+K-V 数据库（作为缓存）+分布式事务。</li>
<li><strong>离线计算</strong> - 如大量数据分析，考虑选列式数据库或关系型数据。</li>
<li><strong>实时计算</strong> - 如实时监控，可以考虑选内存型数据库或者列式数据库。</li>
</ul>
<p>设计实践中，要基于需求、业务驱动架构，无论选用 RDB&#x2F;NoSQL&#x2F;DRDB, <strong>一定是以需求为导向，最终数据存储方案必然是各种权衡的综合性设计</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d62ddf265da0f491bd200">NoSQL 还是 SQL ？这一篇讲清楚</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/33/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/blog/page/35/">35</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/35/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"8b7ba8093d6f261ec293f877ef48b05d"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
