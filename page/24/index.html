<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/24/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/24/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/24/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3610064d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3610064d/" class="post-title-link" itemprop="url">面向对象原则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-19 09:49:05" itemprop="dateCreated datePublished" datetime="2021-05-19T09:49:05+08:00">2021-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>642</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象设计六大原则"><a href="#面向对象设计六大原则" class="headerlink" title="面向对象设计六大原则"></a>面向对象设计六大原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。</p>
<p>简单点说，<strong>一个类，最好只负责一件事。</strong></p>
<h2 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h2><p>开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。</p>
<p>对于扩展是开放的；对于更改是封闭的。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则（Liskov Substitution Principle），子类可以替换父类。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
<p>关键点：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<ul>
<li>客户端不应依赖它不需要的接口</li>
<li>类间的依赖关系应该建立在最小的接口上</li>
</ul>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<p>一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">《Head First 设计模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">《大话设计模式》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/274214a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/274214a7/" class="post-title-link" itemprop="url">SpringBoot 之安全快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-13 18:21:56" itemprop="dateCreated datePublished" datetime="2021-05-13T18:21:56+08:00">2021-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">Spring安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>528</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringBoot-之安全快速入门"><a href="#SpringBoot-之安全快速入门" class="headerlink" title="SpringBoot 之安全快速入门"></a>SpringBoot 之安全快速入门</h1><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>（1）添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）添加配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.security.user.name</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">spring.security.user.password</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">spring.security.user.roles</span> = <span class="string">USER</span></span><br></pre></td></tr></table></figure>

<p>（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root&#x2F;root）即可访问应用页面。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/image-20191118150326556.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3a4a05d9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3a4a05d9/" class="post-title-link" itemprop="url">低代码平台</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-06 16:57:48" itemprop="dateCreated datePublished" datetime="2021-05-06T16:57:48+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计一个低代码平台"><a href="#设计一个低代码平台" class="headerlink" title="设计一个低代码平台"></a>设计一个低代码平台</h1><blockquote>
<p>本文目标是设计一个用于提高开发人员开发效率的低代码平台，这里会采用系统解决方案设计的一般思路来逐步探寻设计方案。</p>
</blockquote>
<h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h2><h3 id="低代码平台是什么"><a href="#低代码平台是什么" class="headerlink" title="低代码平台是什么"></a>低代码平台是什么</h3><p>广义上的低代码平台包括低代码平台和零代码平台，它们都属于 APaaS（Application Platform as a Service 应用平台即服务），两者的主要区别在于对代码的依赖程度：</p>
<ul>
<li><strong>低代码平台</strong>：通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。</li>
<li><strong>零代码平台</strong>：零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。</li>
</ul>
<h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><h4 id="基于-IDE-框架的快速开发平台"><a href="#基于-IDE-框架的快速开发平台" class="headerlink" title="基于 IDE 框架的快速开发平台"></a>基于 IDE 框架的快速开发平台</h4><p>该方案将传统的集成开发环境（IDE）充分可视化，开发者对前端界面组件、数据源绑定方式、数据模型、业务逻辑和工作流等都可以自由定义，平台将自动生成代码，开发者也可以添加自己的代码，对程序具有较强的控制能力，因此该方案具备更高的灵活性，可以设计出定制化程度高、逻辑复杂的软件。</p>
<p>由于该方案仍涉及代码开发、部署等技术工作，所以它仍然是一个技术开发平台，需要较高的学习成本，主要价值是提高开发效率，减少重复劳动。</p>
<p>Outsystems 就是采用该方案的典型产品，如下为产品截图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506193447.png" alt="img"></p>
<h4 id="基于模型驱动的应用平台"><a href="#基于模型驱动的应用平台" class="headerlink" title="基于模型驱动的应用平台"></a>基于模型驱动的应用平台</h4><p>用户通过可视化方式构建数据模型、视图、权限、工作流等，即可在平台提供的环境中运行，无需编译部署，更像一种傻瓜式的应用搭建平台。平台对各类组件、业务逻辑做了较高层级的封装，因此用户无法随心所欲修改界面风格、交互方式、处理逻辑等。</p>
<p>该方案可以实现完全零代码，对使用者技术要求不高，但需要具备业务抽象、建模能力。主要价值是降低开发门槛、快速适应变化。</p>
<p>明道云、伙伴云等都是此类方案的典型产品，如下为明道云的产品截图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506193656.png" alt="img"></p>
<h3 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h3><p>绝大部分的企业软件由以下四个部分组成：</p>
<ul>
<li><strong>业务实体</strong>：即操作对象，如客户、订单</li>
<li><strong>业务活动</strong>：即进行何种操作，如采购申请、合同审批</li>
<li><strong>业务权限</strong>：即何种人拥有何种权限，包括数据查看权限和数据操作权限，如部门经理可以管理所有下属的客户信息，而员工只能管理自己的客户信息</li>
<li><strong>统计报表</strong>：即从哪些方面量化企业活动情况，如客户增长率、各月销售额趋势</li>
</ul>
<p>低代码平台将以上进行抽象，支持数据模型、业务流程、用户权限、统计图表，因此可以作为更通用的企业软件解决方案，这四类能力也是任何一个低代码平台都必须具备的核心要素。</p>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>建立数据模型就是提取业务实体的数据特征，抽象为数据表，建立表间关系。制作 ER 图的过程就是数据建模。市面上常见的低代码平台均提供了丰富的控件，可以拖拽完成数据模型搭建。此外，数据模型搭建与表单展示合二为一，每完成一个数据表的创建，就自动生成了该表的增删改查功能及相关页面，进而隐藏了数据库设计、前端开发这些专业技术。其实，这也就是我们常说的表单引擎。</p>
<p>这里顺便提一下，虽然很多低代码平台将数据建模与表单展示合二为一，但通过这种方式自动生成的表单只能实现最基础的增删改查页面，用户对界面展示内容及形式的控制程度很低，无法满足大部分企业软件的需求，所以低代码平台一般还会提供自定义页面功能，用户可根据需要在页面上配置按钮、图表等元素，满足个性化需求。</p>
<h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>业务流程指为了实现某项目标，由多人合作，按照一定的规则、顺序进行的一系列活动，在软件中，业务流程的参与者可以是人，也可以是程序。低代码平台实现了可视化流程配置，用户对触发条件、处理节点、节点参与者进行配置，实现自定义业务流程。</p>
<h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>大部分的低代码平台都采用了非常经典的 RBAC（Role-Based Access Control ）模型管理用户权限，简单来说就是将拥有相同权限的用户添加为相同角色，通过为角色分配权限，实现了“用户——角色——权限”的授权模式。由于企业是一个组织，一般都会有部门的概念，所以也可以将部门添加到某个角色，实现“用户——部门——角色——权限”的授权模式。</p>
<h4 id="统计图表"><a href="#统计图表" class="headerlink" title="统计图表"></a>统计图表</h4><p>统计图表可以类比 Excel 中的透视图，统计图表由数据源、统计规则、展示形式定义，低代码平台也正是遵循这种方式，实现统计图表的可视化配置。</p>
<h3 id="流行产品"><a href="#流行产品" class="headerlink" title="流行产品"></a>流行产品</h3><h4 id="OutSystems"><a href="#OutSystems" class="headerlink" title="OutSystems"></a>OutSystems</h4><p>OutSystems 是快速应用开发的头号低代码平台，并且是 2018 年 Gartner 高生产力平台的领导者。OutSystems 号称将低代码功能与高级移动功能相结合的唯一解决方案，它支持整个应用程序组合的可视化开发，可轻松与现有系统集成。</p>
<h4 id="Mendix"><a href="#Mendix" class="headerlink" title="Mendix"></a>Mendix</h4><p>Mendix 帮助企业改善创新方式。通过使用可视化模型，在 Mendix 上构建应用程序非常简单，快速且直观，可使开发人员和业务分析人员等众多人员构建强大的应用程序，而无需编写代码。借助模型驱动开发，业务领导者和 IT 部门可以共享语言来快速构建应用程序。</p>
<h2 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h2><p>由于系统的用户群体是有一定技术基础的开发人员。所以，系统定位是低代码平台，而非零代码平台。</p>
<p>其次，由于系统主要是用于简化基本的页面开发，所以技术路线应该选择：基于模型驱动的应用平台。</p>
<p>最后，由于生成的代码是应用于 Java Web 框架。生成的后端代码是 java 代码；前端代码是基于 vue + element-ui 生态的前端代码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506200045.png" alt="img"></p>
<p>代码生成规则对应的数据建模：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506200704.png" alt="img"></p>
<p>自动生成前后端代码。</p>
<ul>
<li>后端代码<ul>
<li>Controller</li>
<li>Service</li>
<li>ServiceImpl</li>
<li>Daomybatis</li>
<li>DaoImpl</li>
<li>Mapper</li>
<li>Query</li>
<li>Dto</li>
<li>Entity</li>
<li>xml</li>
</ul>
</li>
<li>前端代码<ul>
<li>List</li>
<li>Form</li>
<li>Api</li>
</ul>
</li>
</ul>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="列表页"><a href="#列表页" class="headerlink" title="列表页"></a>列表页</h3><h4 id="搜索栏"><a href="#搜索栏" class="headerlink" title="搜索栏"></a>搜索栏</h4><h4 id="操作栏"><a href="#操作栏" class="headerlink" title="操作栏"></a>操作栏</h4><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><h3 id="表单页"><a href="#表单页" class="headerlink" title="表单页"></a>表单页</h3><h4 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h4><h4 id="校验器"><a href="#校验器" class="headerlink" title="校验器"></a>校验器</h4><h2 id="扩展设计"><a href="#扩展设计" class="headerlink" title="扩展设计"></a>扩展设计</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/it/4391545.html">低代码平台：10 分钟从入门到原理</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/182211043">浅谈低代码平台涉及的一些技术选型</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8349a83d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8349a83d/" class="post-title-link" itemprop="url">Kafka 存储</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-29 08:17:17" itemprop="dateCreated datePublished" datetime="2021-04-29T08:17:17+08:00">2021-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-存储"><a href="#Kafka-存储" class="headerlink" title="Kafka 存储"></a>Kafka 存储</h1><blockquote>
<p>Kafka 是 Apache 的开源项目。<strong>Kafka 既可以作为一个消息队列中间件，也可以作为一个分布式流处理平台</strong>。</p>
<p><strong>Kafka 用于构建实时数据管道和流应用。它具有水平可伸缩性，容错性，快速快速性</strong>。</p>
</blockquote>
<h2 id="逻辑存储"><a href="#逻辑存储" class="headerlink" title="逻辑存储"></a>逻辑存储</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070720162.png"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化是 Kafka 的一个重要特性。</p>
<p><strong>Kafka 集群持久化保存（使用可配置的保留期限）所有发布记录——无论它们是否被消费</strong>。但是，Kafka 不会一直保留数据，也不会等待所有的消费者读取了消息才删除消息。<strong>只要数据量达到上限（比如 1G）或者数据达到过期时间（比如 7 天），Kafka 就会删除旧消息</strong>。Kafka 的性能和数据大小无关，所以长时间存储数据没有什么问题。</p>
<p><strong>Kafka 对消息的存储和缓存严重依赖于文件系统</strong>。</p>
<ul>
<li><p>顺序磁盘访问在某些情况下比随机内存访问还要快！在 Kafka 中，所有数据一开始就被写入到文件系统的持久化日志中，而不用在 cache 空间不足的时候 flush 到磁盘。实际上，这表明数据被转移到了内核的 pagecache 中。所以，<strong>虽然 Kafka 数据存储在磁盘中，但其访问性能也不低</strong>。</p>
</li>
<li><p>Kafka 的协议是建立在一个 “消息块” 的抽象基础上，合理将消息分组。 这使得网络请求将多个消息打包成一组，而不是每次发送一条消息，从而使整组消息分担网络中往返的开销。Consumer 每次获取多个大型有序的消息块，并由服务端依次将消息块一次加载到它的日志中。这可以<strong>有效减少大量的小型 I&#x2F;O 操作</strong>。</p>
</li>
<li><p>由于 Kafka 在 Producer、Broker 和 Consumer 都<strong>共享标准化的二进制消息格式</strong>，这样数据块不用修改就能在他们之间传递。这可以<strong>避免字节拷贝带来的开销</strong>。</p>
</li>
<li><p>Kafka 以高效的批处理格式支持一批消息可以压缩在一起发送到服务器。这批消息将以压缩格式写入，并且在日志中保持压缩，只会在 Consumer 消费时解压缩。<strong>压缩传输数据，可以有效减少网络带宽开销</strong>。</p>
<ul>
<li>Kafka 支持 GZIP，Snappy 和 LZ4 压缩协议。</li>
</ul>
</li>
</ul>
<p>所有这些优化都允许 Kafka 以接近网络速度传递消息。</p>
<h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>Kafka 的数据结构采用三级结构，即：主题（Topic）、分区（Partition）、消息（Record）。</p>
<p>在 Kafka 中，任意一个 Topic 维护了一组 Partition 日志，如下所示：</p>
<p>请注意：这里的主题只是一个逻辑上的抽象概念，实际上，<strong>Kafka 的基本存储单元是 Partition</strong>。Partition 无法在多个 Broker 间进行再细分，也无法在同一个 Broker 的多个磁盘上进行再细分。所以，分区的大小受到单个挂载点可用空间的限制。</p>
<p>Partiton 命名规则为 Topic 名称 + 有序序号，第一个 Partiton 序号从 0 开始，序号最大值为 Partition 数量减 1。</p>
<p><code>Log</code> 是 Kafka 用于表示日志文件的组件。每个 Partiton 对应一个 <code>Log</code> 对象，在物理磁盘上则对应一个目录。如：创建一个双分区的主题 <code>test</code>，那么，Kafka 会在磁盘上创建两个子目录：<code>test-0</code> 和 <code>test-1</code>；而在服务器端，这就对应两个 <code>Log</code> 对象。</p>
<h3 id="Log-Segment"><a href="#Log-Segment" class="headerlink" title="Log Segment"></a>Log Segment</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070721654.png"></p>
<p>因为在一个大文件中查找和删除消息是非常耗时且容易出错的。所以，Kafka 将每个 Partition 切割成若干个片段，即日志段（Log Segment）。<strong>默认每个 Segment 大小不超过 1G，且只包含 7 天的数据</strong>。如果 Segment 的消息量达到 1G，那么该 Segment 会关闭，同时打开一个新的 Segment 进行写入。</p>
<p>Broker 会为 Partition 里的每个 Segment 打开一个文件句柄（包括不活跃的 Segment），因此打开的文件句柄数通常会比较多，这个需要适度调整系统的进程文件句柄参数。<strong>正在写入的分片称为活跃片段（active segment），活跃片段永远不会被删除</strong>。</p>
<p>Segment 文件命名规则：Partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用 0 填充。</p>
<p>Segment 文件可以分为两类：</p>
<ul>
<li>索引文件<ul>
<li>偏移量索引文件（ <code>.index</code> ）</li>
<li>时间戳索引文件（ <code>.timeindex</code> ）</li>
<li>已终止事务的索引文件（<code>.txnindex</code>）：如果没有使用 Kafka 事务，则不会创建该文件</li>
</ul>
</li>
<li>日志数据文件（<code>.log</code>）</li>
</ul>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>Kafka 的消息和偏移量保存在文件里。保存在磁盘上的数据格式和从生产者发送过来或消费者读取的数据格式是一样的。因为使用了相同的数据格式，使得 Kafka 可以进行零拷贝技术给消费者发送消息，同时避免了压缩和解压。</p>
<p>除了键、值和偏移量外，消息里还包含了消息大小、校验和（检测数据损坏）、魔数（标识消息格式版本）、压缩算法（Snappy、GZip 或者 LZ4）和时间戳（0.10.0 新增）。时间戳可以是生产者发送消息的时间，也可以是消息到达 Broker 的时间，这个是可配的。</p>
<p>如果生产者发送的是压缩的消息，那么批量发送的消息会压缩在一起，以“包装消息”（wrapper message）来发送，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621134404.png" alt="img"></p>
<p>如果生产者使用了压缩功能，发送的批次越大，就意味着能获得更好的网络传输效率，并且节省磁盘存储空间。</p>
<p>Kafka 附带了一个叫 DumpLogSegment 的工具，可以用它查看片段的内容。它可以显示每个消息的偏移量、校验和、魔术数字节、消息大小和压缩算法。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Kafka 允许消费者从任意有效的偏移量位置开始读取消息。Kafka 为每个 Partition 都维护了一个索引（即 <code>.index</code> 文件），该索引将偏移量映射到片段文件以及偏移量在文件里的位置。</p>
<p>索引也被分成片段，所以在删除消息时，也可以删除相应的索引。Kafka 不维护索引的校验和。如果索引出现损坏，Kafka 会通过重读消息并录制偏移量和位置来重新生成索引。如果有必要，管理员可以删除索引，这样做是绝对安全的，Kafka 会自动重新生成这些索引。</p>
<p>索引文件用于将偏移量映射成为消息在日志数据文件中的实际物理位置，每个索引条目由 offset 和 position 组成，每个索引条目可以唯一确定在各个分区数据文件的一条消息。其中，Kafka 采用稀疏索引存储的方式，每隔一定的字节数建立了一条索引，可以通过<strong>“index.interval.bytes”</strong>设置索引的跨度；</p>
<p>有了偏移量索引文件，通过它，Kafka 就能够根据指定的偏移量快速定位到消息的实际物理位置。具体的做法是，根据指定的偏移量，使用二分法查询定位出该偏移量对应的消息所在的分段索引文件和日志数据文件。然后通过二分查找法，继续查找出小于等于指定偏移量的最大偏移量，同时也得出了对应的 position（实际物理位置），根据该物理位置在分段的日志数据文件中顺序扫描查找偏移量与指定偏移量相等的消息。下面是 Kafka 中分段的日志数据文件和偏移量索引文件的对应映射关系图（其中也说明了如何按照起始偏移量来定位到日志数据文件中的具体消息）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070722556.png"></p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>每个日志片段可以分为以下两个部分：</p>
<ul>
<li><strong>干净的部分</strong>：这部分消息之前已经被清理过，每个键只存在一个值。</li>
<li><strong>污浊的部分</strong>：在上一次清理后写入的新消息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621135557.png" alt="img"></p>
<p>如果在 Kafka 启动时启用了清理功能（通过 <code>log.cleaner.enabled</code> 配置），每个 Broker 会启动一个清理管理器线程和若干个清理线程，每个线程负责一个 Partition。</p>
<p>清理线程会读取污浊的部分，并在内存里创建一个 map。map 的 key 是消息键的哈希吗，value 是消息的偏移量。对于相同的键，只保留最新的位移。其中 key 的哈希大小为 16 字节，位移大小为 8 个字节。也就是说，一个映射只有 24 字节，假设消息大小为 1KB，那么 1GB 的段有 1 百万条消息，建立这个段的映射只需要 24MB 的内存，映射的内存效率是非常高效的。</p>
<p>在配置 Kafka 时，管理员需要设置这些清理线程可以使用的总内存。如果设置 1GB 的总内存同时有 5 个清理线程，那么每个线程只有 200MB 的内存可用。在清理线程工作时，它不需要把所有脏的段文件都一起在内存中建立上述映射，但需要保证至少能够建立一个段的映射。如果不能同时处理所有脏的段，Kafka 会一次清理最老的几个脏段，然后在下一次再处理其他的脏段。</p>
<p>一旦建立完脏段的键与位移的映射后，清理线程会从最老的干净的段开始处理。如果发现段中的消息的键没有在映射中出现，那么可以知道这个消息是最新的，然后简单的复制到一个新的干净的段中；否则如果消息的键在映射中出现，这条消息需要抛弃，因为对于这个键，已经有新的消息写入。处理完会将产生的新段替代原始段，并处理下一个段。</p>
<p>对于一个段，清理前后的效果如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621140117.png" alt="img"></p>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><p>对于只保留最新消息的清理策略来说，Kafka 还支持删除相应键的消息操作（而不仅仅是保留最新的消息内容）。这是通过生产者发送一条特殊的消息来实现的，该消息包含一个键以及一个 null 的消息内容。当清理线程发现这条消息时，它首先仍然进行一个正常的清理并且保留这个包含 null 的特殊消息一段时间，在这段时间内消费者消费者可以获取到这条消息并且知道消息内容已经被删除。过了这段时间，清理线程会删除这条消息，这个键会从 Partition 中消失。这段时间是必须的，因为它可以使得消费者有一定的时间余地来收到这条消息。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/kafka-analysis-part-1">Kafka 剖析（一）：Kafka 背景及架构介绍</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/44e1d423/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/44e1d423/" class="post-title-link" itemprop="url">Kafka 集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-29 08:17:17" itemprop="dateCreated datePublished" datetime="2021-04-29T08:17:17+08:00">2021-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-集群"><a href="#Kafka-集群" class="headerlink" title="Kafka 集群"></a>Kafka 集群</h1><blockquote>
<p>Kafka 是一个分布式的、可水平扩展的、基于发布&#x2F;订阅模式的、支持容错的消息系统。</p>
</blockquote>
<h2 id="Kafka-和-ZooKeeper"><a href="#Kafka-和-ZooKeeper" class="headerlink" title="Kafka 和 ZooKeeper"></a>Kafka 和 ZooKeeper</h2><p><strong>Kafka 使用 Zookeeper 来维护集群成员的信息</strong>。每个 Broker 都有一个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在 Broker 启动的时候，它通过创建<strong>临时节点</strong>把自己的 ID 注册到 Zookeeper。Kafka 组件订阅 Zookeeper 的 <code>/broker/ids</code> 路径，当有 Broker 加入集群或退出集群时，这些组件就可以获得通知。</p>
<p>如果要启动另一个具有相同 ID 的 Broker，会得到一个错误——新 Broker 会试着进行注册，但不会成功，因为 ZooKeeper 中已经有一个具有相同 ID 的 Broker。</p>
<p>在 Broker 停机、出现网络分区或长时间垃圾回收停顿时，Broker 会与 ZooKeeper 断开连接，此时 Broker 在启动时创建的临时节点会自动被 ZooKeeper 移除。监听 Broker 列表的 Kafka 组件会被告知 Broker 已移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070741387.png"></p>
<p>Kafka 在 ZooKeeper 的关键存储信息：</p>
<ul>
<li><code>admin</code>：存储管理信息。主要为删除主题事件，分区迁移事件，优先副本选举，信息 (一般为临时节点)</li>
<li><code>brokers</code>：存储 Broker 相关信息。broker 节点以及节点上的主题相关信息</li>
<li><code>cluster</code>：存储 kafka 集群信息</li>
<li><code>config</code>：存储 broker，client，topic，user 以及 changer 相关的配置信息</li>
<li><code>consumers</code>：存储消费者相关信息</li>
<li><code>controller</code>：存储控制器节点信息</li>
<li><code>controller_epoch</code>：存储控制器节点当前的年龄（说明控制器节点变更次数）</li>
</ul>
<blockquote>
<p>ZooKeeper 两个重要特性：</p>
<ul>
<li>客户端会话结束时，ZooKeeper 就会删除临时节点。</li>
<li>客户端注册监听它关心的节点，当节点状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端。</li>
</ul>
<p>详细内容可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/bigdata-tutorial/blob/master/docs/zookeeper/ZooKeeper%E5%8E%9F%E7%90%86.md">ZooKeeper 原理</a></p>
</blockquote>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器（Controller），是 Apache Kafka 的核心组件。它的主要作用是在 ZooKeeper 的帮助下管理和协调整个 Kafka 集群。控制器其实就是一个 Broker，只不过它除了具有一般 Broker 的功能以外，还负责 Leader 的选举。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070741426.png"></p>
<h3 id="如何选举控制器"><a href="#如何选举控制器" class="headerlink" title="如何选举控制器"></a>如何选举控制器</h3><p>集群中任意一台 Broker 都能充当控制器的角色，但是，在运行过程中，只能有一个 Broker 成为控制器，行使其管理和协调的职责。实际上，Broker 在启动时，会尝试去 ZooKeeper 中创建 <code>/controller</code> 节点。Kafka 当前选举控制器的规则是：<strong>第一个在 ZooKeeper 成功创建 <code>/controller</code> 临时节点的 Broker 会被指定为控制器</strong>。</p>
<p>选举控制器的详细流程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070742505.png"></p>
<ol>
<li><p>第一个在 ZooKeeper 中成功创建 <code>/controller</code> 临时节点的 Broker 会被指定为控制器。</p>
</li>
<li><p>其他 Broker 在控制器节点上创建 Zookeeper watch 对象。</p>
</li>
<li><p>如果控制器被关闭或者与 Zookeeper 断开连接，Zookeeper 临时节点就会消失。集群中的其他 Broker 通过 watch 对象得到状态变化的通知，它们会尝试让自己成为新的控制器。</p>
</li>
<li><p>第一个在 Zookeeper 里创建一个临时节点 <code>/controller</code> 的 Broker 成为新控制器。其他 Broker 在新控制器节点上创建 Zookeeper watch 对象。</p>
</li>
<li><p>每个新选出的控制器通过 Zookeeper 的条件递增操作获得一个全新的、数值更大的 controller epoch。其他节点会忽略旧的 epoch 的消息。</p>
</li>
<li><p>当控制器发现一个 Broker 已离开集群，并且这个 Broker 是某些 Partition 的 Leader。此时，控制器会遍历这些 Partition，并用轮询方式确定谁应该成为新 Leader，随后，新 Leader 开始处理生产者和消费者的请求，而 Follower 开始从 Leader 那里复制消息。</p>
</li>
</ol>
<p>简而言之，<strong>Kafka 使用 Zookeeper 的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行 Partition Leader 选举。控制器使用 epoch 来避免“脑裂”，“脑裂”是指两个节点同时被认为自己是当前的控制器</strong>。</p>
<h3 id="控制器的作用"><a href="#控制器的作用" class="headerlink" title="控制器的作用"></a>控制器的作用</h3><h4 id="Topic-管理（创建、删除、增加分区）"><a href="#Topic-管理（创建、删除、增加分区）" class="headerlink" title="Topic 管理（创建、删除、增加分区）"></a>Topic 管理（创建、删除、增加分区）</h4><p>这里的 Topic 管理，就是指控制器帮助我们完成对 Kafka Topic 的创建、删除以及分区增加的操作。换句话说，当我们执行 <strong>kafka-topics 脚本</strong>时，大部分的后台工作都是控制器来完成的。</p>
<h4 id="分区重分配"><a href="#分区重分配" class="headerlink" title="分区重分配"></a>分区重分配</h4><p>分区重分配主要是指，<strong>kafka-reassign-partitions 脚本</strong>（关于这个脚本，后面我也会介绍）提供的对已有 Topic 分区进行细粒度的分配功能。这部分功能也是控制器实现的。</p>
<h4 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h4><p>Preferred 领导者选举主要是 Kafka 为了避免部分 Broker 负载过重而提供的一种换 Leader 的方案。在专栏后面说到工具的时候，我们再详谈 Preferred 领导者选举，这里你只需要了解这也是控制器的职责范围就可以了。</p>
<h4 id="集群成员管理"><a href="#集群成员管理" class="headerlink" title="集群成员管理"></a>集群成员管理</h4><p>集群成员管理，包括自动检测新增 Broker、Broker 主动关闭及被动宕机。这种自动检测是依赖于前面提到的 Watch 功能和 ZooKeeper 临时节点组合实现的。</p>
<p>比如，控制器组件会利用<strong>Watch 机制</strong>检查 ZooKeeper 的 &#x2F;brokers&#x2F;ids 节点下的子节点数量变更。目前，当有新 Broker 启动后，它会在 &#x2F;brokers 下创建专属的 znode 节点。一旦创建完毕，ZooKeeper 会通过 Watch 机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增 Broker 作业。</p>
<p>侦测 Broker 存活性则是依赖于刚刚提到的另一个机制：<strong>临时节点</strong>。每个 Broker 启动后，会在 &#x2F;brokers&#x2F;ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行“善后”。</p>
<h4 id="数据服务"><a href="#数据服务" class="headerlink" title="数据服务"></a>数据服务</h4><p>控制器的最后一大类工作，就是向其他 Broker 提供数据服务。控制器上保存了最全的集群元数据信息，其他所有 Broker 会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</p>
<p>控制器中保存了多种数据，比较重要的的数据有：</p>
<ul>
<li>所有 Topic 信息。包括具体的分区信息，比如领导者副本是谁，ISR 集合中有哪些副本等。</li>
<li>所有 Broker 信息。包括当前都有哪些运行中的 Broker，哪些正在关闭中的 Broker 等。</li>
<li>所有涉及运维任务的分区。包括当前正在进行 Preferred 领导者选举以及分区重分配的分区列表。</li>
</ul>
<p>值得注意的是，这些数据其实在 ZooKeeper 中也保存了一份。每当控制器初始化时，它都会从 ZooKeeper 上读取对应的元数据并填充到自己的缓存中。有了这些数据，控制器就能对外提供数据服务了。这里的对外主要是指对其他 Broker 而言，控制器通过向这些 Broker 发送请求的方式将这些数据同步到其他 Broker 上。</p>
<h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><p>副本机制是分布式系统实现高可用的不二法门，Kafka 也不例外。</p>
<p>副本机制有哪些好处？</p>
<ol>
<li><strong>提供可用性</strong>：有句俗语叫：鸡蛋不要放在一个篮子里。副本机制也是一个道理——当部分节点宕机时，系统仍然可以依靠其他正常运转的节点，从整体上对外继续提供服务。</li>
<li><strong>提供伸缩性</strong>：通过增加、减少机器可以控制系统整体的吞吐量。</li>
<li><strong>改善数据局部性</strong>：允许将数据放入与用户地理位置相近的地方，从而降低系统延时。</li>
</ol>
<p>但是，Kafka 只实现了第一个好处，原因后面会阐述。</p>
<h3 id="Kafka-副本角色"><a href="#Kafka-副本角色" class="headerlink" title="Kafka 副本角色"></a>Kafka 副本角色</h3><p>Kafka 使用 Topic 来组织数据，每个 Topic 被分为若干个 Partition，每个 Partition 有多个副本。每个 Broker 可以保存成百上千个属于不同 Topic 和 Partition 的副本。<strong>Kafka 副本的本质是一个只能追加写入的提交日志</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070743894.png"></p>
<p>Kafka 副本有两种角色：</p>
<ul>
<li><strong>Leader 副本（主）</strong>：每个 Partition 都有且仅有一个 Leader 副本。为了保证数据一致性，<strong>Leader 处理一切对 Partition （分区）的读写请求</strong>；</li>
<li><strong>Follower 副本（从）</strong>：Leader 副本以外的副本都是 Follower 副本。<strong>Follower 唯一的任务就是从 Leader 那里复制消息，保持与 Leader 一致的状态</strong>。</li>
<li>如果 Leader 宕机，其中一个 Follower 会被选举为新的 Leader。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070743006.png"></p>
<p>为了与 Leader 保持同步，Follower 向 Leader 发起获取数据的请求，这种请求与消费者为了读取消息而发送的请求是一样的。请求消息里包含了 Follower 想要获取消息的偏移量，而这些偏移量总是有序的。</p>
<p>Leader 另一个任务是搞清楚哪个 Follower 的状态与自己是一致的。通过查看每个 Follower 请求的最新偏移量，Leader 就会知道每个 Follower 复制的进度。如果跟随者在 10s 内没有请求任何消息，或者虽然在请求消息，但是在 10s 内没有请求最新的数据，那么它就会被认为是<strong>不同步</strong>的。<strong>如果一个副本是不同步的，在 Leader 失效时，就不可能成为新的 Leader</strong>——毕竟它没有包含全部的消息。</p>
<p>除了当前首领之外，每个分区都有一个首选首领——创建 Topic 时选定的首领就是分区的首选首领。之所以叫首选 Leader，是因为在创建分区时，需要在 Broker 之间均衡 Leader。</p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>ISR 即 In-sync Replicas，表示同步副本。Follower 副本不提供服务，只是定期地异步拉取领导者副本中的数据而已。既然是异步的，说明和 Leader 并非数据强一致性的。</p>
<p><strong>判断 Follower 是否与 Leader 同步的标准</strong>：</p>
<p>Kafka Broker 端参数 <code>replica.lag.time.max.ms</code> 参数，指定了 Follower 副本能够落后 Leader 副本的最长时间间隔，默认为 10s。这意味着：只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 Leader 是<strong>同步</strong>的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p>
<p>ISR 是一个动态调整的集合，会不断将同步副本加入集合，将不同步副本移除集合。Leader 副本天然就在 ISR 中。</p>
<h3 id="Unclean-领导者选举"><a href="#Unclean-领导者选举" class="headerlink" title="Unclean 领导者选举"></a>Unclean 领导者选举</h3><p>因为 Leader 副本天然就在 ISR 中，如果 ISR 为空了，就说明 Leader 副本也“挂掉”了，Kafka 需要重新选举一个新的 Leader。</p>
<p><strong>Kafka 把所有不在 ISR 中的存活副本都称为非同步副本</strong>。通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。<strong>Broker 端参数 <code>unclean.leader.election.enable</code> 控制是否允许 Unclean 领导者选举</strong>。</p>
<p><strong>开启 Unclean 领导者选举可能会造成数据丢失</strong>，但好处是：它使得 Partition Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>Broker 的大部分工作是处理客户端、Partition 副本和控制器发送给 Partition Leader 的请求。Kafka 提供了一个二进制协议（基于 TCP），指定了请求消息的格式以及 Broker 如何对请求作出响应。</p>
<p>broker 会在它所监听的每一个端口上运行一个 Acceptor 线程，这个线程会创建一个连接，并把它交给 Processor 线程去处理。Processor 线程的数量是可配置的。Processor 线程负责从客户端获取请求消息，把它们放进请求队列，然后从响应队列获取响应消息，把它们发送给客户端。</p>
<p>当请求放进请求队列后，IO 线程负责进行处理。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/10427194506.png" alt="img"></p>
<p>生产请求和获取请求都需要发送给 Partition 的 Leader 副本处理。如果 Broker 收到一个针对特定分区的请求，而该分区的 Leader 在另一个 Broker 上，那么发送请求的客户端会收到一个“非分区 Leader”的错误响应。Kafka 客户端要自己负责把生成请求和获取请求发送到正确的 Broker 上。</p>
<h3 id="元数据请求"><a href="#元数据请求" class="headerlink" title="元数据请求"></a>元数据请求</h3><p>客户端怎么知道哪个是 Leader 呢？客户端通过使用另一种类型的请求来实现，那就是<strong>元数据请求（metadata request）</strong>。这种请求包含了客户端感兴趣的 Topic 列表。broker 的响应消息指明了这些 Topic 所包含的 Partition、Partition 有哪些副本，以及哪个副本是 Leader。元数据请求可以发给任意一个 broker，因为所有 Broker 都缓存了这些信息。</p>
<p>客户端会把这些信息缓存起来，并直接往目标 Broker 上发送生产请求和获取请求。它们需要时不时地通过发送元数据请求来刷新这些信息（刷新的时间间隔通过 <code>metadata.max.age.ms</code> 来配置），从而知道元数据是否发生了变化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621123848.png" alt="img"></p>
<h3 id="生产请求"><a href="#生产请求" class="headerlink" title="生产请求"></a>生产请求</h3><p>acks 参数控制多少个副本确认写入成功后生产者才认为消息生产成功。这个参数的取值可以为：</p>
<ul>
<li><code>acks=0</code> - 消息发送完毕，生产者认为消息写入成功；</li>
<li><code>acks=1</code> - Leader 写入成功，生产者认为消息写入成功；</li>
<li><code>acks=all</code> - 所有同步副本写入成功，生产者才认为消息写入成功。</li>
</ul>
<p>如果 Leader 收到生产消息，它会执行一些检查逻辑，包含：</p>
<ul>
<li>发送的用户是否有权限写入 Topic？</li>
<li>请求的 <code>acks</code> 参数取值是否合法（只允许 <code>0</code>，<code>1</code>，<code>all</code>）？</li>
<li>如果 <code>acks</code> 设置为 <code>all</code>，是否有足够的同步副本已经安全写入消息？（我们可以配置如果同步副本数量不足，Leader 拒绝处理新消息）</li>
</ul>
<p>之后，消息被写入到本地磁盘。一旦消息本地持久化后，如果 <code>acks</code> 被设为 <code>0</code> 或 <code>1</code>，那么会返回结果给客户端；如果 <code>acks</code> 被设为 <code>all</code> 那么会将请求放置在一个称为 <code>purgatory</code> 的缓冲区中等待其他的副本写入完成。</p>
<h3 id="消费请求"><a href="#消费请求" class="headerlink" title="消费请求"></a>消费请求</h3><p>Leader 处理拉取请求和处理生产请求的方式很相似：</p>
<ol>
<li>请求需要先到达指定的 Partition Leader 上，然后客户端通过查询元数据来确保请求的路由是正确的。</li>
<li>Leader 在收到请求时，会先检查请求是否有效。</li>
<li>如果请求的偏移量存在，Broker 将按照客户端指定的数量上限从 Partition 里读取消息，再把消息返回给客户端。Kafka 使用零拷贝技术向客户端发送消息——也就是说，Kafka 直接把消息从文件（更准确的说，是文件系统缓存）里发送到网络通道，而不需要经过任何中间缓冲区。这避免了内存的字节拷贝和缓冲区维护，极大地提高了性能。</li>
</ol>
<p><strong>客户端可以指定 Broker 返回数据量的上限和下限，防止数据量过大造成客户端内存溢出</strong>。同时，<strong>客户端也可以指定返回的最小数据量</strong>，当消息数据量没有达到最小数据量时，请求会一直阻塞直到有足够的数据返回。指定最小的数据量在负载不高的情况下非常有用，通过这种方式<strong>可以减轻网络往返的额外开销</strong>。当然请求也不能永远的阻塞，客户端可以指定最大的阻塞时间，如果到达指定的阻塞时间，即便没有足够的数据也会返回。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621124516.png" alt="img"></p>
<p>不是所有 Leader 的数据都能够被读取。<strong>消费者只能读取已提交的消息</strong>。<strong>只有当消息被写入分区的若干同步副本时，才被认为是已提交的</strong>。为什么是若干个 Broker 呢？这取决于你对“已提交”的定义。你可以选择只要 Leader 成功保存该消息就算是已提交，也可以是令所有 Broker 都成功保存该消息才算是已提交。</p>
<p>因为还没有被足够的副本持久化的消息，被认为是不安全的——如果 Leader 发生故障，另一个副本成为新的 Leader，这些消息就丢失了。如果允许读取这些消息，就可能会破坏数据一致性。</p>
<p>这也意味着，如果 Broker 间的消息复制因为某些原因变慢了，那么消息到达消费者的时间也会随之变长。延迟时间可以通过 <code>replica.lag.time.max.ms</code> 来配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621124533.png" alt="img"></p>
<h3 id="其他请求"><a href="#其他请求" class="headerlink" title="其他请求"></a>其他请求</h3><p>我们讨论了 Kafka 中最常见的三种请求类型：元信息请求，生产请求和拉取请求。这些请求都是使用的是 Kafka 的自定义二进制协议。集群中 Broker 间的通信请求也是使用同样的协议，这些请求是内部使用的，客户端不能发送。比如在选举 Partition Leader 过程中，控制器会发送 LeaderAndIsr 请求给新的 Leader 和其他跟随副本。</p>
<p>这个协议目前已经支持 20 种请求类型，并且仍然在演进以支持更多的类型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="副本机制-1"><a href="#副本机制-1" class="headerlink" title="副本机制"></a>副本机制</h3><ul>
<li>每个 Partition 都有一个 Leader，零个或多个 Follower。</li>
<li>Leader 处理一切对 Partition （分区）的读写请求；而 Follower 只需被动的同步 Leader 上的数据。</li>
<li>同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份。</li>
</ul>
<h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>Follower 宕机，啥事儿没有；Leader 宕机了，会从 Follower 中重新选举一个新的 Leader。<br>生产者&#x2F;消费者如何知道谁是 Leader</p>
<ul>
<li>Kafka 将这种元数据存储在 Zookeeper 服务中。</li>
<li>生产者和消费者都和 Zookeeper 连接并通信。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1">Thorough Introduction to Apache Kafka</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b97c8100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b97c8100/" class="post-title-link" itemprop="url">Git帮助手册</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-16 18:19:18" itemprop="dateCreated datePublished" datetime="2021-04-16T18:19:18+08:00">2021-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/DevOps/" itemprop="url" rel="index"><span itemprop="name">DevOps</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/DevOps/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/DevOps/%E5%B7%A5%E5%85%B7/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Git-帮助手册"><a href="#Git-帮助手册" class="headerlink" title="Git 帮助手册"></a>Git 帮助手册</h1><p>国外网友制作了一张 Git Cheat Sheet，总结很精炼，各位不妨收藏一下。</p>
<p>本节选择性介绍 git 中比较常用的命令行场景。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/web/git/git-cheat-sheet.png" alt="img"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>（1）Debian&#x2F;Ubuntu 环境安装</strong></p>
<p>如果你使用的系统是 Debian&#x2F;Ubuntu ， 安装命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span></span><br><span class="line"><span class="language-bash">&gt; libz-dev libssl-dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get install git-core</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git --version</span></span><br><span class="line">git version 1.8.1.2</span><br></pre></td></tr></table></figure>

<p><strong>（2）Centos&#x2F;RedHat 环境安装</strong></p>
<p>如果你使用的系统是 Centos&#x2F;RedHat ，安装命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install curl-devel expat-devel gettext-devel \</span></span><br><span class="line"><span class="language-bash">&gt; openssl-devel zlib-devel</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum -y install git-core</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git --version</span></span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure>

<p><strong>（3）Windows 环境安装</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">Git 官方下载地址</a>下载 exe 安装包。按照安装向导安装即可。</p>
<p>建议安装 Git Bash 这个 git 的命令行工具。</p>
<p><strong>（4）Mac 环境安装</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">Git 官方下载地址</a>下载 mac 安装包。按照安装向导安装即可。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li>
</ul>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p>
<h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>

<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
<p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h3 id="给-Git-命令添加别名"><a href="#给-Git-命令添加别名" class="headerlink" title="给 Git 命令添加别名"></a>给 Git 命令添加别名</h3><p>在 OS X 和 Linux 下, 你的 Git 的配置文件储存在 <code>~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">add</span></span><br><span class="line">    amend = commit --amend</span><br><span class="line">    <span class="keyword">c</span> = commit</span><br><span class="line">    <span class="keyword">ca</span> = commit --amend</span><br><span class="line">    ci = commit -<span class="keyword">a</span></span><br><span class="line">    <span class="keyword">co</span> = checkout</span><br><span class="line">    d = diff</span><br><span class="line">    dc = diff --changed</span><br><span class="line">    <span class="keyword">ds</span> = diff --staged</span><br><span class="line">    <span class="keyword">f</span> = fetch</span><br><span class="line">    loll = <span class="built_in">log</span> --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class="line">    <span class="keyword">m</span> = merge</span><br><span class="line">    one = <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">    outstanding = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    s = status</span><br><span class="line">    unpushed = <span class="built_in">log</span> @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    wc = whatchanged</span><br><span class="line">    wip = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    zap = fetch -<span class="keyword">p</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存一个仓库的用户名和密码"><a href="#缓存一个仓库的用户名和密码" class="headerlink" title="缓存一个仓库的用户名和密码"></a>缓存一个仓库的用户名和密码</h3><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推&#x2F;拉(push&#x2F;pull)的时候都输入，Credential helper 能帮你。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set git to use the credential memory cache</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper &#x27;cache --timeout=3600&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>

<h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH</span></span><br><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br><span class="line"><span class="comment"># 通过 HTTP</span></span><br><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br></pre></td></tr></table></figure>

<h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>有时，我们需要在同一个项目的不同分支上工作。当需要切换分支时，偏偏本地的工作还没有完成，此时，提交修改显得不严谨，但是不提交代码又无法切换分支。这时，你可以使用 <code>git stash</code> 将本地的修改内容作为草稿储藏起来。</p>
<p>官方称之为储藏，但我个人更喜欢称之为存草稿。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 将修改作为当前分支的草稿保存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 查看草稿列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 6fae349 :memo: Writing docs.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.1 删除草稿</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash drop stash@&#123;0&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.2 读取草稿</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><p><code>git add</code> 命令用于将修改添加到暂存区。</p>
<h3 id="暂存指定文件"><a href="#暂存指定文件" class="headerlink" title="暂存指定文件"></a>暂存指定文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br></pre></td></tr></table></figure>

<h3 id="暂存当前目录下所有修改"><a href="#暂存当前目录下所有修改" class="headerlink" title="暂存当前目录下所有修改"></a>暂存当前目录下所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h3 id="暂存所有修改"><a href="#暂存所有修改" class="headerlink" title="暂存所有修改"></a>暂存所有修改</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> -A</span><br></pre></td></tr></table></figure>

<h3 id="暂存文件部分内容"><a href="#暂存文件部分内容" class="headerlink" title="暂存文件部分内容"></a>暂存文件部分内容</h3><p>暂存文件部分内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --patch filename.x</span><br></pre></td></tr></table></figure>

<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)；</p>
<p>然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时，这样做:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -N filename.x</span><br></pre></td></tr></table></figure>

<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>
<h3 id="把暂存的内容变成未暂存，把未暂存的内容暂存起来"><a href="#把暂存的内容变成未暂存，把未暂存的内容暂存起来" class="headerlink" title="把暂存的内容变成未暂存，把未暂存的内容暂存起来"></a>把暂存的内容变成未暂存，把未暂存的内容暂存起来</h3><p>这个有点困难， 我能想到的最好的方法是先 stash 未暂存的内容， 然后重置(reset)，再 pop 第一步 stashed 的内容, 最后再 add 它们。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash -k</span><br><span class="line">git reset --hard</span><br><span class="line">git stash pop</span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p><code>git commit</code> 命令用于将修改保存到到本地仓库。</p>
<h3 id="查看最近一次提交"><a href="#查看最近一次提交" class="headerlink" title="查看最近一次提交"></a>查看最近一次提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -n1 -p</span><br></pre></td></tr></table></figure>

<h3 id="提交本地的所有修改"><a href="#提交本地的所有修改" class="headerlink" title="提交本地的所有修改"></a>提交本地的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>

<h3 id="提交暂存的修改"><a href="#提交暂存的修改" class="headerlink" title="提交暂存的修改"></a>提交暂存的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<h3 id="把暂存的内容添加到上一次的提交"><a href="#把暂存的内容添加到上一次的提交" class="headerlink" title="把暂存的内容添加到上一次的提交"></a>把暂存的内容添加到上一次的提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="附加消息提交"><a href="#附加消息提交" class="headerlink" title="附加消息提交"></a>附加消息提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;commit message&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p>如果你的提交信息写错了且这次提交（commit）还没有推送（push），可以使用以下命令修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &#x27;xxxxxxx&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="修改提交信息中的用户名和邮箱"><a href="#修改提交信息中的用户名和邮箱" class="headerlink" title="修改提交信息中的用户名和邮箱"></a>修改提交信息中的用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author &quot;New Authorname &lt;authoremail@mydomain.com&gt;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="从提交中移除一个文件"><a href="#从提交中移除一个文件" class="headerlink" title="从提交中移除一个文件"></a>从提交中移除一个文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^ myfile</span><br><span class="line">git add -A</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="删除最后一次提交"><a href="#删除最后一次提交" class="headerlink" title="删除最后一次提交"></a>删除最后一次提交</h3><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^ --hard</span><br><span class="line">git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>

<p>如果你还没有推到远程, 把 Git 重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)$ git reset --soft HEAD@&#123;1&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是 rebase-safe 的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href="#deleteremove-last-pushed-commit">the above section</a>。</p>
<h3 id="删除任意提交"><a href="#删除任意提交" class="headerlink" title="删除任意提交"></a>删除任意提交</h3><p>同样的警告：不到万不得已的时候不要这么做.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>

<p>或者做一个 <a href="#interactive-rebase">交互式 rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p>
<h3 id="我尝试推一个修正后的提交-amended-commit-到远程，但是报错"><a href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错" class="headerlink" title="我尝试推一个修正后的提交(amended commit)到远程，但是报错"></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/tanay1337/webmaker.org.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>

<p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 &ndash; <em>总是</em> 确保你指明一个分支!</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git push origin mybranch -f</span></span><br></pre></td></tr></table></figure>

<p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>
<h3 id="不小心强制重置，想找回内容"><a href="#不小心强制重置，想找回内容" class="headerlink" title="不小心强制重置，想找回内容"></a>不小心强制重置，想找回内容</h3><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为 Git 对每件事都会有日志，且都会保存几天。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reflog</span></span><br></pre></td></tr></table></figure>

<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的 SHA，再重置一次:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reset --hard SHA1234</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了。</p>
<h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p>撤销本地修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除缓存区的所有文件（i.e. 撤销上次git add）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset &lt;commit&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将HEAD重置到上一次提交的版本，并保留未提交的本地修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --keep &lt;commit&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放弃工作目录下的所有修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将HEAD重置到指定的版本，并抛弃该版本之后的所有修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard &lt;commit-hash&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用远端分支强制覆盖本地分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放弃某个文件的所有本地修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>删除添加<code>.gitignore</code>文件前错误提交的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交一条 git 记录，提交信息为 remove xyz file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r --cached .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;remove xyz file&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>撤销远程修改（创建一个新的提交，并回滚到指定版本）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">revert 哈希号为 commit-hash 的记录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert &lt;commit-hash&gt;</span></span><br></pre></td></tr></table></figure>

<p>彻底删除指定版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行下面命令后，commit-hash 提交后的记录都会被彻底删除，使用需谨慎</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard &lt;commit-hash&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -f</span></span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载远程端版本，但不合并到HEAD中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将远程端版本合并到本地版本中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以rebase方式将远端分支与本地合并</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull --rebase &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><h3 id="推送提交到远程仓库"><a href="#推送提交到远程仓库" class="headerlink" title="推送提交到远程仓库"></a>推送提交到远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签"></a>发布标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h2 id="未暂存"><a href="#未暂存" class="headerlink" title="未暂存"></a>未暂存</h2><blockquote>
<p>未暂存(Unstaged)的内容</p>
</blockquote>
<h3 id="把未暂存的内容移动到一个新分支"><a href="#把未暂存的内容移动到一个新分支" class="headerlink" title="把未暂存的内容移动到一个新分支"></a>把未暂存的内容移动到一个新分支</h3><ul>
<li><code>git checkout -b my-branch</code></li>
</ul>
<h3 id="我想把未暂存的内容移动到另一个已存在的分支"><a href="#我想把未暂存的内容移动到另一个已存在的分支" class="headerlink" title="我想把未暂存的内容移动到另一个已存在的分支"></a>我想把未暂存的内容移动到另一个已存在的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout my-branch</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="丢弃本地未提交的变化"><a href="#丢弃本地未提交的变化" class="headerlink" title="丢弃本地未提交的变化"></a>丢弃本地未提交的变化</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># one commit</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># two commits</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^^</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># four commits</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD~4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># or</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -f</span></span><br></pre></td></tr></table></figure>

<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure>

<h3 id="我想丢弃某些未暂存的内容"><a href="#我想丢弃某些未暂存的内容" class="headerlink" title="我想丢弃某些未暂存的内容"></a>我想丢弃某些未暂存的内容</h3><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>
<p>签出(checkout)不需要的内容，保留需要的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -p</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Answer y to all of the snippets you want to drop</span></span></span><br></pre></td></tr></table></figure>

<p>另外一个方法是使用 <code>stash</code>， Stash 所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash -p</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Select all of the snippets you want to save</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash pop</span></span><br></pre></td></tr></table></figure>

<p>或者, stash 你不需要的部分, 然后 stash drop。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash -p</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Select all of the snippets you don&#x27;t want to save</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash drop</span></span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote>
<p>分支(Branches)</p>
</blockquote>
<h3 id="列出所有的分支"><a href="#列出所有的分支" class="headerlink" title="列出所有的分支"></a>列出所有的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h3 id="列出所有的远端分支"><a href="#列出所有的远端分支" class="headerlink" title="列出所有的远端分支"></a>列出所有的远端分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<h3 id="基于当前分支创建新分支"><a href="#基于当前分支创建新分支" class="headerlink" title="基于当前分支创建新分支"></a>基于当前分支创建新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="基于远程分支创建新分支"><a href="#基于远程分支创建新分支" class="headerlink" title="基于远程分支创建新分支"></a>基于远程分支创建新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="强制删除本地分支"><a href="#强制删除本地分支" class="headerlink" title="强制删除本地分支"></a>强制删除本地分支</h3><blockquote>
<p>注意：强制删除本地分支，将会丢失未合并的修改</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class="line">git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br></pre></td></tr></table></figure>

<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建并切换到新分支"><a href="#创建并切换到新分支" class="headerlink" title="创建并切换到新分支"></a>创建并切换到新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"><a href="#我从错误的分支拉取了内容，或把内容拉取到了错误的分支" class="headerlink" title="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前 HEAD 的指向。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reflog</span></span><br><span class="line">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class="line">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure>

<p>重置分支到你所需的提交(desired commit):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard c5bc55a</span><br></pre></td></tr></table></figure>

<p>完成。</p>
<h3 id="我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致"><a href="#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致" class="headerlink" title="我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h3><p>先确认你没有推(push)你的内容到远程。</p>
<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># On branch my-branch</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Your branch is ahead of &#x27;origin/my-branch&#x27; by 2 commits.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   (use &quot;git push&quot; to publish your local commits)</span></span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>

<p>一种方法是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reset --hard origin/my-branch</span></span><br></pre></td></tr></table></figure>

<h3 id="我需要提交到一个新分支，但错误的提交到了-master"><a href="#我需要提交到一个新分支，但错误的提交到了-master" class="headerlink" title="我需要提交到一个新分支，但错误的提交到了 master"></a>我需要提交到一个新分支，但错误的提交到了 master</h3><p>在 master 下创建一个新分支，不切换到新分支,仍在 master 下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git branch my-branch</span></span><br></pre></td></tr></table></figure>

<p>把 master 分支重置到前一个提交:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br></pre></td></tr></table></figure>

<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>
<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的 hash(<code>git log</code> 能够完成)， 然后重置到这个 hash。 使用<code>git push</code> 同步内容到远程。</p>
<p>例如, master 分支想重置到的提交的 hash 为<code>a13b85e</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reset --hard a13b85e</span></span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>

<p>签出(checkout)刚才新建的分支继续工作:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout my-branch</span></span><br></pre></td></tr></table></figure>

<h3 id="我想保留来自另外一个-ref-ish-的整个文件"><a href="#我想保留来自另外一个-ref-ish-的整个文件" class="headerlink" title="我想保留来自另外一个 ref-ish 的整个文件"></a>我想保留来自另外一个 ref-ish 的整个文件</h3><p>假设你正在做一个原型方案(原文为 working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(solution)$ </span><span class="language-bash">git add -A &amp;&amp; git commit -m <span class="string">&quot;Adding all changes from this spike into one big commit.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>
<p>假设你有:</p>
<ul>
<li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>
<li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>
</ul>
<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(develop)$ </span><span class="language-bash">git checkout solution -- file1.txt</span></span><br></pre></td></tr></table></figure>

<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># On branch develop</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Your branch is up-to-date with &#x27;origin/develop&#x27;.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">##        modified:   file1.txt</span></span></span><br></pre></td></tr></table></figure>

<p>然后, 正常提交。</p>
<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extreme_programming_practices">Wikipedia</a>.</p>
<h3 id="我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里"><a href="#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里" class="headerlink" title="我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h3><p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug #21 - Added CSRF protection</span><br><span class="line"></span><br><span class="line">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug #14 - Fixed spacing on title</span><br><span class="line"></span><br><span class="line">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class="line">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class="line">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure>

<p>让我们用提交 hash(commit hash)标记 bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>
<p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reset --hard a13b85e</span></span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>

<p>现在, 我们对 bug #21 创建一个新的分支:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout -b 21</span></span><br><span class="line"><span class="meta prompt_">(21)$</span></span><br></pre></td></tr></table></figure>

<p>接着, 我们用 <em>cherry-pick</em> 把对 bug #21 的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在 HEAD 上面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(21)$ </span><span class="language-bash">git cherry-pick e3851e8</span></span><br></pre></td></tr></table></figure>

<p>这时候, 这里可能会产生冲突， 参见<a href="#interactive-rebase">交互式 rebasing 章</a> <a href="#merge-conflict"><strong>冲突节</strong></a> 解决冲突.</p>
<p>再者， 我们为 bug #14 创建一个新的分支, 也基于<code>master</code>分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(21)$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout -b 14</span></span><br><span class="line"><span class="meta prompt_">(14)$</span></span><br></pre></td></tr></table></figure>

<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(14)$ </span><span class="language-bash">git cherry-pick 5ea5173</span></span><br></pre></td></tr></table></figure>

<h3 id="我想删除上游-upstream-分支被删除了的本地分支"><a href="#我想删除上游-upstream-分支被删除了的本地分支" class="headerlink" title="我想删除上游(upstream)分支被删除了的本地分支"></a>我想删除上游(upstream)分支被删除了的本地分支</h3><p>一旦你在 github 上面合并(merge)了一个 pull request, 你就可以删除你 fork 里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>

<h3 id="我不小心删除了我的分支"><a href="#我不小心删除了我的分支" class="headerlink" title="我不小心删除了我的分支"></a>我不小心删除了我的分支</h3><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout -b my-branch</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git branch</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash"><span class="built_in">touch</span> foo.txt</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>

<p>添加文件并做一次提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git commit -m <span class="string">&#x27;foo.txt added&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">foo.txt added</span></span><br><span class="line"> 1 files changed, 1 insertions(+)</span><br><span class="line"> create mode 100644 foo.txt</span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class="line">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class="line">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class="line"></span><br><span class="line">    foo.txt added</span><br><span class="line"></span><br><span class="line">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class="line">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class="line">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class="line"></span><br><span class="line">    Fixes #6: Force pushing after amending commits</span><br></pre></td></tr></table></figure>

<p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git branch -D my-branch</span></span><br><span class="line">Deleted branch my-branch (was 4e3cd85).</span><br><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash"><span class="built_in">echo</span> oh noes, deleted my branch!</span></span><br><span class="line">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure>

<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reflog</span></span><br><span class="line">69204cd HEAD@&#123;0&#125;: checkout: moving from my-branch to master</span><br><span class="line">4e3cd85 HEAD@&#123;1&#125;: commit: foo.txt added</span><br><span class="line">69204cd HEAD@&#123;2&#125;: checkout: moving from master to my-branch</span><br></pre></td></tr></table></figure>

<p>正如你所见，我们有一个来自删除分支的提交 hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout -b my-branch-help</span></span><br><span class="line">Switched to a new branch &#x27;my-branch-help&#x27;</span><br><span class="line"><span class="meta prompt_">(my-branch-help)$ </span><span class="language-bash">git reset --hard 4e3cd85</span></span><br><span class="line">HEAD is now at 4e3cd85 foo.txt added</span><br><span class="line"><span class="meta prompt_">(my-branch-help)$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>

<p>看! 我们把删除的文件找回来了。 Git 的 <code>reflog</code> 在 rebasing 出错的时候也是同样有用的。</p>
<h3 id="我想删除一个分支"><a href="#我想删除一个分支" class="headerlink" title="我想删除一个分支"></a>我想删除一个分支</h3><p>删除一个远程分支:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git push origin --delete my-branch</span></span><br></pre></td></tr></table></figure>

<p>你也可以:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git push origin :my-branch</span></span><br></pre></td></tr></table></figure>

<p>删除一个本地分支:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git branch -D my-branch</span></span><br></pre></td></tr></table></figure>

<h3 id="我想从别人正在工作的远程分支签出-checkout-一个分支"><a href="#我想从别人正在工作的远程分支签出-checkout-一个分支" class="headerlink" title="我想从别人正在工作的远程分支签出(checkout)一个分支"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h3><p>首先, 从远程拉取(fetch) 所有分支:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git fetch --all</span></span><br></pre></td></tr></table></figure>

<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout --track origin/daves</span></span><br><span class="line">Branch daves set up to track remote branch daves from origin.</span><br><span class="line">Switched to a new branch &#x27;daves&#x27;</span><br></pre></td></tr></table></figure>

<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>
<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加标签并附加消息"><a href="#添加标签并附加消息" class="headerlink" title="添加标签并附加消息"></a>添加标签并附加消息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag_name&gt;</span><br><span class="line">git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="恢复已删除标签"><a href="#恢复已删除标签" class="headerlink" title="恢复已删除标签"></a>恢复已删除标签</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure>

<p>记下这个标签(tag)的 hash，然后用 Git 的 <a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-update-ref">update-ref</a>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref refs/tags/&lt;tag_name&gt; &lt;hash&gt;</span><br></pre></td></tr></table></figure>

<p>这时你的标签(tag)应该已经恢复了。</p>
<h2 id="Rebase-和-Merge"><a href="#Rebase-和-Merge" class="headerlink" title="Rebase 和 Merge"></a>Rebase 和 Merge</h2><blockquote>
<p>merge 与 rebase 虽然是 git 常用功能，但是强烈建议不要使用 git 命令来完成这项工作。</p>
<p>因为如果出现代码冲突，在没有代码比对工具的情况下，实在太艰难了。</p>
<p>你可以考虑使用各种 Git GUI 工具。</p>
</blockquote>
<h3 id="将分支合并到当前-HEAD-中"><a href="#将分支合并到当前-HEAD-中" class="headerlink" title="将分支合并到当前 HEAD 中"></a>将分支合并到当前 HEAD 中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="将当前-HEAD-版本重置到分支中"><a href="#将当前-HEAD-版本重置到分支中" class="headerlink" title="将当前 HEAD 版本重置到分支中"></a>将当前 HEAD 版本重置到分支中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="撤销-rebase-merge"><a href="#撤销-rebase-merge" class="headerlink" title="撤销 rebase&#x2F;merge"></a>撤销 rebase&#x2F;merge</h3><p>你可以合并(merge)或 rebase 了一个错误的分支, 或者完成不了一个进行中的 rebase&#x2F;merge。 Git 在进行危险操作的时候会把原始的 HEAD 保存在一个叫 ORIG_HEAD 的变量里, 所以要把分支恢复到 rebase&#x2F;merge 前的状态是很容易的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git reset --hard ORIG_HEAD</span></span><br></pre></td></tr></table></figure>

<h3 id="我已经-rebase-过-但是我不想强推-force-push"><a href="#我已经-rebase-过-但是我不想强推-force-push" class="headerlink" title="我已经 rebase 过, 但是我不想强推(force push)"></a>我已经 rebase 过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了 Git 历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git checkout my-branch</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git rebase -i master</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git merge --ff-only my-branch</span></span><br></pre></td></tr></table></figure>

<p>更多, 参见 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push">this SO thread</a>.</p>
<h3 id="我需要组合-combine-几个提交-commit"><a href="#我需要组合-combine-几个提交-commit" class="headerlink" title="我需要组合(combine)几个提交(commit)"></a>我需要组合(combine)几个提交(commit)</h3><p>假设你的工作分支将会做对于 <code>master</code> 的 pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git reset --soft master</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git commit -am <span class="string">&quot;New awesome feature&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式 rebase (interactive rebase):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git rebase -i master</span></span><br></pre></td></tr></table></figure>

<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD\~2</code> 进行 rebase， 组合最近 3 次提交(commit), 相对于<code>HEAD\~3</code>, 等等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git rebase -i HEAD~2</span></span><br></pre></td></tr></table></figure>

<p>在你执行了交互式 rebase 的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">pick b729ad5 fixup</span><br><span class="line">pick e3851e8 another <span class="keyword">fix</span></span><br><span class="line"></span><br><span class="line">## Rebase <span class="number">8074</span>d12..b729ad5 onto <span class="number">8074</span>d12</span><br><span class="line">#</span><br><span class="line">## Commands:</span><br><span class="line">##  <span class="keyword">p</span>, pick = use commit</span><br><span class="line">##  r, reword = use commit, but <span class="keyword">edit</span> the commit message</span><br><span class="line">##  <span class="keyword">e</span>, <span class="keyword">edit</span> = use commit, but <span class="keyword">stop</span> <span class="keyword">for</span> amending</span><br><span class="line">##  s, squash = use commit, but meld into <span class="keyword">previous</span> commit</span><br><span class="line">##  <span class="keyword">f</span>, fixup = like <span class="string">&quot;squash&quot;</span>, but discard this commit<span class="string">&#x27;s log message</span></span><br><span class="line"><span class="string">##  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>

<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>
<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>
<p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line"><span class="keyword">f</span> b729ad5 fixup</span><br><span class="line"><span class="keyword">f</span> e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>

<p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">s b729ad5 fixup</span><br><span class="line">s e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>

<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Newer, awesomer features</span><br><span class="line"></span><br><span class="line">## Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line">## with <span class="string">&#x27;#&#x27;</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line">## rebase in progress; onto <span class="number">8074</span>d12</span><br><span class="line">## You are currently editing <span class="keyword">a</span> commit <span class="keyword">while</span> rebasing branch <span class="string">&#x27;master&#x27;</span> <span class="keyword">on</span> <span class="string">&#x27;8074d12&#x27;</span>.</span><br><span class="line">#</span><br><span class="line">## Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line"># modified:   README.md</span><br><span class="line">#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果成功了, 你应该看到类似下面的内容:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">Successfully rebased and updated refs/heads/master.</span></span><br></pre></td></tr></table></figure>

<h4 id="安全合并-merging-策略"><a href="#安全合并-merging-策略" class="headerlink" title="安全合并(merging)策略"></a>安全合并(merging)策略</h4><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git merge --no-ff --no-commit my-branch</span></span><br></pre></td></tr></table></figure>

<h4 id="我需要将一个分支合并成一个提交-commit"><a href="#我需要将一个分支合并成一个提交-commit" class="headerlink" title="我需要将一个分支合并成一个提交(commit)"></a>我需要将一个分支合并成一个提交(commit)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git merge --squash my-branch</span></span><br></pre></td></tr></table></figure>

<h4 id="我只想组合-combine-未推的提交-unpushed-commit"><a href="#我只想组合-combine-未推的提交-unpushed-commit" class="headerlink" title="我只想组合(combine)未推的提交(unpushed commit)"></a>我只想组合(combine)未推的提交(unpushed commit)</h4><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git rebase -i @&#123;u&#125;</span></span><br></pre></td></tr></table></figure>

<p>这会产生一次交互式的 rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行 reorder&#x2F;fix&#x2F;squash 都是安全的。</p>
<h3 id="检查是否分支上的所有提交-commit-都合并-merge-过了"><a href="#检查是否分支上的所有提交-commit-都合并-merge-过了" class="headerlink" title="检查是否分支上的所有提交(commit)都合并(merge)过了"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的 head(或任何 commits)之间做一次 diff:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git <span class="built_in">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span></span><br></pre></td></tr></table></figure>

<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git <span class="built_in">log</span> master ^feature/120-on-scroll --no-merges</span></span><br></pre></td></tr></table></figure>

<h3 id="交互式-rebase-interactive-rebase-可能出现的问题"><a href="#交互式-rebase-interactive-rebase-可能出现的问题" class="headerlink" title="交互式 rebase(interactive rebase)可能出现的问题"></a>交互式 rebase(interactive rebase)可能出现的问题</h3><h4 id="这个-rebase-编辑屏幕出现’noop’"><a href="#这个-rebase-编辑屏幕出现’noop’" class="headerlink" title="这个 rebase 编辑屏幕出现’noop’"></a>这个 rebase 编辑屏幕出现’noop’</h4><p>如果你看到的是这样:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noop</span><br></pre></td></tr></table></figure>

<p>这意味着你 rebase 的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p>
<ul>
<li>检查确保主(master)分支没有问题</li>
<li>rebase <code>HEAD\~2</code> 或者更早</li>
</ul>
<h4 id="有冲突的情况"><a href="#有冲突的情况" class="headerlink" title="有冲突的情况"></a>有冲突的情况</h4><p>如果你不能成功的完成 rebase, 你可能必须要解决冲突。</p>
<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch my-branch</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">  modified:   README.md</span><br></pre></td></tr></table></figure>

<p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">some code</span><br><span class="line">=========</span><br><span class="line">some code</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="keyword">new</span>-commit</span><br></pre></td></tr></table></figure>

<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>
<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master*)$ git mergetool -t opendiff</span><br></pre></td></tr></table></figure>

<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续 rebase。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git add README.md</span></span><br><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure>

<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>
<p>任何时候你想结束整个 rebase 过程，回来 rebase 前的分支状态, 你可以做:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(my-branch)$ </span><span class="language-bash">git rebase --abort</span></span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>显示工作路径下已修改的文件：<code>git status</code></p>
<p>显示与上次提交版本文件的不同：<code>git diff</code></p>
<p>显示提交历史：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从最新提交开始，显示所有的提交记录（显示<span class="built_in">hash</span>， 作者信息，提交的标题和时间）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某个用户的所有提交</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --author=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示某个文件的所有修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示搜索内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从当前目录的所有文件中查找文本内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在某一版本中搜索文本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep <span class="string">&quot;Hello&quot;</span> v2.5</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="克隆所有子模块"><a href="#克隆所有子模块" class="headerlink" title="克隆所有子模块"></a>克隆所有子模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure>

<p>如果已经克隆了:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h3 id="已删除补丁-patch"><a href="#已删除补丁-patch" class="headerlink" title="已删除补丁(patch)"></a>已删除补丁(patch)</h3><p>如果某人在 GitHub 上给你发了一个 pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>
<p>做完提交后, 再修改作者，参见<a href="#commit-wrong-author">变更作者</a>。 然后, 应用变化, 再发起一个新的 pull request。</p>
<h2 id="跟踪文件-Tracking-Files"><a href="#跟踪文件-Tracking-Files" class="headerlink" title="跟踪文件(Tracking Files)"></a>跟踪文件(Tracking Files)</h2><h3 id="我只想改变一个文件名字的大小写，而不修改内容"><a href="#我只想改变一个文件名字的大小写，而不修改内容" class="headerlink" title="我只想改变一个文件名字的大小写，而不修改内容"></a>我只想改变一个文件名字的大小写，而不修改内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git <span class="built_in">mv</span> --force myfile MyFile</span></span><br></pre></td></tr></table></figure>

<h3 id="我想从-Git-删除一个文件，但保留该文件"><a href="#我想从-Git-删除一个文件，但保留该文件" class="headerlink" title="我想从 Git 删除一个文件，但保留该文件"></a>我想从 Git 删除一个文件，但保留该文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached log.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="Fork-项目"><a href="#Fork-项目" class="headerlink" title="Fork 项目"></a>Fork 项目</h2><p>GitHub 中 Fork 是 服务端的代码仓库克隆（即 新克隆出来的代码仓库在远程服务端），包含了原来的仓库（即 upstream repository，上游仓库）所有内容，如分支、Tag、提交。代码托管服务（如 Github、BitBucket）提供了方便的完成 Fork 操作的功能（在仓库页面点一下 Fork 按钮）。这样有了一个你自己的可以自由提交的远程仓库，然后可以通过的 Pull Request 把你的提交贡献回 原仓库。而对于原仓库 Owner 来说，鼓励别人 Fork 自己的仓库，通过 Pull Request 给自己的仓库做贡献，也能提高了自己仓库的知名度。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.github.com/en/github/getting-started-with-github/fork-a-repo">Fork a repo</a></p>
</blockquote>
<p>（1）执行 <code>git remote -v</code>，您将看到当前为 fork 配置的远程存储库。</p>
<p>（2）添加上游项目的仓库地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &lt;github仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>（3）确认是否添加成功，再次键入 <code>git remote -v</code>。</p>
<p>（4）获取上游项目更新，可以执行 <code>git fetch upstream</code></p>
<p>（5）同步上游项目的代码到新仓库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">merge</span></span><br><span class="line">git merge upstream/master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rebase</span></span><br><span class="line">git rebase upstream/master origin/master</span><br></pre></td></tr></table></figure>

<h2 id="我不知道我做错了些什么"><a href="#我不知道我做错了些什么" class="headerlink" title="我不知道我做错了些什么"></a>我不知道我做错了些什么</h2><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>
<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次 HEAD 的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(master)$ </span><span class="language-bash">git reflog</span></span><br><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD\~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure>

<p>上面的 reflog 展示了从 master 分支签出(checkout)到 2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@&#123;0&#125;</code>标识.</p>
<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前 master 上指向的提交(0254ea7)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0254ea7</span><br></pre></td></tr></table></figure>

<p>然后使用 git reset 就可以把 master 改回到之前的 commit，这提供了一个在历史被意外更改情况下的安全网。</p>
<h2 id="📚-资料"><a href="#📚-资料" class="headerlink" title="📚 资料"></a>📚 资料</h2><ul>
<li><strong>官方资源</strong><ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/">Git 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/git/git">Git Github</a></li>
<li><a target="_blank" rel="noopener" href="https://guides.github.com/">Github 官方教程</a></li>
</ul>
</li>
<li><strong>模板</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/github/gitignore">gitignore 模板</a> - .gitignore 文件模板</li>
<li><a target="_blank" rel="noopener" href="https://github.com/alexkaratarakis/gitattributes">gitattributes 模板</a> - .gitattributes 文件模板</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tiimgreen/github-cheat-sheet">github-cheat-sheet</a> - git 命令简略图表</li>
</ul>
</li>
<li><strong>Git 教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/">Learn Git branching</a> - 交互式教程</li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">Git 官方推荐教程</a> - Scott Chacon 的 Git 书。<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/k88hudson/git-flight-rules">git-flight-rules</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/521xueweihan/git-tips">git-tips</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/geeeeeeeeek/git-recipes">Git 中文教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的 Git 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xirong/my-git">有关 git 的学习资源</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">Git Cookbook</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/521xueweihan/git-tips">Git 奇技淫巧</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aseaday/git-style-guide">Git 风格指南</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/cnblogsfans/p/5075073.html">Git 在团队中的最佳实践–如何正确使用 Git Flow</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
</ul>
</li>
<li><strong>Git 工具</strong><ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/downloads/guis">guis</a> - Git 官网展示的客户端工具列表。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/gogits/gogs">gogs</a> - 极易搭建的自助 Git 服务。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/nvie/gitflow">gitflow</a> - 应用 <a target="_blank" rel="noopener" href="http://nvie.com/posts/a-successful-git-branching-model/">fit-flow</a> 模型的工具。</li>
<li><a target="_blank" rel="noopener" href="http://firstaidgit.io/">firstaidgit.io</a> 一个可搜索的最常被问到的 Git 的问题</li>
<li><a target="_blank" rel="noopener" href="https://github.com/unixorn/git-extra-commands">git-extra-commands</a> - 一堆有用的额外的 Git 脚本</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tj/git-extras">git-extras</a> - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more</li>
<li><a target="_blank" rel="noopener" href="https://github.com/qw3rtman/git-fire">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/git-tips/tips">git-tips</a> - Git 小提示</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Originate/git-town">git-town</a> - 通用，高级 Git 工作流支持！</li>
</ul>
</li>
<li><strong>GUI 客户端</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.gitkraken.com/">GitKraken</a> - 豪华的 Git 客户端 Windows, Mac &amp; Linux</li>
<li><a target="_blank" rel="noopener" href="https://git-cola.github.io/">git-cola</a> - 另外一个 Git 客户端 Windows &amp; OS X</li>
<li><a target="_blank" rel="noopener" href="https://github.com/git-up/GitUp">GitUp</a> - 一个新的 Git 客户端，在处理 Git 的复杂性上有自己的特点</li>
<li><a target="_blank" rel="noopener" href="https://rowanj.github.io/gitx/">gitx-dev</a> - 图形化的 Git 客户端 OS X</li>
<li><a target="_blank" rel="noopener" href="https://www.sourcetreeapp.com/">Source Tree</a> - 免费的图形化 Git 客户端 Windows &amp; OS X</li>
<li><a target="_blank" rel="noopener" href="http://www.git-tower.com/">Tower</a> - 图形化 Git 客户端 OS X(付费)</li>
</ul>
</li>
<li><strong>git cheat sheet</strong><ul>
<li><a target="_blank" rel="noopener" href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf">github-git-cheat-sheet</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/49bc50c9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/49bc50c9/" class="post-title-link" itemprop="url">一篇文章让你彻底掌握 Scala</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-14 15:27:00" itemprop="dateCreated datePublished" datetime="2021-04-14T15:27:00+08:00">2021-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一篇文章让你彻底掌握-Scala"><a href="#一篇文章让你彻底掌握-Scala" class="headerlink" title="一篇文章让你彻底掌握 Scala"></a>一篇文章让你彻底掌握 Scala</h1><blockquote>
<p>Scala 是大数据领域的热门语言，如：Akka、Kafka，所以，想要学习大数据顶级开源项目的源码，有必要具备一定的 Scala 基础。</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Scala 基本语法需要注意以下几点：</p>
<ul>
<li><strong>区分大小写</strong> - Scala 是大小写敏感的。</li>
<li><strong>类名</strong> - 对于所有的类名的第一个字母要大写。示例：<code>class MyFirstScalaClass</code></li>
<li><strong>方法名称</strong> - 所有的方法名称的第一个字母用小写。示例：<code>def myMethodName()</code></li>
<li><strong>程序文件名</strong> - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。示例: 假设”HelloWorld”是对象的名称。那么该文件应保存为’HelloWorld.scala”</li>
<li><strong><code>def main(args: Array[String])</code></strong> - Scala 程序从 <code>main()</code> 方法开始处理，这是每一个 Scala 程序的强制程序入口部分。</li>
<li>一行中只有空格或者带有注释，Scala 会认为其是空行，会忽略它。标记可以被空格或者注释来分割。</li>
<li>Scala 是面向行的语言，语句可以用分号（;）结束或换行符。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Scala 类似 Java 支持单行和多行注释。</p>
<p>【示例】单行和多行注释</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">   * 以下程序将输出&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, world!&quot;</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 Scala 中，使用关键词 <code>var</code> 声明变量，使用关键词 <code>val</code> 声明常量。</p>
<p>【示例】声明变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Too&quot;</span></span><br></pre></td></tr></table></figure>

<p>【示例】声明常量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="变量类型声明"><a href="#变量类型声明" class="headerlink" title="变量类型声明"></a>变量类型声明</h3><p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br><span class="line"><span class="comment">// 声明常量类型</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br></pre></td></tr></table></figure>

<p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">val</span> myVal = <span class="string">&quot;Hello, Scala!&quot;</span>;</span><br><span class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Scala 与 Java 有着相同的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Byte</td>
<td align="left">8 位有符号补码整数。数值区间为 -128 到 127</td>
</tr>
<tr>
<td align="left">Short</td>
<td align="left">16 位有符号补码整数。数值区间为 -32768 到 32767</td>
</tr>
<tr>
<td align="left">Int</td>
<td align="left">32 位有符号补码整数。数值区间为 -2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">Long</td>
<td align="left">64 位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td>
</tr>
<tr>
<td align="left">Float</td>
<td align="left">32 位, IEEE 754 标准的单精度浮点数</td>
</tr>
<tr>
<td align="left">Double</td>
<td align="left">64 位 IEEE 754 标准的双精度浮点数</td>
</tr>
<tr>
<td align="left">Char</td>
<td align="left">16 位无符号 Unicode 字符, 区间值为 U+0000 到 U+FFFF</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符序列</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">true 或 false</td>
</tr>
<tr>
<td align="left">Unit</td>
<td align="left">表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()。</td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">null 或空引用</td>
</tr>
<tr>
<td align="left">Nothing</td>
<td align="left">Nothing 类型在 Scala 的类层级的最底端；它是任何其他类型的子类型。</td>
</tr>
<tr>
<td align="left">Any</td>
<td align="left">Any 是所有其他类的超类</td>
</tr>
<tr>
<td align="left">AnyRef</td>
<td align="left">AnyRef 类是 Scala 里所有引用类(reference class)的基类</td>
</tr>
</tbody></table>
<p>上表中列出的数据类型都是<strong>对象</strong>，也就是说 scala 没有 java 中的原生类型。在 scala 是可以对数字等基础类型调用方法的。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Scala 数组声明的语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="逻辑控制语句"><a href="#逻辑控制语句" class="headerlink" title="逻辑控制语句"></a>逻辑控制语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>【示例】条件语句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 10&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 20&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 30&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;无法判断 X 的值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>和 Java 一样，Scala 支持 <code>while</code>、<code>do ... while</code>、<code>for</code> 三种循环语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;Value of a: &quot;</span> + a);</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**scala 不支持 <code>break</code> 和 <code>continue</code>**。但是，可以通过 <code>Breaks</code> 对象来进行循环控制。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">val</span> numList1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">val</span> numList2 = <span class="type">List</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> outer = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line">    <span class="keyword">val</span> inner = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line"></span><br><span class="line">    outer.breakable &#123;</span><br><span class="line">      <span class="keyword">for</span> (a &lt;- numList1) &#123;</span><br><span class="line">        println(<span class="string">&quot;Value of a: &quot;</span> + a);</span><br><span class="line">        inner.breakable &#123;</span><br><span class="line">          <span class="keyword">for</span> (b &lt;- numList2) &#123;</span><br><span class="line">            println(<span class="string">&quot;Value of b: &quot;</span> + b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">12</span>) &#123;</span><br><span class="line">              inner.<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// 内嵌循环中断</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// 外部循环中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>scala 的 <code>match</code> 对应 Java 里的 <code>switch</code>，但是写在选择器表达式之后。即： <strong>选择器 match {备选项}。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author peng.zhang</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(matchTest(<span class="string">&quot;two&quot;</span>))</span><br><span class="line">    println(matchTest(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">    println(matchTest(<span class="number">1</span>))</span><br><span class="line">    println(matchTest(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>      =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;two&quot;</span>  =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">&quot;scala.Int&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _      =&gt; <span class="string">&quot;many&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Scala 含有丰富的内置运算符，包括以下几种类型：</p>
<ul>
<li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></li>
<li>关系运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
<li>位运算符：<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code> （无符号右移）</li>
<li>赋值运算符：<code>=</code></li>
</ul>
<h2 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h2><p>Scala 有方法与函数，二者在语义上的区别很小。</p>
<p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p>
<p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p>
<p>Scala 中使用 <code>val</code> 语句可以定义函数，<code>def</code> 语句定义方法。</p>
<p>【示例】</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">Int</span>) = x + <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
<p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p>
<p>如下面这段匿名的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>

<p>在 multiplier 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 multiplier 函数被调用时，i 被赋予一个新的值。然而，factor 不是形式参数，而是自由变量，考虑下面代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>

<p>这里我们引入一个自由变量 factor，这个变量定义在函数外面。</p>
<p>这样定义的函数变量 multiplier 成为一个”闭包”，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClosureDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;muliplier(1) value = &quot;</span> + multiplier(<span class="number">1</span>))</span><br><span class="line">    println(<span class="string">&quot;muliplier(2) value = &quot;</span> + multiplier(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Scala 集合支持 List、Set、Map、元祖、Option。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义整型 List</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Set</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Map</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Map</span>(<span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个不同类型元素的元组</span></span><br><span class="line"><span class="keyword">val</span> x = (<span class="number">10</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Option</span></span><br><span class="line"><span class="keyword">val</span> x:<span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器 it 的两个基本操作是 <strong>next</strong> 和 <strong>hasNext</strong>。</p>
<p>调用 <strong>it.next()</strong> 会返回迭代器的下一个元素，并且更新迭代器的状态。</p>
<p>调用 <strong>it.hasNext()</strong> 用于检测集合中是否还有元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> it = <span class="type">Iterator</span>(<span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (it.hasNext)&#123;</span><br><span class="line">         println(it.next())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    println(<span class="string">&quot;x 的坐标点 : &quot;</span> + x);</span><br><span class="line">    println(<span class="string">&quot;y 的坐标点 : &quot;</span> + y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">override val xc: <span class="type">Int</span>, override val yc: <span class="type">Int</span>, val zc: <span class="type">Int</span></span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Point</span>(xc, yc) &#123;</span><br><span class="line">  <span class="keyword">var</span> z: <span class="type">Int</span> = zc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, dz: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    z = z + dz</span><br><span class="line">    println(<span class="string">&quot;x 的坐标点 : &quot;</span> + x);</span><br><span class="line">    println(<span class="string">&quot;y 的坐标点 : &quot;</span> + y);</span><br><span class="line">    println(<span class="string">&quot;z 的坐标点 : &quot;</span> + z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> loc = <span class="keyword">new</span> <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移到一个新的位置</span></span><br><span class="line">    loc.move(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。</p>
<p>与接口不同的是，它还可以定义属性和方法的实现。</p>
<p>一般情况下 Scala 的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNotEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = !isEqual(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">xc: <span class="type">Int</span>, yc: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(obj: <span class="type">Any</span>) =</span><br><span class="line">    obj.isInstanceOf[<span class="type">Point</span>] &amp;&amp;</span><br><span class="line">      obj.asInstanceOf[<span class="type">Point</span>].x == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(p1.isNotEqual(p2))</span><br><span class="line">    println(p1.isNotEqual(p3))</span><br><span class="line">    println(p1.isNotEqual(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Scala 抛出异常的方法和 Java 一样，使用 <code>throw</code> 关键词。</p>
<p>【示例】抛出异常</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p>【示例】捕获异常</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileNotFoundException</span>, <span class="type">FileReader</span>, <span class="type">IOException</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Missing file exception&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;IO Exception&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;Exiting finally...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h3><p>使用 <code>scala.io.StdIn.readLine()</code> 方法读取用户输入</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StdInDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    print(<span class="string">&quot;请输入内容: &quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> line = <span class="type">StdIn</span>.readLine()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;你输入的是: &quot;</span> + line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;文件内容为:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">&quot;test.txt&quot;</span>).foreach &#123;</span><br><span class="line">      print</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h3><p>Scala 使用 <code>package</code> 关键字定义包，在 Scala 将代码定义到某个包中有两种方式：</p>
<p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure>

<p>第二种方法有些类似 C#，如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Scala 使用 <code>import</code> 关键字引用包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color  <span class="comment">// 引入Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt._  <span class="comment">// 引入包内所有成员</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">handler</span><span class="params">(evt: event.ActionEvent)</span> &#123; <span class="comment">// java.awt.event.ActionEvent</span></span><br><span class="line">  ...  <span class="comment">// 因为引入了java.awt，所以可以省去前面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import 语句可以出现在任何地方，而不是只能在文件顶部。import 的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p>
<p>如果想要引入包中的几个成员，可以使用 selector（选取器）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.&#123;Color, Font&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;HashMap =&gt; JavaHashMap&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;HashMap =&gt; _, _&#125; <span class="comment">// 引入了util包的所有成员，但是HashMap被隐藏了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以 scala 开头的包，在使用时都是省去 scala.的。</p>
</blockquote>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>Scala 访问修饰符基本和 Java 的一样，分别有：private，protected，public。</p>
<p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p>
<p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">      println(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span> </span>&#123;</span><br><span class="line">      f() <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.scala-lang.org/">Scala 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-tutorial.html">Scala 菜鸟教程</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/da2fad50/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/da2fad50/" class="post-title-link" itemprop="url">Kafka 可靠传输</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-14 15:05:34" itemprop="dateCreated datePublished" datetime="2021-04-14T15:05:34+08:00">2021-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-可靠传输"><a href="#Kafka-可靠传输" class="headerlink" title="Kafka 可靠传输"></a>Kafka 可靠传输</h1><h2 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h2><p>如何保证消息的可靠性传输，或者说，如何保证消息不丢失？这对于任何 MQ 都是核心问题。</p>
<p>一条消息从生产到消费，可以划分三个阶段：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070727544.png"></p>
<ul>
<li><strong>生产阶段</strong>：Producer 创建消息，并通过网络发送给 Broker。</li>
<li><strong>存储阶段</strong>：Broker 收到消息并存储，如果是集群，还要同步副本给其他 Broker。</li>
<li><strong>消费阶段</strong>：Consumer 向 Broker 请求消息，Broker 通过网络传输给 Consumer。</li>
</ul>
<p>这三个阶段都可能丢失数据，所以要保证消息丢失，就需要任意一环都保证可靠。</p>
<h3 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h3><p>存储阶段指的是 Kafka Server，也就是 Broker 如何保证消息不丢失。</p>
<p>一句话概括，<strong>Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证</strong>。</p>
<p>上面的话可以解读为：</p>
<ul>
<li><strong>已提交</strong>：<strong>只有当消息被写入分区的若干同步副本时，才被认为是已提交的</strong>。为什么是若干个 Broker 呢？这取决于你对“已提交”的定义。你可以选择只要 Leader 成功保存该消息就算是已提交，也可以是令所有 Broker 都成功保存该消息才算是已提交。</li>
<li><strong>持久化</strong>：Kafka 的数据存储在磁盘上，所以只要写入成功，天然就是持久化的。</li>
<li><strong>只要还有一个副本是存活的，那么已提交的消息就不会丢失</strong>。</li>
<li><strong>消费者只能读取已提交的消息</strong>。</li>
</ul>
<h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p><strong>Kafka 的副本机制是 kafka 可靠性保证的核心</strong>。</p>
<p>Kafka 的主题被分为多个分区，分区是基本的数据块。每个分区可以有多个副本，有一个是 Leader（主副本），其他是 Follower（从副本）。所有数据都直接发送给 Leader，或者直接从 Leader 读取事件。Follower 只需要与 Leader 保持同步，并及时复制最新的数据。当 Leader 宕机时，从 Follower 中选举一个成为新的 Leader。</p>
<p>Broker 有 3 个配置参数会影响 Kafka 消息存储的可靠性。</p>
<h4 id="副本数"><a href="#副本数" class="headerlink" title="副本数"></a>副本数</h4><p><strong><code>replication.factor</code> 的作用是设置每个分区的副本数</strong>。<code>replication.factor</code> 是主题级别配置； <code>default.replication.factor</code> 是 broker 级别配置。</p>
<p>副本数越多，数据可靠性越高；但由于副本数增多，也会增加同步副本的开销，可能会降低集群的可用性。一般，建议设为 3，这也是 Kafka 的默认值。</p>
<h4 id="不完全的选主"><a href="#不完全的选主" class="headerlink" title="不完全的选主"></a>不完全的选主</h4><p><code>unclean.leader.election.enable</code> 用于控制是否支持不同步的副本参与选举 Leader。<code>unclean.leader.election.enable</code> 是 broker 级别（实际上是集群范围内）配置，默认值为 true。</p>
<ul>
<li>如果设为 true，代表着<strong>允许不同步的副本成为主副本</strong>（即不完全的选举），那么将<strong>面临丢失消息的风险</strong>；</li>
<li>如果设为 false，就要<strong>等待原先的主副本重新上线</strong>，从而降低了可用性。</li>
</ul>
<h4 id="最少同步副本"><a href="#最少同步副本" class="headerlink" title="最少同步副本"></a>最少同步副本</h4><p><strong><code>min.insync.replicas</code> 控制的是消息至少要被写入到多少个副本才算是“已提交”</strong>。<code>min.insync.replicas</code> 是主题级别和 broker 级别配置。</p>
<p>尽管可以为一个主题配置 3 个副本，但还是可能会出现只有一个同步副本的情况。如果这个同步副本变为不可用，则必须在可用性和数据一致性之间做出选择。Kafka 中，消息只有被写入到所有的同步副本之后才被认为是已提交的。但如果只有一个同步副本，那么在这个副本不可用时，则数据就会丢失。</p>
<p>如果要确保已经提交的数据被已写入不止一个副本，就需要把最小同步副本的设置为大一点的值。</p>
<blockquote>
<p>注意：要确保 <code>replication.factor</code> &gt; <code>min.insync.replicas</code>。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 <code>replication.factor = min.insync.replicas + 1</code>。</p>
</blockquote>
<h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><p>在生产消息阶段，消息队列一般通过请求确认机制，来保证消息的可靠传递，Kafka 也不例外。</p>
<p><a href="Kafka%E7%94%9F%E4%BA%A7">Kafka 生产</a> 中提到了，Kafka 有三种发送方式：同步、异步、异步回调。</p>
<p>同步方式能保证消息不丢失，但性能太差；异步方式发送消息，通常会立即返回，但消息可能丢失。</p>
<p>解决生产者丢失消息的方案：</p>
<p>生产者使用异步回调方式 <code>producer.send(msg, callback)</code> 发送消息。callback（回调）能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。</p>
<ul>
<li>如果是因为那些瞬时错误，那么仅仅让 Producer 重试就可以了；</li>
<li>如果是消息不合格造成的，那么可以调整消息格式后再次发送。</li>
</ul>
<p>然后，需要基于以下几点来保证 Kafka 生产者的可靠性：</p>
<h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h4><p>生产者可选的确认模式有三种：<code>acks=0</code>、<code>acks=1</code>、<code>acks=all</code>。</p>
<ul>
<li><p><code>acks=0</code>、<code>acks=1</code> 都有丢失数据的风险。</p>
</li>
<li><p><code>acks=all</code> 意味着会等待所有同步副本都收到消息。再结合 <code>min.insync.replicas</code> ，就可以决定在得到确认响应前，至少有多少副本能够收到消息。</p>
</li>
</ul>
<p>这是最保险的做法，但也会降低吞吐量。</p>
<h4 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h4><p>如果 broker 返回的错误可以通过<strong>重试</strong>来解决，生产者会自动处理这些错误。</p>
<ul>
<li><strong>可重试错误</strong>，如：<code>LEADER_NOT_AVAILABLE</code>，主副本不可用，可能过一段时间，集群就会选举出新的主副本，重试可以解决问题。</li>
<li><strong>不可重试错误</strong>，如：<code>INVALID_CONFIG</code>，即使重试，也无法改变配置选项，重试没有意义。</li>
</ul>
<p>需要注意的是：有时可能因为网络问题导致没有收到确认，但实际上消息已经写入成功。生产者会认为出现临时故障，重试发送消息，这样就会出现重复记录。所以，尽可能在业务上保证幂等性。</p>
<p>设置 <code>retries</code> 为一个较大的值。这里的 <code>retries</code> 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>开发者需要自行处理的错误：</p>
<ul>
<li>不可重试的 broker 错误，如消息大小错误、认证错误等；</li>
<li>消息发送前发生的错误，如序列化错误；</li>
<li>生产者达到重试次数上限或消息占用的内存达到上限时发生的错误。</li>
</ul>
<h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><p>前文已经提到，<strong>消费者只能读取已提交的消息</strong>。这就保证了消费者接收到消息时已经具备了数据一致性。</p>
<p>消费者唯一要做的是确保哪些消息是已经读取过的，哪些是没有读取过的（通过提交偏移量给 Broker 来确认）。如果消费者提交了偏移量却未能处理完消息，那么就有可能造成消息丢失，这也是消费者丢失消息的主要原因。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200727140159.png" alt="img"></p>
<h4 id="消费者的可靠性配置"><a href="#消费者的可靠性配置" class="headerlink" title="消费者的可靠性配置"></a>消费者的可靠性配置</h4><ul>
<li><code>group.id</code> - 如果希望消费者可以看到主题的所有消息，那么需要为它们设置唯一的 <code>group.id</code>。</li>
<li><code>auto.offset.reset</code> - 有两个选项：<ul>
<li><code>earliest</code> - 消费者会从分区的开始位置读取数据</li>
<li><code>latest</code> - 消费者会从分区末尾位置读取数据</li>
</ul>
</li>
<li><code>enable.auto.commit</code> - 消费者自动提交偏移量。如果设为 true，处理流程更简单，但无法保证重复处理消息。</li>
<li><code>auto.commit.interval.ms</code> - 自动提交的频率，默认为每 5 秒提交一次。</li>
</ul>
<h4 id="显示提交偏移量"><a href="#显示提交偏移量" class="headerlink" title="显示提交偏移量"></a>显示提交偏移量</h4><blockquote>
<p>如果 <code>enable.auto.commit</code> 设为 true，即自动提交，就无需考虑提交偏移量的问题。</p>
</blockquote>
<p>如果选择显示提交偏移量，需要考虑以下问题：</p>
<ul>
<li>必须在处理完消息后再发送确认（提交偏移量），不要收到消息立即确认。</li>
<li>提交频率是性能和重复消息数之间的权衡</li>
<li>分区再均衡</li>
<li>消费可能需要重试机制</li>
<li>超时处理</li>
<li>消费者可能需要维护消费状态，如：处理完消息后，记录在数据库中。</li>
<li>幂等性设计<ul>
<li>写数据库：根据主键判断记录是否存在</li>
<li>写 Redis：set 操作天然具有幂等性</li>
<li>复杂的逻辑处理，则可以在消息中加入全局 ID</li>
</ul>
</li>
</ul>
<h2 id="重复消息"><a href="#重复消息" class="headerlink" title="重复消息"></a>重复消息</h2><p>在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：</p>
<ul>
<li><strong>At most once</strong>：至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li>
<li><strong>At least once</strong>: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。</li>
<li><strong>Exactly once</strong>：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。</li>
</ul>
<p>绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。也就是说，消息队列很难保证消息不重复。</p>
<p>一般解决重复消息的办法是，在消费端，<strong>保证消费消息的操作具备幂等性</strong>。</p>
<p>常用的实现幂等操作的方法：</p>
<h3 id="利用数据库的唯一约束实现幂等"><a href="#利用数据库的唯一约束实现幂等" class="headerlink" title="利用数据库的唯一约束实现幂等"></a>利用数据库的唯一约束实现幂等</h3><p>关系型数据库可以使用 <code>INSERT IF NOT EXIST</code> 语句防止重复；Redis 可以使用 <code>SETNX</code> 命令来防止重复；其他数据库只要支持类似语义，也是一个道理。</p>
<h3 id="为更新的数据设置前置条件"><a href="#为更新的数据设置前置条件" class="headerlink" title="为更新的数据设置前置条件"></a>为更新的数据设置前置条件</h3><p>如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。</p>
<p>但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。</p>
<h3 id="记录并检查操作"><a href="#记录并检查操作" class="headerlink" title="记录并检查操作"></a>记录并检查操作</h3><p>还有一种通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p>
<p>具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。</p>
<p>需要注意的是，“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。这一组操作可以通过分布式事务或分布式锁来保证其原子性。</p>
<h2 id="消息的有序性"><a href="#消息的有序性" class="headerlink" title="消息的有序性"></a>消息的有序性</h2><p>某些场景下，可能会要求按序发送消息。</p>
<h3 id="方案一、单-Partition"><a href="#方案一、单-Partition" class="headerlink" title="方案一、单 Partition"></a>方案一、单 Partition</h3><p>Kafka 每一个 Partition 只能隶属于消费者群组中的一个 Consumer，换句话说，每个 Partition 只能被一个 Consumer 消费。所以，如果 Topic 是单 Partition，自然是有序的。</p>
<p>方案分析</p>
<p>优点：简单粗暴。开发者什么也不用做。</p>
<p>缺点：<strong>Kafka 基于 Partition 实现其高并发</strong>能力，如果使用单 Partition，会严重限制 Kafka 的吞吐量。</p>
<p>结论：作为分布式消息引擎，限制并发能力，显然等同于自废武功，所以，这个方案几乎是不可接受的。</p>
<h3 id="方案二、同一个-key-的消息发送给指定-Partition"><a href="#方案二、同一个-key-的消息发送给指定-Partition" class="headerlink" title="方案二、同一个 key 的消息发送给指定 Partition"></a>方案二、同一个 key 的消息发送给指定 Partition</h3><p>（1）生产者端显示指定 key 发往一个指定的 Partition，就可以保证同一个 key 在这个 Partition 中是有序的。</p>
<p>（2）接下来，消费者端为每个 key 设定一个缓存队列，然后让一个独立线程负责消费指定 key 的队列，这就保证了消费消息也是有序的。</p>
<h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><p>先修复消费者，然后停掉当前所有消费者。</p>
<p>新建 Topic，扩大分区，以提高并发处理能力。</p>
<p>创建临时消费者程序，并部署在多节点上，扩大消费处理能力。</p>
<p>最后处理完积压消息后，恢复原先部署架构。</p>
<h2 id="验证系统可靠性"><a href="#验证系统可靠性" class="headerlink" title="验证系统可靠性"></a>验证系统可靠性</h2><p>建议从 3 个层面验证系统的可靠性：</p>
<ul>
<li><strong>配置验证</strong></li>
<li><strong>应用验证</strong><ul>
<li>客户端和服务器断开连接</li>
<li>选举</li>
<li>依次重启 broker</li>
<li>依次重启生产者</li>
<li>依次重启消费者</li>
</ul>
</li>
<li><strong>监控可靠性</strong><ul>
<li>对于生产者来说，最重要的两个指标是消息的 <code>error-rate</code> 和 <code>retry-rate</code>。如果这两个指标上升，说明系统出了问题。</li>
<li>对于消费者来说，最重要的指标是 <code>consumer-lag</code>，该指标表明了消费者的处理速度与最近提交到分区里的偏移量之间还有多少差距。</li>
</ul>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>生产者</p>
<ol>
<li>不要使用 <code>producer.send(msg)</code>，而要使用 <code>producer.send(msg, callback)</code>。记住，一定要使用带有回调通知的 <code>send</code> 方法。</li>
<li>设置 <code>acks = all</code>。<code>acks</code> 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li>
<li>设置 <code>retries</code> 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 <code>retries &gt; 0</code> 的 Producer 能够自动重试消息发送，避免消息丢失。</li>
</ol>
<p>服务器（Kafka Broker）</p>
<ol>
<li>设置 <code>unclean.leader.election.enable = false。</code>这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li>
<li>设置 <code>replication.factor</code> &gt;&#x3D; 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li>
<li>设置 <code>min.insync.replicas</code> &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li>
<li>确保 <code>replication.factor</code> &gt; <code>min.insync.replicas</code>。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 <code>replication.factor = min.insync.replicas + 1</code>。</li>
</ol>
<p>消费者</p>
<ol>
<li>确保消息消费完成再提交。Consumer 端有个参数 <code>enable.auto.commit</code>，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100032301">消息队列高手课</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/50068496/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/50068496/" class="post-title-link" itemprop="url">Kafka 消费</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-14 15:05:34" itemprop="dateCreated datePublished" datetime="2021-04-14T15:05:34+08:00">2021-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-消费"><a href="#Kafka-消费" class="headerlink" title="Kafka 消费"></a>Kafka 消费</h1><h2 id="消费者简介"><a href="#消费者简介" class="headerlink" title="消费者简介"></a>消费者简介</h2><h3 id="获取消息模式"><a href="#获取消息模式" class="headerlink" title="获取消息模式"></a>获取消息模式</h3><p>消息引擎获取消息有两种模式：</p>
<ul>
<li><strong>push 模式</strong> - MQ 推送数据给消费者</li>
<li><strong>pull 模式</strong> - 消费者主动向 MQ 请求数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502031317162.png"></p>
<p>Kafka 消费者（Consumer）以 pull 方式从 Broker 拉取消息。相比于 push 方式，pull 方式灵活度和扩展性更好，因为消费的主动性由消费者自身控制。</p>
<p>push 模式的优缺点：</p>
<ul>
<li>缺点：由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理了。push 模式下，当 broker 推送的速率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了。</li>
</ul>
<p>push 模式的优缺点：</p>
<ul>
<li>优点：consumer 可以根据自己的消费能力自主的决定消费策略</li>
<li>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到达。为了避免这点，Kafka 有个参数可以让 consumer 阻塞直到新消息到达</li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>每个 Consumer 的唯一元数据是该 Consumer 在日志中消费的位置。这个偏移量是由 Consumer 控制的：Consumer 通常会在读取记录时线性的增加其偏移量。但实际上，由于位置由 Consumer 控制，所以 Consumer 可以采用任何顺序来消费记录。</p>
<p><strong>一条消息只有被提交，才会被消费者获取到</strong>。如下图，只能消费 Message0、Message1、Message2：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621113917.png" alt="img"></p>
<h3 id="消费者群组"><a href="#消费者群组" class="headerlink" title="消费者群组"></a>消费者群组</h3><p><strong>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制</strong>。</p>
<p>Kafka 的写入数据量很庞大，如果只有一个消费者，消费消息速度很慢，时间长了，就会造成数据积压。为了减少数据积压，Kafka 支持消费者群组，可以让多个消费者并发消费消息，对数据进行分流。</p>
<p>Kafka 消费者从属于消费者群组，<strong>一个群组里的 Consumer 订阅同一个 Topic，一个主题有多个 Partition，每一个 Partition 只能隶属于消费者群组中的一个 Consumer</strong>。</p>
<p>如果超过主题的分区数量，那么有一部分消费者就会被闲置，不会接收到任何消息。</p>
<p>同一时刻，<strong>一条消息只能被同一消费者组中的一个消费者实例消费</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070722981.png"></p>
<p><strong>不同消费者群组之间互不影响</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070723165.png"></p>
<h3 id="消费流程"><a href="#消费流程" class="headerlink" title="消费流程"></a>消费流程</h3><p>Kafka 消费者通过 <code>poll</code> 模式来获取消息，但是获取消息时并不是立刻返回结果，需要考虑两个因素：</p>
<ul>
<li>消费者通过 <code>customer.poll(time)</code> 中设置等待时间</li>
<li>Broker 会等待累计一定量数据，然后发送给消费者。这样可以减少网络开销。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070724283.png"></p>
<p>poll 除了获取消息外，还有其他作用：</p>
<ul>
<li><strong>发送心跳信息</strong>。消费者通过向被指派为群组协调器的 Broker 发送心跳来维护他和群组的从属关系，当机器宕掉后，群组协调器触发再均衡。</li>
</ul>
<h2 id="消费者-API"><a href="#消费者-API" class="headerlink" title="消费者 API"></a>消费者 API</h2><h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// 服务器地址</span></span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 消费者群组</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭自动提交偏移量</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 key 反序列化器</span></span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 value 反序列化器</span></span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br></pre></td></tr></table></figure>

<h3 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅主题列表</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">&quot;t1&quot;</span>, <span class="string">&quot;t2&quot;</span>));</span><br><span class="line"><span class="comment">// 订阅所有与 test 相关的主题</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;test.*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>subscribe</code> 方法允许传入一个正则表达式，这样就可以匹配多个主题。如果有人创建了新的主题，并且主题名恰好匹配正则表达式，那么会立即触发一次分区再均衡，消费者就可以读取新添加的主题。</p>
<h3 id="轮询获取消息"><a href="#轮询获取消息" class="headerlink" title="轮询获取消息"></a>轮询获取消息</h3><p>消息轮询是消费者 API 的核心。一旦消费者订阅了主题，轮询就会处理所有细节，包括：群组协调、分区再均衡、发送心跳和获取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 3. 轮询</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 消费消息</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;topic = &#123;&#125;, partition = &#123;&#125;, offset = &#123;&#125;, key = &#123;&#125;, value = &#123;&#125;&quot;</span>,</span><br><span class="line">                record.topic(), record.partition(),</span><br><span class="line">                record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 5. 退出程序前，关闭消费者</span></span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动提交偏移量"><a href="#手动提交偏移量" class="headerlink" title="手动提交偏移量"></a>手动提交偏移量</h3><h4 id="（1）同步提交"><a href="#（1）同步提交" class="headerlink" title="（1）同步提交"></a>（1）同步提交</h4><p><strong>使用 <code>commitSync()</code> 提交偏移量最简单也最可靠</strong>。这个 API 会提交由 <code>poll()</code> 方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n&quot;</span>,</span><br><span class="line">            record.topic(), record.partition(),</span><br><span class="line">            record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;commit failed&quot;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步提交的缺点：<strong>同步提交方式会一直阻塞，直到接收到 Broker 的响应请求，这会大大限制吞吐量</strong>。</p>
<h4 id="（2）异步提交"><a href="#（2）异步提交" class="headerlink" title="（2）异步提交"></a>（2）异步提交</h4><p><strong>在成功提交或碰到无法恢复的错误之前，<code>commitSync()</code> 会一直重试，但是 <code>commitAsync()</code> 不会</strong>，这也是 <code>commitAsync()</code> 不好的一个地方。<strong>它之所以不进行重试，是因为在它收到服务器响应的时候，可能有一个更大的偏移量已经提交成功</strong>。假设我们发出一个请求用于提交偏移量 2000，这个时候发生了短暂的通信问题，服务器收不到请求，自然也不会作出任何响应。与此同时，我们处理了另外一批消息，并成功提交了偏移量 3000。如果 <code>commitAsync()</code> 重新尝试提交偏移量 2000，它有可能在偏移量 3000 之后提交成功。这个时候<strong>如果发生再均衡，就会出现重复消息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = % d, customer = %s, country = %s\n &quot;</span>,</span><br><span class="line">            record.topic(), record.partition(), record.offset(),</span><br><span class="line">            record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>commitAsync()</code> 也支持回调</strong>，在 Broker 作出响应时会执行回调。<strong>回调经常被用于记录提交错误或生成度量指标，不过如果要用它来进行重试，则一定要注意提交的顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = % d, customer = %s, country = %s\n &quot;</span>,</span><br><span class="line">            record.topic(), record.partition(), record.offset(),</span><br><span class="line">            record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; log.error(<span class="string">&quot;Commit failed for offsets &#123;&#125;&quot;</span>, offsets, e); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重试异步提交</strong></p>
<p>可以使用一个单调递增的序列号来维护异步提交的顺序。在每次提交偏移量之后或在回调里提交偏移量时递增序列号。在进行重试前，先检查回调的序列号和即将提交的偏移量是否相等，如果相等，说明没有新的提交，那么可以安全地进行重试；如果序列号比较大，说明有一个新的提交已经发送出去了，应该停止重试。</p>
</blockquote>
<h4 id="（3）同步和异步组合提交"><a href="#（3）同步和异步组合提交" class="headerlink" title="（3）同步和异步组合提交"></a>（3）同步和异步组合提交</h4><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但<strong>如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功</strong>。</p>
<p>因此，在消费者关闭前一般会组合使用 <code>commitSync()</code> 和 <code>commitAsync()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = % d, customer = %s, country = %s\n &quot;</span>,</span><br><span class="line">                record.topic(), record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Unexpected error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）提交特定的偏移量"><a href="#（4）提交特定的偏移量" class="headerlink" title="（4）提交特定的偏移量"></a>（4）提交特定的偏移量</h4><p>提交偏移量的频率和处理消息批次的频率是一样的。如果想要更频繁地提交该怎么办？如果 <code>poll()</code> 方法返回一大批数据，为了避免因再均衡引起的重复处理整批消息，想要在批次中间提交偏移量该怎么办？这种情况无法通过调用 <code>commitSync()</code> 或 <code>commitAsync()</code> 来实现，因为它们只会提交最后一个偏移量，而此时该批次里的消息还没有处理完。</p>
<p>解决办法是：<strong>消费者 API 允许在调用 <code>commitSync()</code> 和 <code>commitAsync()</code> 方法时传进去希望提交的分区和偏移量的 map</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = % d, customer = %s, country = %s\n &quot;</span>,</span><br><span class="line">                      record.topic(), record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">    currentOffsets.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(),</span><br><span class="line">                                          record.partition()), <span class="keyword">new</span></span><br><span class="line">                       <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>) &#123; consumer.commitAsync(currentOffsets, <span class="literal">null</span>); &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）从特定偏移量处开始处理"><a href="#（5）从特定偏移量处开始处理" class="headerlink" title="（5）从特定偏移量处开始处理"></a>（5）从特定偏移量处开始处理</h4><p>使用 <code>poll()</code> 方法可以从各个分区的最新偏移量处开始处理消息。</p>
<p>不过，有时候，我们可能需要从特定偏移量处开始处理消息。</p>
<ul>
<li>从分区的起始位置开始读消息：<code>seekToBeginning(Collection&lt;TopicPartition&gt; partitions)</code> 方法</li>
<li>从分区的末尾位置开始读消息：<code>seekToEnd(Collection&lt;TopicPartition&gt; partitions)</code> 方法</li>
<li>查找偏移量：<code>seek(TopicPartition partition, long offset)</code> 方法</li>
</ul>
<p>通过 <code>seek(TopicPartition partition, long offset)</code> 可以实现处理消息和提交偏移量在一个事务中完成。思路就是需要在客户端建立一张数据表，保证处理消息和和消息偏移量位置写入到这张数据表。在一个事务中，此时就可以保证处理消息和记录偏移量要么同时成功，要么同时失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(topic);</span><br><span class="line"><span class="comment">// 1.第一次调用pool,加入消费者群组</span></span><br><span class="line">consumer.poll(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.获取负责的分区，并从本地数据库读取改分区最新偏移量，并通过seek方法修改poll获取消息的位置</span></span><br><span class="line"><span class="keyword">for</span> (TopicPartition partition: consumer.assignment())</span><br><span class="line">    consumer.seek(partition, getOffsetFromDB(partition));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">    consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">    &#123;</span><br><span class="line">        processRecord(record);</span><br><span class="line">        storeRecordInDB(record);</span><br><span class="line">        storeOffsetInDB(record.topic(), record.partition(),</span><br><span class="line">        record.offset());</span><br><span class="line">    &#125;</span><br><span class="line">    commitDBTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p><strong>如果想让消费者从轮询消费消息的无限循环中退出，可以通过另一个线程调用 <code>consumer.wakeup()</code> 方法</strong>。 <strong><code>consumer.wakeup()</code> 是消费者唯一一个可以从其他线程里安全调用的方法</strong>。调用 <code>consumer.wakeup()</code> 可以退出 <code>poll()</code> ，并抛出 <code>WakeupException</code> 异常，或者如果调用 <code>consumer.wakeup()</code> 时线程没有等待轮询，那么异常将在下一轮调用 <code>poll()</code> 时抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting exit...&quot;</span>);</span><br><span class="line">        consumer.wakeup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// looping until ctrl-c, the shutdown hook will cleanup on exit</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            movingAvg.consumer.poll(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis() +</span><br><span class="line">            <span class="string">&quot;--  waiting for data...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s\n&quot;</span>,</span><br><span class="line">                record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp: consumer.assignment())</span><br><span class="line">            System.out.println(<span class="string">&quot;Committing offset at position:&quot;</span> +</span><br><span class="line">                consumer.position(tp));</span><br><span class="line">            movingAvg.consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// ignore for shutdown</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;Closed consumer and we are done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h2><h3 id="什么是分区再均衡"><a href="#什么是分区再均衡" class="headerlink" title="什么是分区再均衡"></a>什么是分区再均衡</h3><p>分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为<strong>分区再均衡（Rebalance）</strong>。<strong>Rebalance 实现了消费者群组的高可用性和伸缩性</strong>。</p>
<p><strong>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区</strong>。比如某个 Group 下有 20 个 Consumer 实例，它订阅了一个具有 100 个分区的 Topic。正常情况下，Kafka 平均会为每个 Consumer 分配 5 个分区。这个分配的过程就叫 Rebalance。</p>
<p>当在群组里面新增&#x2F;移除消费者或者新增&#x2F;移除 kafka 集群 broker 节点时，群组协调器 Broker 会触发再均衡，重新为每一个 Partition 分配消费者。<strong>Rebalance 期间，消费者无法读取消息，造成整个消费者群组一小段时间的不可用。</strong></p>
<h3 id="何时生分区再均衡"><a href="#何时生分区再均衡" class="headerlink" title="何时生分区再均衡"></a>何时生分区再均衡</h3><p>分区再均衡的触发时机有三种：</p>
<ul>
<li><strong>消费者群组成员数发生变更</strong>。比如有新的 Consumer 加入群组或者离开群组，或者是有 Consumer 实例崩溃被“踢出”群组。<ul>
<li>新增消费者。consumer 订阅主题之后，第一次执行 poll 方法</li>
<li>移除消费者。执行 <code>consumer.close()</code> 操作或者消费客户端宕机，就不再通过 poll 向群组协调器发送心跳了，当群组协调器检测次消费者没有心跳，就会触发再均衡。</li>
</ul>
</li>
<li><strong>订阅主题数发生变更</strong>。Consumer Group 可以使用正则表达式的方式订阅主题，比如 <code>consumer.subscribe(Pattern.compile(“t.*c”))</code> 就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题。在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li>
<li><strong>订阅主题的分区数发生变更</strong>。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。<ul>
<li>新增 broker。如重启 broker 节点</li>
<li>移除 broker。如 kill 掉 broker 节点。</li>
</ul>
</li>
</ul>
<h3 id="分区再均衡的过程"><a href="#分区再均衡的过程" class="headerlink" title="分区再均衡的过程"></a>分区再均衡的过程</h3><p><strong>Rebalance 是通过消费者群组中的称为“群主”消费者客户端进行的</strong>。</p>
<p>（1）选择群主</p>
<p>当消费者要加入群组时，会向群组协调器发送一个 JoinGroup 请求。第一个加入群组的消费者将成为“群主”。<strong>群主从协调器那里获取群组的活跃成员列表，并负责给每一个消费者分配分区</strong>。</p>
<blockquote>
<p>所谓协调者，在 Kafka 中对应的术语是 Coordinator，它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。具体来讲，Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p>
</blockquote>
<p>（2）消费者通过向被指派为群组协调器（Coordinator）的 Broker 定期发送心跳来维持它们和群组的从属关系以及它们对分区的所有权。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202502070723810.png"></p>
<p>（3）群主从群组协调器获取群组成员列表，然后给每一个消费者进行分配分区 Partition。有两种分配策略：Range 和 RoundRobin。</p>
<ul>
<li><strong>Range 策略</strong>，就是把若干个连续的分区分配给消费者，如存在分区 1-5，假设有 3 个消费者，则消费者 1 负责分区 1-2,消费者 2 负责分区 3-4，消费者 3 负责分区 5。</li>
<li><strong>RoundRoin 策略</strong>，就是把所有分区逐个分给消费者，如存在分区 1-5，假设有 3 个消费者，则分区 1-&gt;消费 1，分区 2-&gt;消费者 2，分区 3&gt;消费者 3，分区 4&gt;消费者 1，分区 5-&gt;消费者 2。</li>
</ul>
<p>（4）群主分配完成之后，把分配情况发送给群组协调器。</p>
<p>（5）群组协调器再把这些信息发送给消费者。<strong>每个消费者只能看到自己的分配信息，只有群主知道所有消费者的分配信息</strong>。</p>
<h3 id="如何判定消费者已经死亡"><a href="#如何判定消费者已经死亡" class="headerlink" title="如何判定消费者已经死亡"></a>如何判定消费者已经死亡</h3><p>消费者通过向被指定为群组协调器的 Broker 发送心跳来维持它们和群组的从属关系以及它们对分区的所有权关系。只要消费者以正常的时间间隔发送心跳，就被认为是活跃的。消费者会在轮询消息或提交偏移量时发送心跳。如果消费者超时未发送心跳，会话就会过期，群组协调器认定它已经死亡，就会触发一次再均衡。</p>
<p>当一个消费者要离开群组时，会通知协调器，协调器会立即触发一次再均衡，尽量降低处理停顿。</p>
<h3 id="查找协调者"><a href="#查找协调者" class="headerlink" title="查找协调者"></a>查找协调者</h3><p>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，<strong>所有 Broker 都有各自的 Coordinator 组件</strong>。那么，Consumer Group 如何确定为它服务的 Coordinator 在哪台 Broker 上呢？答案就在我们之前说过的 Kafka 内部位移主题 <code>__consumer_offsets</code> 身上。</p>
<p>目前，Kafka 为某个 Consumer Group 确定 Coordinator 所在的 Broker 的算法有 2 个步骤。</p>
<ol>
<li><p>第 1 步：确定由位移主题的哪个分区来保存该 Group 数据：<code>partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)</code>。</p>
</li>
<li><p>第 2 步：找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</p>
</li>
</ol>
<h3 id="分区再均衡的问题"><a href="#分区再均衡的问题" class="headerlink" title="分区再均衡的问题"></a>分区再均衡的问题</h3><ul>
<li>首先，Rebalance 过程对 Consumer Group 消费过程有极大的影响。<strong>在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成</strong>。</li>
<li>其次，目前 Rebalance 的设计是所有 Consumer 实例共同参与，全部重新分配所有分区。其实更高效的做法是尽量减少分配方案的变动。</li>
<li>最后，Rebalance 实在是太慢了。</li>
</ul>
<h3 id="避免分区再均衡"><a href="#避免分区再均衡" class="headerlink" title="避免分区再均衡"></a>避免分区再均衡</h3><p>通过前文，我们已经知道了：分区再均衡的代价很高，应该尽量避免不必要的分区再均衡，以整体提高 Consumer 的吞吐量。</p>
<p>分区再均衡发生的时机有三个：</p>
<ul>
<li>组成员数量发生变化</li>
<li>订阅主题数量发生变化</li>
<li>订阅主题的分区数发生变化</li>
</ul>
<p>后面两个通常都是运维的主动操作，所以它们引发的 Rebalance 大都是不可避免的。实际上，大部分情况下，导致分区再均衡的原因是：组成员数量发生变化。</p>
<p>有两种情况，消费者并没有宕机，但也被视为消亡：</p>
<ul>
<li>未及时发送心跳</li>
<li>Consumer 消费时间过长</li>
</ul>
<h4 id="未及时发送心跳"><a href="#未及时发送心跳" class="headerlink" title="未及时发送心跳"></a>未及时发送心跳</h4><p><strong>第一类非必要 Rebalance 是因为未能及时发送心跳</strong>，导致 Consumer 被“踢出”Group 而引发的。因此，<strong>需要合理设置会话超时时间</strong>。这里给出一些推荐数值，你可以“无脑”地应用在你的生产环境中。</p>
<ul>
<li>设置 <code>session.timeout.ms</code> &#x3D; 6s。</li>
<li>设置 <code>heartbeat.interval.ms</code> &#x3D; 2s。</li>
<li>要保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求，即 <code>session.timeout.ms</code> &gt;&#x3D; 3 * <code>heartbeat.interval.ms</code>。</li>
</ul>
<p>将 <code>session.timeout.ms</code> 设置成 6s 主要是为了让 Coordinator 能够更快地定位已经挂掉的 Consumer。毕竟，我们还是希望能尽快揪出那些“尸位素餐”的 Consumer，早日把它们踢出 Group。希望这份配置能够较好地帮助你规避第一类“不必要”的 Rebalance。</p>
<h4 id="Consumer-消费时间过长"><a href="#Consumer-消费时间过长" class="headerlink" title="Consumer 消费时间过长"></a>Consumer 消费时间过长</h4><p><strong>第二类非必要 Rebalance 是 Consumer 消费时间过长导致的</strong>。此时，**<code>max.poll.interval.ms</code>** 参数值的设置显得尤为关键。如果要避免非预期的 Rebalance，你最好将该参数值设置得大一点，比你的下游最大处理时间稍长一点。</p>
<h4 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h4><p>如果你按照上面的推荐数值恰当地设置了这几个参数，却发现还是出现了 Rebalance，那么我建议你去排查一下<strong>Consumer 端的 GC 表现</strong>，比如是否出现了频繁的 Full GC 导致的长时间停顿，从而引发了 Rebalance。为什么特意说 GC？那是因为在实际场景中，我见过太多因为 GC 设置不合理导致程序频发 Full GC 而引发的非预期 Rebalance 了。</p>
<h2 id="提交偏移量"><a href="#提交偏移量" class="headerlink" title="提交偏移量"></a>提交偏移量</h2><p>每次调用 <code>poll()</code> 方法，它总是会返回由生产者写入 Kafka 但还没有被消费者读取过的记录，Kafka 因此可以追踪哪些记录是被哪个群组的哪个消费者读取的。</p>
<p><strong>更新分区当前位置的操作叫作提交</strong>。</p>
<h3 id="偏移量的用处"><a href="#偏移量的用处" class="headerlink" title="偏移量的用处"></a>偏移量的用处</h3><p>如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果消费者发生崩溃或有新的消费者加入群组，就会<strong>触发再均衡</strong>，完成再均衡后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。</p>
<p>（1）<strong>如果提交的偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210412200354.png" alt="img"></p>
<p>（2）<strong>如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210412200405.png" alt="img"></p>
<p>由此可知，处理偏移量，会对客户端处理数据产生影响。</p>
<h3 id="提交偏移量的旧方案"><a href="#提交偏移量的旧方案" class="headerlink" title="提交偏移量的旧方案"></a>提交偏移量的旧方案</h3><p><strong>老版本的 Consumer Group 把偏移量保存在 ZooKeeper 中</strong>。ZooKeeper 是一个分布式的协调服务框架，Kafka 重度依赖它实现各种各样的协调管理。将偏移量保存在 ZooKeeper 外部系统的做法，最显而易见的好处就是减少了 Kafka Broker 端的状态保存开销，有利于实现伸缩性。</p>
<p>这种方案的问题在于：ZooKeeper 其实并不适合进行高频的写操作，而 Consumer Group 的偏移量更新却是一个非常频繁的操作。这种大吞吐量的写操作会极大地拖慢 ZooKeeper 集群的性能，因此 Kafka 社区渐渐有了这样的共识：将 Consumer 偏移量保存在 ZooKeeper 中是不合适的做法。</p>
<h3 id="提交偏移量的新方案"><a href="#提交偏移量的新方案" class="headerlink" title="提交偏移量的新方案"></a>提交偏移量的新方案</h3><p>新版本 Consumer 的偏移量管理机制其实也很简单。</p>
<p>消费者向一个叫做 <code>_consumer_offsets</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果消费者发生崩溃或有新的消费者加入群组，就会<strong>触发再均衡</strong>，完成再均衡后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。</p>
<p>**<code>_consumer_offsets</code> 主题的 Key 中应该保存 3 部分内容：<code>&lt;Group ID，主题名，分区号 &gt;</code>**。</p>
<p>通常来说，<strong>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建偏移量主题</strong>。偏移量主题就是普通的 Kafka 主题，那么它自然也有对应的分区数。<strong>如果偏移量主题是 Kafka 自动创建的，那么该主题的分区数是 50，副本数是 3</strong>。分区数可以通过 <code>offsets.topic.num.partitions</code> 设置；副本数可以通过 <code>offsets.topic.replication.factor</code> 设置。</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>自动提交是 Kafka 处理偏移量最简单的方式。</p>
<p>当 <code>enable.auto.commit</code> 属性被设为 true，那么每过 <code>5s</code>，消费者会自动把从 <code>poll()</code> 方法接收到的最大偏移量提交上去。提交时间间隔由 <code>auto.commit.interval.ms</code> 控制，默认值是 <code>5s</code>。</p>
<p>与消费者里的其他东西一样，<strong>自动提交也是在轮询里进行的</strong>。消费者每次在进行轮询时会检查是否该提交偏移量了，如果是，那么就会提交从上一次轮询返回的偏移量。</p>
<p>假设我们仍然使用默认的 5s 提交时间间隔，在最近一次提交之后的 3s 发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了 3s（因为没有达到 5s 的时限，并没有提交偏移量），所以在这 3s 的数据将会被重复处理。虽然可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复消息的时间窗的时间跨度，不过这种情况是无法完全避免的。</p>
<p>在使用自动提交时，每次调用轮询方法都会把上一次调用返回的偏移量提交上去，它并不知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（在调用 close() 方法之前也会进行自动提交）。一般情况下不会有什么问题，不过在处理异常或提前退出轮询时要格外小心。</p>
<p><strong>自动提交虽然方便，不过无法避免丢失消息和分区再均衡时重复消息的问题</strong>。</p>
<h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p><strong>自动提交虽然方便，不过无法避免丢失消息和分区再均衡时重复消息的问题</strong>。因此，可以通过手动提交偏移量，由开发者自行控制。</p>
<p>首先，<strong>把 <code>enable.auto.commit</code> 设为 false，关闭自动提交</strong>。</p>
<p>如果 Kafka 触发了再均衡，我们需要在消费者失去对一个分区的所有权之前提交最后一个已处理记录的偏移量。如果消费者准备了一个缓冲区用于处理偶发的事件，那么在失去分区所有权之前，需要处理在缓冲区累积下来的记录。可能还需要关闭文件句柄、数据库连接等。</p>
<p>在为消费者分配新分区或移除旧分区时，可以通过消费者 API 执行一些应用程序代码，在调用 <code>subscribe()</code> 方法时传进去一个 <code>ConsumerRebalanceListener</code> 实例就可以了。 <code>ConsumerRebalanceListener</code> 有两个需要实现的方法。</p>
<ul>
<li><code>public void onPartitionsRevoked(Collection partitions)</code> 方法会在再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</li>
<li><code>public void onPartitionsAssigned(Collection partitions)</code> 方法会在重新分配分区之后和消费者开始读取消息之前被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets=</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HandleRebalance</span> <span class="keyword">implements</span> <span class="title class_">ConsumerRebalanceListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt;</span></span><br><span class="line"><span class="params">      partitions)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt;</span></span><br><span class="line"><span class="params">      partitions)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lost partitions in rebalance.</span></span><br><span class="line"><span class="string">          Committing current</span></span><br><span class="line"><span class="string">        offsets:&quot;</span> + currentOffsets);</span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    consumer.subscribe(topics, <span class="keyword">new</span> <span class="title class_">HandleRebalance</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">          consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;topic = %s, partition = %s, offset = %d,</span></span><br><span class="line"><span class="string">             customer = %s, country = %s\n&quot;</span>,</span><br><span class="line">             record.topic(), record.partition(), record.offset(),</span><br><span class="line">             record.key(), record.value());</span><br><span class="line">             currentOffsets.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(),</span><br><span class="line">             record.partition()), <span class="keyword">new</span></span><br><span class="line">             <span class="title class_">OffsetAndMetadata</span>(record.offset()+<span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync(currentOffsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// 忽略异常，正在关闭消费者</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Unexpected error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Closed consumer and we are done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反序列化器"><a href="#反序列化器" class="headerlink" title="反序列化器"></a>反序列化器</h2><p>生产者需要用<strong>序列化器</strong>将 Java 对象转换成字节数组再发送给 Kafka；同理，消费者需要用<strong>反序列化器</strong>将从 Kafka 接收到的字节数组转换成 Java 对象。</p>
<h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><p>通常，会有多个 Kafka 消费者组成群组，关注一个主题。</p>
<p>但可能存在这样的场景：只需要一个消费者从一个主题的所有分区或某个特定的分区读取数据。这时，就不需要消费者群组和再均衡了，只需要<strong>把主题或分区分配给消费者</strong>，然后开始读取消息并提交偏移量。</p>
<p>如果是这样，就不需要订阅主题，取而代之的是为自己分配分区。一个消费者可以订阅主题（并加入消费者群组），或为自己分配分区，但不能同时做这两件事。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitionInfos = <span class="literal">null</span>;</span><br><span class="line">partitionInfos = consumer.partitionsFor(<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (partitionInfos != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (PartitionInfo partition : partitionInfos)</span><br><span class="line">        partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partition.topic(),</span><br><span class="line">            partition.partition()));</span><br><span class="line">    consumer.assign(partitions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record: records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;topic = %s, partition = %s, offset = %d,</span></span><br><span class="line"><span class="string">                customer = %s, country = %s\n&quot;</span>,</span><br><span class="line">                record.topic(), record.partition(), record.offset(),</span><br><span class="line">                record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h2><ul>
<li><strong><code>bootstrap.servers</code></strong> - Broker 集群地址，格式：ip1:port,ip2:port…，不需要设定全部的集群地址，设置两个或者两个以上即可。</li>
<li><strong><code>group.id</code></strong> - 消费者隶属的消费者组名称，如果为空会报异常，一般而言，这个参数要有一定的业务意义。</li>
<li><strong><code>fetch.min.bytes</code></strong> - 消费者获取记录的最小字节数。Kafka 会等到有足够的数据时才返回消息给消费者，以降低负载。</li>
<li><strong><code>fetch.max.wait.ms</code></strong> - Kafka 需要等待足够的数据才返回给消费者，如果一直没有足够的数据，消费者就会迟迟收不到消息。所以需要指定 Broker 的等待延迟，一旦超时，直接返回数据给消费者。</li>
<li><strong><code>max.partition.fetch.bytes</code></strong> - 指定了服务器从每个分区返回给消费者的最大字节数。默认为 1 MB。</li>
<li><strong><code>session.timeout.ms</code></strong> - 指定了消费者的心跳超时时间。如果消费者没有在有效时间内发送心跳给群组协调器，协调器会视消费者已经消亡，从而触发分区再均衡。默认为 3 秒。</li>
<li><strong><code>auto.offset.reset</code></strong> - 指定了消费者在读取一个没有偏移量的分区或偏移量无效的情况下，该如何处理。<ul>
<li><code>latest</code> - 表示在偏移量无效时，消费者将从最新的记录开始读取分区记录。</li>
<li><code>earliest</code> - 表示在偏移量无效时，消费者将从起始位置读取分区记录。</li>
</ul>
</li>
<li><strong><code>enable.auto.commit</code></strong> - 指定了是否自动提交消息偏移量，默认开启。</li>
<li><strong><code>partition.assignment.strategy</code></strong> - 消费者的分区分配策略。<ul>
<li><code>Range</code> - 表示会将主题的若干个连续的分区分配给消费者。</li>
<li><code>RoundRobin</code> - 表示会将主题的所有分区按照轮询方式分配给消费者。</li>
</ul>
</li>
<li><strong><code>client.id</code></strong> - 客户端标识。</li>
<li><strong><code>max.poll.records</code></strong> - 用于控制单次能获取到的记录数量。</li>
<li><strong><code>receive.buffer.bytes</code></strong> - 用于设置 Socket 接收消息缓冲区（SO_RECBUF）的大小，默认值为 64KB。如果设置为-1，则使用操作系统的默认值。</li>
<li><strong><code>send.buffer.bytes</code></strong> - 用于设置 Socket 发送消息缓冲区（SO_SNDBUF）的大小，默认值为 128KB。与 receive.buffer.bytes 参数一样，如果设置为-1，则使用操作系统的默认值。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e52152c2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e52152c2/" class="post-title-link" itemprop="url">Kafka 生产</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-14 15:05:34" itemprop="dateCreated datePublished" datetime="2021-04-14T15:05:34+08:00">2021-04-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-生产"><a href="#Kafka-生产" class="headerlink" title="Kafka 生产"></a>Kafka 生产</h1><h2 id="生产者简介"><a href="#生产者简介" class="headerlink" title="生产者简介"></a>生产者简介</h2><p>不管是把 Kafka 作为消息队列系统、还是数据存储平台，总是需要一个可以向 Kafka 写入数据的生产者和一个可以从 Kafka 读取数据的消费者，或者是一个兼具两种角色的应用程序。</p>
<p>使用 Kafka 的场景很多，诉求也各有不同，主要有：是否允许丢失消息？是否接受重复消息？是否有严格的延迟和吞吐量要求？</p>
<p>不同的场景对于 Kafka 生产者 API 的使用和配置会有直接的影响。</p>
<h3 id="生产者传输实体"><a href="#生产者传输实体" class="headerlink" title="生产者传输实体"></a>生产者传输实体</h3><p>Kafka Producer 发送的数据对象叫做 <code>ProducerRecord</code> ，它有 4 个关键参数：</p>
<ul>
<li><code>Topic</code> - 主题</li>
<li><code>Partition</code> - 分区（非必填）</li>
<li><code>Key</code> - 键（非必填）</li>
<li><code>Value</code> - 值</li>
</ul>
<h3 id="生产者发送流程"><a href="#生产者发送流程" class="headerlink" title="生产者发送流程"></a>生产者发送流程</h3><p>Kafka 生产者发送消息流程：</p>
<p>（1）<strong>序列化</strong> - 发送前，生产者要先把键和值序列化成字节数组，这样它们才能够在网络中传输。</p>
<p>（2）<strong>分区</strong> - 数据被传给分区器。如果在 <code>ProducerRecord</code> 中已经指定了分区，那么分区器什么也不会做；否则，分区器会根据 <code>ProducerRecord</code> 的键来选择一个分区。选定分区后，生产者就知道该把消息发送给哪个主题的哪个分区。</p>
<p>（3）<strong>批次传输</strong> - 接着，这条记录会被添加到一个记录批次中。这个批次中的所有消息都会被发送到相同的主题和分区上。有一个独立的线程负责将这些记录批次发送到相应 Broker 上。</p>
<ul>
<li><strong>批次，就是一组消息，这些消息属于同一个主题和分区</strong>。</li>
<li>发送时，会把消息分成批次传输，如果每次只发送一个消息，会占用大量的网路开销。</li>
</ul>
<p>（4）<strong>响应</strong> - 服务器收到消息会返回一个响应。</p>
<ul>
<li>如果<strong>成功</strong>，则返回一个 <code>RecordMetaData</code> 对象，它包含了主题、分区、偏移量；</li>
<li>如果<strong>失败</strong>，则返回一个错误。生产者在收到错误后，可以进行重试，重试次数可以在配置中指定。失败一定次数后，就返回错误消息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200528224323.png" alt="img"></p>
<p>生产者向 Broker 发送消息时是怎么确定向哪一个 Broker 发送消息？</p>
<ul>
<li>生产者会向任意 broker 发送一个元数据请求（<code>MetadataRequest</code>），获取到每一个分区对应的 Leader 信息，并缓存到本地。</li>
<li>生产者在发送消息时，会指定 Partition 或者通过 key 得到到一个 Partition，然后根据 Partition 从缓存中获取相应的 Leader 信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200621113043.png" alt="img"></p>
<h2 id="生产者-API"><a href="#生产者-API" class="headerlink" title="生产者 API"></a>生产者 API</h2><p>Kafka 的 Java 生产者 API 主要的对象就是 <code>KafkaProducer</code>。通常我们开发一个生产者的步骤有 4 步。</p>
<ol>
<li>构造生产者对象所需的参数对象。</li>
<li>利用第 1 步的参数对象，创建 <code>KafkaProducer</code> 对象实例。</li>
<li>使用 <code>KafkaProducer</code> 的 <code>send</code> 方法发送消息。</li>
<li>调用 <code>KafkaProducer</code> 的 <code>close</code> 方法关闭生产者并释放各种系统资源。</li>
</ol>
<h3 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h3><p>Kafka 生产者核心配置：</p>
<ul>
<li><code>bootstrap.servers</code> - 指定了 Producer 启动时要连接的 Broker 地址。注：如果你指定了 1000 个 Broker 连接信息，那么，Producer 启动时就会首先创建与这 1000 个 Broker 的 TCP 连接。在实际使用过程中，并不建议把集群中所有的 Broker 信息都配置到 <code>bootstrap.servers</code> 中，通常你指定 3 ～ 4 台就足以了。因为 Producer 一旦连接到集群中的任一台 Broker，就能拿到整个集群的 Broker 信息，故没必要为 <code>bootstrap.servers</code> 指定所有的 Broker。</li>
<li><code>key.serializer</code> - 键的序列化器。</li>
<li><code>value.serializer</code> - 值的序列化器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定生产者的配置</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 key 的序列化器</span></span><br><span class="line">properties.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 value 的序列化器</span></span><br><span class="line">properties.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置初始化 Kafka 生产者</span></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br></pre></td></tr></table></figure>

<h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>直接发送消息，不关心消息是否到达。</p>
<p>这种方式吞吐量最高，但有小概率会丢失消息。</p>
<p>【示例】异步发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Precision Products&quot;</span>, <span class="string">&quot;France&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(record);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>返回一个 <code>Future</code> 对象，调用 <code>get()</code> 方法，会一直阻塞等待 <code>Broker</code> 返回结果。</p>
<p>这是一种可靠传输方式，但吞吐量最差。</p>
<p>【示例】同步发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Precision Products&quot;</span>, <span class="string">&quot;France&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步响应发送"><a href="#异步响应发送" class="headerlink" title="异步响应发送"></a>异步响应发送</h3><p>代码如下，异步方式相对于“发送并忽略返回”的方式的不同在于：在异步返回时可以执行一些操作，如：抛出异常、记录错误日志。</p>
<p>这是一个折中的方案，即兼顾吞吐量，也保证消息不丢失。</p>
<p>【示例】异步响应发送</p>
<p>首先，定义一个 callback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，使用这个 callback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Biomedical Materials&quot;</span>, <span class="string">&quot;USA&quot;</span>);</span><br><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">DemoProducerCallback</span>());</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>调用 <code>producer.close()</code> 方法可以关闭 Kafka 生产者连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, msg));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者的连接"><a href="#生产者的连接" class="headerlink" title="生产者的连接"></a>生产者的连接</h2><p><strong>Apache Kafka 的所有通信都是基于 TCP 的</strong>。无论是生产者、消费者，还是 Broker 之间的通信都是如此。</p>
<p>选用 TCP 连接是由于 TCP 本身提供的一些高级功能，如多路复用请求以及同时轮询多个连接的能力。</p>
<h3 id="何时创建-TCP-连接"><a href="#何时创建-TCP-连接" class="headerlink" title="何时创建 TCP 连接"></a>何时创建 TCP 连接</h3><p>Kafka 生产者创建连接有三个时机：</p>
<p>（1）在<strong>创建 KafkaProducer 实例时</strong>，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时，首先会创建与 <code>bootstrap.servers</code> 中所有 Broker 的 TCP 连接。</p>
<p>（2）当 Producer <strong>更新集群的元数据信息</strong>之后，如果发现与某些 Broker 当前没有连接，那么它就会创建一个 TCP 连接。</p>
<ul>
<li>场景一：当 Producer 尝试给一个不存在的主题发送消息时，Broker 会告诉 Producer 说这个主题不存在。此时 Producer 会发送 METADATA 请求给 Kafka 集群，去尝试获取最新的元数据信息。</li>
<li>场景二：Producer 通过 <code>metadata.max.age.ms</code> 参数定期地去更新元数据信息。该参数的默认值是 300000，即 5 分钟，也就是说不管集群那边是否有变化，Producer 每 5 分钟都会强制刷新一次元数据以保证它是最及时的数据。</li>
</ul>
<p>（3）当要<strong>发送消息时</strong>，Producer 发现尚不存在与目标 Broker 的连接，会创建一个 TCP 连接。</p>
<h3 id="何时关闭-TCP-连接"><a href="#何时关闭-TCP-连接" class="headerlink" title="何时关闭 TCP 连接"></a>何时关闭 TCP 连接</h3><p>Producer 端关闭 TCP 连接的方式有两种：<strong>一种是用户主动关闭；一种是 Kafka 自动关闭</strong>。</p>
<p>主动关闭是指调用 <code>producer.close()</code> 方法来关闭生产者连接；甚至包括用户调用 <code>kill -9</code> 主动“杀掉”Producer 应用。</p>
<p>如果设置 Producer 端 <code>connections.max.idle.ms</code> 参数大于 0（默认为 9 分钟），意味着，在 <code>connections.max.idle.ms</code> 指定时间内，如果没有任何请求“流过”某个 TCP 连接，那么 Kafka 会主动帮你把该 TCP 连接关闭。如果设置该参数为 <code>-1</code>，TCP 连接将成为永久长连接。</p>
<p>值得注意的是，在第二种方式中，TCP 连接是在 Broker 端被关闭的，但其实这个 TCP 连接的发起方是客户端，因此在 TCP 看来，这属于被动关闭的场景，即 passive close。被动关闭的后果就是会产生大量的 CLOSE_WAIT 连接，因此 Producer 端或 Client 端没有机会显式地观测到此连接已被中断。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Kafka 内置了常用 Java 基础类型的序列化器，如：<code>StringSerializer</code>、<code>IntegerSerializer</code>、<code>DoubleSerializer</code> 等。</p>
<p>但如果要传输较为复杂的对象，推荐使用序列化性能更高的工具，如：Avro、Thrift、Protobuf 等。</p>
<p>使用方式是通过实现 <code>org.apache.kafka.common.serialization.Serializer</code> 接口来引入自定义的序列化器。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="什么是分区"><a href="#什么是分区" class="headerlink" title="什么是分区"></a>什么是分区</h3><p>Kafka 的数据结构采用三级结构，即：主题（Topic）、分区（Partition）、消息（Record）。</p>
<p>在 Kafka 中，任意一个 Topic 维护了一组 Partition 日志，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/mq/kafka/kafka-log-anatomy.png" alt="img"></p>
<p>每个 Partition 都是一个单调递增的、不可变的日志记录，以不断追加的方式写入数据。Partition 中的每条记录会被分配一个单调递增的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的每条记录。</p>
<h3 id="为什么要分区"><a href="#为什么要分区" class="headerlink" title="为什么要分区"></a>为什么要分区</h3><p>为什么 Kafka 的数据结构采用三级结构？</p>
<p><strong>分区的作用就是提供负载均衡的能力</strong>，以实现系统的高伸缩性（Scalability）。</p>
<p>不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的机器节点来增加整体系统的吞吐量。</p>
<h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>所谓分区策略是决定生产者将消息发送到哪个分区的算法，也就是负载均衡算法。</p>
<p>前文中已经提到，Kafka 生产者发送消息使用的对象 <code>ProducerRecord</code> ，可以选填 Partition 和 Key。不过，大多数应用会用到 key。key 有两个作用：作为消息的附加信息；也可以用来决定消息该被写到 Topic 的哪个 Partition，拥有相同 key 的消息将被写入同一个 Partition。</p>
<p><strong>如果 <code>ProducerRecord</code> 指定了 Partition，则分区器什么也不做</strong>，否则分区器会根据 key 选择一个 Partition 。</p>
<ul>
<li>没有 key 时的分发逻辑：每隔 <code>topic.metadata.refresh.interval.ms</code> 的时间，随机选择一个 partition。这个时间窗口内的所有记录发送到这个 partition。发送数据出错后会重新选择一个 partition。</li>
<li>根据 key 分发：Kafka 的选择分区策略是：根据 key 求 hash 值，然后将 hash 值对 partition 数量求模。这里的关键点在于，<strong>同一个 key 总是被映射到同一个 Partition 上</strong>。所以，在选择分区时，Kafka 会使用 Topic 的所有 Partition ，而不仅仅是可用的 Partition。这意味着，<strong>如果写入数据的 Partition 是不可用的，那么就会出错</strong>。</li>
</ul>
<h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>如果 Kafka 的默认分区策略无法满足实际需要，可以自定义分区策略。需要显式地配置生产者端的参数 <code>partitioner.class</code>。这个参数该怎么设定呢？</p>
<p>首先，要实现 <code>org.apache.kafka.clients.producer.Partitioner</code> 接口。这个接口定义了两个方法：<code>partition</code> 和 <code>close</code>，通常只需要实现最重要的 <code>partition</code> 方法。我们来看看这个方法的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>topic</code>、<code>key</code>、<code>keyBytes</code>、<code>value</code>和 <code>valueBytes</code> 都属于消息数据，<code>cluster</code> 则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）。Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。</p>
<p>接着，设置 <code>partitioner.class</code> 参数为自定义类的全限定名，那么生产者程序就会按照你的代码逻辑对消息进行分区。</p>
<p>负载均衡算法常见的有：</p>
<ul>
<li>随机算法</li>
<li>轮询算法</li>
<li>最小活跃数算法</li>
<li>源地址哈希算法</li>
</ul>
<p>可以根据实际需要去实现。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="Kafka-的消息格式"><a href="#Kafka-的消息格式" class="headerlink" title="Kafka 的消息格式"></a>Kafka 的消息格式</h3><p>目前，Kafka 共有两大类消息格式，社区分别称之为 V1 版本和 V2 版本。V2 版本是 Kafka 0.11.0.0 中正式引入的。</p>
<p>不论是哪个版本，Kafka 的消息层次都分为两层：消息集合（message set）以及消息（message）。一个消息集合中包含若干条日志项（record item），而日志项才是真正封装消息的地方。Kafka 底层的消息日志由一系列消息集合日志项组成。Kafka 通常不会直接操作具体的一条条消息，它总是在消息集合这个层面上进行写入操作。</p>
<p>那么社区引入 V2 版本的目的是什么呢？V2 版本主要是针对 V1 版本的一些弊端做了修正。</p>
<p><strong>在 V1 版本中，每条消息都需要执行 CRC 校验</strong>。但有些情况下消息的 CRC 值是会发生变化的。比如在 Broker 端可能会对消息时间戳字段进行更新，那么重新计算之后的 CRC 值也会相应更新；再比如 Broker 端在执行消息格式转换时（主要是为了兼容老版本客户端程序），也会带来 CRC 值的变化。鉴于这些情况，再对每条消息都执行 CRC 校验就有点没必要了，不仅浪费空间还耽误 CPU 时间。</p>
<p>因此，<strong>在 V2 版本中，只对消息集合执行 CRC 校验</strong>。V2 版本还有一个和压缩息息相关的改进，就是保存压缩消息的方法发生了变化。之前 V1 版本中保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中；而 V2 版本的做法是对整个消息集合进行压缩。显然后者应该比前者有更好的压缩效果。</p>
<h3 id="Kafka-的压缩流程"><a href="#Kafka-的压缩流程" class="headerlink" title="Kafka 的压缩流程"></a>Kafka 的压缩流程</h3><p>Kafka 的压缩流程，一言以概之——<strong>Producer 端压缩、Broker 端保持、Consumer 端解压缩。</strong></p>
<h4 id="压缩过程"><a href="#压缩过程" class="headerlink" title="压缩过程"></a>压缩过程</h4><p>在 Kafka 中，压缩可能发生在两个地方：生产者端和 Broker 端。</p>
<p>生产者程序中配置 <code>compression.type</code> 参数即表示启用指定类型的压缩算法。</p>
<p>【示例】开启 GZIP 的 Producer 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 开启 GZIP 压缩</span></span><br><span class="line">props.put(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br></pre></td></tr></table></figure>

<p>通常，Broker 从 Producer 端接收到消息后，不做任何处理。以下两种情况除外：</p>
<ul>
<li><p>情况一：<strong>Broker 端指定了和 Producer 端不同的压缩算法</strong>。显然，应该尽量避免这种情况。</p>
</li>
<li><p>情况二：<strong>Broker 端发生了消息格式转换</strong>。所谓的消息格式转换，主要是为了兼容老版本的消费者程序。在一个生产环境中，Kafka 集群中同时保存多种版本的消息格式非常常见。为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。一般情况下这种消息格式转换对性能是有很大影响的，除了这里的压缩之外，它还让 Kafka 丧失了引以为豪的 Zero Copy 特性。</p>
</li>
</ul>
<p>所谓零拷贝，说的是当数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝，从而实现快速的数据传输。因此如果 Kafka 享受不到这个特性的话，性能必然有所损失，所以尽量保证消息格式的统一吧，这样不仅可以避免不必要的解压缩 &#x2F; 重新压缩，对提升其他方面的性能也大有裨益。</p>
<h4 id="解压缩的过程"><a href="#解压缩的过程" class="headerlink" title="解压缩的过程"></a>解压缩的过程</h4><p>通常来说解压缩发生在消费者程序中，也就是说 Producer 发送压缩消息到 Broker 后，Broker 照单全收并原样保存起来。当 Consumer 程序请求这部分消息时，Broker 依然原样发送出去，当消息到达 Consumer 端后，由 Consumer 自行解压缩还原成之前的消息。</p>
<p>那么现在问题来了，Consumer 怎么知道这些消息是用何种压缩算法压缩的呢？其实答案就在消息中。Kafka 会将启用了哪种压缩算法封装进消息集合中，这样当 Consumer 读取到消息集合时，它自然就知道了这些消息使用的是哪种压缩算法。</p>
<h4 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h4><p>在 Kafka 2.1.0 版本之前，Kafka 支持 3 种压缩算法：GZIP、Snappy 和 LZ4。从 2.1.0 开始，Kafka 正式支持 Zstandard 算法（简写为 zstd）。</p>
<p>在实际使用中，GZIP、Snappy、LZ4 甚至是 zstd 的表现各有千秋。但对于 Kafka 而言，它们的性能测试结果却出奇得一致，即在吞吐量方面：LZ4 &gt; Snappy &gt; zstd 和 GZIP；而在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy。</p>
<p>如果客户端机器 CPU 资源有很多富余，<strong>强烈建议开启 zstd 压缩，这样能极大地节省网络资源消耗</strong>。</p>
<h3 id="何时启用压缩"><a href="#何时启用压缩" class="headerlink" title="何时启用压缩"></a>何时启用压缩</h3><p>何时启用压缩是比较合适的时机呢？</p>
<p>压缩是在 Producer 端完成的工作，那么启用压缩的一个条件就是 Producer 程序运行机器上的 <strong>CPU 资源要很充足</strong>。如果 Producer 运行机器本身 CPU 已经消耗殆尽了，那么启用消息压缩无疑是雪上加霜，只会适得其反。</p>
<p>如果环境中带宽资源有限，那么也建议开启压缩。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><p><strong>幂等</strong>（idempotent、idempotence）是一个数学与计算机学概念，指的是：<strong>一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</strong></p>
<h3 id="Kafka-Producer-的幂等性"><a href="#Kafka-Producer-的幂等性" class="headerlink" title="Kafka Producer 的幂等性"></a>Kafka Producer 的幂等性</h3><p>在 Kafka 中，Producer <strong>默认不是幂等性的</strong>，但我们可以创建幂等性 Producer。它其实是 0.11.0.0 版本引入的新功能。在此之前，Kafka 向分区发送数据时，可能会出现同一条消息被发送了多次，导致消息重复的情况。在 0.11 之后，指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即 <code>props.put(“enable.idempotence”, ture)</code>，或 <code>props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)</code>。</p>
<p><code>enable.idempotence</code> 被设置成 true 后，Producer 自动升级成幂等性 Producer，其他所有的代码逻辑都不需要改变。Kafka 自动帮你做消息的去重。底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了，于是可以在后台默默地把它们“丢弃”掉。当然，实际的实现原理并没有这么简单，但你大致可以这么理解。</p>
<p>我们必须要了解幂等性 Producer 的作用范围：</p>
<ul>
<li>首先，**<code>enable.idempotence</code> 只能保证单分区上的幂等性**，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。</li>
<li>其次，<strong>它只能实现单会话上的幂等性，不能实现跨会话的幂等性</strong>。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。</li>
</ul>
<p>如果想实现多分区以及多会话上的消息无重复，应该怎么做呢？答案就是事务（transaction）或者依赖事务型 Producer。这也是幂等性 Producer 和事务型 Producer 的最大区别！</p>
<h3 id="PID-和-Sequence-Number"><a href="#PID-和-Sequence-Number" class="headerlink" title="PID 和 Sequence Number"></a>PID 和 Sequence Number</h3><p>为了实现 Producer 的幂等性，Kafka 引入了 Producer ID（即 PID）和 Sequence Number。</p>
<ul>
<li><strong>PID</strong>。每个新的 Producer 在初始化的时候会被分配一个唯一的 PID，这个 PID 对用户是不可见的。</li>
<li><strong>Sequence Numbler</strong>。对于每个 PID，该 Producer 发送数据的每个 <code>&lt;Topic, Partition&gt;</code> 都对应一个从 0 开始单调递增的 Sequence Number。</li>
</ul>
<p>Broker 端在缓存中保存了这 seq number，对于接收的每条消息，如果其序号比 Broker 缓存中序号大于 1 则接受它，否则将其丢弃。这样就可以实现了消息重复提交了。但是，只能保证单个 Producer 对于同一个 <code>&lt;Topic, Partition&gt;</code> 的 Exactly Once 语义。不能保证同一个 Producer 一个 topic 不同的 partion 幂等。</p>
<p><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/1-1.png" alt="img"></p>
<p>实现幂等之后：</p>
<p><img src="http://www.heartthinkdo.com/wp-content/uploads/2018/05/2.png" alt="img"></p>
<h3 id="生成-PID-的流程"><a href="#生成-PID-的流程" class="headerlink" title="生成 PID 的流程"></a>生成 PID 的流程</h3><p>在执行创建事务时，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(props);</span><br></pre></td></tr></table></figure>

<p>会创建一个 Sender，并启动线程，执行如下 run 方法，在 maybeWaitForProducerId()中生成一个 producerId，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">====================================</span><br><span class="line">类名：Sender</span><br><span class="line">====================================</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 ........</span><br><span class="line">                <span class="keyword">if</span> (!transactionManager.isTransactional()) &#123;</span><br><span class="line">                    <span class="comment">// 为idempotent producer生成一个producer id</span></span><br><span class="line">                    maybeWaitForProducerId();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) &#123;</span><br><span class="line">                   ........</span><br></pre></td></tr></table></figure>

<h3 id="幂等性的应用实例"><a href="#幂等性的应用实例" class="headerlink" title="幂等性的应用实例"></a>幂等性的应用实例</h3><p>（1）配置属性</p>
<p>需要设置：</p>
<ul>
<li><code>enable.idempotence</code>，需要设置为 ture，此时就会默认把 acks 设置为 all，所以不需要再设置 acks 属性了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定生产者的配置</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 key 的序列化器</span></span><br><span class="line">properties.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 value 的序列化器</span></span><br><span class="line">properties.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启幂等性</span></span><br><span class="line">properties.put(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置重试次数</span></span><br><span class="line">properties.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//Reduce the no of requests less than 0</span></span><br><span class="line">properties.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// buffer.memory 控制生产者可用于缓冲的内存总量</span></span><br><span class="line">properties.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置初始化 Kafka 生产者</span></span><br><span class="line">producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br></pre></td></tr></table></figure>

<p>（2）发送消息</p>
<p>跟一般生产者一样，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceIdempotMessage</span><span class="params">(String topic, String message)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Producer</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> buildIdempotProducer();</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(topic, message));</span><br><span class="line">    producer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，因为我们并没有配置 <code>transaction.id</code> 属性，所以不能使用事务相关 API，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.initTransactions();</span><br></pre></td></tr></table></figure>

<p>否则会出现如下错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main” java.lang.IllegalStateException: Transactional method invoked on a non-transactional producer.</span><br><span class="line">    at org.apache.kafka.clients.producer.internals.TransactionManager.ensureTransactional(TransactionManager.java:<span class="number">777</span>)</span><br><span class="line">    at org.apache.kafka.clients.producer.internals.TransactionManager.initializeTransactions(TransactionManager.java:<span class="number">202</span>)</span><br><span class="line">    at org.apache.kafka.clients.producer.KafkaProducer.initTransactions(KafkaProducer.java:<span class="number">544</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-事务"><a href="#Kafka-事务" class="headerlink" title="Kafka 事务"></a>Kafka 事务</h2><p><strong>Kafka 的事务概念是指一系列的生产者生产消息和消费者提交偏移量的操作在一个事务，或者说是是一个原子操作），同时成功或者失败</strong>。</p>
<p>消息可靠性保障，由低到高为：</p>
<ul>
<li>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。</li>
<li>至少一次（at least once）：消息不会丢失，但有可能被重复发送。</li>
<li>精确一次（exactly once）：消息不会丢失，也不会被重复发送。</li>
</ul>
<p>Kafka 支持事务功能主要是为了实现精确一次处理语义的，而精确一次处理是实现流处理的基石。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Kafka 自 0.11 版本开始提供了对事务的支持，目前主要是在 read committed 隔离级别上做事情。它能<strong>保证多条消息原子性地写入到目标分区，同时也能保证 Consumer 只能看到事务成功提交的消息</strong>。</p>
<h3 id="事务型-Producer"><a href="#事务型-Producer" class="headerlink" title="事务型 Producer"></a>事务型 Producer</h3><p>事务型 Producer 能够保证将消息原子性地写入到多个分区中。这批消息要么全部写入成功，要么全部失败。另外，事务型 Producer 也不惧进程的重启。Producer 重启回来后，Kafka 依然保证它们发送消息的精确一次处理。</p>
<p><strong>事务属性实现前提是幂等性</strong>，即在配置事务属性 <code>transaction.id</code> 时，必须还得配置幂等性；但是幂等性是可以独立使用的，不需要依赖事务属性。</p>
<p>在事务属性之前先引入了生产者幂等性，它的作用为：</p>
<ul>
<li><strong>生产者多次发送消息可以封装成一个原子操作</strong>，要么都成功，要么失败。</li>
<li>consumer-transform-producer 模式下，因为消费者提交偏移量出现问题，导致<strong>重复消费</strong>。需要将这个模式下消费者提交偏移量操作和生产者一系列生成消息的操作封装成一个原子操作。</li>
</ul>
<p><strong>消费者提交偏移量导致重复消费消息的场景</strong>：消费者在消费消息完成提交便宜量 o2 之前挂掉了（假设它最近提交的偏移量是 o1），此时执行再均衡时，其它消费者会重复消费消息(o1 到 o2 之间的消息）。</p>
<h3 id="事务操作的-API"><a href="#事务操作的-API" class="headerlink" title="事务操作的 API"></a>事务操作的 API</h3><p><code>Producer</code> 提供了 <code>initTransactions</code>, <code>beginTransaction</code>, <code>sendOffsets</code>, <code>commitTransaction</code>, <code>abortTransaction</code> 五个事务方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化事务。需要注意的有：</span></span><br><span class="line"><span class="comment"> * 1、前提</span></span><br><span class="line"><span class="comment"> * 需要保证transation.id属性被配置。</span></span><br><span class="line"><span class="comment"> * 2、这个方法执行逻辑是：</span></span><br><span class="line"><span class="comment"> *   （1）Ensures any transactions initiated by previous instances of the producer with the same</span></span><br><span class="line"><span class="comment"> *      transactional.id are completed. If the previous instance had failed with a transaction in</span></span><br><span class="line"><span class="comment"> *      progress, it will be aborted. If the last transaction had begun completion,</span></span><br><span class="line"><span class="comment"> *      but not yet finished, this method awaits its completion.</span></span><br><span class="line"><span class="comment"> *    （2）Gets the internal producer id and epoch, used in all future transactional</span></span><br><span class="line"><span class="comment"> *      messages issued by the producer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initTransactions</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为消费者提供的在事务内提交偏移量的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,</span></span><br><span class="line"><span class="params">                                     String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放弃事务，类似回滚事务的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException ;</span><br></pre></td></tr></table></figure>

<h3 id="Kafka-事务相关配置"><a href="#Kafka-事务相关配置" class="headerlink" title="Kafka 事务相关配置"></a>Kafka 事务相关配置</h3><p>使用 kafka 的事务 api 时的一些注意事项：</p>
<ul>
<li>需要消费者的自动模式设置为 false，并且不能子再手动的进行执行 <code>consumer#commitSync</code> 或者 <code>consumer#commitAsyc</code></li>
<li>设置 Producer 端参数 <code>transctional.id</code>。最好为其设置一个有意义的名字。</li>
<li>和幂等性 Producer 一样，开启 <code>enable.idempotence = true</code>。如果配置了 <code>transaction.id</code>，则此时 <code>enable.idempotence</code> 会被设置为 true</li>
<li>消费者需要配置事务隔离级别 <code>isolation.level</code>。在 <code>consume-trnasform-produce</code> 模式下使用事务时，必须设置为 <code>READ_COMMITTED</code>。<ul>
<li><code>read_uncommitted</code>：这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。很显然，如果你用了事务型 Producer，那么对应的 Consumer 就不要使用这个值。</li>
<li><code>read_committed</code>：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然了，它也能看到非事务型 Producer 写入的所有消息。</li>
</ul>
</li>
</ul>
<h3 id="Kafka-事务应用示例"><a href="#Kafka-事务应用示例" class="headerlink" title="Kafka 事务应用示例"></a>Kafka 事务应用示例</h3><h4 id="只有生成操作"><a href="#只有生成操作" class="headerlink" title="只有生成操作"></a>只有生成操作</h4><p>创建一个事务，在这个事务操作中，只有生成消息操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务只有生产消息操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onlyProduceInTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> buildProducer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化事务</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开启事务</span></span><br><span class="line">    producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.kafka写操作集合</span></span><br><span class="line">        <span class="comment">// 3.1 do业务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 发送消息</span></span><br><span class="line">        producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;transaction-data-1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;transaction-data-2&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.3 do其他业务逻辑,还可以发送其他topic的消息。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.事务提交</span></span><br><span class="line">        producer.commitTransaction();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 5.放弃事务</span></span><br><span class="line">        producer.abortTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建生产者，代码如下,需要:</p>
<ul>
<li>配置 <code>transactional.id</code> 属性</li>
<li>配置 <code>enable.idempotence</code> 属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要:</span></span><br><span class="line"><span class="comment"> * 1、设置transactional.id</span></span><br><span class="line"><span class="comment"> * 2、设置enable.idempotence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Producer <span class="title function_">buildProducer</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create instance for properties to access producer configs</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置事务id</span></span><br><span class="line">    props.put(<span class="string">&quot;transactional.id&quot;</span>, <span class="string">&quot;first-transactional&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置幂等性</span></span><br><span class="line">    props.put(<span class="string">&quot;enable.idempotence&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set acknowledgements for producer requests.</span></span><br><span class="line">    props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the request fails, the producer can automatically retry,</span></span><br><span class="line">    props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Specify buffer size in config,这里不进行设置这个属性,如果设置了,还需要执行producer.flush()来把缓存中消息发送出去</span></span><br><span class="line">    <span class="comment">//props.put(&quot;batch.size&quot;, 16384);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reduce the no of requests less than 0</span></span><br><span class="line">    props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The buffer.memory controls the total amount of memory available to the producer for buffering.</span></span><br><span class="line">    props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kafka消息是以键值对的形式发送,需要设置key和value类型序列化器</span></span><br><span class="line">    props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费-生产并存（consume-transform-produce）"><a href="#消费-生产并存（consume-transform-produce）" class="headerlink" title="消费-生产并存（consume-transform-produce）"></a>消费-生产并存（consume-transform-produce）</h4><p>在一个事务中，既有生产消息操作又有消费消息操作，即常说的 Consume-tansform-produce 模式。如下实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务内,即有生产消息又有消费消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeTransferProduce</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建上产者</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> buildProducer();</span><br><span class="line">    <span class="comment">// 2.初始化事务(生成productId),对于一个生产者,只能执行一次初始化事务操作</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.构建消费者和订阅主题</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> buildConsumer();</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 4.开启事务</span></span><br><span class="line">        producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 接受消息</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.2 do业务逻辑;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;customer Message---&quot;</span>);</span><br><span class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; commits = Maps.newHashMap();</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 5.2.1 读取消息,并处理消息。print the offset,key and value for the consumer records.</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s\n&quot;</span>,</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.2.2 记录提交的偏移量</span></span><br><span class="line">                commits.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6.生产新的消息。比如外卖订单状态的消息,如果订单成功,则需要发送跟商家结转消息或者派送员的提成消息</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;data2&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.提交偏移量</span></span><br><span class="line">            producer.sendOffsetsToTransaction(commits, <span class="string">&quot;group0323&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.事务提交</span></span><br><span class="line">            producer.commitTransaction();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 7.放弃事务</span></span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建消费者代码，需要：</p>
<ul>
<li>将配置中的自动提交属性（auto.commit）进行关闭</li>
<li>而且在代码里面也不能使用手动提交 commitSync( )或者 commitAsync( )</li>
<li>设置 isolation.level</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要:</span></span><br><span class="line"><span class="comment"> * 1、关闭自动提交 enable.auto.commit</span></span><br><span class="line"><span class="comment"> * 2、isolation.level为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Consumer <span class="title function_">buildConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 消费者群组</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;group0323&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置隔离级别</span></span><br><span class="line">    props.put(<span class="string">&quot;isolation.level&quot;</span>,<span class="string">&quot;read_committed&quot;</span>);</span><br><span class="line">    <span class="comment">// 关闭自动提交</span></span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;session.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span></span><br><span class="line">            &lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="只有消费操作"><a href="#只有消费操作" class="headerlink" title="只有消费操作"></a>只有消费操作</h4><p>创建一个事务，在这个事务操作中，只有生成消息操作，如下代码。这种操作其实没有什么意义，跟使用手动提交效果一样，无法保证消费消息操作和提交偏移量操作在一个事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个事务只有消息操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onlyConsumeInTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> buildProducer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化事务</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开启事务</span></span><br><span class="line">    producer.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.kafka读消息的操作集合</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> buildConsumer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.1 接受消息</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2 do业务逻辑;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;customer Message---&quot;</span>);</span><br><span class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; commits = Maps.newHashMap();</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 3.2.1 处理消息 print the offset,key and value for the consumer records.</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s\n&quot;</span>,</span><br><span class="line">                        record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2.2 记录提交偏移量</span></span><br><span class="line">                commits.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.提交偏移量</span></span><br><span class="line">            producer.sendOffsetsToTransaction(commits, <span class="string">&quot;group0323&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.事务提交</span></span><br><span class="line">            producer.commitTransaction();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 6.放弃事务</span></span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者的配置"><a href="#生产者的配置" class="headerlink" title="生产者的配置"></a>生产者的配置</h2><blockquote>
<p>更详尽的生产者配置可以参考：<a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation/#producerconfigs">Kafka 生产者官方配置说明</a></p>
</blockquote>
<p>以下为生产者主要配置参数清单：</p>
<ul>
<li><code>acks</code>：指定了必须有多少个分区副本收到消息，生产者才会认为消息写入是成功的。默认为 <code>acks=1</code><ul>
<li><code>acks=0</code> 如果设置为 0，则 Producer 不会等待服务器的反馈。该消息会被立刻添加到 socket buffer 中并认为已经发送完成。在这种情况下，服务器是否收到请求是没法保证的，并且参数<code>retries</code>也不会生效（因为客户端无法获得失败信息）。每个记录返回的 offset 总是被设置为-1。</li>
<li><code>acks=1</code> 如果设置为 1，leader 节点会将记录写入本地日志，并且在所有 follower 节点反馈之前就先确认成功。在这种情况下，如果 leader 节点在接收记录之后，并且在 follower 节点复制数据完成之前产生错误，则这条记录会丢失。</li>
<li><code>acks=all</code> 如果设置为 all，这就意味着 leader 节点会等待所有同步中的副本确认之后再确认这条记录是否发送完成。只要至少有一个同步副本存在，记录就不会丢失。这种方式是对请求传递的最有效保证。acks&#x3D;-1 与 acks&#x3D;all 是等效的。</li>
</ul>
</li>
<li><code>buffer.memory</code>：用来设置 Producer 缓冲区大小。</li>
<li><code>compression.type</code>：Producer 生成数据时可使用的压缩类型。默认值是 none(即不压缩)。可配置的压缩类型包括：<code>none</code>、<code>gzip</code>、<code>snappy</code> 、<code>lz4</code> 或 <code>zstd</code>。压缩是针对批处理的所有数据，所以批处理的效果也会影响压缩比（更多的批处理意味着更好的压缩）。</li>
<li><code>retries</code>：用来设置发送失败的重试次数。</li>
<li><code>batch.size</code>：用来设置一个批次可占用的内存大小。</li>
<li><code>linger.ms</code>：用来设置 Producer 在发送批次前的等待时间。</li>
<li><code>client.id</code>：Kafka 服务器用它来识别消息源，可以是任意字符串。</li>
<li><code>max.in.flight.requests.per.connection</code>：用来设置 Producer 在收到服务器响应前可以发送多少个消息。</li>
<li><code>timeout.ms</code>：用来设置 Broker 等待同步副本返回消息确认的时间，与 <code>acks</code> 的配置相匹配。</li>
<li><code>request.timeout.ms</code>：Producer 在发送数据时等待服务器返回响应的时间。</li>
<li><code>metadata.fetch.timeout.ms</code>：Producer 在获取元数据时（如：分区的 Leader 是谁）等待服务器返回响应的时间。</li>
<li><code>max.block.ms</code>：该配置控制 <code>KafkaProducer.send()</code> 和<code>KafkaProducer.partitionsFor()</code> 允许被阻塞的时长。这些方法可能因为缓冲区满了或者元数据不可用而被阻塞。用户提供的序列化程序或分区程序的阻塞将不会被计算到这个超时。</li>
<li><code>max.request.size</code>：请求的最大字节数。</li>
<li><code>receieve.buffer.bytes</code>：TCP 接收缓冲区的大小。</li>
<li><code>send.buffer.bytes</code>：TCP 发送缓冲区的大小。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka Confluent 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://issues.apache.org/jira/projects/KAFKA?selectedItem=com.atlassian.jira.jira-projects-plugin:components-page">Kafka Jira</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30437872/">《深入理解 Kafka：核心设计与实践原理》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/12234113.html">《Kafka 技术内幕》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.heartthinkdo.com/?p=2040#43">Kafak(04) Kafka 生产者事务和幂等</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/blog/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"752f8c1f8841b24486e048991917dbd9"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
