<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/19/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/19/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/19/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/368a5dc2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/368a5dc2/" class="post-title-link" itemprop="url">MyBatis 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/ORM/" itemprop="url" rel="index"><span itemprop="name">ORM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><blockquote>
<p>MyBatis 的前身就是 iBatis ，是一个作用在数据持久层的对象关系映射（Object Relational Mapping，简称 ORM）框架。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716162305.png" alt="img"></p>
<h2 id="Mybatis-简介"><a href="#Mybatis-简介" class="headerlink" title="Mybatis 简介"></a>Mybatis 简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510164925.png" alt="img"></p>
<h3 id="什么是-MyBatis"><a href="#什么是-MyBatis" class="headerlink" title="什么是 MyBatis"></a>什么是 MyBatis</h3><p>MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h3 id="MyBatis-vs-Hibernate"><a href="#MyBatis-vs-Hibernate" class="headerlink" title="MyBatis vs. Hibernate"></a>MyBatis vs. Hibernate</h3><p>MyBatis 和 Hibernate 都是 Java 世界中比较流行的 ORM 框架。我们应该了解其各自的优势，根据项目的需要去抉择在开发中使用哪个框架。</p>
<p><strong>Mybatis 优势</strong></p>
<ul>
<li>MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。</li>
<li>MyBatis 容易掌握，而 Hibernate 门槛较高。</li>
</ul>
<p><strong>Hibernate 优势</strong></p>
<ul>
<li>Hibernate 的 DAO 层开发比 MyBatis 简单，Mybatis 需要维护 SQL 和结果映射。</li>
<li>Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。</li>
<li>Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。</li>
<li>Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote>
<p>这里，我将以一个入门级的示例来演示 Mybatis 是如何工作的。</p>
<p>注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。</p>
</blockquote>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span> (</span><br><span class="line">    id      <span class="type">BIGINT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">    name    <span class="type">VARCHAR</span>(<span class="number">10</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    age     <span class="type">INT</span>(<span class="number">3</span>)              <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    email   <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮件&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">) COMMENT <span class="operator">=</span> <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加-Mybatis"><a href="#添加-Mybatis" class="headerlink" title="添加 Mybatis"></a>添加 Mybatis</h3><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mybatis-配置"><a href="#Mybatis-配置" class="headerlink" title="Mybatis 配置"></a>Mybatis 配置</h3><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p>
<p>本示例中只是给出最简化的配置。</p>
<p>【示例】mybatis-config.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。</p>
</blockquote>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><p>个人理解，Mapper.xml 文件可以看做是 Mybatis 的 JDBC SQL 模板。</p>
<p>【示例】UserMapper.xml 文件</p>
<p>下面是一个通过 Mybatis Generator 自动生成的完整的 Mapper 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, age,</span><br><span class="line">      address, email)</span><br><span class="line">    values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      #&#123;address,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapper-java"><a href="#Mapper-java" class="headerlink" title="Mapper.java"></a>Mapper.java</h4><p>Mapper.java 文件是 Mapper.xml 对应的 Java 对象。</p>
<p>【示例】UserMapper.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：</p>
<p>UserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>）存在一一对应关系。</p>
<p>在 Mybatis 中，正是通过方法的全限定名，将二者绑定在一起。</p>
<h4 id="数据实体-java"><a href="#数据实体-java" class="headerlink" title="数据实体.java"></a>数据实体.java</h4><p>【示例】User.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code> 的 <code>parameterType</code> 属性以及 <code>&lt;resultMap&gt;</code> 的 <code>type</code> 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>【示例】MybatisDemo.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 mybatis 配置文件，创建 SqlSessionFactory</span></span><br><span class="line">        <span class="comment">// 注：在实际的应用中，SqlSessionFactory 应该是单例</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis/mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出：user name: 张三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p><code>SqlSession</code> 接口是 Mybatis API 核心中的核心，它代表了 Mybatis 和数据库的一次完整会话。</p>
<ul>
<li>Mybatis 会解析配置，并根据配置创建 <code>SqlSession</code> 。</li>
<li>然后，Mybatis 将 Mapper 映射为 <code>SqlSession</code>，然后传递参数，执行 SQL 语句并获取结果。</li>
</ul>
</blockquote>
<h2 id="Mybatis-xml-配置"><a href="#Mybatis-xml-配置" class="headerlink" title="Mybatis xml 配置"></a>Mybatis xml 配置</h2><blockquote>
<p>配置的详细内容请参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html">Mybatis 官方文档之配置</a> ” 。</p>
</blockquote>
<p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。主要配置项有以下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
<h2 id="Mybatis-xml-映射器"><a href="#Mybatis-xml-映射器" class="headerlink" title="Mybatis xml 映射器"></a>Mybatis xml 映射器</h2><blockquote>
<p>SQL XML 映射文件详细内容请参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">Mybatis 官方文档之 XML 映射文件</a> ”。</p>
</blockquote>
<p>XML 映射文件只有几个顶级元素：</p>
<ul>
<li><code>cache</code> – 对给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 对其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><del><code>parameterMap</code> – 已被废弃！老式风格的参数映射。更好的办法是使用内联参数，此元素可能在将来被移除。文档中不会介绍此元素。</del></li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h2 id="Mybatis-扩展"><a href="#Mybatis-扩展" class="headerlink" title="Mybatis 扩展"></a>Mybatis 扩展</h2><h3 id="Mybatis-类型处理器"><a href="#Mybatis-类型处理器" class="headerlink" title="Mybatis 类型处理器"></a>Mybatis 类型处理器</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。</p>
<p>从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。</p>
<p>你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 并且可以（可选地）将它映射到一个 JDBC 类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExampleTypeHandler.java</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;org.mybatis.example.ExampleTypeHandler&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。 要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型， 以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。</p>
<h3 id="Mybatis-插件"><a href="#Mybatis-插件" class="headerlink" title="Mybatis 插件"></a>Mybatis 插件</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p>
<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">  type= Executor.class,</span></span><br><span class="line"><span class="meta">  method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnObject</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">Mybatis Github</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">Mybatis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/generator">MyBatis 官方代码生成（mybatis-generator）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/spring">MyBatis 官方集成 Spring（mybatis-spring）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/spring-boot-starter">Mybatis 官方集成 Spring Boot（mybatis-spring-boot）</a></li>
</ul>
</li>
<li><strong>扩展插件</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> - CRUD 扩展插件、代码生成器、分页器等多功能</li>
<li><a target="_blank" rel="noopener" href="https://github.com/abel533/Mapper">Mapper</a> - CRUD 扩展插件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a> - Mybatis 通用分页插件</li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40422941">深入理解 mybatis 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tuguangquan/mybatis">mybatis 源码中文注释</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/isea533/article/details/42102297">MyBatis Generator 详解</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa646cdf265da237e095da1">Mybatis 常见面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cee8b61e51d455d88219ea4">Mybatis 中强大的 resultMap</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ae7b258f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ae7b258f/" class="post-title-link" itemprop="url">MyBatis 原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/ORM/" itemprop="url" rel="index"><span itemprop="name">ORM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis-原理"><a href="#MyBatis-原理" class="headerlink" title="MyBatis 原理"></a>MyBatis 原理</h1><blockquote>
<p>MyBatis 的前身就是 iBatis ，是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。本文以一个 MyBatis 完整示例为切入点，结合 MyBatis 底层源码分析，图文并茂的讲解 MyBatis 的核心工作机制。</p>
</blockquote>
<h2 id="MyBatis-完整示例"><a href="#MyBatis-完整示例" class="headerlink" title="MyBatis 完整示例"></a>MyBatis 完整示例</h2><blockquote>
<p>这里，我将以一个入门级的示例来演示 MyBatis 是如何工作的。</p>
<p>注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-tutorial/blob/master/codes/data/spring-data-mybatis/src/main/java/io/github/dunwu/spring/orm/MybatisDemo.java">完整示例源码地址</a></p>
</blockquote>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span> (</span><br><span class="line">    id      <span class="type">BIGINT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">    name    <span class="type">VARCHAR</span>(<span class="number">10</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    age     <span class="type">INT</span>(<span class="number">3</span>)              <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    email   <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮件&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">) COMMENT <span class="operator">=</span> <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加-MyBatis"><a href="#添加-MyBatis" class="headerlink" title="添加 MyBatis"></a>添加 MyBatis</h3><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MyBatis-配置"><a href="#MyBatis-配置" class="headerlink" title="MyBatis 配置"></a>MyBatis 配置</h3><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p>
<p>本示例中只是给出最简化的配置。</p>
<p>【示例】MyBatis-config.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。</p>
</blockquote>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><p>个人理解，Mapper.xml 文件可以看做是 MyBatis 的 JDBC SQL 模板。</p>
<p>【示例】UserMapper.xml 文件</p>
<p>下面是一个通过 MyBatis Generator 自动生成的完整的 Mapper 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, age,</span><br><span class="line">      address, email)</span><br><span class="line">    values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      #&#123;address,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapper-java"><a href="#Mapper-java" class="headerlink" title="Mapper.java"></a>Mapper.java</h4><p>Mapper.java 文件是 Mapper.xml 对应的 Java 对象。</p>
<p>【示例】UserMapper.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：</p>
<p>UserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>）存在一一对应关系。</p>
<p>在 MyBatis 中，正是通过方法的全限定名，将二者绑定在一起。</p>
<h4 id="数据实体-java"><a href="#数据实体-java" class="headerlink" title="数据实体.java"></a>数据实体.java</h4><p>【示例】User.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code> 的 <code>parameterType</code> 属性以及 <code>&lt;resultMap&gt;</code> 的 <code>type</code> 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>【示例】MybatisDemo.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 MyBatis 配置文件，创建 SqlSessionFactory</span></span><br><span class="line">        <span class="comment">// 注：在实际的应用中，SqlSessionFactory 应该是单例</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatis/MyBatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出：user name: 张三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p><code>SqlSession</code> 接口是 MyBatis API 核心中的核心，它代表了 MyBatis 和数据库的一次完整会话。</p>
<ul>
<li>MyBatis 会解析配置，并根据配置创建 <code>SqlSession</code> 。</li>
<li>然后，MyBatis 将 Mapper 映射为 <code>SqlSession</code>，然后传递参数，执行 SQL 语句并获取结果。</li>
</ul>
</blockquote>
<h2 id="MyBatis-生命周期"><a href="#MyBatis-生命周期" class="headerlink" title="MyBatis 生命周期"></a>MyBatis 生命周期</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510113446.png" alt="img"></p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><h4 id="SqlSessionFactoryBuilder-的职责"><a href="#SqlSessionFactoryBuilder-的职责" class="headerlink" title="SqlSessionFactoryBuilder 的职责"></a>SqlSessionFactoryBuilder 的职责</h4><p><strong><code>SqlSessionFactoryBuilder</code> 负责创建 <code>SqlSessionFactory</code> 实例</strong>。<code>SqlSessionFactoryBuilder</code> 可以从 XML 配置文件或一个预先定制的 <code>Configuration</code> 的实例构建出 <code>SqlSessionFactory</code> 的实例。</p>
<p><code>Configuration</code> 类包含了对一个 <code>SqlSessionFactory</code> 实例你可能关心的所有内容。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210508173040.png" alt="img"></p>
<p><code>SqlSessionFactoryBuilder</code> 应用了建造者设计模式，它有五个 <code>build</code> 方法，允许你通过不同的资源创建 <code>SqlSessionFactory</code> 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span></span><br></pre></td></tr></table></figure>

<h4 id="SqlSessionFactoryBuilder-的生命周期"><a href="#SqlSessionFactoryBuilder-的生命周期" class="headerlink" title="SqlSessionFactoryBuilder 的生命周期"></a>SqlSessionFactoryBuilder 的生命周期</h4><p><code>SqlSessionFactoryBuilder</code> 可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><h4 id="SqlSessionFactory-职责"><a href="#SqlSessionFactory-职责" class="headerlink" title="SqlSessionFactory 职责"></a>SqlSessionFactory 职责</h4><p><strong><code>SqlSessionFactory</code> 负责创建 <code>SqlSession</code> 实例。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510105641.png" alt="img"></p>
<p><code>SqlSessionFactory</code> 应用了工厂设计模式，它提供了一组方法，用于创建 SqlSession 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">()</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span><br><span class="line">Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>方法说明：</p>
<ul>
<li>默认的 <code>openSession()</code> 方法没有参数，它会创建具备如下特性的 <code>SqlSession</code>：<ul>
<li>事务作用域将会开启（也就是不自动提交）。</li>
<li>将由当前环境配置的 <code>DataSource</code> 实例中获取 <code>Connection</code> 对象。</li>
<li>事务隔离级别将会使用驱动或数据源的默认设置。</li>
<li>预处理语句不会被复用，也不会批量处理更新。</li>
</ul>
</li>
<li><code>TransactionIsolationLevel</code> 表示事务隔离级别，它对应着 JDBC 的五个事务隔离级别。</li>
<li><code>ExecutorType</code> 枚举类型定义了三个值:<ul>
<li><code>ExecutorType.SIMPLE</code>：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。</li>
<li><code>ExecutorType.REUSE</code>：该类型的执行器会复用预处理语句。</li>
<li><code>ExecutorType.BATCH</code>：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。</li>
</ul>
</li>
</ul>
<h4 id="SqlSessionFactory-生命周期"><a href="#SqlSessionFactory-生命周期" class="headerlink" title="SqlSessionFactory 生命周期"></a>SqlSessionFactory 生命周期</h4><p><code>SqlSessionFactory</code> 应该以单例形式在应用的运行期间一直存在。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><h4 id="SqlSession-职责"><a href="#SqlSession-职责" class="headerlink" title="SqlSession 职责"></a>SqlSession 职责</h4><p><strong>MyBatis 的主要 Java 接口就是 <code>SqlSession</code>。它包含了所有执行语句，获取映射器和管理事务等方法。</strong></p>
<blockquote>
<p>详细内容可以参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/java-api.html#sqlSessions">MyBatis 官方文档之 SqlSessions</a> ” 。</p>
</blockquote>
<p>SqlSession 类的方法可以按照下图进行大致分类：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510110638.png" alt="img"></p>
<h4 id="SqlSession-生命周期"><a href="#SqlSession-生命周期" class="headerlink" title="SqlSession 生命周期"></a>SqlSession 生命周期</h4><p><code>SqlSessions</code> 是由 <code>SqlSessionFactory</code> 实例创建的；而 <code>SqlSessionFactory</code> 是由 <code>SqlSessionFactoryBuilder</code> 创建的。</p>
<blockquote>
<p>🔔 注意：当 MyBatis 与一些依赖注入框架（如 Spring 或者 Guice）同时使用时，<code>SqlSessions</code> 将被依赖注入框架所创建，所以你不需要使用 <code>SqlSessionFactoryBuilder</code> 或者 <code>SqlSessionFactory</code>。</p>
</blockquote>
<p><strong>每个线程都应该有它自己的 <code>SqlSession</code> 实例。</strong></p>
<p><code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 <code>HttpSession</code>。 正确在 Web 中使用 <code>SqlSession</code> 的场景是：每次收到的 HTTP 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。</p>
<p>编程模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><h4 id="映射器职责"><a href="#映射器职责" class="headerlink" title="映射器职责"></a>映射器职责</h4><p>映射器是一些由用户创建的、绑定 SQL 语句的接口。</p>
<p><code>SqlSession</code> 中的 <code>insert</code>、<code>update</code>、<code>delete</code> 和 <code>select</code> 方法都很强大，但也有些繁琐。更通用的方式是使用映射器类来执行映射语句。<strong>一个映射器类就是一个仅需声明与 <code>SqlSession</code> 方法相匹配的方法的接口类</strong>。</p>
<p>MyBatis 将配置文件中的每一个 <code>&lt;mapper&gt;</code> 节点抽象为一个 <code>Mapper</code> 接口，而这个接口中声明的方法和跟 <code>&lt;mapper&gt;</code> 节点中的 <code>&lt;select|update|delete|insert&gt;</code> 节点相对应，即 <code>&lt;select|update|delete|insert&gt;</code> 节点的 id 值为 Mapper 接口中的方法名称，<code>parameterType</code> 值表示 Mapper 对应方法的入参类型，而 <code>resultMap</code> 值则对应了 Mapper 接口表示的返回值类型或者返回结果集的元素类型。</p>
<p>MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；MyBatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。</p>
<p>下面的示例展示了一些方法签名以及它们是如何映射到 <code>SqlSession</code> 上的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512111723.png" alt="img"></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>映射器接口不需要去实现任何接口或继承自任何类。只要方法可以被唯一标识对应的映射语句就可以了。</li>
<li>映射器接口可以继承自其他接口。当使用 XML 来构建映射器接口时要保证语句被包含在合适的命名空间中。而且，唯一的限制就是你不能在两个继承关系的接口中拥有相同的方法签名（潜在的危险做法不可取）。</li>
</ul>
</blockquote>
<h4 id="映射器生命周期"><a href="#映射器生命周期" class="headerlink" title="映射器生命周期"></a>映射器生命周期</h4><p>映射器接口的实例是从 <code>SqlSession</code> 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 <code>SqlSession</code> 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。</p>
<p>编程模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>映射器注解</strong></li>
</ul>
<p>MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。MyBatis 3 以后，支持注解配置。注解配置基于配置 API；而配置 API 基于 XML 配置。</p>
<p>MyBatis 支持诸如 <code>@Insert</code>、<code>@Update</code>、<code>@Delete</code>、<code>@Select</code>、<code>@Result</code> 等注解。</p>
<blockquote>
<p>详细内容请参考：<a target="_blank" rel="noopener" href="http://www.mybatis.org/v-3/zh/java-api.html#sqlSessions">MyBatis 官方文档之 sqlSessions</a>，其中列举了 MyBatis 支持的注解清单，以及基本用法。</p>
</blockquote>
<h2 id="MyBatis-的架构"><a href="#MyBatis-的架构" class="headerlink" title="MyBatis 的架构"></a>MyBatis 的架构</h2><p>从 MyBatis 代码实现的角度来看，MyBatis 的主要组件有以下几个：</p>
<ul>
<li><strong>SqlSession</strong> - 作为 MyBatis 工作的主要顶层 API，表示和数据库交互的会话，完成必要数据库增删改查功能。</li>
<li><strong>Executor</strong> - MyBatis 执行器，是 MyBatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护。</li>
<li><strong>StatementHandler</strong> - 封装了 JDBC Statement 操作，负责对 JDBC statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。</li>
<li><strong>ParameterHandler</strong> - 负责对用户传递的参数转换成 JDBC Statement 所需要的参数。</li>
<li><strong>ResultSetHandler</strong> - 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。</li>
<li><strong>TypeHandler</strong> - 负责 java 数据类型和 jdbc 数据类型之间的映射和转换。</li>
<li><strong>MappedStatement</strong> - <code>MappedStatement</code> 维护了一条 <code>&lt;select|update|delete|insert&gt;</code> 节点的封装。</li>
<li><strong>SqlSource</strong> - 负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回。</li>
<li><strong>BoundSql</strong> - 表示动态生成的 SQL 语句以及相应的参数信息。</li>
<li><strong>Configuration</strong> - MyBatis 所有的配置信息都维持在 Configuration 对象之中。</li>
</ul>
<p>这些组件的架构层次如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512114852.png" alt="img"></p>
<h3 id="配置层"><a href="#配置层" class="headerlink" title="配置层"></a>配置层</h3><p>配置层决定了 MyBatis 的工作方式。</p>
<p>MyBatis 提供了两种配置方式：</p>
<ul>
<li>基于 XML 配置文件的方式</li>
<li>基于 Java API 的方式</li>
</ul>
<p><code>SqlSessionFactoryBuilder</code> 会根据配置创建 <code>SqlSessionFactory</code> ；</p>
<p><code>SqlSessionFactory</code> 负责创建 <code>SqlSessions</code> 。</p>
<h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><p>接口层负责和数据库交互的方式。</p>
<p>MyBatis 和数据库的交互有两种方式：</p>
<ul>
<li><strong>使用 SqlSession</strong>：SqlSession 封装了所有执行语句，获取映射器和管理事务的方法。<ul>
<li>用户只需要传入 Statement Id 和查询参数给 SqlSession 对象，就可以很方便的和数据库进行交互。</li>
<li>这种方式的缺点是不符合面向对象编程的范式。</li>
</ul>
</li>
<li><strong>使用 Mapper 接口</strong>：MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；MyBatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。</li>
</ul>
<h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p>数据处理层可以说是 MyBatis 的核心，从大的方面上讲，它要完成两个功能：</p>
<ul>
<li>根据传参 <code>Statement</code> 和参数构建动态 SQL 语句<ul>
<li>动态语句生成可以说是 MyBatis 框架非常优雅的一个设计，MyBatis 通过传入的参数值，<strong>使用 Ognl 来动态地构造 SQL 语句</strong>，使得 MyBatis 有很强的灵活性和扩展性。</li>
<li>参数映射指的是对于 java 数据类型和 jdbc 数据类型之间的转换：这里有包括两个过程：查询阶段，我们要将 java 类型的数据，转换成 jdbc 类型的数据，通过 <code>preparedStatement.setXXX()</code> 来设值；另一个就是对 resultset 查询结果集的 jdbcType 数据转换成 java 数据类型。</li>
</ul>
</li>
<li>执行 SQL 语句以及处理响应结果集 ResultSet<ul>
<li>动态 SQL 语句生成之后，MyBatis 将执行 SQL 语句，并将可能返回的结果集转换成 <code>List&lt;E&gt;</code> 列表。</li>
<li>MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</li>
</ul>
</li>
</ul>
<h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><ul>
<li><p><strong>事务管理机制</strong> - MyBatis 将事务抽象成了 Transaction 接口。MyBatis 的事务管理分为两种形式：</p>
<ul>
<li>使用 JDBC 的事务管理机制：即利用 <code>java.sql.Connection</code> 对象完成对事务的提交（<code>commit</code>）、回滚（<code>rollback</code>）、关闭（<code>close</code>）等。</li>
<li>使用 MANAGED 的事务管理机制：MyBatis 自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理。</li>
</ul>
</li>
<li><p><strong>连接池管理</strong></p>
</li>
<li><p><strong>SQL 语句的配置</strong> - 支持两种方式：</p>
<ul>
<li>xml 配置</li>
<li>注解配置</li>
</ul>
</li>
<li><p>缓存机制 - MyBatis 采用两级缓存结构</p>
<ul>
<li><strong>一级缓存是 Session 会话级别的缓存</strong> - 一级缓存又被称之为本地缓存。一般而言，一个 <code>SqlSession</code> 对象会使用一个 <code>Executor</code> 对象来完成会话操作，<code>Executor</code> 对象会维护一个 Cache 缓存，以提高查询性能。<ul>
<li>一级缓存的生命周期是 Session 会话级别的。</li>
</ul>
</li>
<li><strong>二级缓存是 Application 应用级别的缓存</strong> - 用户配置了 <code>&quot;cacheEnabled=true&quot;</code>，才会开启二级缓存。<ul>
<li>如果开启了二级缓存，<code>SqlSession</code> 会先使用 <code>CachingExecutor</code> 对象来处理查询请求。<code>CachingExecutor</code> 会在二级缓存中查看是否有匹配的数据，如果匹配，则直接返回缓存结果；如果缓存中没有，再交给真正的 <code>Executor</code> 对象来完成查询，之后 <code>CachingExecutor</code> 会将真正 <code>Executor</code> 返回的查询结果放置到缓存中，然后在返回给用户。</li>
<li>二级缓存的生命周期是应用级别的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512185709.png" alt="img"></p>
<h2 id="SqlSession-内部工作机制"><a href="#SqlSession-内部工作机制" class="headerlink" title="SqlSession 内部工作机制"></a>SqlSession 内部工作机制</h2><p>从前文，我们已经了解了，MyBatis 封装了对数据库的访问，把对数据库的会话和事务控制放到了 SqlSession 对象中。那么具体是如何工作的呢？接下来，我们通过源码解读来进行分析。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512173437.png" alt="img"></p>
<p><code>SqlSession</code> 对于 insert、update、delete、select 的内部处理机制基本上大同小异。所以，接下来，我会以一次完整的 select 查询流程为例讲解 <code>SqlSession</code> 内部的工作机制。相信读者如果理解了 select 的处理流程，对于其他 CRUD 操作也能做到一通百通。</p>
<h3 id="SqlSession-子组件"><a href="#SqlSession-子组件" class="headerlink" title="SqlSession 子组件"></a>SqlSession 子组件</h3><p>前面的内容已经介绍了：SqlSession 是 MyBatis 的顶层接口，它提供了所有执行语句，获取映射器和管理事务等方法。</p>
<p>实际上，SqlSession 是通过聚合多个子组件，让每个子组件负责各自功能的方式，实现了任务的下发。</p>
<p>在了解各个子组件工作机制前，先让我们简单认识一下 SqlSession 的核心子组件。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor 即执行器，它负责生成动态 SQL 以及管理缓存。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512150000.png" alt="img"></p>
<ul>
<li><code>Executor</code> 即执行器接口。</li>
<li><code>BaseExecutor</code> 是 <code>Executor</code> 的抽象类，它采用了模板方法设计模式，内置了一些共性方法，而将定制化方法留给子类去实现。</li>
<li><code>SimpleExecutor</code> 是最简单的执行器。它只会直接执行 SQL，不会做额外的事。</li>
<li><code>BatchExecutor</code> 是批处理执行器。它的作用是通过批处理来优化性能。值得注意的是，批量更新操作，由于内部有缓存机制，使用完后需要调用 <code>flushStatements</code> 来清除缓存。</li>
<li><code>ReuseExecutor</code> 是可重用的执行器。重用的对象是 <code>Statement</code>，也就是说，该执行器会缓存同一个 SQL 的 <code>Statement</code>，避免重复创建 <code>Statement</code>。其内部的实现是通过一个 <code>HashMap</code> 来维护 <code>Statement</code> 对象的。由于当前 <code>Map</code> 只在该 session 中有效，所以使用完后需要调用 <code>flushStatements</code> 来清除 Map。</li>
<li><code>CachingExecutor</code> 是缓存执行器。它只在启用二级缓存时才会用到。</li>
</ul>
<h4 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h4><p><code>StatementHandler</code> 对象负责设置 <code>Statement</code> 对象中的查询参数、处理 JDBC 返回的 resultSet，将 resultSet 加工为 List 集合返回。</p>
<p><code>StatementHandler</code> 的家族成员：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512160243.png" alt="img"></p>
<ul>
<li><code>StatementHandler</code> 是接口；</li>
<li><code>BaseStatementHandler</code> 是实现 <code>StatementHandler</code> 的抽象类，内置一些共性方法；</li>
<li><code>SimpleStatementHandler</code> 负责处理 <code>Statement</code>；</li>
<li><code>PreparedStatementHandler</code> 负责处理 <code>PreparedStatement</code>；</li>
<li><code>CallableStatementHandler</code> 负责处理 <code>CallableStatement</code>。</li>
<li><code>RoutingStatementHandler</code> 负责代理 <code>StatementHandler</code> 具体子类，根据 <code>Statement</code> 类型，选择实例化 <code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>。</li>
</ul>
<h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h4><p><code>ParameterHandler</code> 负责将传入的 Java 对象转换 JDBC 类型对象，并为 <code>PreparedStatement</code> 的动态 SQL 填充数值。</p>
<p><code>ParameterHandler</code> 只有一个具体实现类，即 <code>DefaultParameterHandler</code>。</p>
<h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><p><code>ResultSetHandler</code> 负责两件事：</p>
<ul>
<li>处理 <code>Statement</code> 执行后产生的结果集，生成结果列表</li>
<li>处理存储过程执行后的输出参数</li>
</ul>
<p><code>ResultSetHandler</code> 只有一个具体实现类，即 <code>DefaultResultSetHandler</code>。</p>
<h4 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h4><p>TypeHandler 负责将 Java 对象类型和 JDBC 类型进行相互转换。</p>
<h3 id="SqlSession-和-Mapper"><a href="#SqlSession-和-Mapper" class="headerlink" title="SqlSession 和 Mapper"></a>SqlSession 和 Mapper</h3><p>先来回忆一下 MyBatis 完整示例章节的 测试程序部分的代码。</p>
<p>MybatisDemo.java 文件中的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中，给 sqlSession 对象的传递一个配置的 Sql 语句的 Statement Id 和参数，然后返回结果</p>
<p><code>io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey</code> 是配置在 <code>UserMapper.xml</code> 的 Statement ID，params 是 SQL 参数。</p>
<p>UserMapper.xml 文件中的代码片段：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">  select id, name, age, address, email</span><br><span class="line">  from user</span><br><span class="line">  where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 通过方法的全限定名，将 SqlSession 和 Mapper 相互映射起来。</p>
<h3 id="SqlSession-和-Executor"><a href="#SqlSession-和-Executor" class="headerlink" title="SqlSession 和 Executor"></a>SqlSession 和 Executor</h3><p><code>org.apache.ibatis.session.defaults.DefaultSqlSession</code> 中 <code>selectList</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 根据 Statement Id，在配置对象 Configuration 中查找和配置文件相对应的 MappedStatement</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 2. 将 SQL 语句交由执行器 Executor 处理</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>MyBatis 所有的配置信息都维持在 <code>Configuration</code> 对象之中。中维护了一个 <code>Map&lt;String, MappedStatement&gt;</code> 对象。其中，key 为 Mapper 方法的全限定名（对于本例而言，key 就是 <code>io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey</code> ），value 为 <code>MappedStatement</code> 对象。所以，传入 Statement Id 就可以从 Map 中找到对应的 <code>MappedStatement</code>。</p>
<p><code>MappedStatement</code> 维护了一个 Mapper 方法的元数据信息，其数据组织可以参考下面的 debug 截图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210511150650.png" alt="img"></p>
<blockquote>
<p>小结：</p>
<p>通过 “SqlSession 和 Mapper” 以及 “SqlSession 和 Executor” 这两节，我们已经知道：</p>
<p>SqlSession 的职能是：根据 Statement ID, 在 <code>Configuration</code> 中获取到对应的 <code>MappedStatement</code> 对象，然后调用 <code>Executor</code> 来执行具体的操作。</p>
</blockquote>
<h3 id="Executor-工作流程"><a href="#Executor-工作流程" class="headerlink" title="Executor 工作流程"></a>Executor 工作流程</h3><p>继续上一节的流程，<code>SqlSession</code> 将 SQL 语句交由执行器 <code>Executor</code> 处理。<code>Executor</code> 又做了哪些事儿呢？</p>
<p>（1）执行器查询入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="comment">// 1. 根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示</span></span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameter);</span><br><span class="line">    <span class="comment">// 2. 根据传参，创建一个缓存Key</span></span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行器查询入口主要做两件事：</p>
<ul>
<li><strong>生成动态 SQL</strong>：根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示。</li>
<li><strong>管理缓存</strong>：根据传参，创建一个缓存 Key。</li>
</ul>
<p>（2）执行器查询第二入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 3. 缓存中有值，则直接从缓存中取数据；否则，查询数据库</span></span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际查询方法主要的职能是判断缓存 key 是否能命中缓存：</p>
<ul>
<li>命中，则将缓存中数据返回；</li>
<li>不命中，则查询数据库：</li>
</ul>
<p>（3）查询数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 执行查询，获取 List 结果，并将查询的结果更新本地缓存中</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>queryFromDatabase</code> 方法的职责是调用 doQuery，向数据库发起查询，并将返回的结果更新到本地缓存。</p>
<p>（4）实际查询方法</p>
<p>SimpleExecutor 类的 doQuery()方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 5. 根据既有的参数，创建StatementHandler对象来执行查询操作</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 6. 创建java.Sql.Statement对象，传递给StatementHandler对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 7. 调用StatementHandler.query()方法，返回List结果</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的 Executor.query()方法几经转折，最后会创建一个 <code>StatementHandler</code> 对象，然后将必要的参数传递给 <code>StatementHandler</code>，使用 <code>StatementHandler</code> 来完成对数据库的查询，最终返回 List 结果集。<br>从上面的代码中我们可以看出，<code>Executor</code> 的功能和作用是：</p>
<ol>
<li><p>根据传递的参数，完成 SQL 语句的动态解析，生成 BoundSql 对象，供 <code>StatementHandler</code> 使用；</p>
</li>
<li><p>为查询创建缓存，以提高性能</p>
</li>
<li><p>创建 JDBC 的 <code>Statement</code> 连接对象，传递给 <code>StatementHandler</code> 对象，返回 List 查询结果。</p>
</li>
</ol>
<p>prepareStatement() 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">//对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 JDBC 的 <code>PreparedStatement</code> 类型的对象，创建的过程中，我们使用的是 SQL 语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。</p>
<h3 id="StatementHandler-工作流程"><a href="#StatementHandler-工作流程" class="headerlink" title="StatementHandler 工作流程"></a>StatementHandler 工作流程</h3><p><code>StatementHandler</code> 有一个子类 <code>RoutingStatementHandler</code>，它负责代理其他 <code>StatementHandler</code> 子类的工作。</p>
<p>它会根据配置的 <code>Statement</code> 类型，选择实例化相应的 <code>StatementHandler</code>，然后由其代理对象完成工作。</p>
<p>【源码】RoutingStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">SimpleStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">PreparedStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">CallableStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【源码】<code>RoutingStatementHandler</code> 的 <code>parameterize</code> 方法源码</p>
<p>【源码】<code>PreparedStatementHandler</code> 的 <code>parameterize</code> 方法源码</p>
<p><code>StatementHandler</code> 使用 <code>ParameterHandler</code> 对象来完成对 <code>Statement</code> 的赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 使用 ParameterHandler 对象来完成对 Statement 的设值</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【源码】<code>StatementHandler</code> 的 <code>query</code> 方法源码</p>
<p><code>StatementHandler</code> 使用 <code>ResultSetHandler</code> 对象来完成对 <code>ResultSet</code> 的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 使用ResultHandler来处理ResultSet</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParameterHandler-工作流程"><a href="#ParameterHandler-工作流程" class="headerlink" title="ParameterHandler 工作流程"></a>ParameterHandler 工作流程</h3><p>【源码】<code>DefaultParameterHandler</code> 的 <code>setParameters</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(PreparedStatement ps)</span> &#123;</span><br><span class="line"><span class="comment">// parameterMappings 是对占位符 #&#123;&#125; 对应参数的封装</span></span><br><span class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">   <span class="keyword">if</span> (parameterMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">       <span class="type">ParameterMapping</span> <span class="variable">parameterMapping</span> <span class="operator">=</span> parameterMappings.get(i);</span><br><span class="line">       <span class="comment">// 不处理存储过程中的参数</span></span><br><span class="line">       <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">         Object value;</span><br><span class="line">         <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">         <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">           <span class="comment">// 获取对应的实际数值</span></span><br><span class="line">           value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="literal">null</span>) &#123;</span><br><span class="line">           value = <span class="literal">null</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">           value = parameterObject;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 获取对象中相应的属性或查找 Map 对象中的值</span></span><br><span class="line">           <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">           value = metaObject.getValue(propertyName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">TypeHandler</span> <span class="variable">typeHandler</span> <span class="operator">=</span> parameterMapping.getTypeHandler();</span><br><span class="line">         <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> parameterMapping.getJdbcType();</span><br><span class="line">         <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">           jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 通过 TypeHandler 将 Java 对象参数转为 JDBC 类型的参数</span></span><br><span class="line">           <span class="comment">// 然后，将数值动态绑定到 PreparedStaement 中</span></span><br><span class="line">           typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ResultSetHandler-工作流程"><a href="#ResultSetHandler-工作流程" class="headerlink" title="ResultSetHandler 工作流程"></a>ResultSetHandler 工作流程</h3><p><code>ResultSetHandler</code> 的实现可以概括为：将 <code>Statement</code> 执行后的结果集，按照 <code>Mapper</code> 文件中配置的 <code>ResultType</code> 或 <code>ResultMap</code> 来转换成对应的 JavaBean 对象，最后将结果返回。</p>
<p>【源码】<code>DefaultResultSetHandler</code> 的 <code>handleResultSets</code> 方法</p>
<p><code>handleResultSets</code> 方法是 <code>DefaultResultSetHandler</code> 的最关键方法。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultSetCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 第一个结果集</span></span><br><span class="line">  <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> getFirstResultSet(stmt);</span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="comment">// 判断结果集的数量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultMapCount</span> <span class="operator">=</span> resultMaps.size();</span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="comment">// 遍历处理结果集</span></span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> resultMaps.get(resultSetCount);</span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="literal">null</span>);</span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      <span class="type">ResultMapping</span> <span class="variable">parentMapping</span> <span class="operator">=</span> nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nestedResultMapId</span> <span class="operator">=</span> parentMapping.getNestedResultMapId();</span><br><span class="line">        <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="literal">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">MyBatis Github</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">MyBatis 官网</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40422941">深入理解 MyBatis 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tuguangquan/mybatis">MyBatis 源码中文注释</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cee8b61e51d455d88219ea4">MyBatis 中强大的 resultMap</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/35e2d3ba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/35e2d3ba/" class="post-title-link" itemprop="url">Shiro 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Shiro-快速入门"><a href="#Shiro-快速入门" class="headerlink" title="Shiro 快速入门"></a>Shiro 快速入门</h1><blockquote>
<p>Shiro 是一个安全框架，具有认证、授权、加密、会话管理功能。</p>
</blockquote>
<h2 id="一、Shiro-简介"><a href="#一、Shiro-简介" class="headerlink" title="一、Shiro 简介"></a>一、Shiro 简介</h2><h3 id="Shiro-特性"><a href="#Shiro-特性" class="headerlink" title="Shiro 特性"></a>Shiro 特性</h3><p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/shiro-features.png">
</p>

<p>核心功能：</p>
<ul>
<li><strong>Authentication</strong> - <strong>认证</strong>。验证用户是不是拥有相应的身份。</li>
<li><strong>Authorization</strong> - <strong>授权</strong>。验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。</li>
<li><strong>Session Manager</strong> - <strong>会话管理</strong>。即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中。会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的。</li>
<li><strong>Cryptography</strong> - <strong>加密</strong>。保护数据的安全性，如密码加密存储到数据库，而不是明文存储。</li>
</ul>
<p>辅助功能：</p>
<ul>
<li><strong>Web Support</strong> - <strong>Web 支持</strong>。可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong> - <strong>缓存</strong>。比如用户登录后，其用户信息、拥有的角色 &#x2F; 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong> - <strong>并发</strong>。Shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong> - <strong>测试</strong>。提供测试支持；</li>
<li><strong>Run As</strong> - <strong>运行方式</strong>。允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong> - <strong>记住我</strong>。即一次登录后，下次再访问免登录。</li>
</ul>
<blockquote>
<p>:bell: 注意：Shiro 不会去维护用户、维护权限；这些需要我们自己去提供；然后通过相应的接口注入给 Shiro 即可。</p>
</blockquote>
<h3 id="Shiro-架构概述"><a href="#Shiro-架构概述" class="headerlink" title="Shiro 架构概述"></a>Shiro 架构概述</h3><p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/ShiroBasicArchitecture.png">
</p>

<ul>
<li><p><strong>Subject</strong> - <strong>主题</strong>。它代表当前用户，<code>Subject</code> 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它——当前和软件交互的任何事件。<code>Subject</code> 是 Shiro 的入口。</p>
<ul>
<li><code>Principals</code> 是 <code>Subject</code> 的“识别属性”。<code>Principals</code> 可以是任何可以识别 <code>Subject</code> 的东西，例如名字（姓氏），姓氏（姓氏或姓氏），用户名，社会保险号等。当然，<code>Principals</code> 在应用程序中最好是惟一的。</li>
<li><code>Credentials</code> 通常是仅由 <code>Subject</code> 知道的秘密值，用作他们实际上“拥有”所主张身份的佐证 凭据的一些常见示例是密码，生物特征数据（例如指纹和视网膜扫描）以及 X.509 证书。</li>
</ul>
</li>
<li><p><strong>SecurityManager</strong> - <strong>安全管理</strong>。它是 Shiro 的核心，所有与安全有关的操作（认证、授权、及会话、缓存的管理）都与 <code>SecurityManager</code> 交互，且它管理着所有 <code>Subject</code>。</p>
</li>
<li><p><strong>Realm</strong> - <strong>域</strong>。用于访问安全相关数据，可以视为应用自身的数据源，需要开发者自己实现。Shiro 会通过 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把 <code>Realm</code> 看成 DataSource，即安全数据源。</p>
</li>
</ul>
<h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p><code>SecurityManager</code> 是 Shiro 框架核心中的核心，它相当于 Shiro 的总指挥，负责调度所有行为，包括：认证、授权、获取安全数据（调用 <code>Realm</code>）、会话管理等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/ShiroArchitecture.png" alt="img"></p>
<p><code>SecurityManager</code> 聚合了以下组件：</p>
<ul>
<li><strong>Authenticator</strong> - 认证器，负责认证。如果用户需要定制认证策略，可以实现此接口。</li>
<li><strong>Authorizer</strong> - 授权器，负责权限控制。用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>SessionManager</strong> - 会话管理器。Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据。</li>
<li><strong>SessionDAO</strong> - 会话 DAO 用于存储会话，需要用户自己实现。</li>
<li><strong>CacheManager</strong> - 缓存控制器。用于管理如用户、角色、权限等信息的缓存。</li>
<li><strong>Cryptography</strong> - 密码器。用于对数据加密、解密。</li>
</ul>
<h2 id="二、Shiro-认证"><a href="#二、Shiro-认证" class="headerlink" title="二、Shiro 认证"></a>二、Shiro 认证</h2><h3 id="认证-Subject"><a href="#认证-Subject" class="headerlink" title="认证 Subject"></a>认证 Subject</h3><p>验证 Subject 的过程可以有效地分为三个不同的步骤：</p>
<p>（1）收集 <code>Subject</code> 提交的 <code>Principals</code> 和 <code>Credentials</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example using most common scenario of username/password pair:</span></span><br><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;Remember Me&quot; built-in:</span></span><br><span class="line">token.setRememberMe(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>（2）提交 <code>Principals</code> 和 <code>Credentials</code> 以进行身份验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">currentUser.login(token);</span><br></pre></td></tr></table></figure>

<p>（3）如果提交成功，则允许访问，否则重试身份验证或阻止访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; <span class="keyword">catch</span> ( UnknownAccountException uae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( IncorrectCredentialsException ice ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( LockedAccountException lae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( ExcessiveAttemptsException eae ) &#123; ...</span><br><span class="line">&#125; ... <span class="keyword">catch</span> your own ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( AuthenticationException ae ) &#123;</span><br><span class="line">    <span class="comment">//unexpected error?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Remembered-和-Authenticated"><a href="#Remembered-和-Authenticated" class="headerlink" title="Remembered 和 Authenticated"></a>Remembered 和 Authenticated</h3><ul>
<li><code>Remembered</code> - 记住我。被记住的 <code>Subject</code> 不是匿名的，并且具有已知的身份（即 <code>subject.getPrincipals()</code> 是非空的）。 但是，在先前的会话期间，通过先前的身份验证会记住此身份。 如果 <code>subject.isRemembered()</code> 返回 <code>true</code>，则认为该主题已被记住。</li>
<li><code>Authenticated</code> - 已认证。已认证的 <code>Subject</code> 是在当前会话期间已成功认证的 <code>Subject</code>。 如果 <code>subject.isAuthenticated()</code> 返回 <code>true</code>，则认为该 <code>Subject</code> 已通过身份验证。</li>
</ul>
<h3 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h3><p>当 Subject 与应用程序完成交互后，可以调用 <code>subject.logout()</code> 登出，即放弃所有标识信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure>

<h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200317092427.png" alt="img"></p>
<ol>
<li><p>应用程序代码调用 <code>Subject.login</code> 方法，传入构造的 <code>AuthenticationToken</code> 实例，该实例代表最终用户的 <code>Principals</code> 和 <code>Credentials</code>。</p>
</li>
<li><p><code>Subject</code> 实例（通常是 <code>DelegatingSubject</code>（或子类））通过调用 <code>securityManager.login</code>（token）委托应用程序的 <code>SecurityManager</code>，在此处开始实际的身份验证工作。</p>
</li>
<li><p><code>SecurityManager</code> 接收令牌，并通过调用 <code>authenticator.authenticate</code>（token）来简单地委派给其内部 <code>Authenticator</code> 实例。这几乎总是一个 <code>ModularRealmAuthenticator</code> 实例，它支持在身份验证期间协调一个或多个 <code>Realm</code> 实例。</p>
</li>
<li><p>如果为该应用程序配置了多个 <code>Realm</code>，则 <code>ModularRealmAuthenticator</code> 实例将利用其配置的 <code>AuthenticationStrategy</code> 发起多域验证尝试。在调用领域进行身份验证之前，期间和之后，将调用 <code>AuthenticationStrategy</code> 以使其对每个领域的结果做出反应。</p>
</li>
<li><p>请咨询每个已配置的 <code>Realm</code>，以查看其是否支持提交的 <code>AuthenticationToken</code>。 如果是这样，将使用提交的令牌调用支持 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法。 <code>getAuthenticationInfo</code> 方法有效地表示对该特定 <code>Realm</code> 的单个身份验证尝试。</p>
</li>
</ol>
<h3 id="认证策略"><a href="#认证策略" class="headerlink" title="认证策略"></a>认证策略</h3><p>当为一个应用程序配置两个或多个领域时，<code>ModularRealmAuthenticator</code> 依赖于内部 <code>AuthenticationStrategy</code> 组件来确定认证尝试成功或失败的条件。</p>
<p>例如，如果只有一个 Realm 成功地对 AuthenticationToken 进行身份验证，而所有其他 Realm 都失败了，那么该身份验证尝试是否被视为成功？还是必须所有领域都成功进行身份验证才能将整体尝试视为成功？或者，如果某个领域成功通过身份验证，是否有必要进一步咨询其他领域？ AuthenticationStrategy 根据应用程序的需求做出适当的决定。</p>
<p><code>AuthenticationStrategy</code> 是无状态组件，在尝试进行身份验证时会被查询 4 次（这 4 种交互所需的任何必要状态都将作为方法参数给出）：</p>
<ul>
<li>在任何领域被调用之前</li>
<li>在调用单个 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法之前</li>
<li>在调用单个 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法之后</li>
<li>在所有领域都被调用之后</li>
</ul>
<p><code>AuthenticationStrategy</code> 还负责汇总每个成功 <code>Realm</code> 的结果，并将它们“捆绑”成单个 <code>AuthenticationInfo</code> 表示形式。最终的聚合 <code>AuthenticationInfo</code> 实例是 <code>Authenticator</code> 实例返回的结果，也是 Shiro 用来表示主体的最终身份（也称为委托人）的东西。</p>
<table>
<thead>
<tr>
<th align="left"><code>AuthenticationStrategy</code></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.html"><code>AtLeastOneSuccessfulStrategy</code></a></td>
<td align="left">只要有一个 <code>Realm</code> 成功认证，则整个尝试都被视为成功。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.html"><code>FirstSuccessfulStrategy</code></a></td>
<td align="left">仅使用从第一个成功通过身份验证的 <code>Realm</code> 返回的信息，所有其他 Realm 将被忽略。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AllSuccessfulStrategy.html"><code>AllSuccessfulStrategy</code></a></td>
<td align="left">只有所有 <code>Realm</code> 成功认证，则整个尝试才被视为成功。</td>
</tr>
</tbody></table>
<blockquote>
<p>:link: 更多认证细节可以参考：<a target="_blank" rel="noopener" href="http://shiro.apache.org/authentication.html#apache-shiro-authentication">Apache Shiro Authentication</a></p>
</blockquote>
<h2 id="三、Shiro-授权"><a href="#三、Shiro-授权" class="headerlink" title="三、Shiro 授权"></a>三、Shiro 授权</h2><p>授权，也称为访问控制，是管理对资源的访问的过程。 换句话说，控制谁有权访问应用程序中的内容。</p>
<h3 id="授权元素"><a href="#授权元素" class="headerlink" title="授权元素"></a>授权元素</h3><p>授权有三个核心要素：权限、角色和用户。</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>权限示例：</p>
<ul>
<li>打开一个文件</li>
<li>查看 <code>/user/list</code> web 页面</li>
<li>查询记录</li>
<li>删除一条记录</li>
<li>…</li>
</ul>
<p>大多数资源都支持一般的 CRUD 操作。除此以外，对于一些特定的资源，任何有意义的行为都是可以的。基本的设计思路是：权限控制，至少是基于资源和行为。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>角色是一个命名实体，通常代表一组行为或职责。这些行为会转化为：谁可以在应用程序中执行哪些行为？谁不可以在程序中执行哪些行为？</p>
<p>角色通常是分配给用户帐户的，因此通过关联，用户可以获得自身角色所赋予的权限。</p>
<h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>用户本质上是应用程序的“用户”。</p>
<p>用户（即 Shiro 的 <code>Subject</code>）通过与角色或直接权限的关联在应用程序中执行某些行为。</p>
<h3 id="基于角色的授权"><a href="#基于角色的授权" class="headerlink" title="基于角色的授权"></a>基于角色的授权</h3><p>如果授权是基于角色赋予权限的数据模型，编程模式如下：</p>
<p>【示例一】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">&quot;administrator&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//show the admin button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例二】</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser <span class="operator">=</span> SecurityUtils.getSubject()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 检查当前 Subject 是否有某种权限</span><br><span class="line">// 如果有，直接跳过；如果没有，Shiro 会抛出 AuthorizationException</span><br><span class="line">currentUser.checkRole(<span class="string">&quot;bankTeller&quot;</span>)<span class="comment">;</span></span><br><span class="line">openBankAccount()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：方式二相比方式一，代码更简洁</p>
</blockquote>
<h3 id="基于权限的授权"><a href="#基于权限的授权" class="headerlink" title="基于权限的授权"></a>基于权限的授权</h3><p><strong>更好的授权策略通常是基于权限的授权</strong>。基于权限的授权，由于它和应用程序的原始功能（针对具体资源上的行为）紧密相关，所以基于权限的授权源代码会在功能更改时同步更改（而不是在安全策略发生更改时）。 这意味着与类似的基于角色的授权代码相比，修改代码的影响面要小得多。</p>
<p>【示例】基于对象的权限检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Permission</span> <span class="variable">printPermission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrinterPermission</span>(<span class="string">&quot;laserjet4400n&quot;</span>, <span class="string">&quot;print&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(printPermission)) &#123;</span><br><span class="line">    <span class="comment">//show the Print button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对象中存储权限控制信息，但这种方式较为繁重</p>
<p>【示例】字符串定义权限控制信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;printer:print:laserjet4400n&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//show the Print button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 : 分隔，表示资源类型、行为、资源 ID，Shiro 提供了默认实现： <code>org.apache.shiro.authz.permission.WildcardPermission</code>。</p>
<p>这种权限控制方式的好处在于：轻量、灵活。</p>
<h3 id="基于注解的授权"><a href="#基于注解的授权" class="headerlink" title="基于注解的授权"></a>基于注解的授权</h3><p>Shiro 提供了一些用于授权的注解，来进一步简化授权代码。</p>
<h4 id="RequiresAuthentication"><a href="#RequiresAuthentication" class="headerlink" title="@RequiresAuthentication"></a><code>@RequiresAuthentication</code></h4><p><code>@RequiresAuthentication</code> 注解要求当前 <code>Subject</code> 必须是已认证用户才可以访问被修饰的方法。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account userAccount)</span> &#123;</span><br><span class="line">    <span class="comment">//this method will only be invoked by a</span></span><br><span class="line">    <span class="comment">//Subject that is guaranteed authenticated</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequiresGuest"><a href="#RequiresGuest" class="headerlink" title="@RequiresGuest"></a><code>@RequiresGuest</code></h4><p><code>@RequiresGuest</code> 注解要求当前 <code>Subject</code> 的角色是 <code>guest</code> 才可以访问被修饰的方法。</p>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200317092618.png" alt="img"></p>
<ol>
<li><p>应用程序或框架代码调用任何 <code>Subject</code> 的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法，并传入所需的权限或角色。</p>
</li>
<li><p><code>Subject</code> 实例，通常是 <code>DelegatingSubject</code>（或子类），通过调用 <code>securityManager</code> 几乎相同的各自 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法来委托 <code>SecurityManager</code> （实现了 <a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html"><code>org.apache.shiro.authz.Authorizer</code></a> 接口）处理授权。</p>
</li>
<li><p><code>SecurityManager</code> 通过调用授权者各自的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法来中继&#x2F;委托其内部的 <code>org.apache.shiro.authz.Authorizer</code> 实例。默认情况下，<code>authorizer</code> 实例是 <code>ModularRealmAuthorizer</code> 实例，该实例支持在任何授权操作期间协调一个或多个 <code>Realm</code> 实例。</p>
</li>
<li><p>检查每个已配置的 <code>Realm</code>，以查看其是否实现相同的 <code>Authorizer</code> 接口。如果是这样，则将调用 <code>Realm</code> 各自的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法。</p>
</li>
</ol>
<blockquote>
<p>:link: 更多授权细节可以参考：<a target="_blank" rel="noopener" href="http://shiro.apache.org/authorization.html#apache-shiro-authorization">Apache Shiro Authorization</a></p>
</blockquote>
<h2 id="四、Shiro-会话管理"><a href="#四、Shiro-会话管理" class="headerlink" title="四、Shiro 会话管理"></a>四、Shiro 会话管理</h2><p>Shiro 提供了一套独特的会话管理方案：其 Session 可以使用 Java SE 程序，也可以使用于 Java Web 程序。</p>
<p>在 Shiro 中，<a target="_blank" rel="noopener" href="http://shiro.apache.org/session-management.html#the-sessionmanager">SessionManager</a> 负责管理应用所有 <code>Subject</code> 的会话，如：创建、删除、失效、验证等。</p>
<p>【示例】会话使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentUser.getSession();</span><br><span class="line">session.setAttribute( <span class="string">&quot;someKey&quot;</span>, someValue);</span><br></pre></td></tr></table></figure>

<h3 id="会话超时"><a href="#会话超时" class="headerlink" title="会话超时"></a>会话超时</h3><p>默认情况下，Shiro 中的会话有效期为 30 分钟，超时后，该会话将被 Shiro 视为无效。</p>
<p>可以通过 <code>globalSessionTimeout</code> 方法设置 Shiro 会话超时时间。</p>
<h3 id="会话监听"><a href="#会话监听" class="headerlink" title="会话监听"></a>会话监听</h3><p>Shiro 提供了 <code>SessionListener</code> 接口（或 <code>SessionListenerAdapter</code> 接口），用于监听重要的会话事件，并允许使用者在事件触发时做定制化处理。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroSessionListener</span> <span class="keyword">implements</span> <span class="title class_">SessionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">sessionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExpiration</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="会话存储"><a href="#会话存储" class="headerlink" title="会话存储"></a>会话存储</h3><p>大多数情况下，应用需要保存会话信息，以便在稍后可以使用它。</p>
<p>Shiro 提供了 <code>SessionManager</code> 接口，负责将针对会话的 CRUD 操作委派给内部组件 <code>SessionDAO</code>，该组件反映了数据访问对象（DAO）设计模式。</p>
<blockquote>
<p>:bell: 注意：由于会话通常具有时效性，所以一般会话天然适合存储于缓存中。存储于 Redis 中是一个不错的选择。</p>
</blockquote>
<h2 id="五、Realm"><a href="#五、Realm" class="headerlink" title="五、Realm"></a>五、Realm</h2><p><code>Realm</code> 是 Shiro 访问程序安全相关数据（如：用户、角色、权限）的接口。</p>
<p><code>Realm</code> 是有开发者自己实现的，开发者可以通过实现 Realm 接口，接入应用的数据源，如：JDBC、文件、Nosql 等等。</p>
<h3 id="认证令牌"><a href="#认证令牌" class="headerlink" title="认证令牌"></a>认证令牌</h3><p>Shiro 支持身份验证令牌。在咨询 Realm 进行认证尝试之前，将调用其支持方法。 如果返回值为 true，则仅会调用其 <a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#getAuthenticationInfo-org.apache.shiro.authc.AuthenticationToken-">getAuthenticationInfo(token)</a> 方法。通常，Realm 会检查所提交令牌的类型（接口或类），以查看其是否可以处理它。</p>
<p>令牌认证处理流程如下：</p>
<ol>
<li>检查用于标识 principal 的令牌（帐户标识信息）。</li>
<li>根据 principal，在数据源中查找相应的帐户数据。</li>
<li>确保令牌提供的凭证与数据存储中存储的凭证匹配。</li>
<li>如果 credentials 匹配，则返回 <code>AuthenticationInfo</code> 实例。</li>
<li>如果 credentials 不匹配，则抛出 <code>AuthenticationException</code> 异常。</li>
</ol>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>通过前文，可以了解：Shiro 需要通过一对 principal 和 credentials 来确认身份是否匹配（即认证）。</p>
<p>一般来说，成熟软件是不允许存储账户、密码这些敏感数据时，使用明文存储。所以，通常要将密码加密后存储。</p>
<p>Shiro 提供了一些加密器，其思想就是用 MD5、SHA 这种数字签名算法，加 Salt，然后转为 Base64 字符串。为了避免被暴力破解，Shiro 使用多次加密的方式获得最终的 credentials 字符串。</p>
<p>【示例】Shiro 加密密码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Sha256Hash;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.RandomNumberGenerator;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.SecureRandomNumberGenerator;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//We&#x27;ll use a Random Number Generator to generate salts.  This</span></span><br><span class="line"><span class="comment">//is much more secure than using a username as a salt or not</span></span><br><span class="line"><span class="comment">//having a salt at all.  Shiro makes this easy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Note that a normal app would reference an attribute rather</span></span><br><span class="line"><span class="comment">//than create a new RNG every time:</span></span><br><span class="line"><span class="type">RandomNumberGenerator</span> <span class="variable">rng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandomNumberGenerator</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">salt</span> <span class="operator">=</span> rng.nextBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Now hash the plain-text password with the random salt and multiple</span></span><br><span class="line"><span class="comment">//iterations and then Base64-encode the value (requires less space than Hex):</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hashedPasswordBase64</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sha256Hash</span>(plainTextPassword, salt, <span class="number">1024</span>).toBase64();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, hashedPasswordBase64);</span><br><span class="line"><span class="comment">//save the salt with the new account.  The HashedCredentialsMatcher</span></span><br><span class="line"><span class="comment">//will need it later when handling login attempts:</span></span><br><span class="line">user.setPasswordSalt(salt);</span><br><span class="line">userDAO.create(user);</span><br></pre></td></tr></table></figure>

<h2 id="六、配置"><a href="#六、配置" class="headerlink" title="六、配置"></a>六、配置</h2><h3 id="过滤链"><a href="#过滤链" class="headerlink" title="过滤链"></a>过滤链</h3><p>运行 Web 应用程序时，Shiro 将创建一些有用的默认 Filter 实例。</p>
<table>
<thead>
<tr>
<th align="left">Filter Name</th>
<th align="left">Class</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anon</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html">org.apache.shiro.web.filter.authc.AnonymousFilter</a></td>
</tr>
<tr>
<td align="left">authc</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</a></td>
</tr>
<tr>
<td align="left">authcBasic</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</a></td>
</tr>
<tr>
<td align="left">logout</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html">org.apache.shiro.web.filter.authc.LogoutFilter</a></td>
</tr>
<tr>
<td align="left">noSessionCreation</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html">org.apache.shiro.web.filter.session.NoSessionCreationFilter</a></td>
</tr>
<tr>
<td align="left">perms</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</a></td>
</tr>
<tr>
<td align="left">port</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html">org.apache.shiro.web.filter.authz.PortFilter</a></td>
</tr>
<tr>
<td align="left">rest</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</a></td>
</tr>
<tr>
<td align="left">roles</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</a></td>
</tr>
<tr>
<td align="left">ssl</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html">org.apache.shiro.web.filter.authz.SslFilter</a></td>
</tr>
<tr>
<td align="left">user</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html">org.apache.shiro.web.filter.authc.UserFilter</a></td>
</tr>
</tbody></table>
<h3 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">token.setRememberMe(<span class="literal">true</span>);</span><br><span class="line">SecurityUtils.getSubject().login(token);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://shiro.apache.org/reference.html">Shiro 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/category/305053">跟我学 Shiro</a></li>
<li><a target="_blank" rel="noopener" href="https://stormpath.com/blog/new-rbac-resource-based-access-control">The New RBAC: Resource-Based Access Control</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/eea88ac8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/eea88ac8/" class="post-title-link" itemprop="url">Spring Security 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Security-快速入门"><a href="#Spring-Security-快速入门" class="headerlink" title="Spring Security 快速入门"></a>Spring Security 快速入门</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>参考：<a target="_blank" rel="noopener" href="https://spring.io/guides/gs/securing-web/">Securing a Web Application</a></p>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>Spring Security 对于 Servlet 的支持基于过滤链（<code>FilterChain</code>）实现。</p>
<p>Spring 提供了一个名为 <code>DelegatingFilterProxy</code> 的 <code>Filter</code> 实现，该实现允许在 Servlet 容器的生命周期和 Spring 的 <code>ApplicationContext</code> 之间进行桥接。 Servlet 容器允许使用其自己的标准注册 Filters，但它不了解 Spring 定义的 Bean。 <code>DelegatingFilterProxy</code> 可以通过标准的 Servlet 容器机制进行注册，但是可以将所有工作委托给实现 Filter 的 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">// Lazily get Filter that was registered as a Spring Bean</span></span><br><span class="line">    <span class="comment">// For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> getFilterBean(someBeanName);</span><br><span class="line">    <span class="comment">// delegate work to the Spring Bean</span></span><br><span class="line">    delegate.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FilterChainProxy</code> 使用 <code>SecurityFilterChain</code> 确定应对此请求调用哪些 Spring Security 过滤器。</p>
<p><code>SecurityFilterChain</code> 中的安全过滤器通常是 Bean，但它们是使用 <code>FilterChainProxy</code> 而不是 <code>DelegatingFilterProxy</code> 注册的。</p>
<p>实际上，<code>FilterChainProxy</code> 可用于确定应使用哪个 <code>SecurityFilterChain</code>。如果您的应用程序可以为不同的模块提供完全独立的配置。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/architecture/multi-securityfilterchain.png" alt="multi securityfilterchain"></p>
<p>ExceptionTranslationFilter 可以将 AccessDeniedException 和 AuthenticationException 转换为 HTTP 响应。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/architecture/exceptiontranslationfilter.png" alt="exceptiontranslationfilter"></p>
<p>核心源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    filterChain.doFilter(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessDeniedException | AuthenticationException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!authenticated || e <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">        startAuthentication();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accessDenied();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Spring Security 框架中的认证数据模型如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200331115710.png" alt="img"></p>
<ul>
<li><code>Authentication</code> - 认证信息实体。<ul>
<li><code>principal</code> - 用户标识。如：用户名、账户名等。通常是 <code>UserDetails</code> 的实例（后面详细讲解）。</li>
<li><code>credentials</code> - 认证凭证。如：密码等。</li>
<li><code>authorities</code> - 授权信息。如：用户的角色、权限等信息。</li>
</ul>
</li>
<li><code>SecurityContext</code> - 安全上下文。包含一个 <code>Authentication</code> 对象。</li>
<li><code>SecurityContextHolder</code> - 安全上下文持有者。用于存储认证信息。</li>
</ul>
<p>【示例】注册认证信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TestingAuthenticationToken</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;ROLE_USER&quot;</span>);</span><br><span class="line">context.setAuthentication(authentication);</span><br><span class="line">SecurityContextHolder.setContext(context);</span><br></pre></td></tr></table></figure>

<p>【示例】访问认证信息</p>
<h3 id="认证基本流程"><a href="#认证基本流程" class="headerlink" title="认证基本流程"></a>认证基本流程</h3><p>AbstractAuthenticationProcessingFilter 用作验证用户凭据的基本过滤器。 在对凭证进行身份验证之前，Spring Security 通常使用 AuthenticationEntryPoint 请求凭证。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter"></p>
<ul>
<li>（1）当用户提交其凭据时，<code>AbstractAuthenticationProcessingFilter</code> 从要验证的 <code>HttpServletRequest</code> 创建一个 <code>Authentication</code>。创建的身份验证类型取决于 <code>AbstractAuthenticationProcessingFilter</code> 的子类。例如，<code>UsernamePasswordAuthenticationFilter</code> 根据在 <code>HttpServletRequest</code> 中提交的用户名和密码来创建 <code>UsernamePasswordAuthenticationToken</code>。</li>
<li>（2）接下来，将身份验证传递到 <code>AuthenticationManager</code> 进行身份验证。</li>
<li>（3）如果身份验证失败，则认证失败<ul>
<li>清除 <code>SecurityContextHolder</code>。</li>
<li>调用 <code>RememberMeServices.loginFail</code>。如果没有配置 remember me，则为空。</li>
<li>调用 <code>AuthenticationFailureHandler</code>。</li>
</ul>
</li>
<li>（4）如果身份验证成功，则认证成功。<ul>
<li>如果是新的登录，则通知 <code>SessionAuthenticationStrategy</code>。</li>
<li>身份验证是在 <code>SecurityContextHolder</code> 上设置的。之后，<code>SecurityContextPersistenceFilter</code> 将 <code>SecurityContext</code> 保存到 <code>HttpSession</code> 中。</li>
<li>调用 <code>RememberMeServices.loginSuccess</code>。如果没有配置 remember me，则为空。</li>
<li><code>ApplicationEventPublisher</code> 发布一个 <code>InteractiveAuthenticationSuccessEvent</code>。</li>
</ul>
</li>
</ul>
<h3 id="用户名-密码认证"><a href="#用户名-密码认证" class="headerlink" title="用户名&#x2F;密码认证"></a>用户名&#x2F;密码认证</h3><p>读取用户名和密码的方式：</p>
<ul>
<li>表单</li>
<li>基本认证</li>
<li>数字认证</li>
</ul>
<p>存储机制</p>
<ul>
<li>内存</li>
<li>JDBC</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a></li>
<li>LDAP</li>
</ul>
<h4 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h4><p>spring security 支持通过从 html 表单获取登录时提交的用户名、密码。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/loginurlauthenticationentrypoint.png" alt="loginurlauthenticationentrypoint"></p>
<p>一旦，登录信息被提交，<code>UsernamePasswordAuthenticationFilter</code> 就会验证用户名和密码。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/usernamepasswordauthenticationfilter.png" alt="usernamepasswordauthenticationfilter"></p>
<h4 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .httpBasic(withDefaults());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存认证"><a href="#内存认证" class="headerlink" title="内存认证"></a>内存认证</h4><p><code>InMemoryUserDetailsManager</code> 实现了 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a> ，提供了基本的用户名、密码认证，其认证数据存储在内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The builder will ensure the passwords are encoded before saving in memory</span></span><br><span class="line">    <span class="type">UserBuilder</span> <span class="variable">users</span> <span class="operator">=</span> User.withDefaultPasswordEncoder();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> users</span><br><span class="line">        .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> users</span><br><span class="line">        .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDBC-认证"><a href="#JDBC-认证" class="headerlink" title="JDBC 认证"></a>JDBC 认证</h4><p>JdbcUserDetailsManager 实现了 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a> ，提供了基本的用户名、密码认证，其认证数据存储在关系型数据库中，通过 JDBC 方式访问。</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">UserDetailsManager users(DataSource dataSource) &#123;</span><br><span class="line">    UserDetails <span class="literal">user</span> = <span class="literal">User</span>.builder()</span><br><span class="line">        .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;&#123;bcrypt&#125;<span class="variable">$2a</span><span class="variable">$10</span><span class="variable">$GRLdNijSQMUvl</span>/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .build()<span class="comment">;</span></span><br><span class="line">    UserDetails <span class="literal">admin</span> = <span class="literal">User</span>.builder()</span><br><span class="line">        .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;&#123;bcrypt&#125;<span class="variable">$2a</span><span class="variable">$10</span><span class="variable">$GRLdNijSQMUvl</span>/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">        .build()<span class="comment">;</span></span><br><span class="line">    JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource)<span class="comment">;</span></span><br><span class="line">    users.createUser()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本的 scheam：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> users(</span><br><span class="line">    username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not null</span> <span class="keyword">primary key</span>,</span><br><span class="line">    password varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    enabled <span class="type">boolean</span> <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> authorities (</span><br><span class="line">    username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    authority varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_authorities_users <span class="keyword">foreign key</span>(username) <span class="keyword">references</span> users(username)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index ix_auth_username <span class="keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure>

<h4 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h4><p><code>UserDetails</code> 由 <code>UserDetailsService</code> 返回。 <code>DaoAuthenticationProvider</code> 验证 <code>UserDetails</code>，然后返回身份验证，该身份验证的主体是已配置的 <code>UserDetailsService</code> 返回的 <code>UserDetails</code>。</p>
<p><code>DaoAuthenticationProvider</code> 使用 <code>UserDetailsService</code> 检索用户名，密码和其他用于使用用户名和密码进行身份验证的属性。 Spring Security 提供 <code>UserDetailsService</code> 的内存中和 JDBC 实现。</p>
<p>您可以通过将自定义 <code>UserDetailsService</code> 公开为 bean 来定义自定义身份验证。</p>
<h4 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h4><p>Spring Security 的 servlet 支持通过与 <code>PasswordEncoder</code> 集成来安全地存储密码。 可以通过公开一个 PasswordEncoder Bean 来定制 Spring Security 使用的 PasswordEncoder 实现。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/daoauthenticationprovider.png" alt="daoauthenticationprovider"></p>
<h3 id="Remember-Me"><a href="#Remember-Me" class="headerlink" title="Remember-Me"></a>Remember-Me</h3><h2 id="Spring-Boot-集成"><a href="#Spring-Boot-集成" class="headerlink" title="Spring Boot 集成"></a>Spring Boot 集成</h2><p><code>@EnableWebSecurity</code> 和 <code>@Configuration</code> 注解一起使用, 注解 <code>WebSecurityConfigurer</code> 类型的类。</p>
<p>或者利用<code>@EnableWebSecurity</code>注解继承 <code>WebSecurityConfigurerAdapter</code> 的类，这样就构成了 <em>Spring Security</em> 的配置。</p>
<ul>
<li>configure(WebSecurity)：通过重载该方法，可配置 Spring Security 的 Filter 链。</li>
<li>configure(HttpSecurity)：通过重载该方法，可配置如何通过拦截器保护请求。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/topicals/spring-security-architecture">Spring Security Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/securing-web/">Securing a Web Application</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/85652fa3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/85652fa3/" class="post-title-link" itemprop="url">Netty 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty-快速入门"><a href="#Netty-快速入门" class="headerlink" title="Netty 快速入门"></a>Netty 快速入门</h1><h2 id="Netty-简介"><a href="#Netty-简介" class="headerlink" title="Netty 简介"></a>Netty 简介</h2><blockquote>
<p><strong>Netty 是一款基于 NIO（Nonblocking I&#x2F;O，非阻塞 IO）开发的网络通信框架</strong>。</p>
</blockquote>
<h3 id="Netty-的特性"><a href="#Netty-的特性" class="headerlink" title="Netty 的特性"></a>Netty 的特性</h3><ul>
<li><strong>高并发</strong>：Netty 是一款<strong>基于 NIO</strong>（Nonblocking IO，非阻塞 IO）开发的网络通信框架，对比于 BIO（Blocking I&#x2F;O，阻塞 IO），他的并发性能得到了很大提高。</li>
<li><strong>传输快</strong>：Netty 的传输依赖于<strong>内存零拷贝</strong>特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li><strong>封装好</strong>：Netty <strong>封装了 NIO 操作</strong>的很多细节，提供了易于使用调用接口。</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul>
<li><code>Channel</code>：Netty 网络操作抽象类，它除了包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。</li>
<li><code>EventLoop</code>：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。</li>
<li><code>ChannelFuture</code>：Netty 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li>
<li><code>ChannelHandler</code>：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li>
<li><code>ChannelPipeline</code>：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>
<p>Netty 有两种发送消息的方式：</p>
<ul>
<li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；</li>
<li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。</li>
</ul>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>Netty 高性能表现在哪些方面：</p>
<ul>
<li><strong>NIO 线程模型</strong>：同步非阻塞，用最少的资源做更多的事。</li>
<li><strong>内存零拷贝</strong>：尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li><strong>内存池设计</strong>：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。</li>
<li><strong>串形化处理读写</strong>：避免使用锁带来的性能开销。</li>
<li><strong>高性能序列化协议</strong>：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="传统意义的拷贝"><a href="#传统意义的拷贝" class="headerlink" title="传统意义的拷贝"></a>传统意义的拷贝</h3><p>是在发送数据的时候，传统的实现方式是：</p>
<p><code>File.read(bytes)</code></p>
<p><code>Socket.send(bytes)</code></p>
<p>这种方式需要四次数据拷贝和四次上下文切换：</p>
<ol>
<li><p>数据从磁盘读取到内核的 read buffer</p>
</li>
<li><p>数据从内核缓冲区拷贝到用户缓冲区</p>
</li>
<li><p>数据从用户缓冲区拷贝到内核的 socket buffer</p>
</li>
<li><p>数据从内核的 socket buffer 拷贝到网卡接口（硬件）的缓冲区</p>
</li>
</ol>
<h3 id="零拷贝的概念"><a href="#零拷贝的概念" class="headerlink" title="零拷贝的概念"></a>零拷贝的概念</h3><p>明显上面的第二步和第三步是非必要的，通过 java 的 FileChannel.transferTo 方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p>
<ul>
<li>调用 transferTo，数据从文件由 DMA 引擎拷贝到内核 read buffer</li>
<li>接着 DMA 从内核 read buffer 将数据拷贝到网卡接口 buffer</li>
</ul>
<p>上面的两次操作都不需要 CPU 参与，所以就达到了零拷贝。</p>
<h3 id="Netty-中的零拷贝"><a href="#Netty-中的零拷贝" class="headerlink" title="Netty 中的零拷贝"></a>Netty 中的零拷贝</h3><p>主要体现在三个方面：</p>
<p><strong>bytebuffer</strong></p>
<p>Netty 发送和接收消息主要使用 bytebuffer，bytebuffer 使用对外内存（DirectMemory）直接进行 Socket 读写。</p>
<p>原因：如果使用传统的堆内存进行 Socket 读写，JVM 会将堆内存 buffer 拷贝一份到直接内存中然后再写入 socket，多了一次缓冲区的内存拷贝。DirectMemory 中可以直接通过 DMA 发送到网卡接口</p>
<p><strong>Composite Buffers</strong></p>
<p>传统的 ByteBuffer，如果需要将两个 ByteBuffer 中的数据组合到一起，我们需要首先创建一个 size&#x3D;size1+size2 大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用 Netty 提供的组合 ByteBuf，就可以避免这样的操作，因为 CompositeByteBuf 并没有真正将多个 Buffer 组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。</p>
<p><strong>对于 FileChannel.transferTo 的使用</strong></p>
<p>Netty 中使用了 FileChannel 的 transferTo 方法，该方法依赖于操作系统实现零拷贝。</p>
<h2 id="Netty-流程"><a href="#Netty-流程" class="headerlink" title="Netty 流程"></a>Netty 流程</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<p>Netty 是一个广泛使用的 Java 网络编程框架。很多著名软件都使用了它，如：Dubbo、Cassandra、Elasticsearch、Vert.x 等。</p>
</blockquote>
<p>有了 Netty，你可以实现自己的 HTTP 服务器，FTP 服务器，UDP 服务器，RPC 服务器，WebSocket 服务器，Redis 的 Proxy 服务器，MySQL 的 Proxy 服务器等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyOioServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.unreleasableBuffer(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;Hi!\r\n&quot;</span>, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            b.group(group)                                    <span class="comment">//2</span></span><br><span class="line">             .channel(OioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//3</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span></span><br><span class="line">                     <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;            <span class="comment">//4</span></span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);<span class="comment">//5</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind().sync();  <span class="comment">//6</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();        <span class="comment">//7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://netty.io/">Netty 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty">Netty Github</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9f3f6a16911">Netty 入门教程——认识 Netty</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bdaf8ea6fb9a0227b02275a">彻底理解 Netty，这一篇文章就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c81b08f5188257a323f4cef">Java 200+ 面试题补充 ② Netty 模块</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a8658bce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a8658bce/" class="post-title-link" itemprop="url">Java 缓存中间件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-缓存中间件"><a href="#Java-缓存中间件" class="headerlink" title="Java 缓存中间件"></a>Java 缓存中间件</h1><blockquote>
<p>关键词：Spring Cache、J2Cache、JetCache</p>
</blockquote>
<h2 id="一-、JSR-107"><a href="#一-、JSR-107" class="headerlink" title="一 、JSR 107"></a>一 、JSR 107</h2><p><a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=107">JSR107</a> 中制订了 Java 缓存的规范。</p>
<p>因此，在很多缓存框架、缓存库中，其 API 都参考了 JSR 107 规范。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200709174139.png" alt="img"></p>
<p>Java Caching 定义了 5 个核心接口</p>
<ul>
<li><strong>CachingProvider</strong> - 定义了创建、配置、获取、管理和控制多个 <code>CacheManager</code>。一个应用可以在运行期访问多个 <code>CachingProvider</code>。</li>
<li><strong>CacheManager</strong> - 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。一个 CacheManager 仅被一个 CachingProvider 所拥有。</li>
<li><strong>Cache</strong> - 是一个类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。</li>
<li><strong>Entry</strong> - 是一个存储在 Cache 中的 key-value 对。</li>
<li><strong>Expiry</strong> - 每一个存储在 Cache 中的条目有一个定义的有效期，即 Expiry Duration。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。</li>
</ul>
<h2 id="二、Spring-Cache"><a href="#二、Spring-Cache" class="headerlink" title="二、Spring Cache"></a>二、Spring Cache</h2><blockquote>
<p>详见：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cache">Spring Cache 官方文档</a></p>
</blockquote>
<p>Spring 作为 Java 开发最著名的框架，也提供了缓存功能的框架—— Spring Cache。</p>
<p>Spring 支持基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如：EHCache 或 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。</p>
<p>Spring Cache 的特点：</p>
<ul>
<li>通过缓存注解即可支持缓存功能</li>
<li>支持 Spring EL 表达式</li>
<li>支持 AspectJ</li>
<li>支持自定义 key 和缓存管理</li>
</ul>
<h3 id="开启缓存注解"><a href="#开启缓存注解" class="headerlink" title="开启缓存注解"></a>开启缓存注解</h3><p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。</p>
<p>有两种方式：</p>
<p>（一）使用标记注解 <code>@EnableCaching</code></p>
<p>这种方式对于 Spring 或 Spring Boot 项目都适用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（二）在 xml 中声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="spring-缓存注解-API"><a href="#spring-缓存注解-API" class="headerlink" title="spring 缓存注解 API"></a>spring 缓存注解 API</h3><p>Spring 对缓存的支持类似于对事务的支持。</p>
<p>首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。</p>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p><strong><code>@Cacheable</code> 用于触发缓存</strong>。</p>
<p>表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。</p>
<p>这个注解可以用<code>condition</code>属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。</p>
<p>可以使用<code>key</code>属性来指定 key 的生成规则。</p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p><strong><code>@CachePut</code> 用于更新缓存</strong>。</p>
<p>与<code>@Cacheable</code>不同，<code>@CachePut</code>不仅会缓存方法的结果，还会执行方法的代码段。</p>
<p>它支持的属性和用法都与<code>@Cacheable</code>一致。</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p><strong><code>@CacheEvict</code> 用于清除缓存</strong>。</p>
<p>与<code>@Cacheable</code>功能相反，<code>@CacheEvict</code>表明所修饰的方法是用来删除失效或无用的缓存数据。</p>
<p>下面是<code>@Cacheable</code>、<code>@CacheEvict</code>和<code>@CachePut</code>基本使用方法的一个集中展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// @Cacheable可以设置多个缓存，形式如：@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, condition = &quot;#user.getId() &lt;= 2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserInLimit</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.getId()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUserInDB(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        removeUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeAllInDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p><strong><code>@Caching</code> 用于组合定义多种缓存功能</strong>。</p>
<p>如果需要使用同一个缓存注解（<code>@Cacheable</code>、<code>@CacheEvict</code>或<code>@CachePut</code>）多次修饰一个方法，就需要用到<code>@Caching</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">importBooks</span><span class="params">(String deposit, Date date)</span></span><br></pre></td></tr></table></figure>

<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p><strong><code>@CacheConfig</code> 用于定义公共缓存配置</strong>。</p>
<p>与前面的缓存注解不同，这是一个类级别的注解。</p>
<p>如果类的所有操作都是缓存操作，你可以使用<code>@CacheConfig</code>来指定类，省去一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(&quot;books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">BookRepository</span> &#123;</span><br><span class="line"> <span class="meta">@Cacheable</span></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(ISBN isbn)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Spring-Boot-Cache"><a href="#三、Spring-Boot-Cache" class="headerlink" title="三、Spring Boot Cache"></a>三、Spring Boot Cache</h2><blockquote>
<p>详见：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-caching">Spring Boot Cache 特性官方文档</a></p>
</blockquote>
<p>Spring Boot Cache 是在 Spring Cache 的基础上做了封装，使得使用更为便捷。</p>
<h3 id="Spring-Boot-Cache-快速入门"><a href="#Spring-Boot-Cache-快速入门" class="headerlink" title="Spring Boot Cache 快速入门"></a>Spring Boot Cache 快速入门</h3><p>（1）引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按序引入需要的缓存库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）缓存配置</p>
<p>例如，选用缓存为 redis，则需要配置 redis 相关的配置项（如：数据源、连接池等配置信息）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存类型，支持类型：GENERIC、JCACHE、EHCACHE、HAZELCAST、INFINISPAN、COUCHBASE、REDIS、CAFFEINE、SIMPLE</span></span><br><span class="line"><span class="attr">spring.cache.type</span> = <span class="string">redis</span></span><br><span class="line"><span class="comment"># 全局缓存时间</span></span><br><span class="line"><span class="attr">spring.cache.redis.time-to-live</span> = <span class="string">60s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 配置</span></span><br><span class="line"><span class="attr">spring.redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span> = <span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span> =<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>（3）使用 <code>@EnableCaching</code> 开启缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）缓存注解（<code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvit</code> 等）使用方式与 Spring Cache 完全一样</p>
<h2 id="四、JetCache"><a href="#四、JetCache" class="headerlink" title="四、JetCache"></a>四、JetCache</h2><blockquote>
<p>JetCache 是一个基于 Java 的缓存系统封装，提供统一的 API 和注解来简化缓存的使用。 JetCache 提供了比 SpringCache 更加强大的注解，可以原生的支持 TTL、两级缓存、分布式自动刷新，还提供了<code>Cache</code>接口用于手工缓存操作。 当前有四个实现，<code>RedisCache</code>、<code>TairCache</code>（此部分未在 github 开源）、<code>CaffeineCache</code>(in memory)和一个简易的<code>LinkedHashMapCache</code>(in memory)，要添加新的实现也是非常简单的。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache">jetcache Github</a></p>
</blockquote>
<h3 id="jetcache-快速入门"><a href="#jetcache-快速入门" class="headerlink" title="jetcache 快速入门"></a>jetcache 快速入门</h3><p>如果使用 Spring Boot，可以按如下的方式配置（这里使用了 jedis 客户端连接 redis，如果需要集群、读写分离、异步等特性支持请使用<a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache/wiki/RedisWithLettuce_CN">lettuce</a>客户端）。</p>
<p>（1）引入 POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）配置</p>
<p>配置一个 spring boot 风格的 application.yml 文件，把他放到资源目录中</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">statIntervalMinutes:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">areaInCacheName:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">valueEncoder:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">valueDecoder:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">maxIdle:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>（3）开启缓存</p>
<p>然后创建一个 App 类放在业务包的根下，EnableMethodCache，EnableCreateCacheAnnotation 这两个注解分别激活 Cached 和 CreateCache 注解，其他和标准的 Spring Boot 程序是一样的。这个类可以直接 main 方法运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.mypackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alicp.jetcache.anno.config.EnableCreateCacheAnnotation;</span><br><span class="line"><span class="keyword">import</span> com.alicp.jetcache.anno.config.EnableMethodCache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableMethodCache(basePackages = &quot;com.company.mypackage&quot;)</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MySpringBootApp.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）API 基本使用</p>
<p>创建缓存实例</p>
<p>通过 @CreateCache 注解创建一个缓存实例，默认超时时间是 100 秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache(expire = 100)</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;Long, UserDO&gt; userCache;</span><br></pre></td></tr></table></figure>

<p>用起来就像 map 一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> userCache.get(<span class="number">123L</span>);</span><br><span class="line">userCache.put(<span class="number">123L</span>, user);</span><br><span class="line">userCache.remove(<span class="number">123L</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个两级（内存+远程）的缓存，内存中的元素个数限制在 50 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache(name = &quot;UserService.userCache&quot;, expire = 100, cacheType = CacheType.BOTH, localLimit = 50)</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;Long, UserDO&gt; userCache;</span><br></pre></td></tr></table></figure>

<p>name 属性不是必须的，但是起个名字是个好习惯，展示统计数据的使用，会使用这个名字。如果同一个 area 两个 @CreateCache 的 name 配置一样，它们生成的 Cache 将指向同一个实例。</p>
<p>创建方法缓存</p>
<p>使用 @Cached 方法可以为一个方法添加上缓存。JetCache 通过 Spring AOP 生成代理，来支持缓存功能。注解可以加在接口方法上也可以加在类方法上，但需要保证是个 Spring bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Cached(name=&quot;UserService.getUserById&quot;, expire = 3600)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、j2cache"><a href="#五、j2cache" class="headerlink" title="五、j2cache"></a>五、j2cache</h2><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>使用缓存框架，使得开发缓存功能非常便捷。</p>
<p>如果你的系统只需要使用一种缓存，那么推荐使用 Spring Boot Cache。Spring Boot Cache 在 Spring Cache 基础上做了封装，使用更简单、方便。</p>
<p>如果你的系统需要使用多级缓存，那么推荐使用 jetcache。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=107">JSR107</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cache">Spring Cache 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-caching">Spring Boot Cache 特性官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/ld/J2Cache">J2Cache Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache">jetcache Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache/wiki/Home_CN">jetcache wiki</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/14ada432/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/14ada432/" class="post-title-link" itemprop="url">Ehcache 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Ehcache-快速入门"><a href="#Ehcache-快速入门" class="headerlink" title="Ehcache 快速入门"></a>Ehcache 快速入门</h1><blockquote>
<p>EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/technology/cache/ehcache-architecture.png" alt="img"></p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p>Ehcache 虽然也支持分布式模式，但是分布式方案不是很好好，建议只将其作为单机的进程内缓存使用。</p>
</blockquote>
<h3 id="Ehcache-特性"><a href="#Ehcache-特性" class="headerlink" title="Ehcache 特性"></a>Ehcache 特性</h3><p>优点</p>
<ul>
<li>快速、简单</li>
<li>支持多种缓存策略：LRU、LFU、FIFO 淘汰算法</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过 RMI、可插入 API 等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供 Hibernate 的缓存实现</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>使用磁盘 Cache 的时候非常占用磁盘空间</strong></li>
<li><strong>不保证数据的安全</strong></li>
<li>虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。</li>
</ul>
<h3 id="Ehcache-集群"><a href="#Ehcache-集群" class="headerlink" title="Ehcache 集群"></a>Ehcache 集群</h3><p>Ehcache 目前支持五种集群方式：</p>
<ul>
<li>RMI</li>
<li>JMS</li>
<li>JGroup</li>
<li>Terracotta</li>
<li>Ehcache Server</li>
</ul>
<h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h4><p>使用组播方式通知所有节点同步数据。</p>
<p>如果网络有问题，或某台服务宕机，则存在数据无法同步的可能，导致数据不一致。</p>
<p><img src="https://www.ehcache.org/images/documentation/rmi_replication.png" alt="Ehcache Image"></p>
<h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p>JMS 类似 MQ，所有节点订阅消息，当某节点缓存发生变化，就向 JMS 发消息，其他节点感知变化后，同步数据。</p>
<p><img src="https://www.ehcache.org/images/documentation/jms_replication.png" alt="Ehcache Image"></p>
<h4 id="Cache-Server"><a href="#Cache-Server" class="headerlink" title="Cache Server"></a>Cache Server</h4><p><img src="https://www.ehcache.org/images/documentation/loadbalancer_hashing.png" alt="Ehcache Image"></p>
<h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><h3 id="引入-Ehcache"><a href="#引入-Ehcache" class="headerlink" title="引入 Ehcache"></a>引入 Ehcache</h3><p>如果你的项目使用 maven 管理，添加以下依赖到你的 pom.xml 中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的项目不使用 maven 管理，请在 <a target="_blank" rel="noopener" href="http://www.ehcache.org/downloads/">Ehcache 官网下载地址</a> 下载 jar 包。</p>
<p>Spring 提供了对于 Ehcache 接口的封装，可以更简便的使用其功能。接入方式如下：</p>
<p>如果你的项目使用 maven 管理，添加以下依赖到你的<em>pom.xml</em>中。</p>
<p><code>spring-context-support</code>这个 jar 包中含有 Spring 对于缓存功能的抽象封装接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p>（1）在 classpath 下添加 <code>ehcache.xml</code><br>添加一个名为 <em>helloworld</em> 的缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 磁盘缓存位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- helloworld缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Ehcache-工作示例"><a href="#Ehcache-工作示例" class="headerlink" title="Ehcache 工作示例"></a>Ehcache 工作示例</h3><p>Ehcache 会自动加载 <code>classpath</code> 根目录下名为 <code>ehcache.xml</code> 文件。</p>
<p>EhcacheDemo 的工作步骤如下：</p>
<ol>
<li>在 EhcacheDemo 中，我们引用 <code>ehcache.xml</code> 声明的名为 <em>helloworld</em> 的缓存来创建<code>Cache</code>对象；</li>
<li>然后我们用一个键值对来实例化<code>Element</code>对象；</li>
<li>将<code>Element</code>对象添加到<code>Cache</code>；</li>
<li>然后用<code>Cache</code>的 get 方法获取<code>Element</code>对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EhcacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create a cache manager</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the cache called &quot;helloworld&quot;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a key to map the data to</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;greeting&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">putGreeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Element</span>(key, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put the element into the data store</span></span><br><span class="line">        cache.put(putGreeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve the data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">getGreeting</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the value</span></span><br><span class="line">        System.out.println(getGreeting.getObjectValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure>

<h2 id="三、Ehcache-API"><a href="#三、Ehcache-API" class="headerlink" title="三、Ehcache API"></a>三、Ehcache API</h2><p><code>Element</code>、<code>Cache</code>、<code>CacheManager</code>是 Ehcache 最重要的 API。</p>
<ul>
<li><code>Element</code> - 缓存的元素，它维护着一个键值对。</li>
<li><code>Cache</code> - 它是 Ehcache 的核心类，它有多个<code>Element</code>，并被<code>CacheManager</code>管理。它实现了对缓存的逻辑行为。</li>
<li><code>CacheManager</code> - <code>Cache</code>的容器对象，并管理着<code>Cache</code>的生命周期。CacheManager 支持两种创建模式：单例（Singleton mode）和实例（InstanceMode）。</li>
</ul>
<h3 id="创建-CacheManager"><a href="#创建-CacheManager" class="headerlink" title="创建 CacheManager"></a>创建 CacheManager</h3><p>下面的代码列举了创建 <code>CacheManager</code> 的五种方式。</p>
<p>使用静态方法<code>create()</code>会以默认配置来创建单例的<code>CacheManager</code>实例。</p>
<p><code>newInstance()</code>方法是一个工厂方法，以默认配置创建一个新的<code>CacheManager</code>实例。</p>
<p>此外，<code>newInstance()</code>还有几个重载函数，分别可以通过传入<code>String</code>、<code>URL</code>、<code>InputStream</code>参数来加载配置文件，然后创建<code>CacheManager</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Ehcache默认配置获取单例的CacheManager实例</span></span><br><span class="line">CacheManager.create();</span><br><span class="line">String[] cacheNames = CacheManager.getInstance().getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Ehcache默认配置新建一个CacheManager实例</span></span><br><span class="line">CacheManager.newInstance();</span><br><span class="line">String[] cacheNames = manager.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的配置文件分别创建一个CacheManager实例</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager1</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache1.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager2</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache2.xml&quot;</span>);</span><br><span class="line">String[] cacheNamesForManager1 = manager1.getCacheNames();</span><br><span class="line">String[] cacheNamesForManager2 = manager2.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于classpath下的配置文件创建CacheManager实例</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> getClass().getResource(<span class="string">&quot;/anotherconfigurationname.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于文件流得到配置文件，并创建CacheManager实例</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span></span><br><span class="line">(<span class="string">&quot;src/config/ehcache.xml&quot;</span>).getAbsolutePath());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(fis);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><p><strong>需要强调一点，<code>Cache</code>对象在用<code>addCache</code>方法添加到<code>CacheManager</code>之前，是无效的。</strong></p>
<p>使用 CacheManager 的 addCache 方法可以根据缓存名将 ehcache.xml 中声明的 cache 添加到容器中；它也可以直接将 Cache 对象添加到缓存容器中。</p>
<p><code>Cache</code>有多个构造函数，提供了不同方式去加载缓存的配置参数。</p>
<p>有时候，你可能需要使用 API 来动态的添加缓存，下面的例子就提供了这样的范例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了可以使用xml文件中配置的缓存，你也可以使用API动态增删缓存</span></span><br><span class="line"><span class="comment">// 添加缓存</span></span><br><span class="line">manager.addCache(cacheName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.addCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义配置添加缓存，注意缓存未添加进CacheManager之前并不可用</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">memoryOnlyCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="string">&quot;testCache&quot;</span>, <span class="number">5000</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">singletonManager.addCache(memoryOnlyCache);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特定的配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">testCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">CacheConfiguration</span>(<span class="string">&quot;testCache&quot;</span>, maxEntriesLocalHeap)</span><br><span class="line"> .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)</span><br><span class="line"> .eternal(<span class="literal">false</span>)</span><br><span class="line"> .timeToLiveSeconds(<span class="number">60</span>)</span><br><span class="line"> .timeToIdleSeconds(<span class="number">30</span>)</span><br><span class="line"> .diskExpiryThreadIntervalSeconds(<span class="number">0</span>)</span><br><span class="line"> .persistence(<span class="keyword">new</span> <span class="title class_">PersistenceConfiguration</span>().strategy(Strategy.LOCALTEMPSWAP)));</span><br><span class="line"> manager.addCache(testCache);</span><br></pre></td></tr></table></figure>

<h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p>删除缓存比较简单，你只需要将指定的缓存名传入<code>removeCache</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.removeCache(<span class="string">&quot;sampleCache1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="基本缓存操作"><a href="#基本缓存操作" class="headerlink" title="基本缓存操作"></a>基本缓存操作</h3><p>Cache 最重要的两个方法就是 put 和 get，分别用来添加 Element 和获取 Element。</p>
<p>Cache 还提供了一系列的 get、set 方法来设置或获取缓存参数，这里不一一列举，更多 API 操作可参考<a target="_blank" rel="noopener" href="http://www.ehcache.org/generated/2.10.2/pdf/Ehcache_API_Developer_Guide.pdf">官方 API 开发手册</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：使用默认配置或使用指定配置来创建CacheManager</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Peng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheOperationTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CacheOperationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Ehcache默认配置(classpath下的ehcache.xml)获取单例的CacheManager实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/test/resources/ehcache/ehcache.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Cache的引用</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;userCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个Element添加到Cache</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Element，Element类支持序列化，所以下面两种方法都可以用</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element1</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取非序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getObjectKey(), element1.getObjectValue());</span><br><span class="line">        <span class="comment">// 获取序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getKey(), element1.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新Cache中的Element</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element2</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element2.getObjectKey(), element2.getObjectValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Cache的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取MemoryStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;MemoryStoreSize:&#123;&#125;&quot;</span>, cache.getMemoryStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取DiskStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;DiskStoreSize:&#123;&#125;&quot;</span>, cache.getDiskStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除Element</span></span><br><span class="line">        cache.remove(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭当前CacheManager对象</span></span><br><span class="line">        manager.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭CacheManager单例实例</span></span><br><span class="line">        CacheManager.getInstance().shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Ehcache-配置"><a href="#四、Ehcache-配置" class="headerlink" title="四、Ehcache 配置"></a>四、Ehcache 配置</h2><blockquote>
<p>Ehcache 支持通过 xml 文件和 API 两种方式进行配置。</p>
<p>详情参考：<a target="_blank" rel="noopener" href="http://www.ehcache.org/documentation/3.8/xml.html">Ehcache 官方 XML 配置手册</a></p>
</blockquote>
<h3 id="xml-配置方式"><a href="#xml-配置方式" class="headerlink" title="xml 配置方式"></a>xml 配置方式</h3><p>Ehcache 的<code>CacheManager</code>构造函数或工厂方法被调用时，会默认加载 classpath 下名为<em>ehcache.xml</em>的配置文件。如果加载失败，会加载 Ehcache jar 包中的<em>ehcache-failsafe.xml</em>文件，这个文件中含有简单的默认配置。<br><strong>ehcache.xml 配置参数说明：</strong></p>
<ul>
<li><strong>name</strong>：缓存名称。</li>
<li><strong>maxElementsInMemory</strong>：缓存最大个数。</li>
<li><strong>eternal</strong>：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。</li>
<li><strong>timeToIdleSeconds</strong>：置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal&#x3D;false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。</li>
<li><strong>timeToLiveSeconds</strong>：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是 0 就意味着元素可以停顿无穷长的时间。</li>
<li><strong>maxEntriesLocalDisk</strong>：当内存中对象数量达到 maxElementsInMemory 时，Ehcache 将会对象写到磁盘中。</li>
<li><strong>overflowToDisk</strong>：内存不足时，是否启用磁盘缓存。</li>
<li><strong>diskSpoolBufferSizeMB</strong>：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区。</li>
<li><strong>maxElementsOnDisk</strong>：硬盘最大缓存个数。</li>
<li><strong>diskPersistent</strong>：是否在 VM 重启时存储硬盘的缓存数据。默认值是 false。</li>
<li><strong>diskExpiryThreadIntervalSeconds</strong>：磁盘失效线程运行时间间隔，默认是 120 秒。</li>
<li><strong>memoryStoreEvictionPolicy</strong>：当达到 maxElementsInMemory 限制时，Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先出）或是 LFU（较少使用）。</li>
<li><strong>clearOnFlush</strong>：内存数量最大时是否清除。</li>
</ul>
<h3 id="API-配置方式"><a href="#API-配置方式" class="headerlink" title="API 配置方式"></a>API 配置方式</h3><p>xml 配置的参数也可以直接通过编程方式来动态的进行配置（dynamicConfig 没有设为 false）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line"><span class="type">CacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> cache.getCacheConfiguration();</span><br><span class="line">config.setTimeToIdleSeconds(<span class="number">60</span>);</span><br><span class="line">config.setTimeToLiveSeconds(<span class="number">120</span>);</span><br><span class="line">config.setmaxEntriesLocalHeap(<span class="number">10000</span>);</span><br><span class="line">config.setmaxEntriesLocalDisk(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>disableDynamicFeatures()</code>方式关闭动态配置开关。配置以后你将无法再以编程方式配置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line">cache.disableDynamicFeatures();</span><br></pre></td></tr></table></figure>

<h2 id="五、Spring-集成-Ehcache"><a href="#五、Spring-集成-Ehcache" class="headerlink" title="五、Spring 集成 Ehcache"></a>五、Spring 集成 Ehcache</h2><p>Spring3.1 开始添加了对缓存的支持。和事务功能的支持方式类似，缓存抽象允许底层使用不同的缓存解决方案来进行整合。</p>
<p>Spring4.1 开始支持 JSR-107 注解。</p>
<blockquote>
<p><strong>注：我本人使用的 Spring 版本为 4.1.4.RELEASE，目前 Spring 版本仅支持 Ehcache2.5 以上版本，但不支持 Ehcache3。</strong></p>
</blockquote>
<h3 id="绑定-Ehcache"><a href="#绑定-Ehcache" class="headerlink" title="绑定 Ehcache"></a>绑定 Ehcache</h3><p><code>org.springframework.cache.ehcache.EhCacheManagerFactoryBean</code>这个类的作用是加载 Ehcache 配置文件。<br><code>org.springframework.cache.ehcache.EhCacheCacheManager</code>这个类的作用是支持 net.sf.ehcache.CacheManager。</p>
<p><em>spring-ehcache.xml</em>的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>ehcache缓存配置管理文件<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ehcache&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:ehcache/ehcache.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ehcache&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启用缓存注解开关 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-的缓存注解"><a href="#使用-Spring-的缓存注解" class="headerlink" title="使用 Spring 的缓存注解"></a>使用 Spring 的缓存注解</h3><h4 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h4><p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。<br>你有两个选择：<br>(1) 在 xml 中声明<br>像上一节 spring-ehcache.xml 中的做法一样，使用<code>&lt;cache:annotation-driven/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 使用标记注解<br>你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。<br>范例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解基本使用方法"><a href="#注解基本使用方法" class="headerlink" title="注解基本使用方法"></a>注解基本使用方法</h3><p>Spring 对缓存的支持类似于对事务的支持。<br>首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。<br>下面三个注解都是方法级别：</p>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。<br>这个注解可以用<code>condition</code>属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。<br>可以使用<code>key</code>属性来指定 key 的生成规则。</p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>与<code>@Cacheable</code>不同，<code>@CachePut</code>不仅会缓存方法的结果，还会执行方法的代码段。<br>它支持的属性和用法都与<code>@Cacheable</code>一致。</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>与<code>@Cacheable</code>功能相反，<code>@CacheEvict</code>表明所修饰的方法是用来删除失效或无用的缓存数据。<br>下面是<code>@Cacheable</code>、<code>@CacheEvict</code>和<code>@CachePut</code>基本使用方法的一个集中展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// @Cacheable可以设置多个缓存，形式如：@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, condition = &quot;#user.getId() &lt;= 2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserInLimit</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.getId()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUserInDB(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        removeUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeAllInDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p>如果需要使用同一个缓存注解（<code>@Cacheable</code>、<code>@CacheEvict</code>或<code>@CachePut</code>）多次修饰一个方法，就需要用到<code>@Caching</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">importBooks</span><span class="params">(String deposit, Date date)</span></span><br></pre></td></tr></table></figure>

<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>与前面的缓存注解不同，这是一个类级别的注解。<br>如果类的所有操作都是缓存操作，你可以使用<code>@CacheConfig</code>来指定类，省去一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(&quot;books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">BookRepository</span> &#123;</span><br><span class="line"> <span class="meta">@Cacheable</span></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(ISBN isbn)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.ehcache.org/">Ehcache 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ehcache/ehcache3">Ehcache Github</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/72885?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&2017331&utm_content=m_15513">Ehcache 优缺点以及分布式详解</a></li>
<li><a target="_blank" rel="noopener" href="http://raychase.iteye.com/blog/1545906">Ehcache 详细解读</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/">注释驱动的 Spring cache 缓存介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Spring 官方文档第 36 章缓存抽象</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/45a5db60/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/45a5db60/" class="post-title-link" itemprop="url">Java 进程内缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-进程内缓存"><a href="#Java-进程内缓存" class="headerlink" title="Java 进程内缓存"></a>Java 进程内缓存</h1><blockquote>
<p>关键词：ConcurrentHashMap、LRUHashMap、Guava Cache、Caffeine、Ehcache</p>
</blockquote>
<h2 id="一、ConcurrentHashMap"><a href="#一、ConcurrentHashMap" class="headerlink" title="一、ConcurrentHashMap"></a>一、ConcurrentHashMap</h2><p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：<strong>不需要淘汰的缓存数据</strong>。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h2 id="二、LRUHashMap"><a href="#二、LRUHashMap" class="headerlink" title="二、LRUHashMap"></a>二、LRUHashMap</h2><p>可以通过**继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>**，即可完成一个简单的 <strong>LRU （最近最少使用）</strong>算法。</p>
<p>缺点：</p>
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
<p>【示例】LRUHashMap 的简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">//无需扩容</span></span><br><span class="line">        <span class="built_in">super</span>((<span class="type">int</span>) (max * <span class="number">1.4f</span>), <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写LinkedHashMap的removeEldestEntry方法即可 在Put的时候判断，如果为true，就会删除最老的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putValue</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeValue</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> remove(key) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Guava-Cache"><a href="#三、Guava-Cache" class="headerlink" title="三、Guava Cache"></a>三、Guava Cache</h2><p>Guava Cache 解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 提供了<strong>基于容量，时间和引用的缓存回收方式</strong>。基于容量的方式内部实现采用 LRU 算法，基于引用回收很好的利用了 Java 虚拟机的垃圾回收机制。</p>
<p>其中的缓存构造器 CacheBuilder 采用构建者模式提供了设置好各种参数的缓存对象。缓存核心类 LocalCache 里面的内部类 Segment 与 jdk1.7 及以前的 <code>ConcurrentHashMap</code> 非常相似，分段加锁，减少锁竞争，并且都继承于 <code>ReetrantLock</code>，还有六个队列，以实现丰富的本地缓存方案。Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="Guava-Cache-缓存回收"><a href="#Guava-Cache-缓存回收" class="headerlink" title="Guava Cache 缓存回收"></a>Guava Cache 缓存回收</h3><p>Guava Cache 提供了三种基本的缓存回收方式。</p>
<h3 id="基于容量回收"><a href="#基于容量回收" class="headerlink" title="基于容量回收"></a>基于容量回收</h3><p><code>maximumSize(long)</code>：当缓存中的元素数量超过指定值时触发回收。</p>
<h3 id="基于定时回收"><a href="#基于定时回收" class="headerlink" title="基于定时回收"></a>基于定时回收</h3><ul>
<li><code>expireAfterAccess(long, TimeUnit)</code>：缓存项在给定时间内没有被读&#x2F;写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</li>
<li><code>expireAfterWrite(long, TimeUnit)</code>：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。</li>
</ul>
<p>如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。</p>
<h3 id="基于引用回收"><a href="#基于引用回收" class="headerlink" title="基于引用回收"></a>基于引用回收</h3><ul>
<li><code>CacheBuilder.weakKeys()</code>：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。</li>
<li><code>CacheBuilder.weakValues()</code>：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。</li>
<li><code>CacheBuilder.softValues()</code>：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。</li>
</ul>
<h3 id="Guava-Cache-核心-API"><a href="#Guava-Cache-核心-API" class="headerlink" title="Guava Cache 核心 API"></a>Guava Cache 核心 API</h3><h4 id="CacheBuilder"><a href="#CacheBuilder" class="headerlink" title="CacheBuilder"></a>CacheBuilder</h4><p>缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。<br>主要采用 builder 的模式，CacheBuilder 的每一个方法都返回这个 CacheBuilder 知道 build 方法的调用。<br>注意 build 方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。</p>
<h4 id="LocalManualCache"><a href="#LocalManualCache" class="headerlink" title="LocalManualCache"></a>LocalManualCache</h4><p>作为 LocalCache 的一个内部类，在构造方法里面会把 LocalCache 类型的变量传入，并且调用方法时都直接或者间接调用 LocalCache 里面的方法。</p>
<h4 id="LocalLoadingCache"><a href="#LocalLoadingCache" class="headerlink" title="LocalLoadingCache"></a>LocalLoadingCache</h4><p>可以看到该类继承了 LocalManualCache 并实现接口 LoadingCache。<br>覆盖了 get，getUnchecked 等方法。</p>
<h4 id="LocalCache"><a href="#LocalCache" class="headerlink" title="LocalCache"></a>LocalCache</h4><p>Guava Cache 中的核心类，重点了解。</p>
<p>LocalCache 的数据结构与 ConcurrentHashMap 很相似，都由多个 segment 组成，且各 segment 相对独立，互不影响，所以能支持并行操作。每个 segment 由一个 table 和若干队列组成。缓存数据存储在 table 中，其类型为 AtomicReferenceArray。</p>
<h2 id="四、Caffeine"><a href="#四、Caffeine" class="headerlink" title="四、Caffeine"></a>四、Caffeine</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">caffeine</a> 是一个使用 JDK8 改进 Guava 缓存的高性能缓存库。</p>
</blockquote>
<p>Caffeine 实现了 W-TinyLFU(<strong>LFU</strong> + <strong>LRU</strong> 算法的变种)，其<strong>命中率和读写吞吐量大大优于 Guava Cache</strong>。</p>
<p>其实现原理较复杂，可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment">你应该知道的缓存进化史</a>。</p>
<h2 id="五、Ehcache"><a href="#五、Ehcache" class="headerlink" title="五、Ehcache"></a>五、Ehcache</h2><blockquote>
<p>参考：<a href="04.Ehcache.md">Ehcache</a></p>
</blockquote>
<h2 id="六、进程内缓存对比"><a href="#六、进程内缓存对比" class="headerlink" title="六、进程内缓存对比"></a>六、进程内缓存对比</h2><p>常用进程内缓存技术对比：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody><tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法,LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：**如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 <code>Caffeine</code>**。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">caffeine github</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8df63c6fb9a019e04ebaf4">深入解密来自未来的缓存-Caffeine</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a80c662dac4">Caffeine 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html">Google Guava 官方教程（中文版）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38bd5f1cf2f2">Google Guava Cache 全解析</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/os-cn-spring-cache/">注释驱动的 Spring cache 缓存介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f5949220/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f5949220/" class="post-title-link" itemprop="url">Http 缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h1><p>HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。</p>
<h2 id="Http-强缓存"><a href="#Http-强缓存" class="headerlink" title="Http 强缓存"></a>Http 强缓存</h2><p>不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 Header 属性共同来控制。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p>
<ul>
<li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>
<li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>
<li><code>public</code>：响应可以被中间代理、CDN 等缓存</li>
<li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p><code>Pragma</code> 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h3><p>Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。</p>
<ol>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li>
<li>相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.</li>
</ol>
<p>但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h3><p>Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>
<ol>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified</li>
</ol>
<p>if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<ol>
<li>如果没有被修改:则开始&#96;继续’传送文件: 服务器返回: 200 OK</li>
<li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li>
</ol>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5eb7f811f265da7bbc7cc5bd">图解 HTTP 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a1d4e546fb9a0450f21af23">HTTP—-HTTP 缓存机制</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7">缓存详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/bef3ae94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/bef3ae94/" class="post-title-link" itemprop="url">Hystrix 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">流量控制</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hystrix-快速入门"><a href="#Hystrix-快速入门" class="headerlink" title="Hystrix 快速入门"></a>Hystrix 快速入门</h1><h2 id="Hystrix-简介"><a href="#Hystrix-简介" class="headerlink" title="Hystrix 简介"></a>Hystrix 简介</h2><h3 id="Hystrix-是什么"><a href="#Hystrix-是什么" class="headerlink" title="Hystrix 是什么"></a>Hystrix 是什么</h3><p>Hystrix 是由 Netflix 开源，用于处理分布式系统的延迟和容错的一个开源组件。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。Hystrix 采用<strong>断路器模式</strong>来实现服务间的彼此隔离，从而避免级联故障，以提高分布式系统整体的弹性。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），<strong>向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<p>Hystrix 官方已宣布<strong>不再发布新版本</strong>。但是，Hystrix 的断路器设计理念，有非常高的学习价值。</p>
<h3 id="为什么需要-Hystrix"><a href="#为什么需要-Hystrix" class="headerlink" title="为什么需要 Hystrix"></a>为什么需要 Hystrix</h3><p>复杂的分布式系统架构中的应用程序往往具有数十个依赖项，每个依赖项都会不可避免地在某个时刻失败。 如果主机应用程序未与这些外部故障隔离开来，则可能会被波及。</p>
<p>例如，对于依赖于 30 个服务的应用程序，假设每个服务的正常运行时间为 99.99％，则可以期望：</p>
<blockquote>
<p>99.99<sup>30</sup> &#x3D; 99.7％ 的正常运行时间</p>
<p>10 亿个请求中的 0.3％&#x3D; 3,000,000 个失败</p>
<p>即使所有依赖项都具有出色的正常运行时间，每月也会有 2 个小时以上的停机时间。</p>
<p>然而，现实情况一般比这种估量情况更糟糕。</p>
</blockquote>
<hr>
<p>当一切正常时，整体系统如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141615.png" alt="img"></p>
<p>在高并发场景，这些依赖的稳定性与否对系统的影响非常大，但是依赖有很多不可控问题：如网络连接、资源繁忙、服务宕机等。例如：下图中有一个 QPS 为 50 的依赖 I 出现不可用，但是其他依赖服务是可用的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141749.png" alt="img"></p>
<p>但是，在高并发场景下，当依赖 I 阻塞时，大多数服务器的线程池就出现阻塞(BLOCK)。当这种级联故障愈演愈烈，就可能造成整个线上服务不可用的雪崩效应，如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141859.png" alt="img"></p>
<p>Hystrix 就是为了解决这类问题而应运而生。</p>
<h3 id="Hystrix-的功能"><a href="#Hystrix-的功能" class="headerlink" title="Hystrix 的功能"></a>Hystrix 的功能</h3><p>Hystrix 具有以下功能：</p>
<ul>
<li>避免资源耗尽：阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li>
<li>避免请求排队和积压：采用限流和 <code>fail fast</code> 来控制故障。</li>
<li>支持降级：提供 fallback 降级机制来应对故障。</li>
<li>资源隔离：比如 <code>bulkhead</code>（舱壁隔离技术）、<code>swimlane</code>（泳道技术）、<code>circuit breaker</code>（断路技术）来限制任何一个依赖服务的故障的影响。</li>
<li>统计&#x2F;监控&#x2F;报警：通过近实时的统计&#x2F;监控&#x2F;报警功能，来提高故障发现的速度。</li>
<li>通过近实时的属性和配置<strong>热修改</strong>功能，来提高故障处理和恢复的速度。</li>
<li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。</li>
</ul>
<p>如果使用 Hystrix 对每个基础依赖服务进行过载保护，则整个系统架构将会类似下图所示，每个依赖项彼此隔离，受到延迟时发生饱和的资源的被限制访问，并包含 fallback 逻辑（用于降级处理），该逻辑决定了在依赖项中发生任何类型的故障时做出对应的处理。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717142842.png" alt="img"></p>
<h2 id="Hystrix-原理"><a href="#Hystrix-原理" class="headerlink" title="Hystrix 原理"></a>Hystrix 原理</h2><p>如下图所示，Hystrix 的工作流程大致可以分为 9 个步骤。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717143247.png" alt="img"></p>
<h3 id="（一）构建一个-HystrixCommand-或-HystrixObservableCommand-对象"><a href="#（一）构建一个-HystrixCommand-或-HystrixObservableCommand-对象" class="headerlink" title="（一）构建一个 HystrixCommand 或 HystrixObservableCommand 对象"></a>（一）构建一个 HystrixCommand 或 HystrixObservableCommand 对象</h3><p>Hystrix 进行资源隔离，其实是提供了一个抽象，叫做命令模式。这也是 Hystrix 最基本的资源隔离技术。</p>
<p>在使用 Hystrix 的过程中，会对依赖服务的调用请求封装成命令对象，Hystrix 对 命令对象抽象了两个抽象类：<code>HystrixCommand</code> 和 <code>HystrixObservableCommand</code> 。</p>
<ul>
<li><code>HystrixCommand</code> 表示的命令对象会返回一个唯一返回值。</li>
<li><code>HystrixObservableCommand</code> 表示的命令对象 会返回多个返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HystrixCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixCommand</span>(arg1, arg2);</span><br><span class="line"><span class="type">HystrixObservableCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixObservableCommand</span>(arg1, arg2);</span><br></pre></td></tr></table></figure>

<h3 id="（二）执行命令"><a href="#（二）执行命令" class="headerlink" title="（二）执行命令"></a>（二）执行命令</h3><p>Hystrix 中共有 4 种方式执行命令，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">执行方式</th>
<th align="left">说明</th>
<th align="left">可用对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixCommand.html#execute()"><code>execute()</code></a></td>
<td align="left">阻塞式同步执行，返回依赖服务的单一返回结果(或者抛出异常)</td>
<td align="left"><code>HystrixCommand</code></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixCommand.html#queue()"><code>queue()</code></a></td>
<td align="left">异步执行，通过 <code>Future</code> 返回依赖服务的单一返回结果(或者抛出异常)</td>
<td align="left"><code>HystrixCommand</code></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixObservableCommand.html#observe()"><code>observe()</code></a></td>
<td align="left">基于 Rxjava 的 Observable 方式，返回通过 Observable 表示的依赖服务返回结果。代调用代码先执行(Hot Obserable)</td>
<td align="left"><code>HystrixObservableCommand</code></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixObservableCommand.html#toObservable()"><code>toObservable()</code></a></td>
<td align="left">基于 Rxjava 的 Observable 方式，返回通过 Observable 表示的依赖服务返回结果。执行代码等到真正订阅的时候才会执行(cold observable)</td>
<td align="left"><code>HystrixObservableCommand</code></td>
</tr>
</tbody></table>
<p>这四种命令中，<code>exeucte()</code>、<code>queue()</code>、<code>observe()</code> 的表示其实是通过 <code>toObservable()</code> 实现的，其转换关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-60964d9fa41614c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/563/format/webp" alt="img"></p>
<p><code>HystrixCommand</code> 执行方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">K</span> <span class="variable">value</span>   <span class="operator">=</span> command.execute();</span><br><span class="line"><span class="comment">// 等价语句：</span></span><br><span class="line"><span class="type">K</span> <span class="variable">value</span> <span class="operator">=</span> command.execute().queue().get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Future&lt;K&gt; fValue  = command.queue();</span><br><span class="line"><span class="comment">//等价语句：</span></span><br><span class="line">Future&lt;K&gt; fValue = command.toObservable().toBlocking().toFuture();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;K&gt; ohValue = command.observe(); <span class="comment">//hot observable，立刻订阅，命令立刻执行</span></span><br><span class="line"><span class="comment">//等价语句：</span></span><br><span class="line">Observable&lt;K&gt; ohValue = command.toObservable().subscribe(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述执行最终实现还是基于 toObservable()</span></span><br><span class="line">Observable&lt;K&gt; ocValue = command.toObservable(); <span class="comment">//cold observable，延后订阅，订阅发生后，执行才真正执行</span></span><br></pre></td></tr></table></figure>

<h3 id="（三）是否缓存"><a href="#（三）是否缓存" class="headerlink" title="（三）是否缓存"></a>（三）是否缓存</h3><p>如果当前命令对象启用了请求缓存，并且请求的响应存在于缓存中，则缓存的响应会立刻以 <code>Observable</code> 的形式返回。</p>
<h3 id="（四）是否开启断路器"><a href="#（四）是否开启断路器" class="headerlink" title="（四）是否开启断路器"></a>（四）是否开启断路器</h3><p>如果第三步没有缓存没有命中，则判断一下当前断路器的断路状态是否打开。如果断路器状态为打开状态，则 Hystrix 将不会执行此 Command 命令，直接执行步骤 8 调用 Fallback；</p>
<p>如果断路器状态是关闭，则执行步骤 5 检查是否有足够的资源运行 Command 命令</p>
<h3 id="（五）信号量、线程池是否拒绝"><a href="#（五）信号量、线程池是否拒绝" class="headerlink" title="（五）信号量、线程池是否拒绝"></a>（五）信号量、线程池是否拒绝</h3><p>当您执行该命令时，Hystrix 会检查断路器以查看电路是否打开。</p>
<p>如果电路开路（或“跳闸”），则 Hystrix 将不会执行该命令，而是将流程路由到 (8) 获取回退。</p>
<p>如果电路闭合，则流程前进至 (5) 以检查是否有可用容量来运行命令。</p>
<p>如果当前要执行的 Command 命令 先关连的线程池 和队列(或者信号量)资源已经满了，Hystrix 将不会运行 Command 命令，直接执行 <strong>步骤 8</strong>的 Fallback 降级处理；如果未满，表示有剩余的资源执行 Command 命令，则执行<strong>步骤 6</strong></p>
<h3 id="（六）construct-或-run"><a href="#（六）construct-或-run" class="headerlink" title="（六）construct() 或 run()"></a>（六）construct() 或 run()</h3><p>当经过<strong>步骤 5</strong> 判断，有足够的资源执行 Command 命令时，本步骤将调用 Command 命令运行方法，基于不同类型的 Command，有如下两种两种运行方式：</p>
<table>
<thead>
<tr>
<th align="left">运行方式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HystrixCommand.run()</code></td>
<td align="left">返回一个处理结果或者抛出一个异常</td>
</tr>
<tr>
<td align="left"><code>HystrixObservableCommand.construct()</code></td>
<td align="left">返回一个 Observable 表示的结果(可能多个)，或者 基于<code>onError</code>的错误通知</td>
</tr>
</tbody></table>
<p>如果<code>run()</code> 或者<code>construct()</code>方法 的<code>真实执行时间</code>超过了 Command 设置的<code>超时时间阈值</code>, 则<strong>当前则执行线程</strong>（或者是独立的定时器线程）将会抛出<code>TimeoutException</code>。抛出超时异常 TimeoutException，后，将执行<strong>步骤 8</strong>的 Fallback 降级处理。即使<code>run()</code>或者<code>construct()</code>执行没有被取消或中断，最终能够处理返回结果，但在降级处理逻辑中，将会抛弃<code>run()</code>或<code>construct()</code>方法的返回结果，而返回 Fallback 降级处理结果。</p>
<blockquote>
<p><strong>注意事项</strong><br>需要注意的是，Hystrix 无法强制 将正在运行的线程停止掉–Hystrix 能够做的最好的方式就是在 JVM 中抛出一个<code>InterruptedException</code>。如果 Hystrix 包装的工作不抛出中断异常<code>InterruptedException</code>, 则在 Hystrix 线程池中的线程将会继续执行，尽管<code>调用的客户端</code>已经接收到了<code>TimeoutException</code>。这种方式会使 Hystrix 的线程池处于饱和状态。大部分的 Java Http Client 开源库并不会解析 <code>InterruptedException</code>。所以确认 HTTP client 相关的连接和读&#x2F;写相关的超时时间设置。<br>如果 Command 命令没有抛出任何异常，并且有返回结果，则 Hystrix 将会在做完日志记录和统计之后会将结果返回。 如果是通过<code>run()</code>方式运行，则返回一个<code>Obserable</code>对象，包含一个唯一值，并且发送一个<code>onCompleted</code>通知；如果是通过<code>consturct()</code>方式运行 ，则返回一个<code>Observable对象</code>。</p>
</blockquote>
<h3 id="（七）健康检查"><a href="#（七）健康检查" class="headerlink" title="（七）健康检查"></a>（七）健康检查</h3><p>Hystrix 会统计 Command 命令执行执行过程中的<strong>成功数</strong>、<strong>失败数</strong>、<strong>拒绝数</strong>和<strong>超时数</strong>,将这些信息记录到<strong>断路器(Circuit Breaker)<strong>中。断路器将上述统计按照</strong>时间窗</strong>的形式记录到一个定长数组中。断路器根据时间窗内的统计数据去判定请求什么时候可以被熔断，熔断后，在接下来一段恢复周期内，相同的请求过来后会直接被熔断。当再次校验，如果健康监测通过后，熔断开关将会被关闭。</p>
<h3 id="（八）获取-Fallback"><a href="#（八）获取-Fallback" class="headerlink" title="（八）获取 Fallback"></a>（八）获取 Fallback</h3><p>当以下场景出现后，Hystrix 将会尝试触发 <code>Fallback</code>:</p>
<blockquote>
<ul>
<li>步骤 6 Command 执行时抛出了任何异常；</li>
<li>步骤 4 断路器已经被打开</li>
<li>步骤 5 执行命令的线程池、队列或者信号量资源已满</li>
<li>命令执行的时间超过阈值</li>
</ul>
</blockquote>
<h3 id="（九）返回结果"><a href="#（九）返回结果" class="headerlink" title="（九）返回结果"></a>（九）返回结果</h3><p>如果 Hystrix 命令对象执行成功，将会返回结果，或者以<code>Observable</code>形式包装的结果。根据<strong>步骤 2</strong>的 command 调用方式，返回的<code>Observable</code> 会按照如下图说是的转换关系进行返回：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-8790f97df332d9a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<ul>
<li><code>execute()</code> — 用和 <code>.queue()</code> 相同的方式获取 <code>Future</code>，然后调用 <code>Future</code> 的 <code>get()</code> 以获取 <code>Observable</code> 的单个值。</li>
<li><code>queue()</code> —将 <code>Observable</code> 转换为 <code>BlockingObservable</code>，以便可以将其转换为 <code>Future</code> 并返回。</li>
<li><code>watch()</code> —订阅 <code>Observable</code> 并开始执行命令的流程； 返回一个 <code>Observable</code>，当订阅该 <code>Observable</code> 时，它会重新通知。</li>
<li><code>toObservable()</code> —返回不变的 <code>Observable</code>； 必须订阅它才能真正开始执行命令的流程。</li>
</ul>
<h2 id="断路器工作原理"><a href="#断路器工作原理" class="headerlink" title="断路器工作原理"></a>断路器工作原理</h2><p><img src="https://upload-images.jianshu.io/upload_images/14126519-dce007513bf90794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<ol>
<li>断路器时间窗内的请求数 是否超过了<strong>请求数断路器生效阈值</strong><code>circuitBreaker.requestVolumeThreshold</code>,如果超过了阈值，则将会触发断路，断路状态为<strong>开启</strong><br>例如，如果当前阈值设置的是<code>20</code>,则当时间窗内统计的请求数共计 19 个，即使 19 个全部失败了，都不会触发断路器。</li>
<li>并且请求错误率超过了<strong>请求错误率阈值</strong><code>errorThresholdPercentage</code></li>
<li>如果两个都满足，则将断路器由<strong>关闭</strong>迁移到<strong>开启</strong></li>
<li>如果断路器开启，则后续的所有相同请求将会被断路掉；</li>
<li>直到过了<strong>沉睡时间窗</strong><code>sleepWindowInMilliseconds</code>后，再发起请求时，允许其通过（此时的状态为<strong>半开起状态</strong>）。如果请求失败了，则保持断路器状态为<strong>开启</strong>状态，并更新<strong>沉睡时间窗</strong>。如果请求成功了，则将断路器状态改为<strong>关闭</strong>状态；</li>
</ol>
<p>核心的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">                       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(HealthCounts hc)</span> &#123;</span><br><span class="line">                           <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">                           <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                               <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></span><br><span class="line">                               <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                               <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                               <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                               <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                                   <span class="comment">//we are not past the minimum error threshold for the stat window,</span></span><br><span class="line">                                   <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                                   <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                                   <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                                   <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></span><br><span class="line">                                   <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</span><br><span class="line">                                       circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统指标"><a href="#系统指标" class="headerlink" title="系统指标"></a>系统指标</h3><p>Hystrix 对系统指标的统计是基于时间窗模式的：</p>
<blockquote>
<p><strong>时间窗</strong>：最近的一个时间区间内，比如前一小时到现在，那么时间窗的长度就是<code>1小时</code>；<br><strong>桶</strong>：桶是在特定的<strong>时间窗</strong>内，等分的指标收集的统计集合；比如时间窗的长度为<code>1小时</code>，而桶的数量为<code>10</code>,那么每个桶在时间轴上依次排开，时间由远及近，每个桶统计的时间分片为 <code>1h / 10 = 6 min</code> 6 分钟。一个桶中，包含了<code>成功数</code>、<code>失败数</code>、<code>超时数</code>、<code>拒绝数</code> 四个指标。</p>
</blockquote>
<p>在系统内，时间窗会随着系统的运行逐渐向前移动，而时间窗的长度和桶的数量是固定不变的，那么随着时间的移动，会出现较久的过期的桶被移除出去，新的桶被添加进来，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-11710915e1a5dcda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h2 id="资源隔离技术"><a href="#资源隔离技术" class="headerlink" title="资源隔离技术"></a>资源隔离技术</h2><h3 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h3><p>如下图所示，由于计算机系统的基本执行单位就是线程，线程具备独立的执行能力，所以，为了做到资源保护，需要对系统的线程池进行划分，对于外部调用方</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="title">Request</span></span><br></pre></td></tr></table></figure>

<p>的请求，调用各个线程池的服务，各个线程池独立完成调用，然后将结果返回</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用方</span><br></pre></td></tr></table></figure>

<p>。在调用服务的过程中，如果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务提供方</span><br></pre></td></tr></table></figure>

<p>执行时间过长，则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用方</span><br></pre></td></tr></table></figure>

<p>可以直接以超时的方式直接返回，快速失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-55a0be64ecac4cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>线程池隔离的几点好处</p>
<blockquote>
<ol>
<li>使用超时返回的机制，避免同步调用服务时，调用时间过长，无法释放，导致资源耗尽的情况</li>
<li>服务方可以控制请求数量，请求过多，可以直接拒绝,达到快速失败的目的；</li>
<li>请求排队，线程池可以维护执行队列，将请求压到队列中处理</li>
</ol>
</blockquote>
<p>举个例子，如下代码段，模拟了同步调用服务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务提供方，执行服务的时候模拟2分钟的耗时</span></span><br><span class="line">Callable&lt;String&gt; callableService  = ()-&gt;&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span>(System.currentTimeMillis()-start&gt; <span class="number">1000</span> * <span class="number">60</span> *<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="comment">//模拟服务执行时间过长的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟10个客户端调用服务</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">clients</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//模拟给10个客户端提交处理请求</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    clients.execute(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//同步调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> callableService.call();</span><br><span class="line">            System.out.println(<span class="string">&quot;当前客户端：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用服务完成，得到结果：&quot;</span>+result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此环节中，客户端 <code>clients</code>必须等待服务方返回结果之后，才能接收新的请求。如果用吞吐量来衡量系统的话，会发现系统的处理能力比较低。为了提高相应时间，可以借助线程池的方式，设置超时时间，这样的话，客户端就不需要必须等待服务方返回，如果时间过长，可以提前返回,改造后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务提供方，执行服务的时候模拟2分钟的耗时</span></span><br><span class="line">       Callable&lt;String&gt; callableService  = ()-&gt;&#123;</span><br><span class="line">           <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">while</span>(System.currentTimeMillis()-start&gt; <span class="number">1000</span> * <span class="number">60</span> *<span class="number">2</span>)&#123;</span><br><span class="line">              <span class="comment">//模拟服务执行时间过长的情况</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建线程池作为服务方</span></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//模拟10个客户端调用服务</span></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">clients</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           clients.execute(()-&gt;&#123;</span><br><span class="line">               <span class="comment">//同步调用</span></span><br><span class="line">                   <span class="comment">//将请求提交给线程池执行，Callable 和 Runnable在某种意义上，也是Command对象</span></span><br><span class="line">                   Future&lt;String&gt; future = executorService.submit(callableService::call);</span><br><span class="line">                   <span class="comment">//在指定的时间内获取结果，如果超时，调用方可以直接返回</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">                       <span class="comment">//客户端等待时间之后，快速返回</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;当前客户端：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用服务完成，得到结果：&quot;</span>+result);</span><br><span class="line">                   &#125;<span class="keyword">catch</span> (TimeoutException timeoutException)&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务调用超时，返回处理&quot;</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将服务方的线程池设置为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,<span class="number">1000</span>,TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy() <span class="comment">// 提交请求过多时，可以丢弃请求，避免死等阻塞的情况。</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>线程池隔离模式的弊端</strong></p>
<blockquote>
<p>线程池隔离模式，会根据服务划分出独立的线程池，系统资源的线程并发数是有限的，当线程数过多，系统话费大量的 CPU 时间来做线程上下文切换的无用操作，反而降低系统性能；如果线程池隔离的过多，会导致真正用于接收用户请求的线程就相应地减少，系统吞吐量反而下降；<br><strong>在实践上，应当对像远程方法调用，网络资源请求这种服务时间不太可控的场景下使用线程池隔离模式处理</strong><br>如下图所示，是线程池隔离模式的三种场景：</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-8e16e7f8072475eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h3 id="信号量隔离"><a href="#信号量隔离" class="headerlink" title="信号量隔离"></a>信号量隔离</h3><p>由于基于线程池隔离的模式占用系统线程池资源，Hystrix 还提供了另外一个隔离技术：基于信号量的隔离。</p>
<p>基于信号量的隔离方式非常地简单，其核心就是使用共用变量</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">semaphore</span></span><br></pre></td></tr></table></figure>

<p>进行原子操作，控制线程的并发量，当并发量达到一定量级时，服务禁止调用。如下图所示：信号量本身不会消耗多余的线程资源，所以就非常轻量。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-9af3442e03df941e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>基于信号量隔离的利弊</p>
<blockquote>
<p>利：基于信号量的隔离，利用 JVM 的原子性 CAS 操作，避免了资源锁的竞争，省去了线程池开销，效率非常高；<br>弊：本质上基于信号量的隔离是同步行为，所以无法做到超时熔断，所以服务方自身要控制住执行时间，避免超时。<br>应用场景：<strong>业务服务上，有并发上限限制时，可以考虑此方式</strong> &gt; <code>Alibaba Sentinel</code>开源框架，就是基于信号量的熔断和断路器框架。</p>
</blockquote>
<h2 id="Hystrix-应用"><a href="#Hystrix-应用" class="headerlink" title="Hystrix 应用"></a>Hystrix 应用</h2><ul>
<li><strong>Hystrix 配置无法动态调节生效</strong>。Hystrix 框架本身是使用的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/Netflix/archaius">Archaius</a>框架完成的配置加载和刷新，但是集成自 Spring Cloud 下，无法有效地根据实时监控结果，动态调整熔断和系统参数</li>
<li><strong>线程池和 Command 之间的配置比较复杂</strong>,在 Spring Cloud 在做 feigin-hystrix 集成的时候，还有些 BUG，对 command 的默认配置没有处理好，导致所有 command 占用公共的 command 线程池，没有细粒度控制，还需要做框架适配调整</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hystrix setter appropriate for the given target and method</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  HystrixCommand.Setter <span class="title function_ invoke__">create</span>(Target&lt;?&gt; target, Method method);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default behavior is to derive the group key from &#123;<span class="doctag">@link</span> Target#name()&#125; and the command key from</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> Feign#configKey(Class, Method)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">SetterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> HystrixCommand.Setter <span class="title function_ invoke__">create</span>(Target&lt;?&gt; target, Method method) &#123;</span><br><span class="line">      String groupKey = target.<span class="title function_ invoke__">name</span>();</span><br><span class="line">      String commandKey = Feign.<span class="title function_ invoke__">configKey</span>(target.<span class="title function_ invoke__">type</span>(), method);</span><br><span class="line">      <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">          .<span class="title function_ invoke__">withGroupKey</span>(HystrixCommandGroupKey.Factory.<span class="title function_ invoke__">asKey</span>(groupKey))</span><br><span class="line">          .<span class="title function_ invoke__">andCommandKey</span>(HystrixCommandKey.Factory.<span class="title function_ invoke__">asKey</span>(commandKey));</span><br><span class="line">          <span class="comment">//没有处理好default配置项的加载</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hystrix-配置"><a href="#Hystrix-配置" class="headerlink" title="Hystrix 配置"></a>Hystrix 配置</h2><blockquote>
<p>详细配置可以参考 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix 官方配置手册</a>，这里仅介绍比较核心的配置</p>
</blockquote>
<h3 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h3><p>以下配置用于控制 <a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixCommand.html#run()"><code>HystrixCommand.run()</code></a> 如何执行。</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy"><code>execution.isolation.strategy</code></a></td>
<td>线程隔离（THREAD）或信号量隔离（SEMAPHORE）</td>
<td>THREAD</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.thread.timeoutInMilliseconds"><code>execution.isolation.thread.timeoutInMilliseconds</code></a></td>
<td>方法执行超时时间</td>
<td>1000(ms)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.semaphore.maxConcurrentRequests"><code>execution.isolation.semaphore.maxConcurrentRequests</code></a></td>
<td>信号量隔离最大并发数</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="断路配置"><a href="#断路配置" class="headerlink" title="断路配置"></a>断路配置</h3><p>以下配置用于控制 <a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/index.html?com/netflix/hystrix/HystrixCircuitBreaker.html"><code>HystrixCircuitBreaker</code></a> 的断路处理。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.enabled"><code>circuitBreaker.enabled</code></a></td>
<td align="left">是否开启断路器</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.requestVolumeThreshold"><code>circuitBreaker.requestVolumeThreshold</code></a></td>
<td align="left">断路器启用请求数阈值</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.sleepWindowInMilliseconds"><code>circuitBreaker.sleepWindowInMilliseconds</code></a></td>
<td align="left">断路器启用后的休眠时间</td>
<td align="left">5000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.errorThresholdPercentage"><code>circuitBreaker.errorThresholdPercentage</code></a></td>
<td align="left">断路器启用失败率阈值</td>
<td align="left">50(%)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.forceOpen"><code>circuitBreaker.forceOpen</code></a></td>
<td align="left">是否强制将断路器设置成开启状态</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.forceClosed"><code>circuitBreaker.forceClosed</code></a></td>
<td align="left">是否强制将断路器设置成关闭状态</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="指标配置"><a href="#指标配置" class="headerlink" title="指标配置"></a>指标配置</h3><p>以下配置用于从 HystrixCommand 和 HystrixObservableCommand 执行中捕获相关指标。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingStats.timeInMilliseconds"><code>metrics.rollingStats.timeInMilliseconds</code></a></td>
<td align="left">时间窗的长度</td>
<td align="left">10000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingStats.numBuckets"><code>metrics.rollingStats.numBuckets</code></a></td>
<td align="left">桶的数量，需要保证<code>timeInMilliseconds % numBuckets =0</code></td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.enabled"><code>metrics.rollingPercentile.enabled</code></a></td>
<td align="left">是否统计运行延迟的占比</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.timeInMilliseconds"><code>metrics.rollingPercentile.timeInMilliseconds</code></a></td>
<td align="left"><strong>运行延迟占比</strong>统计的时间窗</td>
<td align="left">60000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.numBuckets"><code>metrics.rollingPercentile.numBuckets</code></a></td>
<td align="left"><strong>运行延迟占比</strong>统计的桶数</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.bucketSize"><code>metrics.rollingPercentile.bucketSize</code></a></td>
<td align="left">百分比统计桶的容量，桶内最多保存的运行时间统计</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.healthSnapshot.intervalInMilliseconds"><code>metrics.healthSnapshot.intervalInMilliseconds</code></a></td>
<td align="left">统计快照刷新间隔</td>
<td align="left">500 (ms)</td>
</tr>
</tbody></table>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>以下配置用于控制 Hystrix Command 执行所使用的线程池。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#coreSize"><code>coreSize</code></a></td>
<td align="left">线程池核心线程数</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#maximumSize"><code>maximumSize</code></a></td>
<td align="left">线程池最大线程数</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#maxQueueSize"><code>maxQueueSize</code></a></td>
<td align="left">最大 LinkedBlockingQueue 的大小，-1 表示用 SynchronousQueue</td>
<td align="left">-1</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#queueSizeRejectionThreshold"><code>queueSizeRejectionThreshold</code></a></td>
<td align="left">队列大小阈值，超过则拒绝</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#allowMaximumSizeToDivergeFromCoreSize"><code>allowMaximumSizeToDivergeFromCoreSize</code></a></td>
<td align="left">此属性允许 maximumSize 的配置生效。该值可以等于或大于 coreSize。设置 coreSize &lt;maximumSize 使得线程池可以维持 maximumSize 并发性，但是会在相对空闲时将线程回收。（取决于 keepAliveTimeInMinutes）</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h2 id="其他限流技术"><a href="#其他限流技术" class="headerlink" title="其他限流技术"></a>其他限流技术</h2><ul>
<li><p><strong>resilience4j</strong><br>Hystrix 虽然官方宣布不再维护，其推荐另外一个框架：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/resilience4j/resilience4j">resilience4j</a>, 这个框架是是为 Java 8 和 函数式编程设计的一个轻量级的容错框架，该框架充分利用函数式编程的概念，为<code>函数式接口</code>、<code>lamda表达式</code>、<code>方法引用</code>高阶函数进行包装，(本质上是装饰者模式的概念)，通过包装实现<code>断路</code>、<code>限流</code>、<code>重试</code>、<code>舱壁</code>功能。<br>这个框架整体而言比较轻量，没有控制台，不太好做系统级监控；</p>
</li>
<li><p>Alibaba Sentinel</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sentinel</span></span><br></pre></td></tr></table></figure>

<p>是 阿里巴巴开源的轻量级的流量控制、熔断降级 Java 库，该库的核心是使用的是信号量隔离的方式做流量控制和熔断，其优点是其集成性和易用性，几乎能和当前主流的 Spring Cloud, dubbo ,grpc ,nacos, zookeeper 做集成，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-70fd779fc1f3b9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>sentinel-features-overview-en.png</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sentinel</span></span><br></pre></td></tr></table></figure>

<p>的目标生态圈：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-84833e6225a05df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sentinel</span></span><br></pre></td></tr></table></figure>

<p>一个强大的功能，就是它有一个流控管理控制台，你可以实时地监控每个服务的流控情况，并且可以实时编辑各种流控、熔断规则，有效地保证了服务保护的及时性。下图是内部试用的 sentinel 控制台：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-bb4aa4ba3a1de64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img">另外，</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sentinel</span></span><br></pre></td></tr></table></figure>

<p>还可以和</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ctrip apollo</span></span><br></pre></td></tr></table></figure>

<p>分布式配置系统进行集成，将流控规降级等各种规则先配置在 apollo 中，然后服务启动自动加载流控规则。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/684b04b6c454">Spring Cloud Hystrix 设计原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c009ff6f265da614b11b84d">Hystrix 都停更了，我为什么还要学？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/18/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/blog/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/20/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"7bfe66064a49a63bf2ff1331d43e50e7"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
