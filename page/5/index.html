<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ecf1efce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ecf1efce/" class="post-title-link" itemprop="url">《极客时间教程 - 深入浅出 Java 虚拟机》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-06 08:00:04" itemprop="dateCreated datePublished" datetime="2024-08-06T08:00:04+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-深入浅出-Java-虚拟机》笔记"><a href="#《极客时间教程-深入浅出-Java-虚拟机》笔记" class="headerlink" title="《极客时间教程 - 深入浅出 Java 虚拟机》笔记"></a>《极客时间教程 - 深入浅出 Java 虚拟机》笔记</h1><h2 id="开篇词：JVM，一块难啃的骨头"><a href="#开篇词：JVM，一块难啃的骨头" class="headerlink" title="开篇词：JVM，一块难啃的骨头"></a>开篇词：JVM，一块难啃的骨头</h2><p>略</p>
<h2 id="一探究竟：为什么需要-JVM？它处在什么位置？"><a href="#一探究竟：为什么需要-JVM？它处在什么位置？" class="headerlink" title="一探究竟：为什么需要 JVM？它处在什么位置？"></a>一探究竟：为什么需要 JVM？它处在什么位置？</h2><p><strong>JVM</strong> - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 <code>*.java</code> 文件编译为 JVM 可理解的 <code>*.class</code> 文件（字节码）。Java 有一句著名的口号：“Write Once, Run Anywhere（一次编写，随处运行）”，JVM 正是其核心所在。实际上，JVM 针对不同的系统（Windows、Linux、MacOS）有不同的实现，目的在于用相同的字节码执行同样的结果。</p>
<p><strong>JRE</strong> - Java Runtime Environment 的缩写，即 Java 运行时环境。它是运行已编译 Java 程序所需的一切的软件包，主要包括 JVM、Java 类库（Class Library）、Java 命令和其他基础结构。但是，它不能用于创建新程序。</p>
<p><strong>JDK</strong> - Java Development Kit 的缩写，即 Java SDK。它不仅包含 JRE 的所有功能，还包含编译器 (javac) 和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<blockquote>
<p>总结来说，JDK、JRE、JVM 三者的关系是：JDK &gt; JRE &gt; JVM</p>
<p><strong>JDK &#x3D; JRE + 开发&#x2F;调试工具</strong></p>
<p><strong>JRE &#x3D; JVM + Java 类库 + Java 运行库</strong></p>
<p><strong>JVM &#x3D; 类加载系统 + 运行时内存区域 + 执行引擎</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504030804019.png" alt="enter image description here"></p>
<blockquote>
<p>摘自 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre">stackoverflow 高票问题 - What is the difference between JDK and JRE?</a></p>
</blockquote>
<h2 id="大厂面试题：你不得不掌握的-JVM-内存管理"><a href="#大厂面试题：你不得不掌握的-JVM-内存管理" class="headerlink" title="大厂面试题：你不得不掌握的 JVM 内存管理"></a>大厂面试题：你不得不掌握的 JVM 内存管理</h2><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjWAPqAuAARqnz6cigo666.png" alt="img"></p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjaANruFAAQKxZvgfSs652.png" alt="img"></p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4VrjaAIlgaAAJKReuKXII670.png" alt="img"></p>
<h2 id="大厂面试题：从覆盖-JDK-的类开始掌握类的加载机制"><a href="#大厂面试题：从覆盖-JDK-的类开始掌握类的加载机制" class="headerlink" title="大厂面试题：从覆盖 JDK 的类开始掌握类的加载机制"></a>大厂面试题：从覆盖 JDK 的类开始掌握类的加载机制</h2><p>Java 类的完整生命周期包括以下几个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong> - 将 _.java 文件转为 _.class</li>
<li><strong>链接（Linking）</strong><ul>
<li><strong>验证（Verification）</strong> - 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</li>
<li><strong>准备（Preparation）</strong> - 为 static 变量在方法区分配内存并初始化为默认值</li>
<li><strong>解析（Resolution）</strong> - 将常量池的符号引用替换为直接引用的过程</li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong> - 为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgqCHl9ZjveAemjoAAB4J1dCVDo17.jpeg"></p>
<p>类加载器</p>
<ul>
<li><p>Bootstrap ClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\lib</code> 或被 <code>-Xbootclasspath</code> 指定的路径</p>
</li>
<li><p>ExtClassLoader - 负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 或被<code>java.ext.dir</code> 指定的路径</p>
</li>
<li><p>AppClassLoader - 负载加载 <code>classpath</code> 路径</p>
</li>
<li><p>自定义类加载器 - 继承自 <code>java.lang.ClassLoader</code></p>
</li>
</ul>
<p><strong>双亲委派机制</strong> - 除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4cQNeAZ4FuAABzsqSozok762.png"></p>
<h2 id="动手实践：从栈帧看字节码是如何在-JVM-中进行流转的"><a href="#动手实践：从栈帧看字节码是如何在-JVM-中进行流转的" class="headerlink" title="动手实践：从栈帧看字节码是如何在 JVM 中进行流转的"></a>动手实践：从栈帧看字节码是如何在 JVM 中进行流转的</h2><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgpOIF4ezuOAK_6bAACFY5oeX-Y174.jpg"></p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/CgpOIF4ezeKAHVCXAABv7rzSgXE896.jpg"></p>
<ul>
<li><p>javap - javap 是 JDK 自带的反解析工具。它的作用是将 .class 字节码文件解析成可读的文件格式。</p>
</li>
<li><p>jclasslib - jclasslib 是一个图形化的工具，能够更加直观的查看字节码中的内容。</p>
</li>
</ul>
<h2 id="大厂面试题：得心应手应对-OOM-的疑难杂症"><a href="#大厂面试题：得心应手应对-OOM-的疑难杂症" class="headerlink" title="大厂面试题：得心应手应对 OOM 的疑难杂症"></a>大厂面试题：得心应手应对 OOM 的疑难杂症</h2><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4hefWAWKFZAAMwndGjScg437.png"></p>
<p>对象生命周期判断</p>
<ul>
<li>引用计数法</li>
<li>可达性分析法 - GC Roots</li>
</ul>
<p>引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h2 id="深入剖析：垃圾回收你真的了解吗？（上）"><a href="#深入剖析：垃圾回收你真的了解吗？（上）" class="headerlink" title="深入剖析：垃圾回收你真的了解吗？（上）"></a>深入剖析：垃圾回收你真的了解吗？（上）</h2><p>垃圾回收算法</p>
<ul>
<li>标记-复制 - 效率最高，但会浪费大量内存空间</li>
<li>标记-清除 - 效率一般，会产生大量内存碎片</li>
<li>标记-整理 - 效率最差，但是不会浪费空间，也消除了内存碎片</li>
</ul>
<p>GC 分代收集：年轻代 GC 使用标记-复制算法；老年代 GC 使用标记-清除算法、标记-整理算法。</p>
<p>常见 GC 收集器：</p>
<ul>
<li>年轻代：Serial、ParNew、Parallel</li>
<li>老年代：Serial Old、Parallel Old、CMS</li>
<li>元空间：G1、ZGC</li>
</ul>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%20Java%20%e8%99%9a%e6%8b%9f%e6%9c%ba-%e5%ae%8c/assets/Cgq2xl4lQuiAHmINAACWihcFScA929.jpg"></p>
<p>GC 收集器配置参数：</p>
<ul>
<li><strong>-XX:+UseSerialGC</strong> 年轻代和老年代都用串行收集器</li>
<li><strong>-XX:+UseParNewGC</strong> 年轻代使用 ParNew，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelGC</strong> 年轻代使用 ParallerGC，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelOldGC</strong> 新生代和老年代都使用并行收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong>，表示年轻代使用 ParNew，老年代的用 CMS</li>
<li><strong>-XX:+UseG1GC</strong> 使用 G1 垃圾回收器</li>
<li><strong>-XX:+UseZGC</strong> 使用 ZGC 垃圾回收器</li>
</ul>
<h2 id="深入剖析：垃圾回收你真的了解吗？（下）"><a href="#深入剖析：垃圾回收你真的了解吗？（下）" class="headerlink" title="深入剖析：垃圾回收你真的了解吗？（下）"></a>深入剖析：垃圾回收你真的了解吗？（下）</h2><ul>
<li>Minor GC：发生在年轻代的 GC。</li>
<li>Major GC：发生在老年代的 GC。</li>
<li>Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。</li>
</ul>
<p>CMS 垃圾回收器分为四个阶段：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清理</li>
</ol>
<p>CMS 中都会有哪些停顿（STW）：</p>
<ol>
<li>初始标记，这部分的停顿时间较短；</li>
<li>Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定；</li>
<li>重新标记，由于 preclaen 阶段的介入，这部分停顿也较短；</li>
<li>Serial-Old 收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长；</li>
<li>Full GC，永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长。</li>
</ol>
<h2 id="大厂面试题：有了-G1-还需要其他垃圾回收器吗？"><a href="#大厂面试题：有了-G1-还需要其他垃圾回收器吗？" class="headerlink" title="大厂面试题：有了 G1 还需要其他垃圾回收器吗？"></a>大厂面试题：有了 G1 还需要其他垃圾回收器吗？</h2><p>G1 最重要的概念，其实就是 Region。它采用分而治之，部分收集的思想，尽力达到我们给它设定的停顿目标。</p>
<h2 id="案例实战：亿级流量高并发下如何进行估算和调优"><a href="#案例实战：亿级流量高并发下如何进行估算和调优" class="headerlink" title="案例实战：亿级流量高并发下如何进行估算和调优"></a>案例实战：亿级流量高并发下如何进行估算和调优</h2><p>GC 指标：</p>
<ul>
<li>系统容量（Capacity）</li>
<li>延迟（Latency）</li>
<li>吞吐量（Throughput）</li>
</ul>
<p><strong>选择垃圾回收器</strong></p>
<ul>
<li>如果你的堆大小不是很大（比如 100MB），选择串行收集器一般是效率最高的。参数：-XX:+UseSerialGC。</li>
<li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有 1C，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。参数：-XX:+UseSerialGC。</li>
<li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。参数：-XX:+UseParallelGC。</li>
<li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。参数：-XX:+UseConcMarkSweepGC、-XX:+UseG1GC、-XX:+UseZGC 等。</li>
</ul>
<h2 id="第-09-讲：案例实战：面对突如其来的-GC-问题如何下手解决"><a href="#第-09-讲：案例实战：面对突如其来的-GC-问题如何下手解决" class="headerlink" title="第 09 讲：案例实战：面对突如其来的 GC 问题如何下手解决"></a>第 09 讲：案例实战：面对突如其来的 GC 问题如何下手解决</h2><h2 id="第-10-讲：动手实践：自己模拟-JVM-内存溢出场景"><a href="#第-10-讲：动手实践：自己模拟-JVM-内存溢出场景" class="headerlink" title="第 10 讲：动手实践：自己模拟 JVM 内存溢出场景"></a>第 10 讲：动手实践：自己模拟 JVM 内存溢出场景</h2><h2 id="第-11-讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏"><a href="#第-11-讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏" class="headerlink" title="第 11 讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏"></a>第 11 讲：动手实践：遇到问题不要慌，轻松搞定内存泄漏</h2><p>jinfo、jstat、jstack、jhsdb（jmap）等是经常被使用的一些工具，尤其是 jmap，在分析处理内存泄漏问题的时候，是必须的。</p>
<h2 id="工具进阶：如何利用-MAT-找到问题发生的根本原因"><a href="#工具进阶：如何利用-MAT-找到问题发生的根本原因" class="headerlink" title="工具进阶：如何利用 MAT 找到问题发生的根本原因"></a>工具进阶：如何利用 MAT 找到问题发生的根本原因</h2><p>MAT 是用来分析内存快照的。</p>
<h2 id="动手实践：让面试官刮目相看的堆外内存排查"><a href="#动手实践：让面试官刮目相看的堆外内存排查" class="headerlink" title="动手实践：让面试官刮目相看的堆外内存排查"></a>动手实践：让面试官刮目相看的堆外内存排查</h2><h2 id="预警与解决：深入浅出-GC-监控与调优"><a href="#预警与解决：深入浅出-GC-监控与调优" class="headerlink" title="预警与解决：深入浅出 GC 监控与调优"></a>预警与解决：深入浅出 GC 监控与调优</h2><h2 id="案例分析：一个高死亡率的报表系统的优化之路"><a href="#案例分析：一个高死亡率的报表系统的优化之路" class="headerlink" title="案例分析：一个高死亡率的报表系统的优化之路"></a>案例分析：一个高死亡率的报表系统的优化之路</h2><h2 id="案例分析：分库分表后，我的应用崩溃了"><a href="#案例分析：分库分表后，我的应用崩溃了" class="headerlink" title="案例分析：分库分表后，我的应用崩溃了"></a>案例分析：分库分表后，我的应用崩溃了</h2><h2 id="动手实践：从字节码看方法调用的底层实现"><a href="#动手实践：从字节码看方法调用的底层实现" class="headerlink" title="动手实践：从字节码看方法调用的底层实现"></a>动手实践：从字节码看方法调用的底层实现</h2><h2 id="大厂面试题：不要搞混-JMM-与-JVM"><a href="#大厂面试题：不要搞混-JMM-与-JVM" class="headerlink" title="大厂面试题：不要搞混 JMM 与 JVM"></a>大厂面试题：不要搞混 JMM 与 JVM</h2><h2 id="动手实践：从字节码看并发编程的底层实现"><a href="#动手实践：从字节码看并发编程的底层实现" class="headerlink" title="动手实践：从字节码看并发编程的底层实现"></a>动手实践：从字节码看并发编程的底层实现</h2><h2 id="动手实践：不为人熟知的字节码指令"><a href="#动手实践：不为人熟知的字节码指令" class="headerlink" title="动手实践：不为人熟知的字节码指令"></a>动手实践：不为人熟知的字节码指令</h2><h2 id="深入剖析：如何使用-Java-Agent-技术对字节码进行修改"><a href="#深入剖析：如何使用-Java-Agent-技术对字节码进行修改" class="headerlink" title="深入剖析：如何使用 Java Agent 技术对字节码进行修改"></a>深入剖析：如何使用 Java Agent 技术对字节码进行修改</h2><h2 id="23-动手实践：JIT-参数配置如何影响程序运行？"><a href="#23-动手实践：JIT-参数配置如何影响程序运行？" class="headerlink" title="23 动手实践：JIT 参数配置如何影响程序运行？"></a>23 动手实践：JIT 参数配置如何影响程序运行？</h2><h2 id="案例分析：大型项目如何进行性能瓶颈调优？"><a href="#案例分析：大型项目如何进行性能瓶颈调优？" class="headerlink" title="案例分析：大型项目如何进行性能瓶颈调优？"></a>案例分析：大型项目如何进行性能瓶颈调优？</h2><h2 id="未来：JVM-的历史与展望"><a href="#未来：JVM-的历史与展望" class="headerlink" title="未来：JVM 的历史与展望"></a>未来：JVM 的历史与展望</h2><h2 id="福利：常见-JVM-面试题补充"><a href="#福利：常见-JVM-面试题补充" class="headerlink" title="福利：常见 JVM 面试题补充"></a>福利：常见 JVM 面试题补充</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/2b98e1ab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/2b98e1ab/" class="post-title-link" itemprop="url">Java 并发面试三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-23 07:21:03" itemprop="dateCreated datePublished" datetime="2024-07-23T07:21:03+08:00">2024-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发面试三"><a href="#Java-并发面试三" class="headerlink" title="Java 并发面试三"></a>Java 并发面试三</h1><h2 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h2><h3 id="【简单】为什么要用线程池？"><a href="#【简单】为什么要用线程池？" class="headerlink" title="【简单】为什么要用线程池？"></a>【简单】为什么要用线程池？</h3><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="【简单】Java-创建线程池有哪些方式？"><a href="#【简单】Java-创建线程池有哪些方式？" class="headerlink" title="【简单】Java 创建线程池有哪些方式？"></a>【简单】Java 创建线程池有哪些方式？</h3><p>Java 提供了多种创建线程池的方法，主要通过 <code>java.util.concurrent.Executors</code> 工厂类和直接使用 <code>ThreadPoolExecutor</code> 构造函数来实现。</p>
<ul>
<li>简单场景使用 <code>Executors</code> 工厂方法</li>
<li>需要精细控制时使用 <code>ThreadPoolExecutor</code> 构造器</li>
<li>注意根据任务类型选择合适的线程池类型</li>
<li>避免使用无界队列以防内存溢出</li>
</ul>
<p><strong>（1）通过 Executors 工厂方法</strong></p>
<p><code>Executors</code> 类中提供了几种内置的 <code>ThreadPoolExecutor</code> 实现：</p>
<ul>
<li>**<code>FixedThreadPool</code>**：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li>**<code>SingleThreadExecutor</code>**： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>**<code>CachedThreadPool</code>**： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li>**<code>ScheduledThreadPool</code>**：给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p><strong>（2）直接使用 <code>ThreadPoolExecutor</code> 构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="type">int</span> corePoolSize,</span><br><span class="line">    <span class="type">int</span> maximumPoolSize,</span><br><span class="line">    <span class="type">long</span> keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>提供更精细的控制参数</li>
<li>可以自定义线程工厂和拒绝策略</li>
</ul>
<p><strong>（3）<code>ForkJoinPool</code> (JDK7+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="type">int</span> parallelism);</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于分治算法和并行任务</li>
<li>使用工作窃取 (work-stealing) 算法</li>
</ul>
<h3 id="【中等】Java-线程池有哪些核心参数？各有什么作用？"><a href="#【中等】Java-线程池有哪些核心参数？各有什么作用？" class="headerlink" title="【中等】Java 线程池有哪些核心参数？各有什么作用？"></a>【中等】Java 线程池有哪些核心参数？各有什么作用？</h3><p><code>ThreadPoolExecutor</code> 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,// 线程池的核心线程数量</span></span><br><span class="line"><span class="params">						  <span class="type">int</span> maximumPoolSize,// 线程池的最大线程数</span></span><br><span class="line"><span class="params">						  <span class="type">long</span> keepAliveTime,// 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">						  TimeUnit unit,// 时间单位</span></span><br><span class="line"><span class="params">						  BlockingQueue&lt;Runnable&gt; workQueue,// 任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">						  ThreadFactory threadFactory,// 线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">						  RejectedExecutionHandler handler// 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">)</span> &#123;<span class="comment">// 略&#125;</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong><code>corePoolSize</code><strong>：</strong>表示线程池保有的最小线程数</strong>。</li>
<li><strong><code>maximumPoolSize</code><strong>：</strong>表示线程池允许创建的最大线程数</strong>。<ul>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
<li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li>
</ul>
</li>
<li><strong><code>keepAliveTime &amp; unit</code><strong>：</strong>表示非核心线程存活时间</strong>。如果一个线程空闲了<code>keepAliveTime &amp; unit</code> 这么久，而且线程池的线程数大于 <code>corePoolSize</code> ，那么这个空闲的线程就要被回收了。</li>
<li><strong><code>workQueue</code><strong>：</strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<ul>
<li><strong><code>ArrayBlockingQueue</code><strong>：基于数组的</strong>有界阻塞队列</strong>。</li>
<li><strong><code>LinkedBlockingQueue</code><strong>：基于链表的</strong>无界阻塞队列</strong>，可能导致 OOM。</li>
<li><strong><code>SynchronousQueue</code><strong>：</strong>不保存任务，直接新建一个线程来执行任务</strong>（需要有可用线程，否则拒绝）。</li>
<li>**<code>DelayedWorkQueue</code>**：延迟阻塞队列。</li>
<li><strong><code>PriorityBlockingQueue</code><strong>：</strong>具有优先级的无界阻塞队列</strong>。</li>
</ul>
</li>
<li><strong><code>threadFactory</code><strong>：</strong>线程工厂</strong>。线程工程用于自定义如何创建线程。</li>
<li><strong><code>handler</code><strong>：</strong>拒绝策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：<ul>
<li><strong><code>AbortPolicy</code><strong>：</strong>默认策略</strong>，<strong>丢弃任务并抛出异常</strong>，直接抛出 <code>RejectedExecutionException</code>。</li>
<li><strong><code>DiscardPolicy</code><strong>：</strong>丢弃任务但不抛出异常</strong>。</li>
<li><strong><code>DiscardOldestPolicy</code><strong>：</strong>丢弃队列最老的任务，然后重新尝试提交</strong>。</li>
<li><strong><code>CallerRunsPolicy</code><strong>：</strong>提交任务的线程自己去执行该任务</strong>。</li>
<li>如果以上策略都不能满足需要，也可以通过实现 <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
</ul>
<p>合理配置这些参数可以优化线程池的性能和稳定性，避免 OOM 或任务丢失。</p>
<h3 id="【中等】Java-线程池的工作原理是什么？"><a href="#【中等】Java-线程池的工作原理是什么？" class="headerlink" title="【中等】Java 线程池的工作原理是什么？"></a>【中等】Java 线程池的工作原理是什么？</h3><p>线程池的工作流程遵循 <strong>任务提交 → 线程分配 → 队列管理 → 拒绝处理</strong> 机制：</p>
<ol>
<li><strong>提交任务</strong>：调用 <code>execute(Runnable)</code> 或 <code>submit(Callable)</code> 提交任务。</li>
<li><strong>线程分配逻辑</strong><ul>
<li><strong>核心线程可用</strong> → 立即执行任务（即使有空闲线程也会优先创建新线程直到 <code>corePoolSize</code>）。</li>
<li><strong>核心线程已满</strong> → 任务进入任务队列（<code>workQueue</code>）等待。</li>
<li><strong>队列已满</strong> → 创建新线程（不超过 <code>maximumPoolSize</code>）。</li>
<li><strong>线程数达 <code>maximumPoolSize</code> 且队列满</strong> → 触发拒绝策略（<code>RejectedExecutionHandler</code>）。</li>
</ul>
</li>
<li><strong>线程回收</strong>：非核心线程在空闲超过 <code>keepAliveTime</code> 后被回收，核心线程默认常驻（除非设置 <code>allowCoreThreadTimeOut=true</code>）。</li>
</ol>
<p>::: info 线程分配和队列管理源码</p>
<p>:::</p>
<p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。提交任务可以使用 <code>execute</code> 方法，它是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以<strong>向线程池提交一个任务，交由线程池去执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于控制线程池的运行状态和线程池中的有效线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ctl 中存储的线程池状态信息</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池执行可以分为 3 个步骤</span></span><br><span class="line">    <span class="comment">// 1. 若工作线程数小于核心线程数，则尝试启动一个新的线程来执行任务</span></span><br><span class="line">	<span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">		<span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		c = ctl.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果任务可以成功地加入队列，还需要再次确认是否需要添加新的线程（因为可能自从上次检查以来已经有线程死亡）或者检查线程池是否已经关闭</span></span><br><span class="line">    <span class="comment">// 	-&gt; 如果是后者，则可能需要回滚入队操作；</span></span><br><span class="line">    <span class="comment">// 	-&gt; 如果是前者，则可能需要启动新的线程</span></span><br><span class="line">	<span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">		<span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">			reject(command);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">			addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果任务无法加入队列，则尝试添加一个新的线程</span></span><br><span class="line">    <span class="comment">// 如果添加新线程失败，说明线程池已经关闭或者达到了容量上限，此时将拒绝该任务</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">		reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>execute</code> 方法工作流程如下：</p>
<ol>
<li>如果 <code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果 <code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果 <code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409190726019.png"></p>
<p>::: info 线程池任务状态</p>
<p>:::</p>
<p><code>ThreadPoolExecutor</code> 有以下重要字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p><strong><code>ctl</code> 用于控制线程池的运行状态和线程池中的有效线程数量</strong>。它包含两部分的信息：</p>
<ul>
<li>线程池的运行状态 (<code>runState</code>)</li>
<li>线程池内有效线程的数量 (<code>workerCount</code>)</li>
<li>可以看到，<code>ctl</code> 使用了 <code>Integer</code> 类型来保存，高 3 位保存 <code>runState</code>，低 29 位保存 <code>workerCount</code>。<code>COUNT_BITS</code> 就是 29，<code>CAPACITY</code> 就是 1 左移 29 位减 1（29 个 1），这个常量表示 <code>workerCount</code> 的上限值，大约是 5 亿。</li>
</ul>
<p><strong>线程池一共有五种运行状态</strong>：</p>
<ul>
<li><strong><code>RUNNING</code>（运行状态）</strong>。接受新任务，并且也能处理阻塞队列中的任务。</li>
<li><strong><code>SHUTDOWN</code>（关闭状态）</strong>。不接受新任务，但可以处理阻塞队列中的任务。<ul>
<li>在线程池处于 <code>RUNNING</code> 状态时，调用 <code>shutdown</code> 方法会使线程池进入到该状态。</li>
<li><code>finalize</code> 方法在执行过程中也会调用 <code>shutdown</code> 方法进入该状态。</li>
</ul>
</li>
<li><strong><code>STOP</code>（停止状态）</strong>。不接受新任务，也不处理队列中的任务。会中断正在处理任务的线程。在线程池处于 <code>RUNNING</code> 或 <code>SHUTDOWN</code> 状态时，调用 <code>shutdownNow</code> 方法会使线程池进入到该状态。</li>
<li><strong><code>TIDYING</code>（整理状态）</strong>。如果所有的任务都已终止了，<code>workerCount</code> （有效线程数） 为 0，线程池进入该状态后会调用 <code>terminated</code> 方法进入 <code>TERMINATED</code> 状态。</li>
<li><strong><code>TERMINATED</code>（已终止状态）</strong>。在 <code>terminated</code> 方法执行完后进入该状态。默认 <code>terminated</code> 方法中什么也没有做。进入 <code>TERMINATED</code> 的条件如下：<ul>
<li>线程池不是 <code>RUNNING</code> 状态；</li>
<li>线程池状态不是 <code>TIDYING</code> 状态或 <code>TERMINATED</code> 状态；</li>
<li>如果线程池状态是 <code>SHUTDOWN</code> 并且 <code>workerQueue</code> 为空；</li>
<li><code>workerCount</code> 为 0；</li>
<li>设置 <code>TIDYING</code> 状态成功。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409190729946.png"></p>
<p>在 <code>execute</code> 方法中，多次调用 <code>addWorker</code> 方法。<code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁 mainLock 的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//获取线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 参数为 true 的话表示使用线程池的基本大小，为 false 使用线程池最大大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加成功就返回 true 否则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">	retry:</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">		<span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">		<span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">			! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">			   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">			   ! workQueue.isEmpty()))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		   <span class="comment">//获取线程池中工作的线程的数量</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">			<span class="comment">// core 参数为 false 的话表明队列也满了，线程池大小变为 maximumPoolSize</span></span><br><span class="line">			<span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">				wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		   <span class="comment">//原子操作将 workcount 的数量加 1</span></span><br><span class="line">			<span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">				<span class="keyword">break</span> retry;</span><br><span class="line">			<span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">			c = ctl.get();</span><br><span class="line">			<span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">				<span class="keyword">continue</span> retry;</span><br><span class="line">			<span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">		w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">		<span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">		  <span class="comment">// 加锁</span></span><br><span class="line">			<span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">			mainLock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">			   <span class="comment">//获取线程池状态</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">			   <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为 RUNNING, 并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">			  <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null) 如果线程池状态小于 STOP，也就是 RUNNING 或者 SHUTDOWN 状态下，同时传入的任务实例 firstTask 为 null，则需要添加到工作线程集合和启动新的 Worker</span></span><br><span class="line">			   <span class="comment">// firstTask == null 证明只新建线程而不执行任务</span></span><br><span class="line">				<span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">					(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">					workers.add(w);</span><br><span class="line">				   <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">					<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">					<span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">						largestPoolSize = s;</span><br><span class="line">				  <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">					workerAdded = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 释放锁</span></span><br><span class="line">				mainLock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//// 如果成功添加工作线程，则调用 Worker 内部的线程实例 t 的 Thread#start() 方法启动真实的线程实例</span></span><br><span class="line">			<span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">				t.start();</span><br><span class="line">			  <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">				workerStarted = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	   <span class="comment">// 线程启动失败，需要从工作线程中移除对应的 Worker</span></span><br><span class="line">		<span class="keyword">if</span> (! workerStarted)</span><br><span class="line">			addWorkerFailed(w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【简单】Java-线程池的核心线程会被回收吗？"><a href="#【简单】Java-线程池的核心线程会被回收吗？" class="headerlink" title="【简单】Java 线程池的核心线程会被回收吗？"></a>【简单】Java 线程池的核心线程会被回收吗？</h3><p>在标准情况下，<strong>核心线程（core threads）即使处于空闲状态也不会被线程池回收</strong>。这是线程池的默认行为，目的是保持一定数量的常驻线程，以便快速响应新任务。通过设置 <code>allowCoreThreadTimeOut(true)</code> 可以改变这一行为。</p>
<h3 id="【中等】如何合理地设置-Java-线程池的线程数？"><a href="#【中等】如何合理地设置-Java-线程池的线程数？" class="headerlink" title="【中等】如何合理地设置 Java 线程池的线程数？"></a>【中等】如何合理地设置 Java 线程池的线程数？</h3><p><strong>根据任务类型设置线程数指导</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">推荐设置</th>
<th align="left">关键考虑</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CPU 密集型</td>
<td align="left">核心数+1</td>
<td align="left">避免上下文切换</td>
</tr>
<tr>
<td align="left">I&#x2F;O 密集型</td>
<td align="left">核心数* 2~5</td>
<td align="left">IO 等待时间比例</td>
</tr>
<tr>
<td align="left">混合型</td>
<td align="left">核心数* 1.5~3</td>
<td align="left">根据 CPU&#x2F;IO 时间比例动态调整</td>
</tr>
<tr>
<td align="left">未知场景</td>
<td align="left">动态调整+监控</td>
<td align="left">逐步优化</td>
</tr>
</tbody></table>
<p><strong>通用计算公式</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = <span class="meta">CPU</span> 核心数 × 目标 <span class="meta">CPU</span> 利用率 × (<span class="number">1</span> + 等待时间/计算时间）</span><br></pre></td></tr></table></figure>

<p>（目标 CPU 利用率建议 0.7-0.9）</p>
<p><strong>场景化配置</strong></p>
<ul>
<li>Web 服务器（如 Tomcat）推荐：<code>50-200</code>（需压测确定）。考虑因素：<ul>
<li>并发请求量</li>
<li>平均响应时间</li>
<li>系统资源（内存、CPU）</li>
</ul>
</li>
<li>微服务调用推荐：<code>核心数 * 2</code> 到 <code>核心数 * 5</code>，需配合熔断&#x2F;降级机制</li>
<li>批处理任务推荐：<code>核心数 ± 2</code>，避免与在线服务争抢资源</li>
</ul>
<p><strong>避坑指南</strong></p>
<ul>
<li>禁止设置<code>maximumPoolSize=Integer.MAX_VALUE</code>，以避免 OOM。</li>
<li>避免使用无界队列（推荐<code>ArrayBlockingQueue</code>），避免内存堆积</li>
<li>必须配置拒绝策略（建议日志+降级）</li>
<li>动态线程池优于静态配置</li>
</ul>
<p><strong>最佳实践</strong></p>
<ul>
<li>通过<code>Runtime.getRuntime().availableProcessors()</code>获取核心数</li>
<li>配合有界队列+合理拒绝策略</li>
<li>建立线程池监控（活跃线程&#x2F;队列堆积等）</li>
<li>重要服务建议使用动态调整：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务器 CPU 核心数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cpuCores</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池（I/O 密集型场景）</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    cpuCores * <span class="number">2</span>,          <span class="comment">// corePoolSize</span></span><br><span class="line">    cpuCores * <span class="number">4</span>,          <span class="comment">// maximumPoolSize</span></span><br><span class="line">    <span class="number">30</span>,                    <span class="comment">// keepAliveTime （秒）</span></span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>),  <span class="comment">// 有界队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomThreadFactory</span>(),       <span class="comment">// 命名线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LogAndFallbackPolicy</span>()       <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="【中等】Java-线程池支持哪些阻塞队列，如何选择？"><a href="#【中等】Java-线程池支持哪些阻塞队列，如何选择？" class="headerlink" title="【中等】Java 线程池支持哪些阻塞队列，如何选择？"></a>【中等】Java 线程池支持哪些阻塞队列，如何选择？</h3><table>
<thead>
<tr>
<th align="left">队列类型</th>
<th align="left">数据结构</th>
<th align="left">是否有界</th>
<th align="left">锁机制</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
<th align="left">不适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>ArrayBlockingQueue</strong></td>
<td align="left">数组</td>
<td align="left">有界</td>
<td align="left">ReentrantLock</td>
<td align="left">固定容量，内存连续，支持公平锁</td>
<td align="left">已知并发量的稳定系统</td>
<td align="left">任务量波动大的场景</td>
</tr>
<tr>
<td align="left"><strong>LinkedBlockingQueue</strong></td>
<td align="left">链表</td>
<td align="left">可选*</td>
<td align="left">双锁分离（put&#x2F;take）</td>
<td align="left">默认无界 (Integer.MAX_VALUE)，吞吐量高，节点动态分配</td>
<td align="left">任务量不可预测的中等吞吐系统</td>
<td align="left">严格内存控制的系统</td>
</tr>
<tr>
<td align="left"><strong>SynchronousQueue</strong></td>
<td align="left">无存储</td>
<td align="left">无容量</td>
<td align="left">无锁 (CAS)</td>
<td align="left">直接传递任务，吞吐量最高，公平&#x2F;非公平模式可选</td>
<td align="left">高并发短任务处理</td>
<td align="left">存在长任务的场景</td>
</tr>
<tr>
<td align="left"><strong>PriorityBlockingQueue</strong></td>
<td align="left">堆</td>
<td align="left">无界</td>
<td align="left">ReentrantLock</td>
<td align="left">按优先级排序，自动扩容，元素需实现 Comparable</td>
<td align="left">需要任务优先级调度的系统</td>
<td align="left">对内存敏感的系统</td>
</tr>
<tr>
<td align="left"><strong>DelayQueue</strong></td>
<td align="left">堆+PriorityQueue</td>
<td align="left">无界</td>
<td align="left">ReentrantLock</td>
<td align="left">按延迟时间排序，元素需实现 Delayed 接口</td>
<td align="left">定时任务&#x2F;缓存过期处理</td>
<td align="left">普通任务队列</td>
</tr>
</tbody></table>
<p><strong>关键说明</strong>：</p>
<ul>
<li><strong>有界性</strong>：<ul>
<li>LinkedBlockingQueue 构造时可指定容量变为有界</li>
<li>SynchronousQueue 是特殊的”零容量”队列</li>
</ul>
</li>
<li><strong>吞吐量排序</strong>：<code>SynchronousQueue &gt; LinkedBlockingQueue &gt; ArrayBlockingQueue &gt; PriorityBlockingQueue ≈ DelayQueue</code></li>
<li><strong>内存开销</strong>：<code>PriorityBlockingQueue ≈ DelayQueue &gt; LinkedBlockingQueue &gt; ArrayBlockingQueue &gt; SynchronousQueue</code></li>
<li><strong>特殊机制</strong>：<ul>
<li><strong>公平模式</strong>：ArrayBlockingQueue&#x2F;SynchronousQueue 可设置公平锁（降低吞吐但减少线程饥饿）</li>
<li><strong>双锁分离</strong>：LinkedBlockingQueue 的 put&#x2F;take 操作使用不同锁，提升并发度</li>
<li><strong>直接传递</strong>：SynchronousQueue 实现生产者-消费者直接握手</li>
</ul>
</li>
</ul>
<p><strong>选型决策参考</strong>：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">是否需要优先级/延迟？</span></span><br><span class="line"><span class="attr">├─ 是 → PriorityBlockingQueue/DelayQueue</span></span><br><span class="line"><span class="attr">└─ 否 → 是否接受任务丢失？</span></span><br><span class="line"><span class="attr">   ├─ 是 → SynchronousQueue+CallerRunsPolicy</span></span><br><span class="line"><span class="attr">   └─ 否 → 能否预估最大任务量？</span></span><br><span class="line"><span class="attr">      ├─ 能 → ArrayBlockingQueue（容量</span>=<span class="string">预估峰值×1.5)</span></span><br><span class="line"><span class="string">      └─ 不能 → LinkedBlockingQueue（建议显式设置安全上限）</span></span><br></pre></td></tr></table></figure>

<p><strong>生产建议</strong>：</p>
<ul>
<li><strong>Web 服务</strong>：ArrayBlockingQueue（2000-10000 容量）+ AbortPolicy</li>
<li><strong>消息处理</strong>：LinkedBlockingQueue（10 万上限）+ DiscardOldestPolicy</li>
<li><strong>实时交易</strong>：SynchronousQueue + CachedThreadPool</li>
<li><strong>定时任务</strong>：DelayQueue（单线程消费）</li>
</ul>
<h3 id="【中等】Java-线程池支持哪些拒绝策略？如何选择？"><a href="#【中等】Java-线程池支持哪些拒绝策略？如何选择？" class="headerlink" title="【中等】Java 线程池支持哪些拒绝策略？如何选择？"></a>【中等】Java 线程池支持哪些拒绝策略？如何选择？</h3><p>Java 线程池支持以下拒绝策略：</p>
<table>
<thead>
<tr>
<th>策略名称（实现类）</th>
<th>处理方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AbortPolicy</strong>（默认）</td>
<td>直接抛出 <code>RejectedExecutionException</code> 异常</td>
<td>快速失败，避免系统过载</td>
<td>需要调用方处理异常</td>
<td>需要明确知道任务被拒绝的场景</td>
</tr>
<tr>
<td><strong>CallerRunsPolicy</strong></td>
<td>让提交任务的线程自己执行该任务</td>
<td>降低新任务提交速度，保证任务不丢失</td>
<td>可能阻塞调用线程，影响整体性能</td>
<td>低优先级任务或允许同步执行的场景</td>
</tr>
<tr>
<td><strong>DiscardPolicy</strong></td>
<td>静默丢弃新提交的任务，不做任何通知</td>
<td>系统行为简单</td>
<td>任务丢失无感知，可能造成数据不一致</td>
<td>允许丢弃非关键任务的场景（如日志记录）</td>
</tr>
<tr>
<td><strong>DiscardOldestPolicy</strong></td>
<td>丢弃队列中最旧的任务（队头），然后尝试重新提交新任务</td>
<td>优先处理新任务</td>
<td>可能丢失重要旧任务</td>
<td>新任务比旧任务更重要的场景（如实时数据）</td>
</tr>
</tbody></table>
<p><strong>所有策略均在以下条件同时满足时触发</strong>：</p>
<ul>
<li>线程数达到 <code>maximumPoolSize</code></li>
<li>工作队列已满（对于有界队列）</li>
<li>仍有新任务提交</li>
</ul>
<p><strong>策略选择建议</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是否允许任务丢失？</span><br><span class="line">├─ 允许 → 选择 DiscardPolicy/DiscardOldestPolicy</span><br><span class="line">└─ 不允许 → 是否能接受降级？</span><br><span class="line">   ├─ 能 → 自定义策略（如持久化存储）</span><br><span class="line">   └─ 不能 → 选择 CallerRunsPolicy（影响调用方）</span><br></pre></td></tr></table></figure>

<p><strong>生产环境推荐组合</strong>：</p>
<ul>
<li><strong>严格系统</strong>：<code>AbortPolicy</code> + 告警监控</li>
<li><strong>弹性系统</strong>：<code>CallerRunsPolicy</code> + 熔断机制</li>
<li><strong>最终一致性系统</strong>：自定义策略（如写入 Redis 重试队列）</li>
</ul>
<p><strong>Spring 的增强策略</strong>：</p>
<p><code>ThreadPoolTaskExecutor</code> 额外支持：</p>
<ul>
<li>通过 <code>TaskRejectedException</code> 提供更详细的拒绝信息</li>
<li>与 <code>@Async</code> 注解配合时自动应用策略</li>
</ul>
<h3 id="【中等】Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？"><a href="#【中等】Java-线程池内部任务出异常后，如何知道是哪个线程出了异常？" class="headerlink" title="【中等】Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？"></a>【中等】Java 线程池内部任务出异常后，如何知道是哪个线程出了异常？</h3><p>在 Java 线程池中，当任务抛出异常时，默认情况下异常会被线程池”吞掉”，不会直接抛出给调用者。</p>
<ol>
<li>对于需要获取结果的异步任务，使用<code>submit()</code>和<code>Future</code>组合</li>
<li>对于不需要结果的批量任务，使用自定义的<code>ThreadFactory</code>或重写<code>afterExecute</code></li>
<li>在复杂系统中，考虑结合日志框架记录完整的异常堆栈和线程信息</li>
</ol>
<p>通过以上方法，你可以有效地追踪线程池中哪个线程执行的任务抛出了异常。</p>
<p>以下是几种方法来识别哪个线程出了异常：</p>
<p><strong>（1）使用 <code>Future.get()</code> 捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get(); <span class="comment">// 这里会抛出 ExecutionException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务抛出异常：&quot;</span> + e.getCause());</span><br><span class="line">    <span class="comment">// e.getCause() 获取原始异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）自定义 <code>ThreadFactory</code> 设置未捕获异常处理器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> r -&gt; &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + thread.getName() + <span class="string">&quot; 抛出异常：&quot;</span> + throwable);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>, factory);</span><br></pre></td></tr></table></figure>

<p><strong>（3）重写 <code>ThreadPoolExecutor</code> 的 <code>afterExecute</code> 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(..., ...) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterExecute(r, t);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行抛出异常：&quot;</span> + t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于通过 FutureTask 运行的任务，异常被封装在 Future 中</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Future&lt;?&gt;) r).get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Future 任务异常：&quot;</span> + e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）在任务内部捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 任务代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 抛出异常：&quot;</span> + e);</span><br><span class="line">        <span class="comment">// 记录线程信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="【中等】Java-线程池中-shutdown-与-shutdownNow-的区别是什么？"><a href="#【中等】Java-线程池中-shutdown-与-shutdownNow-的区别是什么？" class="headerlink" title="【中等】Java 线程池中 shutdown 与 shutdownNow 的区别是什么？"></a>【中等】Java 线程池中 shutdown 与 shutdownNow 的区别是什么？</h3><p><strong><code>shutdown</code> 不会立即终止线程池</strong>，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</p>
<ul>
<li>将线程池切换到 <code>SHUTDOWN</code> 状态；</li>
<li>并调用 <code>interruptIdleWorkers</code> 方法请求中断所有空闲的 worker；</li>
<li>最后调用 <code>tryTerminate</code> 尝试结束线程池。</li>
</ul>
<p><strong><code>shutdownNow</code> 立即终止线程池</strong>，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。与 <code>shutdown</code> 方法类似，不同的地方在于：</p>
<ul>
<li>设置状态为 <code>STOP</code>；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回。</li>
</ul>
<h3 id="【困难】Java-线程池参数在运行过程中能修改吗？如何修改？"><a href="#【困难】Java-线程池参数在运行过程中能修改吗？如何修改？" class="headerlink" title="【困难】Java 线程池参数在运行过程中能修改吗？如何修改？"></a>【困难】Java 线程池参数在运行过程中能修改吗？如何修改？</h3><ul>
<li><strong>可动态修改参数</strong>：核心线程数、最大线程数、空闲时间、拒绝策略</li>
<li><strong>不可动态修改</strong>：队列实现类、线程工厂</li>
<li><strong>Spring 增强</strong>：<code>ThreadPoolTaskExecutor</code>提供更友好的 API</li>
<li><strong>生产建议</strong>：<ul>
<li>配合监控系统实现自动扩缩容</li>
<li>修改时遵循先 max 后 core 的顺序</li>
<li>对队列容量修改要特别小心</li>
</ul>
</li>
</ul>
<p>::: info ThreadPoolExecutor 原生动态修改参数方法</p>
<p>:::</p>
<p>ThreadPoolExecutor 提供了以下核心参数的动态修改方法：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>修改方法</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>核心线程数</td>
<td><code>setCorePoolSize(int)</code></td>
<td>新值&gt;旧值时立即生效；新值&lt;旧时空闲线程会被逐渐回收</td>
</tr>
<tr>
<td>最大线程数</td>
<td><code>setMaximumPoolSize(int)</code></td>
<td>必须≥核心线程数；仅影响后续新增线程</td>
</tr>
<tr>
<td>空闲线程存活时间</td>
<td><code>setKeepAliveTime(long, TimeUnit)</code></td>
<td>对所有空闲的非核心线程生效</td>
</tr>
<tr>
<td>拒绝策略</td>
<td><code>setRejectedExecutionHandler()</code></td>
<td>立即生效，但已进入拒绝流程的任务不受影响</td>
</tr>
</tbody></table>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">2</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调整</span></span><br><span class="line">executor.setCorePoolSize(<span class="number">4</span>);  <span class="comment">// 核心线程数 2→4</span></span><br><span class="line">executor.setMaximumPoolSize(<span class="number">8</span>); <span class="comment">// 最大线程数 5→8</span></span><br><span class="line">executor.setKeepAliveTime(<span class="number">30</span>, TimeUnit.SECONDS); <span class="comment">// 60s→30s</span></span><br><span class="line">executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<p>::: info Spring 的 ThreadPoolTaskExecutor 增强</p>
<p>:::</p>
<p>Spring 的<code>ThreadPoolTaskExecutor</code>在原生基础上增加了更多动态能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(<span class="number">4</span>);</span><br><span class="line">    executor.setMaxPoolSize(<span class="number">8</span>);</span><br><span class="line">    executor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调整示例</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    taskExecutor.setCorePoolSize(<span class="number">6</span>);</span><br><span class="line">    taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">    taskExecutor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// Spring 会自动应用新配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::: info 动态调整队列容量</p>
<p>:::</p>
<p>队列容量的动态调整需要特殊处理，因为大多数 BlockingQueue 创建后容量固定：</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>使用自定义的可变容量队列</li>
<li>重建线程池（优雅迁移）</li>
</ol>
<p><strong>自定义队列示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizableCapacityLinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResizableCapacityLinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setCapacity</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现容量调整逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java 线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答</a></li>
</ul>
<p>开源项目：</p>
<ul>
<li>**<a target="_blank" rel="noopener" href="https://github.com/opengoofy/hippo4j">Hippo4j</a>**：异步线程池框架，支持线程池动态变更&amp;监控&amp;报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。</li>
<li>**<a target="_blank" rel="noopener" href="https://github.com/dromara/dynamic-tp">Dynamic TP</a>**：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li>
</ul>
</blockquote>
<h2 id="Java-并发同步工具"><a href="#Java-并发同步工具" class="headerlink" title="Java 并发同步工具"></a>Java 并发同步工具</h2><h3 id="【中等】CountDownLatch-的工作原理是什么？"><a href="#【中等】CountDownLatch-的工作原理是什么？" class="headerlink" title="【中等】CountDownLatch 的工作原理是什么？"></a>【中等】CountDownLatch 的工作原理是什么？</h3><p>CountDownLatch 通过计数器实现线程间的“等待-通知”机制，适用于分阶段任务同步，但不可重复使用。</p>
<p><strong>基本作用</strong></p>
<ul>
<li>允许一个或多个线程等待，直到其他线程完成一组操作后再继续执行。</li>
<li>典型场景：主线程等待多个子线程完成任务后再汇总结果。</li>
</ul>
<p><strong>核心机制</strong></p>
<ul>
<li><strong>计数器初始化</strong>：创建时指定初始计数值（如 <code>new CountDownLatch(3)</code>）。</li>
<li><strong>计数递减</strong>：子线程完成任务后调用 <code>countDown()</code>，计数器减 1（线程不会阻塞）。</li>
<li><strong>等待阻塞</strong>：主线程调用 <code>await()</code> 会阻塞，直到计数器归零（或超时）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CountDownLatch.png" alt="img"></p>
<p><strong>关键特性</strong></p>
<ul>
<li><strong>一次性</strong>：计数器归零后无法重置，需重新创建实例。</li>
<li><strong>非中断递减</strong>：<code>countDown()</code> 不受线程中断影响，但 <code>await()</code> 可被中断。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程完成任务后递减</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    doTask();</span><br><span class="line">    latch.countDown(); <span class="comment">// 计数器-1</span></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程等待所有子线程完成</span></span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;All tasks done!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="【中等】CyclicBarrier-的工作原理是什么？"><a href="#【中等】CyclicBarrier-的工作原理是什么？" class="headerlink" title="【中等】CyclicBarrier 的工作原理是什么？"></a>【中等】CyclicBarrier 的工作原理是什么？</h3><p><code>CyclicBarrier</code> 通过“线程互相等待”实现协同，适合需要<strong>多轮同步</strong>的场景，且具备更高的灵活性。</p>
<p><strong>核心作用</strong></p>
<ul>
<li>让<strong>一组线程互相等待</strong>，直到所有线程都到达某个屏障点（Barrier）后，再一起继续执行。</li>
<li>适用于<strong>分阶段并行任务</strong>（如多线程计算后合并结果）。</li>
</ul>
<p><strong>关键机制</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>屏障初始化</strong></td>
<td>创建时指定参与线程数 <code>N</code>（如 <code>new CyclicBarrier(3)</code>）及可选的<strong>回调任务</strong>（触发后执行）。</td>
</tr>
<tr>
<td><strong>线程等待</strong></td>
<td>每个线程调用 <code>await()</code> 时会被阻塞，直到**所有 <code>N</code> 个线程都调用 <code>await()</code>**。</td>
</tr>
<tr>
<td><strong>屏障突破</strong></td>
<td>当所有线程到达屏障点后：<br> 1. 执行回调任务（若设置）；<br> 2. 所有线程被唤醒，继续执行后续逻辑。</td>
</tr>
<tr>
<td><strong>重置能力</strong></td>
<td>屏障被突破后，<strong>自动重置</strong>，可重复使用（区别于 <code>CountDownLatch</code>）。</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CyclicBarrier.png" alt="img"></p>
<p><strong>主要特性</strong></p>
<ul>
<li><strong>可重复使用</strong>：一轮屏障突破后，自动重置计数器，支持下一轮同步。</li>
<li><strong>回调任务</strong>：通过构造函数传入 <code>Runnable</code>，在所有线程到达后由<strong>最后一个到达的线程</strong>执行。</li>
<li><strong>超时与中断</strong>：<code>await(timeout, unit)</code> 支持超时；线程在等待时若被中断，会抛出 <code>BrokenBarrierException</code>。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;All threads reached the barrier!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is working...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await(); <span class="comment">// 等待其他线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continues after barrier.&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比 CountDownLatch</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CyclicBarrier</strong></th>
<th><strong>CountDownLatch</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>重置能力</strong></td>
<td>自动重置，可重复使用</td>
<td>一次性，不可重置</td>
</tr>
<tr>
<td><strong>等待角色</strong></td>
<td>所有线程互相等待</td>
<td>主线程等待子线程</td>
</tr>
<tr>
<td><strong>计数方向</strong></td>
<td>递增（线程到达后计数）</td>
<td>递减（任务完成后计数）</td>
</tr>
<tr>
<td><strong>回调任务</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>典型应用场景</strong></p>
<ul>
<li><strong>多阶段并行计算</strong>：如 MapReduce 中，多个 Worker 完成局部计算后同步，再进入下一阶段。</li>
<li><strong>模拟压力测试</strong>：让所有测试线程同时开始请求。</li>
<li><strong>游戏同步</strong>：多个玩家加载资源完成后同时开始游戏。</li>
</ul>
<h3 id="【中等】Semaphore-的工作原理是什么？"><a href="#【中等】Semaphore-的工作原理是什么？" class="headerlink" title="【中等】Semaphore 的工作原理是什么？"></a>【中等】Semaphore 的工作原理是什么？</h3><p><strong><code>Semaphore</code> 译为信号量，是一种同步机制，用于控制多线程对共享资源的访问</strong>。</p>
<p>Semaphore 通过<strong>许可证机制</strong>灵活控制并发度，既可用于严格互斥（许可证&#x3D;1 时类似锁），也可用于资源池管理。与 <code>CyclicBarrier</code>&#x2F;<code>CountDownLatch</code> 不同，它关注的是<strong>资源的访问权限</strong>而非线程间的同步。</p>
<p><strong>核心作用</strong></p>
<ul>
<li><strong>控制并发访问资源的线程数量</strong>，通过“许可证”（permits）机制实现限流。</li>
<li>适用于：<ul>
<li>资源池管理（如数据库连接池）</li>
<li>限流（如接口每秒最大请求数）</li>
<li>互斥场景（类似锁，但更灵活）</li>
</ul>
</li>
</ul>
<p><strong>关键机制</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>许可证初始化</strong></td>
<td>创建时指定许可证数量（如 <code>new Semaphore(3)</code> 表示最多允许 3 个线程同时访问）。</td>
</tr>
<tr>
<td><strong>获取许可证</strong></td>
<td>线程调用 <code>acquire()</code>：<br> - 若有剩余许可证，立即获取并继续执行；<br> - 若无许可证，则阻塞等待。</td>
</tr>
<tr>
<td><strong>释放许可证</strong></td>
<td>线程调用 <code>release()</code>：返还许可证，唤醒等待线程。</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>可指定公平模式（<code>new Semaphore(3, true)</code>），避免线程饥饿。</td>
</tr>
</tbody></table>
<p><strong>主要特性</strong></p>
<ul>
<li><strong>动态调整</strong>：可通过 <code>release()</code> 增加许可证，或 <code>reducePermits()</code> 动态减少。</li>
<li><strong>非阻塞尝试</strong>：<code>tryAcquire()</code> 立即返回是否成功，支持超时（如 <code>tryAcquire(2, TimeUnit.SECONDS)</code>）。</li>
<li><strong>可中断</strong>：<code>acquire()</code> 可被其他线程中断（抛出 <code>InterruptedException</code>）。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 允许 3 个线程并发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可证</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 占用资源&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可证</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span><span class="number">-0</span> 占用资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span> 占用资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-2</span> 占用资源</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span> 释放资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-3</span> 占用资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span> 释放资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-4</span> 占用资源</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>

<p><strong>对比其他同步工具</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Semaphore</strong></th>
<th><strong>ReentrantLock</strong></th>
<th><strong>CountDownLatch</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心能力</strong></td>
<td>控制并发线程数</td>
<td>互斥锁</td>
<td>等待事件完成</td>
</tr>
<tr>
<td><strong>是否可重入</strong></td>
<td>是（但需手动释放）</td>
<td>是（可重复加锁）</td>
<td>不适用</td>
</tr>
<tr>
<td><strong>资源释放</strong></td>
<td>必须显式调用 <code>release()</code></td>
<td>必须显式解锁</td>
<td>自动递减</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>限流、资源池</td>
<td>临界区保护</td>
<td>主线程等待子线程</td>
</tr>
</tbody></table>
<p><strong>典型应用场景</strong></p>
<ul>
<li><strong>连接池管理</strong>：限制同时使用的数据库连接数。</li>
<li><strong>流量控制</strong>：限制每秒处理的请求数。</li>
<li><strong>生产者-消费者模型</strong>：通过信号量控制缓冲区大小。</li>
</ul>
<h2 id="Java-并发分工工具"><a href="#Java-并发分工工具" class="headerlink" title="Java 并发分工工具"></a>Java 并发分工工具</h2><h3 id="【中等】ForkJoinPool-的工作原理是什么？"><a href="#【中等】ForkJoinPool-的工作原理是什么？" class="headerlink" title="【中等】ForkJoinPool 的工作原理是什么？"></a>【中等】ForkJoinPool 的工作原理是什么？</h3><p><strong>ForkJoinPool 通过工作窃取机制高效处理分治任务，适合递归并行计算，核心是本地队列+LIFO 处理+FIFO 窃取。</strong></p>
<p><strong>设计目标</strong></p>
<ul>
<li><strong>高效执行分治任务</strong>：适用于<strong>递归分解</strong>的可并行计算（如归并排序、MapReduce）。</li>
<li><strong>工作窃取（Work-Stealing）</strong>：每个线程有自己的任务队列，空闲线程可从其他队列“窃取”任务，避免资源闲置。</li>
</ul>
<p><strong>核心组件</strong></p>
<ul>
<li><strong>工作线程（ForkJoinWorkerThread）</strong>：每个线程维护一个<strong>双端队列（Deque）</strong>，存放自己的任务。</li>
<li><strong>任务队列</strong>：<ul>
<li><strong>本地队列</strong>：LIFO（后进先出）处理自己生成的任务（<code>fork()</code>）。</li>
<li><strong>窃取队列</strong>：FIFO（先进先出）窃取其他线程的任务（公平性）。</li>
</ul>
</li>
<li><strong>任务类型（ForkJoinTask）</strong>：<code>RecursiveAction</code>（无返回值） &#x2F; <code>RecursiveTask</code>（有返回值）。</li>
</ul>
<p><strong>工作流程</strong></p>
<ol>
<li><strong>任务拆分（Fork）</strong>：调用 <code>fork()</code> 将子任务压入<strong>本地队列</strong>（LIFO）。</li>
<li><strong>任务执行（Join）</strong>：调用 <code>join()</code> 等待子任务结果，期间线程会<strong>优先处理本地任务</strong>。</li>
<li><strong>工作窃取（Stealing）</strong>：若线程无任务，从其他线程队列<strong>尾部窃取任务</strong>（FIFO，减少竞争）。</li>
</ol>
<p><strong>关键特性</strong></p>
<ul>
<li><strong>低竞争</strong>：线程优先处理本地任务，减少同步开销。</li>
<li><strong>负载均衡</strong>：空闲线程自动窃取任务，提高 CPU 利用率。</li>
<li><strong>递归优化</strong>：适合深度递归任务，避免线程阻塞。</li>
</ul>
<p><strong>与普通线程池对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ForkJoinPool</strong></th>
<th><strong>ThreadPoolExecutor</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>任务类型</strong></td>
<td>分治任务（递归拆分）</td>
<td>独立任务</td>
</tr>
<tr>
<td><strong>任务调度</strong></td>
<td>工作窃取（本地队列+窃取）</td>
<td>全局队列（可能竞争）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>CPU 密集型并行计算</td>
<td>IO 密集型或短任务</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>避免阻塞操作</strong>：不适合 IO 密集型任务（线程数有限，易阻塞）。</li>
<li><strong>任务粒度</strong>：过小的任务会增加调度开销。</li>
</ul>
<h3 id="【中等】CompleteFuture-的工作原理是什么？"><a href="#【中等】CompleteFuture-的工作原理是什么？" class="headerlink" title="【中等】CompleteFuture 的工作原理是什么？"></a>【中等】CompleteFuture 的工作原理是什么？</h3><p><strong>CompletableFuture 通过回调链和 Completion 阶段机制实现灵活的异步编程，支持任务编排、结果转换和异常传播，底层采用无锁设计优化性能。</strong></p>
<p><strong>核心设计</strong></p>
<ul>
<li><strong>异步编程模型</strong>：基于 Future 的增强实现，支持显式完成（手动设置结果）</li>
<li><strong>回调驱动</strong>：通过链式调用实现异步任务编排</li>
<li><strong>双阶段执行</strong>：<ul>
<li>异步计算阶段（任务执行）</li>
<li>完成阶段（结果处理）</li>
</ul>
</li>
</ul>
<p><strong>关键组件</strong></p>
<ul>
<li><strong>CompletionStage 接口</strong>：定义 50+种组合操作（thenApply&#x2F;thenAccept&#x2F;thenRun 等）</li>
<li><strong>依赖关系堆栈</strong>：维护任务依赖链（类似链表结构）</li>
<li><strong>执行器支持</strong>：可指定自定义线程池（默认使用 ForkJoinPool.commonPool）</li>
</ul>
<p><strong>工作流程</strong></p>
<ol>
<li><p><strong>任务创建</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;task&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果转换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.thenApply(s -&gt; s + <span class="string">&quot; result&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>最终处理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.thenAccept(System.out::println)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>核心机制</strong></p>
<ul>
<li><strong>回调链（Completion 链）</strong>：<ul>
<li>每个操作生成新的 Completion 节点</li>
<li>节点间形成单向链表</li>
</ul>
</li>
<li><strong>触发机制</strong>：<ul>
<li>前置任务完成时触发后续操作</li>
<li>支持同步&#x2F;异步执行切换</li>
</ul>
</li>
<li><strong>结果传递</strong>：<ul>
<li>异常传播（exceptionally 处理）</li>
<li>结果转换（thenApply）</li>
</ul>
</li>
</ul>
<p><strong>线程模型</strong></p>
<ul>
<li><strong>默认线程池</strong>：ForkJoinPool.commonPool()</li>
<li><strong>可控性</strong>：<ul>
<li>支持显式指定线程池</li>
<li>可强制指定同步执行（thenApply vs thenApplyAsync）</li>
</ul>
</li>
</ul>
<p><strong>特殊功能</strong></p>
<ul>
<li><strong>组合操作</strong>：<ul>
<li>allOf&#x2F;anyOf（多任务协调）</li>
<li>thenCombine（双源合并）</li>
</ul>
</li>
<li><strong>完成控制</strong>：<ul>
<li>complete()&#x2F;completeExceptionally()（手动完成）</li>
<li>obtrudeValue（强制覆盖结果）</li>
</ul>
</li>
</ul>
<p><strong>性能特点</strong></p>
<ul>
<li><strong>无锁设计</strong>：基于 CAS 操作</li>
<li><strong>零等待</strong>：回调立即触发（无轮询）</li>
<li><strong>最小化线程切换</strong>：优化执行路径</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>线程泄漏风险</strong>：未指定线程池时使用默认池</li>
<li><strong>回调地狱</strong>：过度链式调用降低可读性</li>
<li><strong>异常处理</strong>：必须显式处理异常</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>服务调用编排</li>
<li>异步流水线处理</li>
<li>多源结果聚合</li>
</ul>
<h3 id="【中等】Timer-的工作原理是什么？"><a href="#【中等】Timer-的工作原理是什么？" class="headerlink" title="【中等】Timer 的工作原理是什么？"></a>【中等】Timer 的工作原理是什么？</h3><p><strong><code>Timer</code> 通过单线程+优先级队列调度任务，简单但不可靠；生产环境建议用线程池替代。</strong></p>
<p><strong>基本组成</strong></p>
<ul>
<li>**<code>Timer</code>**：任务调度器，管理任务队列和后台线程。</li>
<li>**<code>TimerTask</code>**：需实现 <code>run()</code>，定义要执行的任务。</li>
</ul>
<p><strong>核心机制</strong></p>
<ul>
<li><strong>单线程调度</strong>：<ul>
<li>所有任务由<strong>单个后台线程</strong>（<code>TimerThread</code>）顺序执行。</li>
<li>任务队列按<strong>执行时间排序</strong>（优先级队列，最小堆）。</li>
</ul>
</li>
<li><strong>任务触发流程</strong>：<ol>
<li>调用 <code>schedule()</code> 将任务加入队列。</li>
<li>线程循环检查队首任务，通过 <code>wait(timeout)</code> 休眠至执行时间。</li>
<li>执行 <code>run()</code> 后，根据调度类型计算下次执行时间：<ul>
<li><strong>固定延迟（<code>schedule</code>）</strong>：基于<strong>实际结束时间</strong> + 周期。</li>
<li><strong>固定速率（<code>scheduleAtFixedRate</code>）</strong>：基于<strong>计划开始时间</strong> + 周期（可能追赶延迟）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>关键问题</strong></p>
<ul>
<li><strong>单线程阻塞</strong>：一个任务执行过长或崩溃会导致后续任务延迟&#x2F;终止。</li>
<li><strong>异常影响</strong>：任务抛出未捕获异常时，整个 <code>Timer</code> 线程停止。</li>
<li><strong>资源释放</strong>：必须调用 <code>cancel()</code> 避免内存泄漏。</li>
</ul>
<p><strong>替代方案</strong></p>
<p><strong><code>ScheduledThreadPoolExecutor</code></strong> 更优：支持多线程、异常隔离、灵活调度。</p>
<h3 id="【困难】时间轮（Time-Wheel）的工作原理是什么？"><a href="#【困难】时间轮（Time-Wheel）的工作原理是什么？" class="headerlink" title="【困难】时间轮（Time Wheel）的工作原理是什么？"></a>【困难】时间轮（Time Wheel）的工作原理是什么？</h3><p>JDK 内置的三种实现定时器的方式，实现思路都非常相似，都离不开<strong>任务</strong>、<strong>任务管理</strong>、<strong>任务调度</strong>三个角色。三种定时器新增和取消任务的时间复杂度都是 <code>O(logn)</code>，面对海量任务插入和删除的场景，这三种定时器都会遇到比较严重的性能瓶颈。<strong>对于性能要求较高的场景，一般都会采用时间轮算法来实现定时器</strong>。</p>
<p><strong>时间轮通过环形数组分片管理定时任务，以 O(1) 时间复杂度实现高效调度，多级设计兼顾长短延迟任务，是高性能定时器的核心实现方案。</strong></p>
<p>时间轮（Timing Wheel）是 George Varghese 和 Tony Lauck 在 1996 年的论文 <a target="_blank" rel="noopener" href="https://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a> 实现的，它在 Linux 内核中使用广泛，是 Linux 内核定时器的实现方法和基础之一。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/assets/CgpVE1_okKiAGl0gAAMLshtTq-M933.png" alt="图片 22.png"></p>
<p><strong>核心设计思想</strong></p>
<ul>
<li><strong>环形数组结构</strong>：采用环形缓冲区（类似时钟表盘）分层管理定时任务</li>
<li><strong>时间分片</strong>：将时间划分为固定间隔的槽（tick），每个槽对应一个任务链表</li>
<li><strong>层级扩展</strong>：支持多级时间轮（小时&#x2F;分钟&#x2F;秒）处理不同精度的时间任务</li>
</ul>
<p><strong>核心组件</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>环形数组</strong></td>
<td>存储各时间槽的任务（如数组长度 60&#x3D;1 分钟精度，每个槽代表 1 秒）</td>
</tr>
<tr>
<td><strong>任务链表</strong></td>
<td>每个槽挂载到期时间相同的任务节点</td>
</tr>
<tr>
<td><strong>当前指针</strong></td>
<td>指向当前时间槽，随 tick 前进</td>
</tr>
<tr>
<td><strong>层级指针</strong></td>
<td>多级时间轮间的任务传递（如秒轮→分钟轮）</td>
</tr>
</tbody></table>
<p><strong>工作流程</strong></p>
<ol>
<li><p><strong>任务添加</strong></p>
<ul>
<li>计算目标槽位：<code>槽位 = （当前指针 + 延迟时间/tick) % 轮盘大小</code></li>
<li>相同槽位的任务以链表形式存储</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：tick=1s，轮盘大小=60，添加 10 秒后执行的任务</span></span><br><span class="line">slot = (current_pos + <span class="number">10</span>) % <span class="number">60</span>  <span class="comment"># 存入第 10 个槽</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间推进（tick）</strong></p>
<ul>
<li>每次 tick 移动当前指针到下一槽位</li>
<li>执行该槽位所有任务</li>
<li><strong>多级时间轮</strong>：当低级轮转完一圈，高级轮降级一个任务到低级轮</li>
</ul>
</li>
<li><p><strong>任务降级（多级时间轮）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当秒级时间轮（60 槽）转完一圈：</span><br><span class="line">将分钟轮当前槽的任务重新映射到秒轮</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键优势</strong></p>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>O(1) 时间复杂度</strong></td>
<td>添加&#x2F;删除任务仅需计算槽位，与任务数量无关</td>
</tr>
<tr>
<td><strong>低内存开销</strong></td>
<td>仅存储未到期任务，空槽不占资源</td>
</tr>
<tr>
<td><strong>适合高频调度</strong></td>
<td>Kafka&#x2F;Netty 等框架用于心跳检测、超时控制等场景</td>
</tr>
</tbody></table>
<p><strong>单级 vs 多级时间轮</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>精度</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单级</strong></td>
<td>高精度</td>
<td>轮盘大（内存占用高）</td>
<td>短延迟任务（&lt;1 分钟）</td>
</tr>
<tr>
<td><strong>多级</strong></td>
<td>分级精度</td>
<td>任务降级开销</td>
<td>长短延迟混合任务</td>
</tr>
</tbody></table>
<p><strong>实际应用</strong></p>
<ul>
<li><strong>Kafka</strong>：延迟消息处理（<code>DelayedOperationPurgatory</code>）</li>
<li><strong>Netty</strong>：连接超时控制（<code>HashedWheelTimer</code>）</li>
<li><strong>Linux 内核</strong>：定时器管理</li>
</ul>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>添加复杂度</th>
<th>触发复杂度</th>
<th>内存占用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时间轮</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>优先级队列</strong></td>
<td>O(log n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>轮询检测</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>HashedWheelTimer 是 Netty 中时间轮算法的实现类。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p><strong>经典问题</strong></p>
<p>（1）什么是生产者消费者模式</p>
<p>（2）Java 中如何实现生产者消费者模式</p>
<p><strong>知识点</strong></p>
<p>（1）什么是生产者消费者模式</p>
<p>生产者消费者模式是一个经典的并发设计模式。在这个模型中，有一个共享缓冲区；有两个线程，一个负责向缓冲区推数据，另一个负责向缓冲区拉数据。要让两个线程更好的配合，就需要一个阻塞队列作为媒介来进行调度，由此便诞生了生产者消费者模式。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/assets/CgotOV3OJ3iAGcaiAAFrcv5xk9U160.png"></p>
<p>（2）Java 中如何实现生产者消费者模式</p>
<p>在 Java 中，实现生产者消费者模式有 3 种具有代表性的方式：</p>
<ul>
<li>基于 BlockingQueue 实现</li>
<li>基于 Condition 实现</li>
<li>基于 wait&#x2F;notify 实现</li>
</ul>
<p>【示例】基于 BlockingQueue 实现生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(queue), <span class="string">&quot;producer1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(queue), <span class="string">&quot;producer2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(queue), <span class="string">&quot;consumer1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(queue), <span class="string">&quot;consumer2&quot;</span>);</span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Object&gt; queue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产 1 条数据，已生产数据量：&quot;</span> + ++count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Object&gt; queue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费 1 条数据，已消费数据量：&quot;</span> + ++count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】基于 Condition 实现生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        MyBlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产 1 条数据，总数据量：&quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费 1 条数据，总数据量：&quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.max = size;</span><br><span class="line">            queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == max) &#123;</span><br><span class="line">                    notFull.await();</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(o);</span><br><span class="line">                notEmpty.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    notEmpty.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                notFull.signalAll();</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】基于 wait&#x2F;notify 实现生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        MyBlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产 1 条数据，总数据量：&quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费 1 条数据，总数据量：&quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">            max = size;</span><br><span class="line">            queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == max) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(o);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            notifyAll();</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/696ebf40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/696ebf40/" class="post-title-link" itemprop="url">Java 并发面试二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-23 07:21:03" itemprop="dateCreated datePublished" datetime="2024-07-23T07:21:03+08:00">2024-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发面试二"><a href="#Java-并发面试二" class="headerlink" title="Java 并发面试二"></a>Java 并发面试二</h1><h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><h3 id="【中等】Java-中，根据不同维度划分，锁有哪些分类？"><a href="#【中等】Java-中，根据不同维度划分，锁有哪些分类？" class="headerlink" title="【中等】Java 中，根据不同维度划分，锁有哪些分类？"></a>【中等】Java 中，根据不同维度划分，锁有哪些分类？</h3><p>在 Java 中，锁可以按照 <strong>多个维度</strong> 进行分类，不同维度的锁适用于不同的并发场景。以下是详细的分类：</p>
<p><strong>按锁的公平性划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>公平锁</strong></td>
<td>严格按照线程请求顺序（FIFO）分配锁，避免线程饥饿，但性能较低。</td>
<td><code>ReentrantLock(true)</code></td>
</tr>
<tr>
<td><strong>非公平锁</strong></td>
<td>允许插队，新请求的线程可能直接抢到锁，吞吐量高，但可能导致线程饥饿（默认方式）。</td>
<td><code>ReentrantLock(false)</code>、<code>synchronized</code></td>
</tr>
</tbody></table>
<p><strong>按锁的获取方式划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>悲观锁</strong></td>
<td>认为并发冲突必然发生，先加锁再操作（阻塞其他线程）。</td>
<td><code>synchronized</code>、<code>ReentrantLock</code></td>
</tr>
<tr>
<td><strong>乐观锁</strong></td>
<td>认为并发冲突较少，不加锁，更新时检查（CAS 或版本号机制）。</td>
<td><code>AtomicInteger</code>、<code>StampedLock</code></td>
</tr>
</tbody></table>
<p><strong>按锁的可重入性划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>可重入锁</strong></td>
<td>同一线程可多次获取同一把锁（避免死锁）。</td>
<td><code>ReentrantLock</code>、<code>synchronized</code></td>
</tr>
<tr>
<td><strong>不可重入锁</strong></td>
<td>同一线程重复获取同一把锁会导致死锁（Java 无原生实现，需自定义）。</td>
<td>无（需自行实现）</td>
</tr>
</tbody></table>
<p><strong>按锁的共享性划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>独占锁（排他锁）</strong></td>
<td>同一时间只有一个线程能持有锁（如 <code>synchronized</code>、<code>ReentrantLock</code>）。</td>
<td><code>synchronized</code>、<code>ReentrantLock</code></td>
</tr>
<tr>
<td><strong>共享锁</strong></td>
<td>允许多个线程同时读取，但写入时独占（如 <code>ReadWriteLock</code>）。</td>
<td><code>ReentrantReadWriteLock</code></td>
</tr>
</tbody></table>
<p><strong>按锁的阻塞方式划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>阻塞锁</strong></td>
<td>获取不到锁时，线程进入阻塞状态（如 <code>synchronized</code>）。</td>
<td><code>synchronized</code>、<code>ReentrantLock</code></td>
</tr>
<tr>
<td><strong>自旋锁</strong></td>
<td>获取不到锁时，线程循环尝试（避免线程切换，但消耗 CPU）。</td>
<td><code>AtomicInteger</code>（CAS 自旋）</td>
</tr>
<tr>
<td><strong>适应性自旋锁</strong></td>
<td>JVM 自动优化自旋次数（如 <code>synchronized</code> 在 JDK 6+ 的优化）。</td>
<td>JVM 内部优化</td>
</tr>
</tbody></table>
<p><strong>按锁的优化策略划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>偏向锁</strong></td>
<td>单线程访问时无同步开销（JDK 6+ 对 <code>synchronized</code> 的优化）。</td>
<td>JVM 自动优化（<code>synchronized</code>）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>多线程无竞争时，使用 CAS 代替阻塞（JDK 6+ 优化）。</td>
<td>JVM 自动优化（<code>synchronized</code>）</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>真正的互斥锁，涉及 OS 线程阻塞（如 <code>synchronized</code> 竞争激烈时）。</td>
<td>JVM 自动升级（<code>synchronized</code>）</td>
</tr>
</tbody></table>
<p><strong>按锁的实现方式划分</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>实现类&#x2F;关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内置锁（JVM 锁）</strong></td>
<td>由 JVM 实现（如 <code>synchronized</code>）。</td>
<td><code>synchronized</code></td>
</tr>
<tr>
<td><strong>显式锁</strong></td>
<td>由 Java API 提供（如 <code>ReentrantLock</code>）。</td>
<td><code>ReentrantLock</code>、<code>ReadWriteLock</code></td>
</tr>
<tr>
<td><strong>分布式锁</strong></td>
<td>跨 JVM 的锁（如 Redis、ZooKeeper 实现）。</td>
<td><code>Redisson</code>、<code>Curator</code></td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>分类维度</strong></th>
<th><strong>锁类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>公平性</strong></td>
<td>公平锁、非公平锁</td>
</tr>
<tr>
<td><strong>获取方式</strong></td>
<td>悲观锁、乐观锁</td>
</tr>
<tr>
<td><strong>可重入性</strong></td>
<td>可重入锁、不可重入锁</td>
</tr>
<tr>
<td><strong>共享性</strong></td>
<td>独占锁、共享锁</td>
</tr>
<tr>
<td><strong>阻塞方式</strong></td>
<td>阻塞锁、自旋锁、适应性自旋锁</td>
</tr>
<tr>
<td><strong>优化策略</strong></td>
<td>偏向锁、轻量级锁、重量级锁</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>内置锁（<code>synchronized</code>）、显式锁（<code>ReentrantLock</code>）、分布式锁（<code>Redisson</code>）</td>
</tr>
</tbody></table>
<p><strong>选择合适的锁取决于：</strong></p>
<ul>
<li><strong>并发竞争程度</strong>（高竞争→悲观锁，低竞争→乐观锁）</li>
<li><strong>任务执行时间</strong>（长任务→公平锁，短任务→非公平锁）</li>
<li><strong>读写比例</strong>（读多→共享锁，写多→独占锁）</li>
<li><strong>是否需要跨 JVM</strong>（是→分布式锁）</li>
</ul>
<p>这些分类帮助开发者根据业务场景选择最优的锁策略，平衡 <strong>性能、公平性、一致性</strong>。</p>
<h3 id="【中等】悲观锁和乐观锁有什么区别？"><a href="#【中等】悲观锁和乐观锁有什么区别？" class="headerlink" title="【中等】悲观锁和乐观锁有什么区别？"></a>【中等】悲观锁和乐观锁有什么区别？</h3><p>以下是悲观锁与乐观锁的详细对比：</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>悲观锁</strong></th>
<th><strong>乐观锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td>假定并发冲突必然发生，先加锁再访问数据</td>
<td>假定并发冲突较少，先操作再检测冲突</td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td>显式加锁（阻塞其他线程）</td>
<td>无锁机制（依赖 CAS 或版本号控制）</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td><code>synchronized</code>、<code>ReentrantLock</code>、数据库<code>SELECT FOR UPDATE</code></td>
<td><code>Atomic</code>类（CAS）、版本号机制、数据库乐观锁（如 MVCC）</td>
</tr>
<tr>
<td><strong>线程阻塞</strong></td>
<td>会阻塞竞争线程（线程挂起）</td>
<td>不阻塞线程，但可能自旋重试或失败</td>
</tr>
<tr>
<td><strong>数据一致性</strong></td>
<td>强一致性（独占访问）</td>
<td>最终一致性（可能需重试）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 写操作频繁<br>- 临界区代码执行时间长<br>- 强一致性要求高</td>
<td>- 读多写少<br>- 短平快操作<br>- 高吞吐量需求</td>
</tr>
<tr>
<td><strong>性能特点</strong></td>
<td>- 高竞争时性能下降明显（线程切换开销）<br>- 低竞争时仍有固定锁开销</td>
<td>- 低竞争时性能极佳（无阻塞）<br>- 高竞争时 CPU 自旋浪费</td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>通过锁排队避免冲突</td>
<td>通过重试或放弃处理冲突</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>- 银行转账<br>- 订单支付<br>- 数据库行级锁</td>
<td>- 库存扣减<br>- 计数器<br>- 点赞系统</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>✅ 强一致性<br>❌ 吞吐量低、死锁风险</td>
<td>✅ 高并发性能好<br>❌ 实现复杂、可能 ABA 问题</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>：</p>
<ul>
<li><strong>悲观锁</strong>适合”宁可排队等，不能出错”的场景（如金融交易）。</li>
<li><strong>乐观锁</strong>适合”宁可重试，不要阻塞”的场景（如电商库存）。</li>
</ul>
<h3 id="【中等】公平锁和非公平锁有什么区别？"><a href="#【中等】公平锁和非公平锁有什么区别？" class="headerlink" title="【中等】公平锁和非公平锁有什么区别？"></a>【中等】公平锁和非公平锁有什么区别？</h3><p><strong>Java 中公平锁和非公平锁的对比</strong>：</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>公平锁 (Fair Lock)</strong></th>
<th><strong>非公平锁 (Nonfair Lock)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁获取顺序</strong></td>
<td>严格按照线程请求顺序（FIFO）分配锁</td>
<td>允许插队，新请求的线程可能直接抢到锁</td>
</tr>
<tr>
<td><strong>性能表现</strong></td>
<td>吞吐量较低（上下文切换频繁）</td>
<td>吞吐量较高（减少线程切换，但可能线程饥饿）</td>
</tr>
<tr>
<td><strong>响应时间</strong></td>
<td>等待时间稳定（适合长任务）</td>
<td>短任务可能更快获取锁（适合高并发短任务）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 需要严格公平性<br>- 线程执行时间差异大（避免饥饿）</td>
<td>- 高并发短任务<br>- 追求吞吐量</td>
</tr>
<tr>
<td><strong>锁实现类</strong></td>
<td><code>ReentrantLock(true)</code></td>
<td><code>ReentrantLock(false)</code>（默认）</td>
</tr>
<tr>
<td><strong>实现</strong></td>
<td>依赖 AQS 维护等待线程，先到先得</td>
<td>先尝试 CAS 抢锁，失败后进入 AQS 队列</td>
</tr>
<tr>
<td><strong>线程饥饿</strong></td>
<td>不会发生</td>
<td>可能发生（高并发时某些线程长期无法获取锁）</td>
</tr>
<tr>
<td><strong>操作系统调度影响</strong></td>
<td>依赖系统线程调度，可能因优先级反转影响公平性</td>
<td>更依赖 JVM 的锁优化策略</td>
</tr>
<tr>
<td><strong>锁重入性</strong></td>
<td>支持（与公平性无关）</td>
<td>支持（与公平性无关）</td>
</tr>
<tr>
<td><strong>适用并发模型</strong></td>
<td>适合任务执行时间不均衡的场景</td>
<td>适合任务执行时间短的场景</td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li><p><strong>选公平锁</strong>：</p>
<ul>
<li>需要严格顺序执行（如订单处理）</li>
<li>避免低优先级线程饥饿</li>
<li>线程任务执行时间差异大</li>
</ul>
</li>
<li><p><strong>选非公平锁</strong>：</p>
<ul>
<li>追求高吞吐量（如秒杀系统）</li>
<li>任务执行时间短且均匀</li>
<li>能接受偶尔的线程饥饿</li>
</ul>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>默认行为</strong>：<code>ReentrantLock</code> 和 <code>synchronized</code> 默认都是<strong>非公平锁</strong>（因为性能更好）。</li>
<li><strong>性能差异</strong>：非公平锁在高并发下吞吐量可提升 **10%~30%**，但可能增加延迟方差。</li>
<li><strong>synchronized 的公平性</strong>：Java 的 <code>synchronized</code> <strong>不支持公平锁</strong>，仅 <code>ReentrantLock</code> 可配置。</li>
</ul>
<h3 id="【中等】synchronized-和-ReentrantLock-有什么区别？"><a href="#【中等】synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="【中等】synchronized 和 ReentrantLock 有什么区别？"></a>【中等】synchronized 和 ReentrantLock 有什么区别？</h3><p>使用差异：</p>
<p>::: code-tabs#synchronized 和 ReentrantLock 使用差异</p>
<p>@tab synchronized 使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2. 用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3. 用于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 4. 可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab ReentrantLock 使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> <span class="keyword">throw</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 1. 初始化选择公平锁、非公平锁</span></span><br><span class="line">	<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 2. 可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3. 支持多种加锁方式，比较灵活；具有可重入特性</span></span><br><span class="line">			<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4. 手动释放锁</span></span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<p>以下是 <strong><code>synchronized</code></strong> 和 <strong><code>ReentrantLock</code></strong> 的详细对比表格，涵盖 <strong>锁机制、功能、性能、使用场景</strong> 等核心维度：</p>
<hr>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong><code>synchronized</code></strong></th>
<th><strong><code>ReentrantLock</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁类型</strong></td>
<td>JVM 内置关键字（隐式锁）</td>
<td>JDK 提供的类（显式锁）</td>
</tr>
<tr>
<td><strong>加锁解锁方式</strong></td>
<td>自动加锁&#x2F;释放锁（进入同步代码块加锁，退出时释放）</td>
<td>需手动调用 <code>lock()</code> 和 <code>unlock()</code>（必须配合 <code>try-finally</code> 使用）</td>
</tr>
<tr>
<td><strong>是否可重入</strong></td>
<td>支持（同一线程可重复获取）</td>
<td>支持（同一线程可重复获取）</td>
</tr>
<tr>
<td><strong>是否支持公平</strong></td>
<td>仅支持非公平锁</td>
<td>可配置公平锁或非公平锁（构造函数传参 <code>true/false</code>）</td>
</tr>
<tr>
<td><strong>是否可中断</strong></td>
<td>不支持中断</td>
<td>支持 <code>lockInterruptibly()</code>，可响应中断</td>
</tr>
<tr>
<td><strong>是否支持超时</strong></td>
<td>不支持超时</td>
<td>支持 <code>tryLock(timeout, unit)</code>，可设置超时时间</td>
</tr>
<tr>
<td><strong>是否支持多条件</strong></td>
<td>通过 <code>wait()</code>&#x2F;<code>notify()</code> 实现，单一等待队列</td>
<td>支持多个 <code>Condition</code>，可精确控制线程唤醒（如 <code>await()</code>&#x2F;<code>signal()</code>）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>JDK 6+ 优化后（偏向锁→轻量级锁→重量级锁）性能接近 <code>ReentrantLock</code></td>
<td>在高竞争场景下性能略优（减少上下文切换）</td>
</tr>
<tr>
<td><strong>死锁检测</strong></td>
<td>无内置死锁检测</td>
<td>可通过 <code>tryLock</code> 避免死锁</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单同步场景（如单方法同步）</td>
<td>复杂同步需求（如公平锁、可中断锁、超时锁）</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>JVM 通过 <code>monitorenter</code>&#x2F;<code>monitorexit</code> 字节码实现</td>
<td>基于 <code>AbstractQueuedSynchronizer (AQS)</code> 实现</td>
</tr>
</tbody></table>
<p><strong>关键区别总结</strong></p>
<ul>
<li><p><strong>灵活性</strong></p>
<ul>
<li><code>ReentrantLock</code> 更强大：支持公平锁、可中断、超时、多条件变量。</li>
<li><code>synchronized</code> 更简单：自动管理锁，适合基础同步需求。</li>
</ul>
</li>
<li><p><strong>性能差异</strong>：JDK 6 后两者性能接近，但 <code>ReentrantLock</code> 在高竞争场景仍略有优势。</p>
</li>
<li><p><strong>使用选择建议</strong></p>
<ul>
<li>**选择 <code>synchronized</code>**：<ul>
<li>需要简单的代码块同步。</li>
<li>不需要高级功能（如超时、公平锁）。</li>
</ul>
</li>
<li>**选择 <code>ReentrantLock</code>**：<ul>
<li>需要精细控制（如公平性、可中断）。</li>
<li>需要避免死锁（<code>tryLock</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li><code>ReentrantLock</code> <strong>必须手动释放锁</strong>，否则会导致死锁！</li>
<li><code>synchronized</code> 是 Java 并发的基础，而 <code>ReentrantLock</code> 是它的增强扩展。</li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong><code>synchronized</code> 适用场景</strong>：单例模式的双重检查锁、简单的线程安全计数器。</li>
<li><strong><code>ReentrantLock</code> 适用场景</strong>：<ul>
<li>需要公平性的任务队列（如订单处理）。</li>
<li>需要超时控制的资源争用（如避免死锁）。</li>
<li>复杂的多条件线程协调（如生产者-消费者模型）。</li>
</ul>
</li>
</ul>
<h3 id="【困难】ReentrantLock-的实现原理是什么？"><a href="#【困难】ReentrantLock-的实现原理是什么？" class="headerlink" title="【困难】ReentrantLock 的实现原理是什么？"></a>【困难】ReentrantLock 的实现原理是什么？</h3><p><strong>ReentrantLock 基于 AQS（AbstractQueuedSynchronizer）实现</strong>：</p>
<ul>
<li><strong>核心依赖</strong>：<code>ReentrantLock</code> 通过内部类 <code>Sync</code>（继承 <code>AQS</code>）实现锁机制。</li>
<li><strong>AQS 作用</strong>：提供线程阻塞&#x2F;唤醒的队列管理（CLH 变体）和状态（<code>state</code>）的原子操作。</li>
</ul>
<p><strong>锁状态（state）管理</strong></p>
<ul>
<li><strong><code>state</code> 字段</strong>：<ul>
<li><code>=0</code>：锁未被占用。</li>
<li><code>&gt;0</code>：锁被占用，数值表示重入次数（可重入性）。</li>
</ul>
</li>
<li><strong>修改方式</strong>：通过 <code>CAS</code>（Compare-And-Swap）保证原子性。</li>
</ul>
<p><strong>获取锁（公平 &#x2F; 非公平）</strong></p>
<ul>
<li><strong>公平锁</strong>（<code>FairSync</code>）：严格按照 FIFO 顺序获取锁（先检查队列是否有等待线程）。<ul>
<li>先检查是否有前驱节点（队列中有无等待线程），有则排队。</li>
<li>无则尝试 CAS 获取锁。</li>
</ul>
</li>
<li><strong>非公平锁</strong>（<code>NonfairSync</code>，默认）：新线程直接尝试 CAS 抢锁（可能插队），失败才进入队列。<ul>
<li>直接尝试 CAS 修改 <code>state</code>（抢锁）。</li>
<li>失败后调用 <code>AQS.acquire()</code> 进入队列等待。</li>
</ul>
</li>
</ul>
<p><strong>释放锁</strong></p>
<ol>
<li>减少 <code>state</code> 值（重入次数减 1）。</li>
<li>若 <code>state=0</code>，唤醒队列中的下一个线程（通过 <code>LockSupport.unpark()</code>）。</li>
</ol>
<p><strong>可重入性</strong></p>
<ul>
<li>记录当前持有锁的线程（<code>exclusiveOwnerThread</code>）。</li>
<li>同一线程重复获取锁时，<code>state</code> 递增（无需重新排队）。</li>
</ul>
<p><strong>关键方法</strong></p>
<ul>
<li>**<code>tryLock()</code>**：非阻塞尝试获取锁（直接 CAS）。</li>
<li>**<code>lockInterruptibly()</code>**：支持中断的锁获取。</li>
<li>**<code>Condition</code>**：基于 <code>AQS</code> 实现多个等待队列（如 <code>await()</code>&#x2F;<code>signal()</code>）。</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li><strong>非公平锁</strong>：减少线程切换，提高吞吐量（但可能饥饿）。</li>
<li><strong>自旋优化</strong>：短暂自旋尝试获取锁，避免立即入队。</li>
</ul>
<p><strong>总结</strong></p>
<p><code>ReentrantLock</code> 的核心是通过 <strong>AQS 队列 + CAS 操作</strong> 实现：</p>
<ul>
<li><strong>锁竞争</strong>：通过 <code>state</code> 和 CLH 队列管理线程阻塞&#x2F;唤醒。</li>
<li><strong>灵活性</strong>：支持公平性、可中断、超时等高级功能。</li>
<li><strong>可重入</strong>：记录持有线程和重入次数。</li>
</ul>
<p>适用于需要精细控制锁行为的场景（如公平性、条件变量）。</p>
<h3 id="【困难】AQS-的实现原理是什么？"><a href="#【困难】AQS-的实现原理是什么？" class="headerlink" title="【困难】AQS 的实现原理是什么？"></a>【困难】AQS 的实现原理是什么？</h3><p>AQS（<strong>AbstractQueuedSynchronizer</strong>）是 Java 并发包（<code>java.util.concurrent.locks</code>）的核心框架，用于构建锁（如 <code>ReentrantLock</code>）和同步器（如 <code>CountDownLatch</code>、<code>Semaphore</code>）。它的核心思想是 <strong>CLH 队列 + CAS + 状态管理</strong>，提供了一种高效、灵活的同步机制。</p>
<p><strong>关键属性</strong></p>
<ul>
<li><strong>状态变量（state）</strong>：一个 <code>volatile</code> 整型变量，用于表示同步状态。不同的同步组件对 <code>state</code> 有不同的解读，例如在 <code>ReentrantLock</code> 里，<code>state</code> 为 0 表示锁未被持有，大于 0 表示锁已被持有，且重入次数就是 <code>state</code> 的值。</li>
<li><strong>等待队列（head 和 tail）</strong>：指向 FIFO 队列的头尾节点。队列中的每个节点都代表一个等待获取同步状态的线程。每个 <code>Node</code> 包含以下重要属性：<ul>
<li>**<code>thread</code>**：指向等待获取同步状态的线程。</li>
<li>**<code>prev</code> 和 <code>next</code>**：分别指向前一个节点和后一个节点，从而形成双向链表。</li>
<li>**<code>waitStatus</code>**：表示节点的等待状态，常见的状态有：<ul>
<li><code>CANCELLED</code>（1）：表示该节点对应的线程已取消等待。</li>
<li><code>SIGNAL</code>（-1）：表示该节点的后继节点需要被唤醒。</li>
<li><code>CONDITION</code>（-2）：表示该节点处于条件队列中。</li>
<li><code>PROPAGATE</code>（-3）：用于共享模式下，表明状态需要向后传播。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>同步模式</strong></p>
<p>AQS 支持两种同步模式：</p>
<ul>
<li><strong>独占模式</strong>：同一时刻仅允许一个线程获取同步状态，例如 <code>ReentrantLock</code>。<ul>
<li><strong>获取锁</strong>：<ul>
<li>线程调用 <code>acquire(int)</code> → <code>tryAcquire(int)</code>（子类实现）。</li>
<li>如果成功（<code>state</code> 修改成功），则获取锁。</li>
<li>如果失败，线程被封装成 <code>Node</code> 加入 <strong>CLH 队列</strong>，并进入 <code>park()</code> 等待。</li>
</ul>
</li>
<li><strong>释放锁</strong>：<ul>
<li>线程调用 <code>release(int)</code> → <code>tryRelease(int)</code>（子类实现）。</li>
<li>如果成功，唤醒队列中的下一个线程（<code>unparkSuccessor</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>共享模式</strong>：同一时刻允许多个线程获取同步状态，例如 <code>CountDownLatch</code> 和 <code>Semaphore</code>。<ul>
<li><strong>获取锁</strong>：<ul>
<li>线程调用 <code>acquireShared(int)</code> → <code>tryAcquireShared(int)</code>（子类实现）。</li>
<li>如果成功（返回 <code>≥0</code>），获取锁；否则进入队列等待。</li>
</ul>
</li>
<li><strong>释放锁</strong>：<ul>
<li>线程调用 <code>releaseShared(int)</code> → <code>tryReleaseShared(int)</code>（子类实现）。</li>
<li>如果成功，唤醒后续等待的线程（可能多个）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>关键方法</strong></p>
<ul>
<li><strong>独占模式</strong><ul>
<li>**<code>tryAcquire(int arg)</code>**：尝试以独占模式获取同步状态，此方法需由子类实现。</li>
<li>**<code>acquire(int arg)</code>**：以独占模式获取同步状态，若获取失败则将线程加入队列并阻塞。</li>
<li>**<code>tryRelease(int arg)</code>**：尝试以独占模式释放同步状态，需子类实现。</li>
<li>**<code>release(int arg)</code>**：以独占模式释放同步状态，若释放成功则唤醒队列中的后继节点。</li>
</ul>
</li>
<li><strong>共享模式</strong><ul>
<li>**<code>tryAcquireShared(int arg)</code>**：尝试以共享模式获取同步状态，需子类实现。</li>
<li>**<code>acquireShared(int arg)</code>**：以共享模式获取同步状态，若获取失败则将线程加入队列并阻塞。</li>
<li>**<code>tryReleaseShared(int arg)</code>**：尝试以共享模式释放同步状态，需子类实现。</li>
<li>**<code>releaseShared(int arg)</code>**：以共享模式释放同步状态，若释放成功则唤醒队列中的后继节点。</li>
</ul>
</li>
</ul>
<p>::: info AQS 核心机制</p>
<p><strong>CAS（Compare-And-Swap）</strong></p>
<p>使用 <code>Unsafe</code> 类的 <code>compareAndSwapXXX</code> 方法保证 <code>state</code> 和队列操作的原子性。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自旋 + <code>park()</code> 等待</strong></p>
<ul>
<li>线程在入队前会自旋尝试获取锁（减少上下文切换）。</li>
<li>如果仍然失败，则调用 <code>LockSupport.park()</code> 挂起线程。</li>
</ul>
<p><strong>公平性控制</strong></p>
<ul>
<li><strong>公平锁</strong>：严格按照 CLH 队列顺序获取锁（<code>hasQueuedPredecessors()</code> 检查是否有前驱节点）。</li>
<li><strong>非公平锁</strong>：新线程可以插队（<code>tryAcquire</code> 直接尝试获取锁，不检查队列）。</li>
</ul>
<p>:::</p>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从 ReentrantLock 的实现看 AQS 的原理及应用</a></p>
<p>:::</p>
<h3 id="【困难】ReentrantReadWriteLock-的实现原理是什么？"><a href="#【困难】ReentrantReadWriteLock-的实现原理是什么？" class="headerlink" title="【困难】ReentrantReadWriteLock 的实现原理是什么？"></a>【困难】ReentrantReadWriteLock 的实现原理是什么？</h3><p><strong>ReentrantReadWriteLock 是为【读多写少】的并发场景设计的锁实现</strong>。</p>
<p><strong>ReentrantReadWriteLock 允许多个线程同时持有读锁，但同一时刻只允许一个线程持有写锁</strong>。此外，存在读锁时无法获取写锁，存在写锁时无法获取读锁。</p>
<p>ReentrantReadWriteLock 有以下特性：</p>
<ul>
<li><strong>可重入</strong>：读写锁都支持可重入。</li>
<li><strong>支持公平锁</strong>，默认为非公平锁。</li>
<li><strong>支持锁降级</strong>：<strong>持有写锁可以获取读锁；反之不允许</strong>。</li>
</ul>
<p><strong>ReentrantReadWriteLock 基于 AQS 实现的读写锁</strong>，其<strong>核心设计思想是将一个 32 位的 int 状态变量拆分为两部分</strong>：</p>
<ul>
<li><strong>高 16 位</strong>：表示读锁的持有数量（包括重入次数）</li>
<li><strong>低 16 位</strong>：表示写锁的重入次数</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">状态变量结构：</span></span><br><span class="line"><span class="section">+-------------------------------+-------------------------------+</span></span><br><span class="line"><span class="section">|         读锁状态 (16 位）        |         写锁状态 (16 位）        |</span></span><br><span class="line"><span class="section">+-------------------------------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>写锁实现（WriteLock）</strong></p>
<ul>
<li>排他锁，使用 AQS 的独占模式</li>
<li>获取条件：<ul>
<li>读锁计数为 0（没有读锁）</li>
<li>写锁计数为 0 或当前线程已持有写锁（可重入）</li>
</ul>
</li>
<li>实现方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否有读锁或其他线程持有写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span> &amp;&amp; w == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查重入或 CAS 设置状态</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>读锁实现（ReadLock）</strong></p>
<ul>
<li>共享锁，使用 AQS 的共享模式</li>
<li>获取条件：<ul>
<li>没有线程持有写锁，或写锁被当前线程持有（锁降级）</li>
</ul>
</li>
<li>实现特点：<ul>
<li>使用 ThreadLocal 记录每个线程的重入次数</li>
<li>第一个获取读锁的线程会记录自己（firstReader）</li>
<li>后续线程使用 cachedHoldCounter 优化性能</li>
</ul>
</li>
</ul>
<p><strong>锁降级实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁降级示例代码</span></span><br><span class="line">writeLock.lock();         <span class="comment">// 获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据。..</span></span><br><span class="line">    readLock.lock();      <span class="comment">// 在保持写锁的情况下获取读锁（锁降级关键步骤）</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();  <span class="comment">// 释放写锁，降级为读锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时仍持有读锁，其他线程可以获取读锁但不能获取写锁</span></span><br></pre></td></tr></table></figure>

<p><strong>关键数据结构</strong></p>
<p><strong>HoldCounter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;          <span class="comment">// 重入次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> Thread.currentThread().getId(); <span class="comment">// 线程 ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocalHoldCounter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class ThreadLocalHoldCounter</span><br><span class="line">    extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">    public HoldCounter initialValue() &#123;</span><br><span class="line">        return new HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能优化技巧</strong></p>
<ul>
<li><strong>firstReader 优化</strong>：记录第一个获取读锁的线程，避免 ThreadLocal 查找</li>
<li><strong>cachedHoldCounter</strong>：缓存最近一个获取读锁的线程计数器</li>
<li><strong>读锁计数存储</strong>：使用 ThreadLocal 保存每个线程的重入次数，避免竞争</li>
</ul>
<h3 id="【困难】StampedLock-的实现原理是什么？"><a href="#【困难】StampedLock-的实现原理是什么？" class="headerlink" title="【困难】StampedLock 的实现原理是什么？"></a>【困难】StampedLock 的实现原理是什么？</h3><p><code>StampedLock</code>是 JDK8 引入的高性能锁，<strong>适合读多写少且追求极致吞吐的场景</strong>，但需谨慎处理乐观读失败和死锁风险。</p>
<p>StampedLock 通过<strong>版本号+状态位拆分</strong>实现无锁读，牺牲重入性和公平性换取更高吞吐，适合短期读操作的并发场景。</p>
<p><strong>StampedLock 支持三种锁模式</strong>：</p>
<ul>
<li><strong>写锁（独占锁）</strong>：类似<code>ReentrantLock</code>，同一时刻只有一个线程能获取。阻塞其他所有读锁和写锁请求。</li>
<li><strong>悲观读锁（共享锁）</strong>：允许多线程并发读，但会阻塞写锁请求（类似<code>ReentrantReadWriteLock</code>的读锁）。</li>
<li><strong>乐观读（无锁优化）</strong>：不阻塞写操作，仅通过<code>tryOptimisticRead()</code>获取一个”邮戳”（版本号），读完后需校验邮戳是否有效（未被写操作修改）。</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li><strong>更高的并发度</strong>：乐观读允许读操作与写操作并发执行（无阻塞）。</li>
<li><strong>不可重入</strong>：锁不可重入，嵌套获取可能导致死锁。</li>
<li><strong>支持锁升级&#x2F;降级</strong>：<ul>
<li><strong>锁降级</strong>：写锁→悲观读锁（类似<code>ReentrantReadWriteLock</code>）。</li>
<li><strong>锁升级</strong>：乐观读→悲观读锁或写锁（需校验邮戳后尝试转换）。</li>
</ul>
</li>
<li>**不支持 <code>Condition</code>**：不能像<code>ReentrantLock</code>那样使用<code>await()</code>&#x2F;<code>signal()</code>。</li>
</ul>
<p><strong>StampedLock vs. ReentrantReadWriteLock</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>StampedLock</code></th>
<th><code>ReentrantReadWriteLock</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>读并发度</strong></td>
<td>最高（乐观读无阻塞）</td>
<td>高（悲观读阻塞写）</td>
</tr>
<tr>
<td><strong>写饥饿</strong></td>
<td>可能发生</td>
<td>非公平模式下可能发生</td>
</tr>
<tr>
<td><strong>锁重入</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>仅非公平</td>
<td>支持公平&#x2F;非公平</td>
</tr>
<tr>
<td><strong>条件变量</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>状态设计</strong></p>
<ul>
<li><strong>64 位长整型状态变量</strong>（<code>state</code>）拆分为三部分：<ul>
<li><strong>写锁标记</strong>（最低位）：<code>WBIT</code>（写锁占用标志）</li>
<li><strong>版本号</strong>（中间 7 位）：乐观读的邮戳版本</li>
<li><strong>读锁计数</strong>（剩余 56 位）：记录悲观读锁的持有数量</li>
</ul>
</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State 结构：</span><br><span class="line">[读锁计数 (<span class="number">56</span> 位） | <span class="type">版本号 (7</span> 位） | <span class="type">写锁标记 (1</span> 位）]</span><br></pre></td></tr></table></figure>

<p><strong>关键操作实现</strong></p>
<p><strong>写锁获取</strong></p>
<ul>
<li><strong>CAS 设置 WBIT 位</strong>：若成功则获取写锁，失败则进入队列等待</li>
<li><strong>版本号+1</strong>：每次写锁释放时递增版本号（保证乐观读的可见性）</li>
</ul>
<p><strong>悲观读锁获取</strong></p>
<ul>
<li><strong>检查无写锁</strong>（WBIT&#x3D;0）时通过 CAS 增加读计数</li>
<li><strong>写锁占用时</strong>：进入等待队列（类似 AQS 的 CLH 队列）</li>
</ul>
<p><strong>乐观读实现</strong></p>
<ol>
<li>调用<code>tryOptimisticRead()</code>获取当前版本号（不修改状态）</li>
<li>读取共享数据</li>
<li>调用<code>validate(stamp)</code>检查版本号是否变化（无写操作则有效）</li>
</ol>
<p><strong>锁转换机制</strong></p>
<p>**tryConvertToXLock()**：核心转换方法（避免释放再获取的开销）</p>
<ul>
<li>乐观读→悲观读：验证邮戳后直接获取读锁</li>
<li>读锁→写锁：当读计数&#x3D;1 且当前线程唯一持有读锁时可转换</li>
</ul>
<p><strong>性能优化手段</strong></p>
<ul>
<li><strong>无锁乐观读</strong>：完全不阻塞写操作（通过版本号校验）</li>
<li><strong>延迟唤醒</strong>：读锁释放时不立即唤醒等待线程（减少竞争）</li>
<li><strong>自旋优化</strong>：短时冲突时先自旋再入队（类似 AQS）</li>
</ul>
<p><strong>与 AQS 的差异</strong></p>
<ul>
<li><strong>非 AQS 实现</strong>：独立的状态机设计（更轻量）</li>
<li><strong>无公平性</strong>：所有锁均为非公平模式</li>
<li><strong>无条件队列</strong>：不支持<code>Condition</code>功能</li>
</ul>
<p><strong>典型使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观读示例</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 读取共享数据。..</span></span><br><span class="line"><span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">// 版本失效，转悲观读</span></span><br><span class="line">    stamp = lock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新读取数据。..</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁示例</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据。..</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-无锁"><a href="#Java-无锁" class="headerlink" title="Java 无锁"></a>Java 无锁</h2><h3 id="【中等】什么是-CAS？CAS-的实现原理是什么？"><a href="#【中等】什么是-CAS？CAS-的实现原理是什么？" class="headerlink" title="【中等】什么是 CAS？CAS 的实现原理是什么？"></a>【中等】什么是 CAS？CAS 的实现原理是什么？</h3><p>::: info 什么是 CAS？</p>
<p>:::</p>
<p><strong>CAS（Compare-And-Swap，比较并交换）</strong> 是一种 <strong>无锁（Lock-Free）</strong> 的并发编程技术，基于 <strong>比较-交换</strong> 实现原子操作。它是现代并发编程的基石，被广泛应用于 Java 的 <code>Atomic</code> 类、<code>ReentrantLock</code>、<code>ConcurrentHashMap</code> 等并发工具中。</p>
<p>CAS 底层实现依赖 CPU 指令（如 <code>CMPXCHG</code>），通过 <code>Unsafe</code> 类调用本地方法。</p>
<p>CAS 的核心应用有：原子类、自旋锁、无锁数据结构（如 <code>ConcurrentHashMap</code>）。</p>
<p><strong>CAS 的核心思想</strong>：</p>
<ul>
<li><strong>比较</strong>：检查某个内存位置的值是否等于预期值（Expected Value）。</li>
<li><strong>交换</strong>：如果相等，则更新为新值（New Value），否则不做任何操作。</li>
<li><strong>原子性</strong>：整个操作由 <strong>CPU 指令</strong> 保证不可分割，不会出现线程安全问题。</li>
</ul>
<p>::: info CAS 的实现原理是什么？</p>
<p>:::</p>
<p><strong>（1）底层 CPU 指令支持</strong></p>
<p><strong>在 Java 中，通过 <code>Unsafe</code> 类调用本地方法（Native Method）实现 CAS</strong>。更底层的实现依赖于 <strong>硬件指令</strong>（如 x86 的 <code>CMPXCHG</code>、ARM 的 <code>LL/SC</code>），确保操作是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> newValue)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（2）CAS 操作流程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">CAS</span><span class="params">(Variable <span class="keyword">var</span>, <span class="type">int</span> expected, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">var</span>.value == expected) &#123;  <span class="comment">// 比较当前值是否等于预期值</span></span><br><span class="line">        <span class="keyword">var</span>.value = newValue;     <span class="comment">// 如果相等，更新为新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 否则失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际执行流程</strong>：</p>
<ol>
<li>读取内存值 <code>V</code>。</li>
<li>比较 <code>V</code> 和预期值 <code>A</code>：<ul>
<li>如果 <code>V == A</code>，说明没有其他线程修改过，更新为 <code>B</code>。</li>
<li>如果 <code>V != A</code>，说明值已被修改，放弃更新。</li>
</ul>
</li>
<li>返回操作是否成功。</li>
</ol>
<p><strong>（3）Java 中的 CAS 实现（以 AtomicInteger 为例）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS 操作：如果当前值是 0，则设置为 1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> count.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 内部调用 Unsafe.compareAndSwapInt</span></span><br></pre></td></tr></table></figure>

<p><strong>底层实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>this</code>：目标对象（如 <code>AtomicInteger</code> 实例）。</li>
<li><code>valueOffset</code>：字段在对象内存中的偏移量（通过 <code>Unsafe.objectFieldOffset</code> 获取）。</li>
<li><code>expect</code>：预期值。</li>
<li><code>update</code>：新值。</li>
</ul>
<p><strong>CAS 的典型应用</strong></p>
<p><strong>（1）原子类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">atomicInt.incrementAndGet();  <span class="comment">// CAS 实现原子自增</span></span><br></pre></td></tr></table></figure>

<p><strong>底层实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）自旋锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!CAS(lock, <span class="number">0</span>, <span class="number">1</span>)) &#123;  <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="comment">// 自旋等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）无锁数据结构</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>（JDK 8 使用 CAS + <code>synchronized</code> 替代分段锁）。</li>
<li><code>CopyOnWriteArrayList</code>（CAS 保证写入原子性）。</li>
</ul>
<p><strong>CAS 的优缺点</strong></p>
<p><strong>优点</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无锁</strong></td>
<td>避免线程阻塞，减少上下文切换</td>
</tr>
<tr>
<td><strong>高性能</strong></td>
<td>在低竞争场景下比锁更高效</td>
</tr>
<tr>
<td><strong>可扩展</strong></td>
<td>适合高并发读多写少场景</td>
</tr>
</tbody></table>
<p><strong>缺点</strong></p>
<table>
<thead>
<tr>
<th>缺点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ABA 问题</strong></td>
<td>值从 <code>A→B→A</code>，CAS 无法感知中间变化</td>
</tr>
<tr>
<td><strong>自旋开销</strong></td>
<td>高竞争时 CPU 空转</td>
</tr>
<tr>
<td><strong>单变量限制</strong></td>
<td>只能保证一个变量的原子性</td>
</tr>
<tr>
<td><strong>公平性问题</strong></td>
<td>无法保证先来先服务</td>
</tr>
</tbody></table>
<p><strong>CAS vs 锁</strong></p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>CAS</th>
<th>锁（如 synchronized）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现方式</strong></td>
<td>无锁（CPU 指令）</td>
<td>阻塞（JVM 管理）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低竞争时更优</td>
<td>高竞争时更稳定</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单原子操作</td>
<td>复杂临界区保护</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>非公平</td>
<td>可公平（如 <code>ReentrantLock(true)</code>）</td>
</tr>
</tbody></table>
<h3 id="【中等】CAS-算法存在哪些问题？"><a href="#【中等】CAS-算法存在哪些问题？" class="headerlink" title="【中等】CAS 算法存在哪些问题？"></a>【中等】CAS 算法存在哪些问题？</h3><p>CAS（Compare-And-Swap）是一种无锁并发编程技术，广泛用于 Java 的 <code>Atomic</code> 类、AQS、<code>ConcurrentHashMap</code> 等并发工具中。但它也存在一些问题和限制：</p>
<p><strong>ABA 问题</strong></p>
<ul>
<li><strong>问题描述</strong>：变量值从 <code>A</code> → <code>B</code> → <code>A</code>，CAS 检查时认为没有变化，但实际上已经被修改过。</li>
<li><strong>影响</strong>：可能导致数据不一致（如链表操作时节点被替换但指针仍有效）。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <strong>版本号&#x2F;时间戳</strong>（如 <code>AtomicStampedReference</code>）。</li>
<li>使用 <code>boolean</code> 标记（如 <code>AtomicMarkableReference</code>）。</li>
</ul>
</li>
</ul>
<p><strong>自旋产生的 CPU 空转</strong></p>
<ul>
<li><strong>问题描述</strong>：如果 CAS 长时间失败，线程会持续自旋（<code>while</code> 循环），占用 CPU 资源。</li>
<li><strong>影响</strong>：高并发竞争时，可能导致 CPU 使用率飙升。</li>
<li><strong>解决方案</strong>：<ul>
<li>限制自旋次数（如 <code>LongAdder</code> 改用分段 CAS）。</li>
<li>结合 <code>yield()</code> 或 <code>Thread.sleep()</code> 减少竞争。</li>
</ul>
</li>
</ul>
<p><strong>只能保证单个变量的原子性</strong></p>
<ul>
<li><strong>问题描述</strong>：CAS 只能对一个变量进行原子操作，无法保证多个变量的复合操作（如 <code>i++</code> 和 <code>j--</code>）。</li>
<li><strong>影响</strong>：需要额外同步机制（如锁）来保证多变量一致性。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <code>synchronized</code> 或 <code>ReentrantLock</code>。</li>
<li>设计不可变对象（如 <code>String</code>、<code>BigInteger</code>）。</li>
</ul>
</li>
</ul>
<p><strong>公平性问题</strong></p>
<ul>
<li><strong>问题描述</strong>：CAS 是非公平的，新线程可能比等待队列中的线程更快获取锁。</li>
<li><strong>影响</strong>：可能导致线程饥饿（某些线程长期得不到执行）。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用公平锁（如 <code>ReentrantLock(true)</code>）。</li>
<li>结合队列调度（如 AQS 的 CLH 队列）。</li>
</ul>
</li>
</ul>
<p><strong>不适用于复杂操作</strong></p>
<ul>
<li><strong>问题描述</strong>：CAS 适合简单操作（如 <code>count++</code>），但不适合复杂逻辑（如数据库事务）。</li>
<li><strong>影响</strong>：需要拆分为多个 CAS 步骤，可能引入中间状态不一致。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用锁（如 <code>synchronized</code>）。</li>
<li>改用事务内存（如 Clojure STM）。</li>
</ul>
</li>
</ul>
<p><strong>平台依赖性</strong></p>
<ul>
<li><strong>问题描述</strong>：CAS 依赖底层 CPU 指令（如 <code>CMPXCHG</code>），不同架构性能可能差异较大。</li>
<li><strong>影响</strong>：在 ARM 等弱内存模型平台可能出现意外行为。</li>
<li><strong>解决方案</strong>：使用 JVM 内置原子类（如 <code>AtomicInteger</code>），而非手动实现。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>影响</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ABA 问题</strong></td>
<td>数据不一致</td>
<td><code>AtomicStampedReference</code></td>
</tr>
<tr>
<td><strong>自旋开销</strong></td>
<td>CPU 占用高</td>
<td>限制自旋次数 &#x2F; 退让策略</td>
</tr>
<tr>
<td><strong>单变量限制</strong></td>
<td>复合操作不安全</td>
<td>锁 &#x2F; 不可变对象</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>线程饥饿</td>
<td>公平锁 &#x2F; 队列调度</td>
</tr>
<tr>
<td><strong>复杂操作</strong></td>
<td>难以实现</td>
<td>锁 &#x2F; 事务内存</td>
</tr>
<tr>
<td><strong>平台依赖</strong></td>
<td>跨平台兼容性差</td>
<td>使用标准库</td>
</tr>
</tbody></table>
<p>CAS 在无锁编程中非常高效，但需结合场景权衡利弊。在高竞争环境下，可能需要改用锁或其他并发策略。</p>
<h3 id="【中等】什么是-ThreadLocal？"><a href="#【中等】什么是-ThreadLocal？" class="headerlink" title="【中等】什么是 ThreadLocal？"></a>【中等】什么是 ThreadLocal？</h3><p>::: info 什么是 ThreadLocal？</p>
<p>:::</p>
<p>在多线程环境下，共享变量存在并发安全问题。换个思路，如果变量非共享，而是各个线程独享，就不会有并发安全问题。这种思想有个术语叫<strong>线程封闭</strong>，其本质上就是避免共享。没有共享，自然也就没有并发安全问题。在 Java 中，<code>ThreadLocal</code> 正是根据这个思路而设计的。</p>
<p><strong><code>ThreadLocal</code> 为每个线程都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</p>
<p>::: info ThreadLocal 有哪些应用场景？</p>
<p>:::</p>
<p><strong>（1）存储线程私有数据</strong></p>
<ul>
<li><p><strong>用户会话（Session）管理</strong>：每个请求线程存储当前用户的 <code>Session</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前用户</span></span><br><span class="line">currentUser.set(user);</span><br><span class="line"><span class="comment">// 获取当前用户</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> currentUser.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库连接（Connection）管理</strong>：避免传递 <code>Connection</code> 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; connectionHolder =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; dataSource.getConnection());</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>避免参数透传</strong></p>
<p><strong>问题</strong>：多层方法调用需要透传某个上下文参数（如 <code>traceId</code>）。</p>
<p><strong>解决</strong>：使用 <code>ThreadLocal</code> 存储，避免方法参数传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; traceIdHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在入口处设置 traceId</span></span><br><span class="line">traceIdHolder.set(<span class="string">&quot;req-123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在任意深层方法获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> traceIdHolder.get(); <span class="comment">// 无需透传参数</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）线程安全的工具类</strong></p>
<p><strong>例如</strong>：<code>SimpleDateFormat</code> 是线程不安全的，但可以用 <code>ThreadLocal</code> 包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatHolder =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全地使用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> dateFormatHolder.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践</strong></p>
<p>（1）<strong>尽量用 <code>static final</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>避免重复创建 <code>ThreadLocal</code> 实例。</p>
<p>（2）<strong>必须调用 <code>remove()</code></strong></p>
<p>尤其在线程池场景，否则会导致内存泄漏。</p>
<p>（3）<strong>推荐初始化默认值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;User&gt; userHolder = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br></pre></td></tr></table></figure>

<p>（4）<strong>避免在父子线程间传递</strong></p>
<p><code>ThreadLocal</code> 不能自动继承，需手动处理（可用 <code>InheritableThreadLocal</code>）。</p>
<h3 id="【中等】ThreadLocal-的原理是什么？"><a href="#【中等】ThreadLocal-的原理是什么？" class="headerlink" title="【中等】ThreadLocal 的原理是什么？"></a>【中等】<code>ThreadLocal</code> 的原理是什么？</h3><p><strong>内部结构</strong></p>
<p><code>ThreadLocal</code> 主要依赖于两个类：<code>ThreadLocal</code> 自身和 <code>ThreadLocalMap</code>。</p>
<ul>
<li><strong><code>Thread</code> 类</strong>：每个 <code>Thread</code> 对象内部都有一个类型为 <code>ThreadLocalMap</code> 的成员变量 <code>threadLocals</code>，用于存储该线程的所有 <code>ThreadLocal</code> 变量及其对应的值。</li>
<li>**<code>ThreadLocalMap</code>**：它是 <code>ThreadLocal</code> 的一个静态内部类，类似于 <code>HashMap</code>，但它使用弱引用的 <code>ThreadLocal</code> 对象作为键，值则是用户设置的对象。</li>
</ul>
<p><strong>存储机制</strong></p>
<ul>
<li>当调用 <code>ThreadLocal</code> 的 <code>set</code> 方法时，它会首先获取当前线程的 <code>ThreadLocalMap</code>。</li>
<li>如果 <code>ThreadLocalMap</code> 存在，则以当前 <code>ThreadLocal</code> 对象为键，将值存储到 <code>ThreadLocalMap</code> 中。</li>
<li>如果 <code>ThreadLocalMap</code> 不存在，则创建一个新的 <code>ThreadLocalMap</code>，并将当前 <code>ThreadLocal</code> 对象和值作为第一个元素存入其中。</li>
</ul>
<p><strong>获取机制</strong></p>
<ul>
<li>当调用 <code>ThreadLocal</code> 的 <code>get</code> 方法时，它会先获取当前线程的 <code>ThreadLocalMap</code>。</li>
<li>如果 <code>ThreadLocalMap</code> 存在，则以当前 <code>ThreadLocal</code> 对象为键去查找对应的值。</li>
<li>如果 <code>ThreadLocalMap</code> 不存在或者没有找到对应的值，则调用 <code>initialValue</code> 方法（可以通过继承 <code>ThreadLocal</code> 类并重写该方法来设置初始值）来获取初始值，并将其存储到 <code>ThreadLocalMap</code> 中。</li>
</ul>
<p><strong>弱引用机制</strong></p>
<p><code>ThreadLocalMap</code> 的键是对 <code>ThreadLocal</code> 对象的弱引用。这意味着当外部对 <code>ThreadLocal</code> 对象的强引用被释放后，<code>ThreadLocal</code> 对象会在下次垃圾回收时被回收。这样可以避免内存泄漏，因为如果使用强引用，即使外部不再使用 <code>ThreadLocal</code> 对象，它也不会被回收，从而导致 <code>ThreadLocalMap</code> 中的条目一直存在。</p>
<h3 id="【中等】如何解决-ThreadLocal-内存泄漏问题？"><a href="#【中等】如何解决-ThreadLocal-内存泄漏问题？" class="headerlink" title="【中等】如何解决 ThreadLocal 内存泄漏问题？"></a>【中等】如何解决 <code>ThreadLocal</code> 内存泄漏问题？</h3><p><strong>ThreadLocal 的内存泄漏问题源于其特殊的 “弱引用 Key + 强引用 Value” 存储结构</strong>，主要发生在以下两种场景：</p>
<p><strong>(1) Key 被回收，Value 残留（主要泄漏场景）</strong></p>
<ul>
<li><code>ThreadLocal</code> 实例（Key）是<strong>弱引用</strong>，会被 GC 回收</li>
<li>对应的 Value 是<strong>强引用</strong>，会持续占用内存</li>
<li>导致 <code>ThreadLocalMap</code> 中出现 <code>key=null</code> 但 <code>value≠null</code> 的无效 Entry</li>
</ul>
<p><strong>(2) 线程长期存活时的累积泄漏</strong></p>
<ul>
<li>线程池复用线程（如 Tomcat worker 线程）</li>
<li>每次任务执行后未调用 <code>remove()</code></li>
<li>导致多个无效 Entry 堆积在 <code>ThreadLocalMap</code> 中</li>
</ul>
<p>::: code-tabs#内存泄漏的具体场景</p>
<p>@tab 线程池环境未清理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">ThreadLocal&lt;BigObject&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line">    tl.set(<span class="keyword">new</span> <span class="title class_">BigObject</span>());  <span class="comment">// 存储大对象</span></span><br><span class="line">    <span class="comment">// 业务逻辑。..</span></span><br><span class="line">    <span class="comment">// 缺少 tl.remove()！线程复用后旧 Value 仍然存在</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>后果</strong>：线程被重复使用时，之前的 <code>BigObject</code> 实例无法被回收</p>
<p>@tab 静态 ThreadLocal 长期持有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    userHolder.set(<span class="keyword">new</span> <span class="title class_">User</span>()); <span class="comment">// 每次请求新 User 对象</span></span><br><span class="line">    <span class="comment">// 业务逻辑。..</span></span><br><span class="line">    <span class="comment">// 忘记调用 userHolder.remove()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后果</strong>：Web 应用中，线程处理多个请求后，内存中堆积多个废弃 <code>User</code> 对象</p>
<p>@tab 使用非 static 的 ThreadLocal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Config&gt; configHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;(); <span class="comment">// 非 static</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        configHolder.set(loadConfig());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后果</strong>：每次创建 Service 实例都会产生新的 ThreadLocal，增加内存泄漏风险</p>
<p>:::</p>
<p><strong>解决方案与最佳实践</strong></p>
<p><strong>(1) 强制清理方案</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>实现方式</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>try-finally</strong></td>
<td>确保 remove() 执行</td>
<td>通用场景</td>
</tr>
<tr>
<td><strong>拦截器清理</strong></td>
<td>AOP&#x2F;@Around</td>
<td>Web 应用</td>
</tr>
<tr>
<td><strong>线程池钩子</strong></td>
<td><code>afterExecute</code></td>
<td>线程池任务</td>
</tr>
</tbody></table>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案 1：try-finally（推荐）</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(data);</span><br><span class="line">    <span class="comment">// 业务逻辑。..</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案 2：Spring 拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                          HttpServletResponse response,</span></span><br><span class="line"><span class="params">                          Object handler, Exception ex)</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) 设计优化方案</strong></p>
<ol>
<li><p><strong>使用 static final 修饰</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>避免重复创建 ThreadLocal 实例</li>
</ul>
</li>
<li><p><strong>初始化默认值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">LightweightObject</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>避免持有大对象</li>
</ul>
</li>
<li><p><strong>改用 InheritableThreadLocal</strong>（需谨慎）</p>
<ul>
<li>适用于需要父子线程传递数据的场景</li>
</ul>
</li>
</ol>
<p><strong>ThreadLocalMap 的自动清理机制</strong></p>
<p>虽然 ThreadLocalMap 有部分自清理能力，但<strong>不可依赖</strong>：</p>
<ul>
<li><strong>set() 触发清理</strong>：探测式清理（expungeStaleEntry）</li>
<li><strong>get() 触发清理</strong>：启发式清理（cleanSomeSlots）</li>
<li><strong>remove() 触发清理</strong>：完全清理指定 Entry</li>
</ul>
<p><strong>重要结论</strong>：</p>
<ul>
<li>自动清理不彻底（只清理部分无效 Entry）</li>
<li>高并发场景可能清理不及时</li>
<li><strong>必须显式调用 remove()</strong></li>
</ul>
<h3 id="【中等】InheritableThreadLocal-的实现原理是什么？"><a href="#【中等】InheritableThreadLocal-的实现原理是什么？" class="headerlink" title="【中等】InheritableThreadLocal 的实现原理是什么？"></a>【中等】InheritableThreadLocal 的实现原理是什么？</h3><p><strong>核心设计目标</strong></p>
<ul>
<li><strong>线程间值继承</strong>：子线程自动继承父线程的 ThreadLocal 值</li>
<li><strong>与 ThreadLocal 兼容</strong>：继承自<code>ThreadLocal</code>，保持相同 API</li>
</ul>
<p><strong>数据存储位置</strong></p>
<p>继承自<code>ThreadLocal</code>，但使用线程对象的<strong>独立字段</strong>；<code>Thread.inheritableThreadLocals</code>（专门存储可继承的变量）</p>
<p><strong>线程创建时的值拷贝</strong></p>
<ul>
<li><p><strong>触发时机</strong>：当父线程创建子线程（<code>Thread.init()</code>方法）</p>
</li>
<li><p><strong>拷贝逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>深拷贝保证隔离</strong>：子线程获得父线程值的独立副本（修改互不影响）</p>
</li>
</ul>
<p><strong>值传递规则</strong></p>
<ul>
<li><strong>仅初始化时拷贝</strong>：子线程创建后父线程对值的修改不再影响子线程</li>
<li><strong>浅拷贝问题</strong>：若存储引用对象，父子线程仍共享同一对象（需开发者自行处理线程安全）</li>
</ul>
<p><strong>与 ThreadLocal 的对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>InheritableThreadLocal</code></th>
<th><code>ThreadLocal</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>继承性</strong></td>
<td>子线程自动继承父线程值</td>
<td>完全隔离</td>
</tr>
<tr>
<td><strong>存储字段</strong></td>
<td><code>Thread.inheritableThreadLocals</code></td>
<td><code>Thread.threadLocals</code></td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>略高（需初始化时拷贝数据）</td>
<td>更低</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>需要跨线程传递上下文（如 TraceID）</td>
<td>线程私有数据</td>
</tr>
</tbody></table>
<p><strong>使用注意事项</strong></p>
<ul>
<li><strong>对象共享风险</strong>：若值是可变的引用对象，需自行保证线程安全</li>
<li><strong>线程池陷阱</strong>：线程池复用线程时会导致旧值残留（需手动清理）</li>
<li><strong>性能影响</strong>：大量线程创建时，值拷贝可能成为瓶颈</li>
</ul>
<p><strong>典型应用场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父线程设置值</span></span><br><span class="line">InheritableThreadLocal&lt;String&gt; itl = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">itl.set(<span class="string">&quot;parent_value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 子线程自动读取到父线程设置的值</span></span><br><span class="line">    System.out.println(itl.get()); <span class="comment">// 输出：parent_value</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong>实现局限</strong></p>
<ul>
<li><strong>不支持动态更新</strong>：子线程启动后父线程的修改不可见</li>
<li><strong>无回调机制</strong>：无法像<code>ThreadLocal</code>的<code>initialValue()</code>那样自定义子线程初始值</li>
</ul>
<h3 id="【中等】Java-中支持哪些原子类？"><a href="#【中等】Java-中支持哪些原子类？" class="headerlink" title="【中等】Java 中支持哪些原子类？"></a>【中等】Java 中支持哪些原子类？</h3><p>原子性是确保并发安全三大特性之一。为了兼顾原子性以及锁带来的性能问题，Java 引入了 CAS （主要体现在 <code>Unsafe</code> 类）来实现非阻塞同步（也叫乐观锁），CAS 底层基于 CPU 指令（硬件支持）支持，具有原子性。并基于 CAS ，提供了一套原子工具类。</p>
<p>原子类<strong>比锁的粒度更细，更轻量级</strong>，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。</p>
<p>原子类相当于一种泛化的 <code>volatile</code> 变量，能够<strong>支持原子的、有条件的读&#x2F;改&#x2F;写操</strong>作。</p>
<p>原子类可以分为 5 个类别，这 5 个类别提供的方法基本上是相似的：</p>
<ul>
<li><strong>基本数据类型</strong>：基本数据类型原子类针对 Java 基本类型提供原子操作。<ul>
<li><code>AtomicBoolean</code> - 布尔类型原子类</li>
<li><code>AtomicInteger</code> - 整型原子类</li>
<li><code>AtomicLong</code> - 长整型原子类</li>
</ul>
</li>
<li><strong>引用数据类型</strong>：Java 数据类型分为 <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong> 两大类（不了解 Java 数据类型划分可以参考： <a href="https://dunwu.github.io/waterdrop/pages/17bf2e10/">Java 基本数据类型</a> ）。如果想针对引用类型做原子操作怎么办？Java 也提供了相关的原子类：<ul>
<li><code>AtomicReference</code> - 引用类型原子类</li>
<li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li>
<li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li>
</ul>
</li>
<li><strong>数组数据类型</strong>：<strong>数组类型的原子类为数组元素提供了 <code>volatile</code> 类型的访问语义</strong>，这是普通数组所不具备的特性——**<code>volatile</code> 类型的数组仅在数组引用上具有 <code>volatile</code> 语义**。<ul>
<li><code>AtomicIntegerArray</code> - 整形数组原子类</li>
<li><code>AtomicLongArray</code> - 长整型数组原子类</li>
<li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li>
</ul>
</li>
<li><strong>属性更新器类型</strong>：<strong>属性更新器支持基于反射机制的更新字段值的原子操作</strong>。<ul>
<li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器</li>
<li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器</li>
<li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段</li>
</ul>
</li>
<li><strong>累加器</strong>：相比原子化的基本数据类型，速度更快，但是不支持 <code>compareAndSet()</code> 方法。<ul>
<li><code>DoubleAdder</code> - 浮点型原子累加器</li>
<li><code>LongAdder</code> - 长整型原子累加器。</li>
<li><code>DoubleAccumulator</code> - 更复杂的浮点型原子累加器</li>
<li><code>LongAccumulator</code> - 更复杂的长整型原子累加器</li>
</ul>
</li>
</ul>
<p><strong>原子类底层实现</strong></p>
<p>所有原子类都基于 <strong>Unsafe + CAS</strong> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Unsafe</code>：直接操作内存（CAS 原子指令）</li>
<li><code>valueOffset</code>：字段内存偏移量</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>读多写少</strong>：<code>AtomicXXX</code></li>
<li><strong>高并发写</strong>：<code>LongAdder</code></li>
<li><strong>无锁数据结构</strong>：<code>AtomicReference</code> + CAS</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>原子类 <strong>不适用于复合操作</strong>（如 <code>check-then-act</code>，仍需锁）</li>
<li><code>LongAdder</code> 适合统计，但 <strong>不保证实时精确值</strong>（调用 <code>sum()</code> 时才合并）。<code>LongAdder</code> 在操作后的返回值只是一个近似准确的数值，但是 <code>LongAdder</code> 最终返回的是一个准确的数值，所以在一些对实时性要求比较高的场景下，<code>LongAdder</code> 并不能取代 <code>AtomicInteger</code> 或 <code>AtomicLong</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/191e4e96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/191e4e96/" class="post-title-link" itemprop="url">Java 基础面试三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-12 08:18:58" itemprop="dateCreated datePublished" datetime="2024-07-12T08:18:58+08:00">2024-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-基础面试三"><a href="#Java-基础面试三" class="headerlink" title="Java 基础面试三"></a>Java 基础面试三</h1><h2 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h2><h3 id="【中等】Java-泛型的作用是什么？"><a href="#【中等】Java-泛型的作用是什么？" class="headerlink" title="【中等】Java 泛型的作用是什么？"></a>【中等】Java 泛型的作用是什么？</h3><p>::: info Java 泛型是什么？</p>
<p>:::</p>
<p>泛型允许在<strong>类、接口、方法</strong>上使用<strong>类型参数（如 <code>&lt;T&gt;</code>）</strong>，使代码能适应多种数据类型，同时保证类型安全。</p>
<p>::: info Java 泛型有什么用？</p>
<p>:::</p>
<ul>
<li><strong>类型安全</strong>：编译时检查类型，避免运行时 <code>ClassCastException</code>。</li>
<li><strong>代码复用</strong>：同一套逻辑可处理不同数据类型（如 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code>）。</li>
<li><strong>消除强制转换</strong>：直接使用泛型类型，无需手动转换（如 <code>(String) list.get(0)</code>）。</li>
</ul>
<p>::: info Java 泛型有什么特性？</p>
<p>:::</p>
<ul>
<li><strong>类型擦除</strong>：泛型仅在编译时有效，运行时类型信息会被擦除（<code>List&lt;String&gt;</code> 运行时变成 <code>List</code>）。</li>
<li>**通配符 <code>&lt;?&gt;</code>**：表示未知类型（如 <code>List&lt;?&gt;</code> 可接受任意类型的 <code>List</code>）。</li>
<li><strong>界限限定</strong>：<ul>
<li><code>T extends Class</code>（限定类型范围，如 <code>&lt;T extends Number&gt;</code>）。</li>
<li><code>&lt;? super T&gt;</code>（支持父类类型）。</li>
</ul>
</li>
</ul>
<p><strong>简单示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T content)</span> &#123; <span class="built_in">this</span>.content = content; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需强制转换</span></span><br></pre></td></tr></table></figure>

<p><strong>一句话总结</strong>：泛型让代码更灵活、安全，减少冗余和运行时错误。</p>
<h3 id="【中等】什么是-Java-泛型的上下界限定符？"><a href="#【中等】什么是-Java-泛型的上下界限定符？" class="headerlink" title="【中等】什么是 Java 泛型的上下界限定符？"></a>【中等】什么是 Java 泛型的上下界限定符？</h3><p>Java 泛型的上下界限定符用于<strong>限制泛型类型参数的范围</strong>，确保类型安全，提供更灵活的类型约束。</p>
<p>::: info Java 什么是上界限定符？有什么用？</p>
<p>:::</p>
<p><strong>上界限定符（<code>&lt;? extends T&gt;</code>）</strong> 限定泛型类型必须是 <code>T</code> <strong>或其子类</strong>（<code>T</code> 可以是类或接口）。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>只读安全</strong>：能安全读取数据（因为元素至少是 <code>T</code> 类型）。</li>
<li><strong>不能写入</strong>：无法确定具体子类型，防止类型污染。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受 Number 或其子类（如 Integer, Double）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number num : list) &#123;  <span class="comment">// 安全读取</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(1);  // 编译错误！无法安全写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::: info Java 什么是下界限定符？有什么用？</p>
<p>:::</p>
<p>下界限定符（<code>&lt;? super T&gt;</code>）限定泛型类型必须是 <code>T</code> <strong>或其父类</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>可写入</strong>：能安全添加 <code>T</code> 及其子类的对象。</li>
<li><strong>读取受限</strong>：只能以 <code>Object</code> 类型读取（因为父类型不确定）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受 Integer 或其父类（如 Number, Object）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>);     <span class="comment">// 安全写入 Integer</span></span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Integer num = list.get(0);  // 编译错误！需强制转换</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);      <span class="comment">// 只能以 Object 读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通配符限定对比</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">语法</th>
<th align="left">读取</th>
<th align="left">写入</th>
<th align="left">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">上界</td>
<td align="left"><code>? extends T</code></td>
<td align="left">安全（作为T）</td>
<td align="left">禁止</td>
<td align="left">生产者场景</td>
</tr>
<tr>
<td align="left">下界</td>
<td align="left"><code>? super T</code></td>
<td align="left">需转Object</td>
<td align="left">安全（T及子类）</td>
<td align="left">消费者场景</td>
</tr>
<tr>
<td align="left">无界</td>
<td align="left"><code>?</code></td>
<td align="left">作为Object</td>
<td align="left">禁止</td>
<td align="left">完全不确定类型</td>
</tr>
</tbody></table>
<p><strong>小结</strong></p>
<ul>
<li>**<code>extends T</code>**：安全读取，限制类型上界。如遍历 <code>List&lt;? extends Number&gt;</code>。</li>
<li>**<code>super T</code>**：安全写入，限制类型下界。如 <code>Collections.copy(dest&lt;? super T&gt;, src&lt;? extends T&gt;)</code>。</li>
<li><strong>PECS 原则</strong>（Producer-Extends, Consumer-Super）指导何时用哪种限定符。<ul>
<li><strong>生产者（Producer）</strong> 用 <code>extends</code>（输出数据）。</li>
<li><strong>消费者（Consumer）</strong> 用 <code>super</code>（输入数据）。</li>
</ul>
</li>
</ul>
<h3 id="【中等】泛型擦除的作用是什么？"><a href="#【中等】泛型擦除的作用是什么？" class="headerlink" title="【中等】泛型擦除的作用是什么？"></a>【中等】泛型擦除的作用是什么？</h3><p>泛型擦除是 Java 在<strong>编译时检查类型安全</strong>、<strong>运行时丢弃类型信息</strong>的折中设计，平衡了兼容性、性能和类型安全，但牺牲了部分运行时灵活性。</p>
<p><strong>泛型擦除</strong>是 Java 泛型的实现机制：</p>
<ul>
<li><strong>编译时</strong>：泛型类型（如 <code>&lt;T&gt;</code>、<code>List&lt;String&gt;</code>）会被检查，确保类型安全。</li>
<li><strong>运行时</strong>：所有泛型类型信息会被擦除，替换为<strong>原始类型（Raw Type）</strong>或<strong>边界类型（如 <code>Object</code>&#x2F;<code>extends</code> 上限）</strong>。</li>
</ul>
<p><strong>泛型擦除规则</strong></p>
<table>
<thead>
<tr>
<th>泛型定义</th>
<th>擦除后类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无界限 <code>&lt;T&gt;</code></strong></td>
<td><code>Object</code></td>
<td><code>List&lt;T&gt;</code> → <code>List</code></td>
</tr>
<tr>
<td><strong>有界限 <code>&lt;T extends Number&gt;</code></strong></td>
<td><code>Number</code>（边界类型）</td>
<td><code>Box&lt;T&gt;</code> → <code>Box&lt;Number&gt;</code></td>
</tr>
<tr>
<td><strong>通配符 <code>&lt;?&gt;</code> &#x2F; <code>&lt;? extends T&gt;</code></strong></td>
<td>边界类型</td>
<td><code>List&lt;?&gt;</code> → <code>List</code></td>
</tr>
<tr>
<td><strong><code>&lt;? super T&gt;</code></strong></td>
<td><code>Object</code></td>
<td><code>List&lt;? super Integer&gt;</code> → <code>List</code></td>
</tr>
</tbody></table>
<p><strong>泛型擦除作用</strong></p>
<ul>
<li><strong>兼容性</strong>：确保泛型代码能与旧版 Java（非泛型）字节码兼容。</li>
<li><strong>运行时效率</strong>：避免为每个泛型类型生成新类，减少 JVM 负担。</li>
<li><strong>简化设计</strong>：统一类型系统，避免 C++ 模板的复杂性。</li>
</ul>
<p><strong>泛型擦除的问题</strong></p>
<ul>
<li><p><strong>类型信息丢失</strong>：运行时无法获取泛型参数（如 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 运行时都是 <code>List</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(list.getClass());  <span class="comment">// 输出 ArrayList，而非 ArrayList&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强制类型转换</strong>：编译器自动插入类型转换代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  <span class="comment">// 编译后实际为：(String) list.get(0)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不支持原生类型</strong>：不能直接使用 <code>List&lt;int&gt;</code>，必须用包装类（如 <code>List&lt;Integer&gt;</code>）。</p>
</li>
</ul>
<p><strong>绕过擦除的限制</strong></p>
<ul>
<li><p>**显式传递 <code>Class&lt;T&gt;</code>**：通过反射保留类型信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();  <span class="comment">// 运行时知道具体类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型令牌（Type Token）</strong>：利用匿名子类捕获泛型类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;;  <span class="comment">// Guava 提供的方案</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>典型问题与解决方案</strong></p>
<table>
<thead>
<tr>
<th>问题场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>需要运行时获取泛型类型</td>
<td>传递 <code>Class&lt;T&gt;</code> 参数或使用 Type Token</td>
</tr>
<tr>
<td>泛型数组创建（<code>new T[]</code>）</td>
<td>使用 <code>Object[]</code> 转换或反射（<code>Array.newInstance</code>）</td>
</tr>
<tr>
<td>方法重载冲突（如 <code>void foo(List&lt;String&gt;)</code> 和 <code>void foo(List&lt;Integer&gt;)</code>）</td>
<td>编译报错（擦除后方法签名相同）</td>
</tr>
</tbody></table>
<h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><h3 id="【简单】什么是反射？反射有什么作用？"><a href="#【简单】什么是反射？反射有什么作用？" class="headerlink" title="【简单】什么是反射？反射有什么作用？"></a>【简单】什么是反射？反射有什么作用？</h3><p><strong>反射（Reflection）是 Java 提供的动态机制</strong>，允许程序在<strong>运行时</strong>：</p>
<ul>
<li><strong>获取类的信息</strong>（类名、方法、字段、注解等）</li>
<li><strong>操作类的成员</strong>（调用方法、访问&#x2F;修改字段、创建对象等）</li>
<li><strong>绕过访问控制</strong>（如调用私有方法）</li>
</ul>
<p><strong>反射核心类</strong>：</p>
<ul>
<li><code>Class&lt;T&gt;</code>：表示类或接口</li>
<li><code>Method</code>：表示类的方法</li>
<li><code>Field</code>：表示类的字段</li>
<li><code>Constructor</code>：表示类的构造方法</li>
</ul>
<p><strong>反射的主要用途</strong></p>
<ul>
<li><strong>动态加载类</strong>（如插件化开发）</li>
<li><strong>框架设计</strong>（如 Spring 的依赖注入、Hibernate 的 ORM 映射）</li>
<li><strong>测试工具</strong>（如 Mockito 模拟对象）</li>
<li><strong>绕过访问限制</strong>（调试或特殊场景）</li>
</ul>
<p><strong>如何使用反射？</strong></p>
<p>::: code-tabs#反射使用示例</p>
<p>@tab <strong>获取 <code>Class</code> 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：通过类名.class</span></span><br><span class="line">Class&lt;String&gt; strClass = String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：通过对象.getClass()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; strClass2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：通过Class.forName(&quot;全限定类名&quot;)</span></span><br><span class="line">Class&lt;?&gt; strClass3 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);  <span class="comment">// 需处理ClassNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>@tab <strong>创建对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：直接调用无参构造（需强制类型转换）</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) clazz.newInstance();  <span class="comment">// 已过时，推荐用 getConstructor()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：调用带参构造</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>@tab <strong>调用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法（需方法名 + 参数类型）</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法（需对象实例 + 参数值）</span></span><br><span class="line">method.invoke(user, <span class="string">&quot;Bob&quot;</span>);  <span class="comment">// 相当于 user.setName(&quot;Bob&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">staticMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">staticMethod.invoke(<span class="literal">null</span>);  <span class="comment">// 静态方法传 null</span></span><br></pre></td></tr></table></figure>

<p>@tab <strong>访问&#x2F;修改字段</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字段（包括私有字段）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问私有字段</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);  <span class="comment">// 关闭访问检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取字段值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) field.get(user);  <span class="comment">// 相当于 user.name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改字段值</span></span><br><span class="line">field.set(user, <span class="string">&quot;Charlie&quot;</span>);  <span class="comment">// 相当于 user.name = &quot;Charlie&quot;</span></span><br></pre></td></tr></table></figure>

<p>@tab <strong>获取注解信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类/方法/字段上的注解</span></span><br><span class="line">Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line"><span class="keyword">if</span> (clazz.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">    <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="【简单】反射有什么优缺点？"><a href="#【简单】反射有什么优缺点？" class="headerlink" title="【简单】反射有什么优缺点？"></a>【简单】反射有什么优缺点？</h3><table>
<thead>
<tr>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>动态性高（运行时决定行为）</td>
<td>性能较差（比直接调用慢）</td>
</tr>
<tr>
<td>可访问私有成员（突破封装）</td>
<td>代码可读性降低</td>
</tr>
<tr>
<td>支持泛型擦除后的类型操作</td>
<td>安全隐患（如破坏单例）</td>
</tr>
</tbody></table>
<p><strong>性能优化建议</strong>：</p>
<ul>
<li><strong>缓存 <code>Class</code>&#x2F;<code>Method</code>&#x2F;<code>Field</code> 对象</strong>：避免重复反射调用。</li>
<li>**优先使用 <code>getDeclaredXXX</code>**：比 <code>getXXX</code> 更高效（不检查继承链）。</li>
<li>**限制 <code>setAccessible(true)</code>**：频繁调用影响性能。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>反射可以破坏封装性</strong>（如修改 <code>final</code> 字段、调用私有方法）。</li>
<li>**慎用 <code>setAccessible(true)</code>**：可能导致安全漏洞（如绕过权限检查）。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?</a> 。</p>
<p>:::</p>
<h3 id="【中等】什么是-Java-中的动态代理？"><a href="#【中等】什么是-Java-中的动态代理？" class="headerlink" title="【中等】什么是 Java 中的动态代理？"></a>【中等】什么是 Java 中的动态代理？</h3><p>动态代理是一种在<strong>运行时</strong>动态创建代理对象的技术，允许在不修改原始类代码的情况下，<strong>增强或拦截</strong>目标对象的方法调用。</p>
<p>Java 动态代理通过 <code>Proxy</code> 和 <code>InvocationHandler</code> 在运行时生成接口代理对象，<strong>非侵入式</strong>地实现方法拦截和功能增强，是 AOP 和框架设计的核心技术。</p>
<ul>
<li>**<code>java.lang.reflect.Proxy</code>**：提供静态方法创建代理对象（核心方法：<code>Proxy.newProxyInstance()</code>）。</li>
<li>**<code>java.lang.reflect.InvocationHandler</code>**：接口，实现代理逻辑（核心方法：<code>invoke()</code>）。</li>
</ul>
<p><strong>动态代理的特点</strong></p>
<ul>
<li><strong>运行时生成</strong>：代理类在运行时动态生成，无需手动编写。</li>
<li><strong>基于接口</strong>：只能代理接口（不能代理普通类）。</li>
<li><strong>非侵入性</strong>：无需修改原始代码即可增强功能。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>AOP（面向切面编程）</strong>：如日志、事务管理（Spring AOP 基于动态代理）。</li>
<li><strong>远程方法调用（RPC）</strong>：如 Dubbo 的消费者代理。</li>
<li><strong>权限控制</strong>：拦截方法调用检查权限。</li>
</ul>
<p><strong>动态代理 vs 静态代理</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>动态代理</strong></th>
<th><strong>静态代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>生成时机</strong></td>
<td>运行时动态生成</td>
<td>编译时手动编写</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>低（自动适配接口）</td>
<td>高（需为每个类编写代理）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>高（通用逻辑集中处理）</td>
<td>低（逻辑分散）</td>
</tr>
</tbody></table>
<p><strong>局限性</strong></p>
<ul>
<li><strong>仅支持接口代理</strong>：不能代理普通类（CGLIB 可弥补此问题）。</li>
<li><strong>性能开销</strong>：反射调用比直接调用略慢（现代 JVM 已优化）。</li>
</ul>
<p><strong>扩展：CGLIB 动态代理</strong></p>
<ul>
<li><strong>原理</strong>：通过字节码技术生成目标类的子类代理。</li>
<li><strong>特点</strong>：可代理普通类，但无法代理 <code>final</code> 类&#x2F;方法。</li>
</ul>
<h3 id="【中等】JDK-动态代理和-CGLIB-动态代理有什么区别？"><a href="#【中等】JDK-动态代理和-CGLIB-动态代理有什么区别？" class="headerlink" title="【中等】JDK 动态代理和 CGLIB 动态代理有什么区别？"></a>【中等】JDK 动态代理和 CGLIB 动态代理有什么区别？</h3><p>JDK 动态代理 vs. CGLIB 动态代理：</p>
<table>
<thead>
<tr>
<th><strong>代理类型</strong></th>
<th><strong>JDK 动态代理</strong></th>
<th><strong>CGLIB 代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现机制</strong></td>
<td>基于<strong>接口</strong>，运行时生成代理类（<code>$Proxy0</code>）</td>
<td>基于<strong>继承</strong>，生成目标类的子类</td>
</tr>
<tr>
<td><strong>技术依赖</strong></td>
<td>Java 反射 API（<code>Proxy</code>类）</td>
<td>ASM 字节码操作库</td>
</tr>
<tr>
<td><strong>限制条件</strong></td>
<td>目标类必须实现接口</td>
<td>无法代理 <code>final</code> 类&#x2F;方法</td>
</tr>
<tr>
<td><strong>可代理目标</strong></td>
<td>只能代理<strong>接口</strong></td>
<td>可代理<strong>普通类</strong>和接口</td>
</tr>
</tbody></table>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>JDK 动态代理</strong></th>
<th><strong>CGLIB 代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>生成速度</strong></td>
<td>较快（反射生成）</td>
<td>较慢（需操作字节码）</td>
</tr>
<tr>
<td><strong>调用速度</strong></td>
<td>反射调用，略慢</td>
<td>直接方法调用，更快</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较小</td>
<td>较大（生成子类）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>：现代 JVM 对反射做了优化，JDK 代理性能差距已不明显。</p>
</blockquote>
<p><strong>使用示例</strong></p>
<p>::: code-tabs#反射使用示例</p>
<p>@tab <strong>JDK 动态代理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：目标类必须实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理逻辑</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;JDK 代理前置处理&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">&quot;JDK 代理后置处理&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),</span><br><span class="line">    target.getClass().getInterfaces(),  <span class="comment">// 关键：需传入接口</span></span><br><span class="line">    handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>@tab <strong>CGLIB 代理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类无需实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;保存用户&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理逻辑</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line">enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CGLIB 代理前置处理&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);  <span class="comment">// 直接调用父类方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;CGLIB 代理后置处理&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();  <span class="comment">// 生成子类对象</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<p><strong>如何选择？</strong></p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>推荐代理</strong></th>
<th><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td>目标对象实现了接口</td>
<td>JDK 动态代理</td>
<td>轻量级，标准库支持</td>
</tr>
<tr>
<td>目标对象无接口</td>
<td>CGLIB</td>
<td>唯一选择</td>
</tr>
<tr>
<td>需要代理 <code>final</code> 方法</td>
<td>JDK 动态代理</td>
<td>CGLIB 无法代理 final 方法</td>
</tr>
<tr>
<td>高性能要求（如高频调用）</td>
<td>CGLIB</td>
<td>直接方法调用更快</td>
</tr>
<tr>
<td>避免额外依赖</td>
<td>JDK 动态代理</td>
<td>CGLIB 需引入第三方库</td>
</tr>
</tbody></table>
<p><strong>主流框架的选择</strong></p>
<ul>
<li><strong>Spring AOP</strong>：<ul>
<li>默认使用 <strong>JDK 动态代理</strong>（如果目标有接口）</li>
<li>无接口时自动切换为 <strong>CGLIB</strong></li>
<li>可通过 <code>@EnableAspectJAutoProxy(proxyTargetClass=true)</code> 强制使用 CGLIB</li>
</ul>
</li>
<li><strong>MyBatis</strong>：Mapper 接口代理使用 <strong>JDK 动态代理</strong></li>
</ul>
<p><strong>一句话总结</strong></p>
<ul>
<li><strong>JDK 动态代理</strong>：基于接口，反射实现，轻量但功能有限。</li>
<li><strong>CGLIB</strong>：基于继承，字节码增强，功能强但有 <code>final</code> 限制。</li>
<li><strong>选择依据</strong>：目标是否有接口、性能需求、是否允许第三方依赖。</li>
</ul>
<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><h3 id="【中等】Java-中的注解原理是什么？"><a href="#【中等】Java-中的注解原理是什么？" class="headerlink" title="【中等】Java 中的注解原理是什么？"></a>【中等】Java 中的注解原理是什么？</h3><p><strong>注解通过编译期处理（APT）或运行时反射实现元数据编程，其本质是特殊接口，由 JVM 或工具库按生命周期策略处理。</strong></p>
<p><strong>注解本质</strong></p>
<ul>
<li><strong>元数据标签</strong>：注解本质是继承自 <code>java.lang.annotation.Annotation</code> 的接口</li>
<li><strong>编译后保留策略</strong>：通过 <code>@Retention</code> 指定生命周期<ul>
<li><code>SOURCE</code>：仅保留在源码（如 <code>@Override</code>）</li>
<li><code>CLASS</code>：保留到字节码（默认）</li>
<li><code>RUNTIME</code>：运行时可通过反射读取（如 <code>@SpringBootApplication</code>）</li>
</ul>
</li>
</ul>
<p><strong>核心处理机制</strong></p>
<ul>
<li><strong>编译期处理</strong>：<ul>
<li><strong>APT（Annotation Processing Tool）</strong>：在编译时生成代码（如 Lombok）</li>
<li><strong>编译器检查</strong>：如 <code>@Override</code> 验证方法重写</li>
</ul>
</li>
<li><strong>运行时处理</strong>：<ul>
<li><strong>反射读取</strong>：通过 <code>getAnnotation()</code> 获取注解信息（如 Spring 扫描 <code>@Component</code>）</li>
<li><strong>动态代理</strong>：结合 AOP 实现功能增强（如 <code>@Transactional</code>）</li>
</ul>
</li>
</ul>
<p><strong>关键技术点</strong></p>
<ul>
<li><strong>元注解</strong>：修饰注解的注解（如 <code>@Target</code> 指定作用目标）</li>
<li><strong>注解属性</strong>：本质是接口方法（需编译时常量值）</li>
<li><strong>字节码操作</strong>：ASM 等工具可直接修改字节码中的注解信息</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>框架配置</strong>：Spring 的 <code>@Autowired</code>、<code>@RequestMapping</code></li>
<li><strong>代码生成</strong>：Lombok 的 <code>@Data</code></li>
<li><strong>静态检查</strong>：<code>@Nullable</code>、<code>@Deprecated</code></li>
</ul>
<h2 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h2><h3 id="【中等】什么是-SPI，有什么用？"><a href="#【中等】什么是-SPI，有什么用？" class="headerlink" title="【中等】什么是 SPI，有什么用？"></a>【中等】什么是 SPI，有什么用？</h3><p>SPI 通过<code>接口+配置文件</code>实现<strong>运行时服务发现</strong>，是解耦和扩展的利器，JDBC&#x2F;日志等经典框架均基于此机制。</p>
<p>SPI 是 Java 提供的<strong>服务发现机制</strong>，通过<strong>接口与实现分离</strong>，实现：</p>
<ul>
<li><strong>运行时动态加载实现类</strong></li>
<li><strong>解耦接口与实现</strong></li>
<li><strong>可插拔式扩展</strong></li>
</ul>
<p><strong>核心组成</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>接口</strong></td>
<td>定义服务标准</td>
<td><code>java.sql.Driver</code></td>
</tr>
<tr>
<td><strong>实现类</strong></td>
<td>提供具体功能</td>
<td><code>com.mysql.cj.jdbc.Driver</code></td>
</tr>
<tr>
<td><strong>配置文件</strong></td>
<td>声明实现类</td>
<td><code>META-INF/services/接口全限定名</code></td>
</tr>
</tbody></table>
<p><strong>工作原理</strong></p>
<ul>
<li>在<code>META-INF/services/</code>下创建以<strong>接口全限定名</strong>命名的文件</li>
<li>文件中写入<strong>实现类全限定名</strong>（每行一个）</li>
<li>通过<code>ServiceLoader</code>动态加载实现类</li>
</ul>
<p><strong>主要应用场景</strong></p>
<ul>
<li><strong>JDBC 驱动加载</strong>（<code>DriverManager</code>）</li>
<li><strong>日志门面实现</strong>（SLF4J → Logback&#x2F;Log4j）</li>
<li><strong>Spring Boot 自动配置</strong></li>
<li><strong>Dubbo 扩展点机制</strong></li>
</ul>
<p><strong>优势与局限</strong></p>
<table>
<thead>
<tr>
<th><strong>优势</strong></th>
<th><strong>局限</strong></th>
</tr>
</thead>
<tbody><tr>
<td>实现热插拔</td>
<td>配置文件需严格规范</td>
</tr>
<tr>
<td>解耦接口与实现</td>
<td>原生SPI会加载所有实现类（可能浪费资源）</td>
</tr>
<tr>
<td>扩展性强</td>
<td>无默认实现筛选机制</td>
</tr>
</tbody></table>
<p><strong>与API的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>SPI</strong></th>
<th><strong>API</strong></th>
</tr>
</thead>
<tbody><tr>
<td>调用方向</td>
<td>由实现方提供，调用方选择</td>
<td>由提供方定义，调用方使用</td>
</tr>
<tr>
<td>控制权</td>
<td>调用方控制</td>
<td>提供方控制</td>
</tr>
<tr>
<td>典型场景</td>
<td>JDBC驱动、日志实现</td>
<td>Java标准库</td>
</tr>
</tbody></table>
<p><strong>改进方案</strong></p>
<ul>
<li><strong>Dubbo SPI</strong>：增加按需加载、扩展点缓存等优化</li>
<li><strong>Spring Factories</strong>：<code>META-INF/spring.factories</code>机制</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="【简单】什么是序列化？什么是反序列化？"><a href="#【简单】什么是序列化？什么是反序列化？" class="headerlink" title="【简单】什么是序列化？什么是反序列化？"></a>【简单】什么是序列化？什么是反序列化？</h3><p><strong>基本概念</strong></p>
<ul>
<li><strong>序列化</strong>：将对象转换为<strong>字节流</strong>（用于存储&#x2F;传输）</li>
<li><strong>反序列化</strong>：将字节流恢复为对象</li>
</ul>
<p><strong>核心用途</strong></p>
<ul>
<li><strong>持久化存储</strong>（如保存到文件&#x2F;数据库）</li>
<li><strong>网络传输</strong>（如RPC调用）</li>
<li><strong>深拷贝实现</strong>（通过序列化+反序列化）</li>
</ul>
<p><strong>Java实现方式</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Serializable</code>接口</strong></td>
<td>标记接口，默认Java序列化</td>
<td><code>class User implements Serializable</code></td>
</tr>
<tr>
<td><strong><code>Externalizable</code>接口</strong></td>
<td>需手动实现读写逻辑</td>
<td>覆盖<code>writeExternal()</code>&#x2F;<code>readExternal()</code></td>
</tr>
<tr>
<td><strong>第三方库</strong>（JSON&#x2F;Protobuf等）</td>
<td>跨语言、高效</td>
<td>Gson、Jackson、Protobuf</td>
</tr>
</tbody></table>
<p><strong>关键注意事项</strong></p>
<ul>
<li><p>**<code>serialVersionUID</code>**：显式声明版本号，避免反序列化失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>敏感字段处理</strong>：用<code>transient</code>跳过序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;  <span class="comment">// 不会被序列化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>避免序列化大对象</li>
<li>第三方库（如Protobuf）比Java原生序列化更快</li>
</ul>
</li>
</ul>
<p><strong>常见序列化协议对比</strong></p>
<table>
<thead>
<tr>
<th>协议</th>
<th>语言支持</th>
<th>可读性</th>
<th>性能</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Java原生</strong></td>
<td>仅Java</td>
<td>差</td>
<td>低</td>
<td>Java RMI</td>
</tr>
<tr>
<td><strong>JSON</strong></td>
<td>多语言</td>
<td>好</td>
<td>中</td>
<td>Web API</td>
</tr>
<tr>
<td><strong>Protobuf</strong></td>
<td>多语言</td>
<td>差</td>
<td>高</td>
<td>gRPC</td>
</tr>
<tr>
<td><strong>Hessian</strong></td>
<td>多语言</td>
<td>差</td>
<td>中</td>
<td>Dubbo</td>
</tr>
</tbody></table>
<p><strong>安全风险</strong></p>
<ul>
<li><strong>反序列化漏洞</strong>：恶意字节流可触发代码执行（需校验数据来源）</li>
<li><strong>解决方案</strong>：<ul>
<li>使用白名单控制反序列化类</li>
<li>替换为JSON等文本协议</li>
</ul>
</li>
</ul>
<h3 id="【中等】Java-提供了哪些-IO-方式？"><a href="#【中等】Java-提供了哪些-IO-方式？" class="headerlink" title="【中等】Java 提供了哪些 IO 方式？"></a>【中等】Java 提供了哪些 IO 方式？</h3><p>Java 提供了多种 I&#x2F;O（输入输出）方式，主要分为 <strong>传统 I&#x2F;O（BIO）、NIO（New I&#x2F;O）、AIO（异步 I&#x2F;O）</strong> 三大类，并支持 <strong>文件操作、网络通信、序列化</strong> 等场景。以下是主要 I&#x2F;O 方式的概述及要点：</p>
<p>::: info 什么是 BIO？</p>
<p>:::</p>
<p>传统 I&#x2F;O（BIO，Blocking I&#x2F;O）是同步阻塞式 I&#x2F;O，适用于连接数较少、延迟不敏感的场景。</p>
<p><strong>核心类</strong>：</p>
<ul>
<li><strong>字节流</strong>：<code>InputStream</code> &#x2F; <code>OutputStream</code>（如 <code>FileInputStream</code>、<code>FileOutputStream</code>）</li>
<li><strong>字符流</strong>：<code>Reader</code> &#x2F; <code>Writer</code>（如 <code>FileReader</code>、<code>FileWriter</code>）</li>
<li><strong>缓冲流</strong>：<code>BufferedReader</code>、<code>BufferedWriter</code>（提升性能）</li>
<li><strong>标准 I&#x2F;O</strong>：<code>System.in</code>（输入）、<code>System.out</code>（输出）</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：每个连接需要独立的线程，高并发时资源消耗大。</p>
<p>::: info 什么是 NIO？</p>
<p>:::</p>
<p>NIO（New I&#x2F;O，Non-blocking I&#x2F;O）是同步非阻塞 I&#x2F;O，基于 <strong>通道（Channel）</strong> 和 <strong>缓冲区（Buffer）</strong>，支持多路复用（Selector）。</p>
<p><strong>核心类</strong>：</p>
<ul>
<li><strong>Buffer</strong>：<code>ByteBuffer</code>、<code>CharBuffer</code>（数据存储）</li>
<li><strong>Channel</strong>：<code>FileChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code>（数据传输）</li>
<li><strong>Selector</strong>：监听多个通道的事件（如连接、读、写）</li>
</ul>
<p><strong>示例（NIO 文件复制）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">src</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;src.txt&quot;</span>));</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">dest</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;dest.txt&quot;</span>), StandardOpenOption.CREATE, StandardOpenOption.WRITE)) &#123;</span><br><span class="line">    src.transferTo(<span class="number">0</span>, src.size(), dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：单线程可处理多个连接，适合高并发（如 Netty 框架底层）。</li>
<li><strong>缺点</strong>：编程复杂度较高。</li>
</ul>
<p>::: info 什么是 AIO？</p>
<p>:::</p>
<p>AIO（Asynchronous I&#x2F;O）是异步非阻塞 I&#x2F;O，基于回调或 Future 机制，适用于高吞吐场景。</p>
<p><strong>核心类</strong>：</p>
<ul>
<li><code>AsynchronousFileChannel</code>（文件操作）</li>
<li><code>AsynchronousSocketChannel</code>（网络通信）</li>
<li><code>CompletionHandler</code>（回调接口）</li>
</ul>
<p><strong>示例（AIO 文件读取）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：真正异步，适合长连接、高吞吐场景（如大文件传输）。</li>
<li><strong>缺点</strong>：JDK 实现较少，Linux 支持有限（底层依赖 epoll）。</li>
</ul>
<p>::: info 有哪些常见的 IO 工具？</p>
<p>:::</p>
<ul>
<li><strong>序列化</strong>：<code>ObjectInputStream</code> &#x2F; <code>ObjectOutputStream</code>（Java 原生序列化）</li>
<li><strong>压缩流</strong>：<code>GZIPInputStream</code>、<code>ZipOutputStream</code></li>
<li><strong>内存映射文件</strong>：<code>MappedByteBuffer</code>（NIO 高性能文件访问）</li>
<li><strong>Files 工具类</strong>（Java 7+）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.readAllLines(Paths.get(<span class="string">&quot;file.txt&quot;</span>)); <span class="comment">// 快速读取文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>::: info BIO vs. NIO vs. AIO？</p>
<p>:::</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>模型</th>
<th>适用场景</th>
<th>典型框架</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>同步阻塞</td>
<td>低并发、简单 I&#x2F;O</td>
<td>Java Socket</td>
</tr>
<tr>
<td>NIO</td>
<td>同步非阻塞</td>
<td>高并发、网络通信</td>
<td>Netty、Tomcat NIO</td>
</tr>
<tr>
<td>AIO</td>
<td>异步非阻塞</td>
<td>高吞吐、大文件操作</td>
<td>较少使用</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>：</p>
<ul>
<li><strong>BIO</strong>：简单文件操作或低并发场景。</li>
<li><strong>NIO</strong>：高并发网络编程（如 Netty）。</li>
<li><strong>AIO</strong>：需要真正异步 I&#x2F;O 的场景（但实际使用较少）。</li>
</ul>
<p>如果需要更高层次的封装，可以考虑 <strong>Apache Commons IO</strong>、<strong>Guava</strong> 等工具库。</p>
<h3 id="【困难】NIO-如何实现多路复用？"><a href="#【困难】NIO-如何实现多路复用？" class="headerlink" title="【困难】NIO 如何实现多路复用？"></a>【困难】NIO 如何实现多路复用？</h3><p>::: info Java NIO 的核心组件有哪些？</p>
<p>:::</p>
<p>Java NIO 多路复用的核心是通过 <strong>Selector 轮询事件</strong> + <strong>非阻塞 Channel</strong> + <strong>Buffer 数据交换</strong>，允许单线程管理多个通道的 I&#x2F;O 操作。这是构建高性能网络应用的基础，也是 Netty 等框架的底层原理。</p>
<p><strong>Java NIO 核心组件</strong></p>
<ul>
<li><strong>Selector（选择器）</strong>：核心多路复用器，可监控多个 <code>Channel</code> 的 I&#x2F;O 事件（如连接、读、写）<ul>
<li>通过 <code>Selector.open()</code> 创建</li>
<li>一个 <code>Selector</code> 可绑定多个 <code>Channel</code></li>
</ul>
</li>
<li><strong>Channel（通道）</strong>：非阻塞 I&#x2F;O 操作的抽象，支持读写。主要类型：<ul>
<li><code>SocketChannel</code>：TCP 网络通信</li>
<li><code>ServerSocketChannel</code>：监听 TCP 连接</li>
<li><code>FileChannel</code>：文件 I&#x2F;O（不支持 Selector）</li>
</ul>
</li>
<li><strong>Buffer（缓冲区）</strong>：数据容器（如 <code>ByteBuffer</code>），<code>Channel</code> 通过 <code>Buffer</code> 读写数据。</li>
</ul>
<p>::: info Java NIO 多路复用的实现步骤是怎样的？</p>
<p>:::</p>
<p><strong>多路复用实现步骤</strong></p>
<p><strong>(1) 创建 Selector 并注册 Channel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 必须设为非阻塞</span></span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT); <span class="comment">// 注册监听事件</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) 事件类型</strong></p>
<ul>
<li><code>SelectionKey.OP_ACCEPT</code>：接受连接（<code>ServerSocketChannel</code>）</li>
<li><code>SelectionKey.OP_CONNECT</code>：连接就绪（<code>SocketChannel</code>）</li>
<li><code>SelectionKey.OP_READ</code>：数据可读</li>
<li><code>SelectionKey.OP_WRITE</code>：数据可写</li>
</ul>
<p><strong>(3) 事件轮询</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select(); <span class="comment">// 阻塞直到有事件就绪</span></span><br><span class="line">    <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 处理新连接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 处理读事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 处理写事件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keyIterator.remove(); <span class="comment">// 必须移除已处理的键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::: info Java NIO 的关键机制有哪些？</p>
<p>:::</p>
<p><strong>(1) 非阻塞模式</strong></p>
<ul>
<li>Channel 必须设置为非阻塞：<code>channel.configureBlocking(false)</code></li>
<li>避免单线程因 I&#x2F;O 操作阻塞</li>
</ul>
<p><strong>(2) 事件驱动</strong></p>
<ul>
<li>Selector 通过操作系统级轮询（如 Linux 的 <code>epoll</code>）监听事件</li>
<li>仅处理活跃的 <code>Channel</code>，避免无效遍历</li>
</ul>
<p><strong>(3) SelectionKey</strong></p>
<ul>
<li>绑定 Channel 与 Selector 的关系</li>
<li>可通过 <code>key.attachment()</code> 附加自定义对象（如会话状态）</li>
</ul>
<p>::: info Java NIO 的底层原理是什么？</p>
<p>:::</p>
<ul>
<li><strong>Linux</strong>：基于 <code>epoll</code> 实现（高效监控大量文件描述符）</li>
<li><strong>Windows</strong>：基于 <code>IOCP</code>（完成端口）</li>
<li>相比传统 BIO 的线程池模型，NIO 单线程可处理数千连接</li>
</ul>
<p><strong>NIO 优点</strong></p>
<ul>
<li>单线程管理多连接，资源消耗低</li>
<li>高并发支持（如 Netty 框架底层依赖 NIO）</li>
<li>避免线程上下文切换开销</li>
</ul>
<p><strong>NIO 适用场景</strong></p>
<ul>
<li>高并发网络服务（如聊天服务器、API 网关）</li>
<li>需要长连接的应用（如 WebSocket）</li>
<li>大数据量、低延迟的 I&#x2F;O 操作</li>
</ul>
<h2 id="Java-语法糖"><a href="#Java-语法糖" class="headerlink" title="Java 语法糖"></a>Java 语法糖</h2><h3 id="【中等】Java-中有哪些常见的语法糖？"><a href="#【中等】Java-中有哪些常见的语法糖？" class="headerlink" title="【中等】Java 中有哪些常见的语法糖？"></a>【中等】Java 中有哪些常见的语法糖？</h3><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>
<p>Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。所有这些语法糖在编译阶段都会被”脱糖”(desugar)，即转换为更基础的Java语法结构。可以使用<code>javap -c</code>命令查看字节码来验证这一点。语法糖虽然不增加语言功能，但能显著提高代码的可读性和编写效率，是Java语言不断演进的重要组成部分。</p>
<p><strong>自动装箱与拆箱 (Autoboxing&#x2F;Unboxing)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 实际编译为 Integer.valueOf(10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;      <span class="comment">// 实际编译为 i.intValue()</span></span><br></pre></td></tr></table></figure>

<p><strong>增强 for 循环 (foreach)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 语法糖形式</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际编译为迭代器模式</span></span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变长参数 (Varargs)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际编译为数组参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String[] args)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>数值字面量下划线</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">million</span> <span class="operator">=</span> <span class="number">1_000_000</span>;  <span class="comment">// 编译后等同于 1000000</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="comment">// 编译优化为</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量拼接会转为 StringBuilder</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>, b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(a).append(b).toString();</span><br></pre></td></tr></table></figure>

<p><strong>switch 支持字符串 (Java 7+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s an apple&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 实际编译为基于hashCode()和equals()的比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 如果没有显式定义构造方法，编译器会自动添加无参构造方法</span></span><br></pre></td></tr></table></figure>

<p><strong>枚举类 (Java 5+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;</span><br><span class="line"><span class="comment">// 实际编译为继承java.lang.Enum的类</span></span><br></pre></td></tr></table></figure>

<p><strong>内部类访问外部类成员</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(x);  <span class="comment">// 实际通过 Outer.this.x 访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法引用 (Java 8+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 编译为lambda表达式</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p><strong>钻石操作符 (Diamond Operator, Java 7+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 类型推断</span></span><br><span class="line"><span class="comment">// Java 7之前需要</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>集合字面量 (Java 9+ 的List.of等)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式 (Java 8+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 实际生成实现Runnable的匿名类</span></span><br></pre></td></tr></table></figure>

<p><strong>try-with-resources (Java 7+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125;  <span class="comment">// 自动调用close()</span></span><br><span class="line"><span class="comment">// 编译为try-finally块</span></span><br></pre></td></tr></table></figure>

<p><strong>接口中的默认方法和静态方法 (Java 8+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记录类 (Record, Java 14+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 编译后自动生成:</span></span><br><span class="line"><span class="comment">// - 私有final字段x和y</span></span><br><span class="line"><span class="comment">// - 公共构造方法</span></span><br><span class="line"><span class="comment">// - 访问器方法x()和y()</span></span><br><span class="line"><span class="comment">// - equals(), hashCode(), toString()</span></span><br></pre></td></tr></table></figure>

<p><strong><code>instanceof</code> 模式匹配</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// 可以直接使用s</span></span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文本块 (Text Blocks, Java 15+)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/46f290c1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/46f290c1/" class="post-title-link" itemprop="url">Java 基础面试二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-基础面试二"><a href="#Java-基础面试二" class="headerlink" title="Java 基础面试二"></a>Java 基础面试二</h1><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><h3 id="【简单】对象实体与对象引用有何不同？"><a href="#【简单】对象实体与对象引用有何不同？" class="headerlink" title="【简单】对象实体与对象引用有何不同？"></a>【简单】对象实体与对象引用有何不同？</h3><p>（1）<strong>对象是用来描述客观事物的一个抽象</strong>。一个对象由一组属性和对这组属性进行操作的一组服务组成。</p>
<p>（2）<strong>类是具有相同属性和方法的一组对象的集合</strong>，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。</p>
<p>（3）对象实体与对象引用的不同之处在于：</p>
<ul>
<li><code>new</code> 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）</li>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="【简单】接口和抽象类有什么区别？"><a href="#【简单】接口和抽象类有什么区别？" class="headerlink" title="【简单】接口和抽象类有什么区别？"></a>【简单】接口和抽象类有什么区别？</h3><p>（1）接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p>
<p>接口的主要特性有：</p>
<ul>
<li>接口不能实例化。</li>
<li>接口不能包含任何非常量成员，任何字段都隐式的被 <code>public static final</code> 修饰。</li>
<li>接口中没有非静态方法，也就是说要么是抽象方法，要么是静态方法。</li>
<li>从 Java8 开始，接口增加了 <code>default</code> 方法特性，可以定义方法的默认实现；Java 9 以后，甚至可以定义私有的 <code>default</code> 方法。</li>
</ul>
<p>（2）抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p>
<p>（3）接口和抽象类有什么相同点和不同点？</p>
<p>Java 中的类可以实现多个接口。</p>
<p>（4）与 C++ 等语言不一样，Java 类不支持多继承。这意味着，Java 不能通过继承多个抽象类来重用逻辑。那么，如何来实现重用呢？Java 的解决方案是：接口支持多继承，准确的说，接口支持扩展多个接口，而接口也支持实现多个接口。</p>
<h3 id="【中等】什么是-Java-内部类？内部类有什么作用？"><a href="#【中等】什么是-Java-内部类？内部类有什么作用？" class="headerlink" title="【中等】什么是 Java 内部类？内部类有什么作用？"></a>【中等】什么是 Java 内部类？内部类有什么作用？</h3><p>::: info 什么是内部类？<br>:::</p>
<p>内部类 (Inner Class) 是定义在另一个类内部的类。Java 中有四种类型的内部类：</p>
<ul>
<li><strong>成员内部类</strong>：作为外部类的成员存在</li>
<li><strong>局部内部类</strong>：定义在方法或作用域内的类</li>
<li><strong>匿名内部类</strong>：没有名字的局部内部类</li>
<li><strong>静态嵌套类</strong>：用 static 修饰的嵌套类</li>
</ul>
<p>::: info 内部类有什么作用？<br>:::</p>
<ul>
<li><strong>逻辑分组</strong>：当某个类只对另一个类有用时，可以将其嵌入使用它的类中，保持代码在一起</li>
<li><strong>增强封装性</strong>：内部类可以访问外部类的私有成员，同时自身也可以对外部完全隐藏</li>
<li><strong>实现多重继承</strong>：通过内部类可以间接实现多重继承的效果</li>
<li><strong>回调机制</strong>：常用于事件处理和监听器实现</li>
<li><strong>代码简洁</strong>：特别是匿名内部类可以减少代码量</li>
</ul>
<p>::: info 内部类有哪些特点？<br>:::</p>
<ul>
<li>内部类可以访问外部类的所有成员（包括 private)</li>
<li>外部类需要通过实例化内部类来访问其成员</li>
<li>内部类编译后会生成独立的。class 文件（格式：<code>OuterClass$InnerClass.class</code>)</li>
<li>非静态内部类不能有静态成员（静态内部类可以）</li>
<li>内部类可以继承其他类或实现接口</li>
</ul>
<h3 id="【简单】为什么-Java-不支持多重继承？"><a href="#【简单】为什么-Java-不支持多重继承？" class="headerlink" title="【简单】为什么 Java 不支持多重继承？"></a>【简单】为什么 Java 不支持多重继承？</h3><p>Java 不支持多重继承的核心原因是<strong>为了避免【菱形继承问题（Diamond Problem）】</strong>。</p>
<p>::: info 什么是菱形继承问题？<br>:::</p>
<p>菱形继承存在歧义性：</p>
<ul>
<li>如果类 C 继承自类 A 和类 B，而 A 和 B 都有同名方法 <code>method()</code></li>
<li>调用 <code>C.method()</code> 时无法确定应该调用 A 还是 B 的版本</li>
</ul>
<p>由于菱形继承歧义性而引发的复杂性增加问题：</p>
<ul>
<li>多重继承会显著增加编译器和 JVM 的实现复杂度</li>
<li>方法调用、构造函数调用顺序变得难以确定</li>
</ul>
<p>::: info Java 如何解决多重继承？<br>:::</p>
<p>在 Java 中，类可以实现多个接口。接口提供多重继承的行为规范，但不包含具体实现。</p>
<p>JDK8 之后，接口支持默认方法（default），是不是又出现了菱形继承问题？</p>
<p>为了规避这个问题，Java 强制规定，如果多个接口存在相同的默认方法，子类必须重写这个方法。否则，编译器会报错。</p>
<h3 id="【中等】深拷贝和浅拷贝有什么区别？"><a href="#【中等】深拷贝和浅拷贝有什么区别？" class="headerlink" title="【中等】深拷贝和浅拷贝有什么区别？"></a>【中等】深拷贝和浅拷贝有什么区别？</h3><p>::: info 深拷贝和浅拷贝有什么区别？<br>:::</p>
<table>
<thead>
<tr>
<th align="left"><strong>关键点</strong></th>
<th align="left"><strong>浅拷贝</strong></th>
<th align="left"><strong>深拷贝</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>复制对象</strong></td>
<td align="left">只复制对象本身（基本类型值拷贝）</td>
<td align="left">递归复制对象及其引用的所有子对象</td>
</tr>
<tr>
<td align="left"><strong>引用类型字段</strong></td>
<td align="left">新旧对象共享同一引用（修改相互影响）</td>
<td align="left">创建全新引用对象（修改完全隔离）</td>
</tr>
<tr>
<td align="left"><strong>内存开销</strong></td>
<td align="left">小（仅复制一层）</td>
<td align="left">大（递归复制所有关联对象）</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">默认<code>Object.clone()</code></td>
<td align="left">需手动实现递归克隆&#x2F;序列化&#x2F;工具类</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">对象无可变引用字段</td>
<td align="left">对象含可变引用字段且需完全独立</td>
</tr>
</tbody></table>
<p><strong>本质区别</strong>：浅拷贝是”复制钥匙”，深拷贝是”复制钥匙+保险箱”。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>深拷贝需处理循环引用问题</li>
<li>推荐使用<code>SerializationUtils.clone()</code>或 JSON 序列化实现深拷贝</li>
<li>不可变对象（如 String）的浅拷贝是安全的</li>
</ul>
<p>::: info 深拷贝和浅拷贝实现方式有什么区别？<br>:::</p>
<p><strong>实现方式对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>浅拷贝</strong></th>
<th align="left"><strong>深拷贝</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Object.clone()</code></td>
<td align="left">✓</td>
<td align="left">✗</td>
<td align="left">默认浅拷贝</td>
</tr>
<tr>
<td align="left"><strong>手动递归克隆</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left">需所有引用类型实现<code>Cloneable</code></td>
</tr>
<tr>
<td align="left"><strong>序列化反序列化</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left">通过<code>ObjectOutputStream</code>实现</td>
</tr>
<tr>
<td align="left"><strong>工具类（Apache Commons）</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left"><code>SerializationUtils.clone()</code></td>
</tr>
</tbody></table>
<p>::: code-tabs#深拷贝和浅拷贝实现示例</p>
<p>@tab 浅拷贝实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// 引用类型字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone(); <span class="comment">// 默认浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person)p1.clone();</span><br><span class="line">p2.address.city = <span class="string">&quot;上海&quot;</span>; <span class="comment">// p1.address.city 也会变成&quot;上海&quot;</span></span><br></pre></td></tr></table></figure>

<p>@tab 深拷贝实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person)<span class="built_in">super</span>.clone();</span><br><span class="line">    cloned.address = (Address)address.clone(); <span class="comment">// 手动复制引用对象</span></span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address 类也需实现 Cloneable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="【简单】面向对象和面向过程有什么区别？"><a href="#【简单】面向对象和面向过程有什么区别？" class="headerlink" title="【简单】面向对象和面向过程有什么区别？"></a>【简单】面向对象和面向过程有什么区别？</h3><p>面向对象和面向过程的主要区别：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>面向对象（OOP）</th>
<th>面向过程（POP）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td>以<strong>对象</strong>为中心</td>
<td>以<strong>步骤</strong>为中心</td>
</tr>
<tr>
<td><strong>代码组织</strong></td>
<td>按<strong>现实实体</strong>抽象为类</td>
<td>按<strong>功能流程</strong>拆分为函数</td>
</tr>
<tr>
<td><strong>数据管理</strong></td>
<td>数据与行为封装在对象中</td>
<td>数据与函数独立</td>
</tr>
<tr>
<td><strong>扩展方式</strong></td>
<td>通过继承&#x2F;多态扩展（开闭原则）</td>
<td>需修改函数逻辑</td>
</tr>
<tr>
<td><strong>典型特性</strong></td>
<td>封装、继承、多态三大特性</td>
<td>无三大特性</td>
</tr>
<tr>
<td><strong>典型语言</strong></td>
<td>Java, Python, C++</td>
<td>C, Pascal</td>
</tr>
</tbody></table>
<h3 id="【中等】面向对象三大特征和五大原则是什么？"><a href="#【中等】面向对象三大特征和五大原则是什么？" class="headerlink" title="【中等】面向对象三大特征和五大原则是什么？"></a>【中等】面向对象三大特征和五大原则是什么？</h3><p>::: info 面向对象三大特征是什么？<br>:::</p>
<p><strong>面向对象三大特征：</strong></p>
<ul>
<li><p><strong>封装（Encapsulation）</strong> ：<strong>隐藏内部细节，暴露安全接口</strong>。</p>
<ul>
<li>用 <code>private</code> 保护数据，通过 <code>getter/setter</code> 控制访问</li>
<li>示例：<code>BankAccount</code> 类隐藏余额，提供 <code>deposit()</code>&#x2F;<code>withdraw()</code> 方法</li>
</ul>
</li>
<li><p><strong>继承（Inheritance）</strong> ：<strong>子类复用父类属性和方法</strong>。</p>
<ul>
<li>通过 <code>extends</code> 实现（如 <code>Dog extends Animal</code>）</li>
<li>注意：Java 是单继承（一个子类只能有一个父类）</li>
</ul>
</li>
<li><p><strong>多态（Polymorphism）</strong> ：<strong>同一行为的不同实现方式</strong>。</p>
<ul>
<li><strong>编译时多态</strong>：方法重载（<code>Overload</code>）</li>
<li><strong>运行时多态</strong>：方法重写（<code>Override</code>）+ 父类引用指向子类对象（如 <code>Animal a = new Dog(); a.sound();</code>）</li>
</ul>
</li>
</ul>
<p><strong>一言以概之</strong>：<strong>封装保证安全性，继承提高复用性，多态增强扩展性</strong>。</p>
<p>::: info 面向对象的五大原则是什么？<br>:::</p>
<p>面向对象的五大原则是 <strong>SOLID</strong> 原则：</p>
<ul>
<li><strong>单一职责原则 (SRP)<strong>：</strong>一个类只负责一个功能</strong>，避免职责过多导致代码臃肿。</li>
<li><strong>开闭原则 (OCP)<strong>：</strong>对扩展开放，对修改关闭</strong>。通过抽象和继承扩展功能，而非直接修改原有代码。</li>
<li><strong>里氏替换原则 (LSP)<strong>：</strong>子类必须能替换父类</strong>，确保继承关系不会破坏程序逻辑。</li>
<li><strong>接口隔离原则 (ISP)<strong>：</strong>接口应当小而专</strong>，避免臃肿接口强制实现不必要的方法。</li>
<li><strong>依赖倒置原则 (DIP)<strong>：</strong>依赖抽象而非具体</strong>，高层模块不直接依赖低层模块，而是通过接口或抽象类交互。</li>
</ul>
<p><strong>一言以概之</strong>：SOLID 原则让代码更灵活、可维护、易扩展。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>典型问题</strong></p>
<p>（1）你知道哪些设计模式？</p>
<p>（2）你知道哪些设计模式在 Java 源码中的应用案例？</p>
<p>（3）你知道哪些设计模式在主流框架中的应用案例？</p>
<p><strong>知识点</strong></p>
<p>（1）23 种经典设计模式分类如下：</p>
<ul>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<p>（2）设计模式在 Java 源码中应用的经典案例：</p>
<p>InputStream 是一个抽象类，标准类库中提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。</p>
<p>（3）设计模式在主流框架中应用的经典案例：</p>
<p>如 Spring 等如何在 API 设计中使用设计模式。你至少要有个大体的印象，如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">BeanFactory</a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationContext.java">ApplicationContext</a> 应用了工厂模式。</li>
<li>在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。</li>
<li>Spring Aop 使用了代理模式、装饰器模式、适配器模式等。</li>
<li>各种事件监听器，是观察者模式的典型应用。</li>
<li>类似 JdbcTemplate 等则是应用了模板模式。</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="【简单】Object-类的常见方法有哪些？"><a href="#【简单】Object-类的常见方法有哪些？" class="headerlink" title="【简单】Object 类的常见方法有哪些？"></a>【简单】Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>方法签名</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>默认行为</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String toString()</code></td>
<td align="left">返回对象的字符串表示</td>
<td align="left"><code>类名@十六进制哈希码</code>（如 <code>Person@1b6d3586</code>）</td>
</tr>
<tr>
<td align="left"><code>boolean equals(Object obj)</code></td>
<td align="left">比较两个对象是否逻辑相等</td>
<td align="left">比较内存地址（<code>==</code>）</td>
</tr>
<tr>
<td align="left"><code>int hashCode()</code></td>
<td align="left">返回对象的哈希码</td>
<td align="left">基于内存地址生成</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getClass()</code></td>
<td align="left">返回对象的运行时类（<code>Class</code> 对象）</td>
<td align="left">由 JVM 提供</td>
</tr>
<tr>
<td align="left"><code>protected Object clone()</code></td>
<td align="left">创建并返回对象的副本</td>
<td align="left">浅拷贝（需实现 <code>Cloneable</code> 接口）</td>
</tr>
<tr>
<td align="left"><code>protected void finalize()</code></td>
<td align="left">已废弃，对象被 GC 回收前调用</td>
<td align="left">空实现（不推荐使用）</td>
</tr>
<tr>
<td align="left"><code>void notify()</code></td>
<td align="left">唤醒一个等待该对象监视器的线程</td>
<td align="left">依赖 JVM 实现</td>
</tr>
<tr>
<td align="left"><code>void notifyAll()</code></td>
<td align="left">唤醒所有等待该对象监视器的线程</td>
<td align="left">依赖 JVM 实现</td>
</tr>
<tr>
<td align="left"><code>void wait()</code></td>
<td align="left">让当前线程等待，直到被唤醒</td>
<td align="left">必须在同步代码块中调用</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeout)</code></td>
<td align="left">让线程等待，最多 <code>timeout</code> 毫秒</td>
<td align="left">超时后自动唤醒</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeout, int nanos)</code></td>
<td align="left">更精确的等待（纳秒级）</td>
<td align="left">实际精度依赖系统</td>
</tr>
</tbody></table>
<h3 id="【简单】-和-equals-有什么区别？"><a href="#【简单】-和-equals-有什么区别？" class="headerlink" title="【简单】&#x3D;&#x3D; 和 equals() 有什么区别？"></a>【简单】&#x3D;&#x3D; 和 equals() 有什么区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong><code>==</code></strong></th>
<th align="left"><strong><code>equals()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本类型比较</strong></td>
<td align="left">比较<strong>值</strong></td>
<td align="left">不能比较</td>
</tr>
<tr>
<td align="left"><strong>引用类型比较</strong></td>
<td align="left">比较<strong>内存地址</strong></td>
<td align="left">默认比较<strong>内存地址</strong>（同 <code>==</code>），但可重写为逻辑比较（如内容是否相同）</td>
</tr>
<tr>
<td align="left"><strong>是否可重写</strong></td>
<td align="left">否（运算符，行为固定）</td>
<td align="left">是（可自定义比较逻辑）</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">快速判断基本类型值相等或引用是否指向同一对象</td>
<td align="left">判断对象逻辑是否相等（如内容、属性等）</td>
</tr>
</tbody></table>
<h3 id="【简单】为什么重写-equals-时必须重写-hashCode-方法？"><a href="#【简单】为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="【简单】为什么重写 equals() 时必须重写 hashCode() 方法？"></a>【简单】为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为 Java 规定：<strong>两个对象若<code>equals()</code>相等，它们的<code>hashCode()</code>必须相同</strong>。</p>
<p>如果违背，则哈希集合（如 <code>HashMap</code>、<code>HashSet</code>）无法正确去重或查找。</p>
<ul>
<li><code>HashMap</code>&#x2F;<code>HashSet</code> 先通过 <code>hashCode()</code> 快速定位数据，再用 <code>equals()</code> 精确匹配。</li>
<li>若 <code>hashCode()</code> 不一致，即使 <code>equals()</code> 为 <code>true</code>，集合会误判为不同对象。</li>
</ul>
<p>::: info 如何正确重写 <code>hashCode()</code>？<br>:::</p>
<ul>
<li>**<code>equals()</code>**：比较所有关键字段（如 <code>name</code>、<code>age</code>）。</li>
<li>**<code>hashCode()</code>**：用 <code>Objects.hash(字段1, 字段2)</code> 生成（确保与 <code>equals()</code> 字段一致）。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals() 的若干问题解答</a></p>
<p>:::</p>
<h3 id="【简单】finalize-有什么用？"><a href="#【简单】finalize-有什么用？" class="headerlink" title="【简单】finalize 有什么用？"></a>【简单】finalize 有什么用？</h3><p>一言以概之，**<code>finalize</code> 可用于对象销毁前的清理，但不可靠且性能差，现代 Java 开发应避免使用，改用 <code>AutoCloseable</code> 或 <code>Cleaner</code>。**</p>
<p>**Java 9+ 已弃用 <code>finalize</code>**，推荐使用：</p>
<ul>
<li><code>try-with-resources</code>（实现 <code>AutoCloseable</code> 接口）</li>
<li><code>Cleaner</code> 或 <code>PhantomReference</code>（更可控的清理机制）。</li>
</ul>
<p><strong><code>finalize</code> 的作用（Java）</strong> ：</p>
<ul>
<li><strong>对象被垃圾回收前的清理</strong>：在对象被 GC 回收前，<code>finalize()</code> 会被调用，可用于释放非内存资源（如文件句柄、数据库连接等）。</li>
<li><strong>最后的补救机会</strong>：如果对象未被正确关闭，<code>finalize</code> 提供最后一次资源释放的机会。</li>
</ul>
<p><strong><code>finalize</code> 的问题</strong> ：</p>
<ul>
<li><strong>不保证执行</strong>：JVM 不保证 <code>finalize</code> 一定会执行（如程序突然终止时）。即使对象可达性失效，GC 可能延迟回收，导致 <code>finalize</code> 延迟调用。</li>
<li><strong>性能开销</strong>：覆写 <code>finalize</code> 的对象会被 JVM 放入特殊队列，垃圾回收变慢。可能引发内存泄漏（如果 <code>finalize</code> 阻塞或执行过久）。</li>
<li><strong>安全问题</strong>：在 <code>finalize</code> 中抛出异常会导致清理中断，且异常被忽略。可能被恶意代码利用（如通过重写 <code>finalize</code> 复活对象，干扰 GC）。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="【简单】String、StringBuffer、StringBuilder-的区别？"><a href="#【简单】String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="【简单】String、StringBuffer、StringBuilder 的区别？"></a>【简单】String、StringBuffer、StringBuilder 的区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>String</strong></th>
<th align="left"><strong>StringBuffer</strong></th>
<th align="left"><strong>StringBuilder</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">❌ 不可变</td>
<td align="left">✅ 可变</td>
<td align="left">✅ 可变</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">✅（因不可变）</td>
<td align="left">✅（同步方法）</td>
<td align="left">❌（非线程安全）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">⚠️ 最差（频繁创建新对象）</td>
<td align="left">⚠️ 中等（同步开销）</td>
<td align="left">✅ 最高（无同步开销）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">常量、少量拼接</td>
<td align="left">多线程字符串操作</td>
<td align="left"><strong>单线程字符串操作（推荐）</strong></td>
</tr>
</tbody></table>
<p><strong>概括</strong></p>
<ul>
<li><strong>用 <code>String</code> 存储常量</strong>，<strong>用 <code>StringBuilder</code> 高效拼接（单线程）</strong>，<strong>用 <code>StringBuffer</code> 保证线程安全（多线程）</strong>。</li>
<li>**优先选 <code>StringBuilder</code>**（90%场景适用）。</li>
</ul>
<h3 id="【简单】String-为什么是不可变的？"><a href="#【简单】String-为什么是不可变的？" class="headerlink" title="【简单】String 为什么是不可变的？"></a>【简单】String 为什么是不可变的？</h3><p><code>String</code> 的不可变性是 Java 为安全、性能、线程安全做的核心设计。</p>
<p><strong>String 不可变的核心原因</strong>：</p>
<ul>
<li><strong><code>final</code> 修饰的 <code>char[]</code> 数组</strong>：Java 中 <code>String</code> 内部用 <code>private final char[]</code>（JDK 9+ 改为 <code>byte[]</code>）存储数据，数组引用和内容均不可修改。</li>
<li><strong>无修改内部状态的方法</strong>：所有看似“修改”的方法（如 <code>concat()</code>、<code>substring()</code>）都返回<strong>新 <code>String</code> 对象</strong>，原对象不变。</li>
</ul>
<p><strong>设计安全优化</strong></p>
<ul>
<li><strong>线程安全</strong>：不可变天然线程安全，无需同步。</li>
<li><strong>缓存哈希值</strong>：<code>String</code> 的 <code>hashCode()</code> 计算结果可缓存（因内容不变），提升性能（如 <code>HashMap</code> 的键）。</li>
<li><strong>字符串常量池复用</strong>：如 <code>String s = &quot;abc&quot;</code> 会复用常量池中的相同字符串，减少内存开销。</li>
</ul>
<p><strong>为什么这样设计</strong>：</p>
<ul>
<li><strong>安全</strong>：防止恶意修改（如网络请求参数、数据库连接字符串被篡改）。</li>
<li><strong>性能</strong>：哈希缓存、常量池复用提升效率。</li>
<li><strong>简单</strong>：避免多线程同步问题。</li>
</ul>
<p><strong>示例验证不可变性</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.concat(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 输出 &quot;Hello&quot;（原字符串未变）</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 输出 &quot;Hello World&quot;（新对象）</span></span><br></pre></td></tr></table></figure>

<h3 id="【简单】字符串拼接用“-”-还是-StringBuilder"><a href="#【简单】字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="【简单】字符串拼接用“+” 还是 StringBuilder?"></a>【简单】字符串拼接用“+” 还是 StringBuilder?</h3><p><strong>循环&#x2F;动态拼接 → <code>StringBuilder</code>；简单常量拼接 → “+”；多线程 → <code>StringBuffer</code>（极少用）。</strong><br><strong><code>StringBuilder</code> 是默认推荐选择！</strong></p>
<p><strong>优先用 <code>StringBuilder</code>（大多数场景）</strong></p>
<ul>
<li><strong>适用情况</strong>：循环、动态拼接、大量字符串操作。</li>
<li><strong>原因</strong>：<ul>
<li><strong>高性能</strong>：直接修改缓冲区，避免 <code>+</code> 频繁创建新对象。</li>
<li><strong>低内存开销</strong>：减少临时对象和 GC 压力。</li>
</ul>
</li>
</ul>
<p><strong>简单拼接可用 “+”（编译期优化）</strong></p>
<ul>
<li><strong>适用情况</strong>：少量<strong>固定字符串</strong>拼接（如 <code>&quot;a&quot; + &quot;b&quot;</code>）。</li>
<li><strong>原因</strong>：<ul>
<li><strong>代码简洁</strong>：可读性更好。</li>
<li><strong>编译器优化</strong>：JVM 自动合并为常量（如 <code>&quot;ab&quot;</code>），无性能损失。</li>
<li>通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的。</li>
<li>在循环内使用“+”，会导致创建过多的 <code>StringBuilder</code> 对象。JDK9 中，优化了这个问题，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</li>
</ul>
</li>
</ul>
<p><strong>多线程拼接用 <code>StringBuffer</code>（极少需要）</strong></p>
<ul>
<li><strong>适用情况</strong>：多线程环境且需线程安全（通常局部变量仍可用 <code>StringBuilder</code>）。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7182872058743750715">StringBuilder？来重温一下字符串拼接吧</a> 。</p>
<p>:::</p>
<h3 id="【简单】String-equals-和-Object-equals-有何区别？"><a href="#【简单】String-equals-和-Object-equals-有何区别？" class="headerlink" title="【简单】String#equals() 和 Object#equals() 有何区别？"></a>【简单】String#equals() 和 Object#equals() 有何区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong><code>Object#equals()</code></strong></th>
<th align="left"><strong><code>String#equals()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>默认行为</strong></td>
<td align="left">比较<strong>内存地址</strong>（<code>==</code>）</td>
<td align="left">比较<strong>字符串内容</strong>（逐字符对比）</td>
</tr>
<tr>
<td align="left"><strong>重写目的</strong></td>
<td align="left">需子类自行重写以实现逻辑相等</td>
<td align="left">已优化为内容比较，满足字符串业务需求</td>
</tr>
<tr>
<td align="left"><strong>性能影响</strong></td>
<td align="left">无额外开销</td>
<td align="left">需遍历字符数组，但优先检查地址和长度</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">通用对象比较（默认不满足内容相等）</td>
<td align="left">字符串内容对比（如 <code>&quot;abc&quot;.equals(&quot;abc&quot;)</code>）</td>
</tr>
</tbody></table>
<h3 id="【简单】字符串常量池有什么用？"><a href="#【简单】字符串常量池有什么用？" class="headerlink" title="【简单】字符串常量池有什么用？"></a>【简单】字符串常量池有什么用？</h3><p>字符串常量池是JVM 的特殊内存区域，用于存储字符串字面量（如 <code>&quot;abc&quot;</code>），确保相同内容的字符串只存一份。</p>
<p><strong>字符串常量池通过复用相同字符串，节省内存并提升性能，直接赋值（<code>&quot;abc&quot;</code>）优先使用池，<code>new String()</code> 强制创建新对象。</strong></p>
<p>字符串常量池的作用有：</p>
<p><strong>节省内存</strong>：相同字符串复用，避免重复创建（如 <code>String s1 = &quot;hello&quot;</code> 和 <code>String s2 = &quot;hello&quot;</code> 指向同一对象）。</p>
<p><strong>提升性能</strong>：</p>
<ul>
<li><strong>快速比较</strong>：直接通过 <code>==</code> 判断地址是否相同（比 <code>equals()</code> 更快）。</li>
<li><strong>哈希优化</strong>：如 <code>HashMap</code> 的键可复用缓存的 <code>hashCode</code>。</li>
</ul>
<p><strong>实现规则</strong></p>
<ul>
<li><strong>直接赋值</strong>（<code>String s = &quot;abc&quot;</code>）→ <strong>优先从常量池引用</strong>。</li>
<li><strong><code>new String(&quot;abc&quot;)</code></strong> → <strong>强制在堆中创建新对象</strong>（不推荐，除非需隔离实例）。</li>
<li><strong><code>intern()</code> 方法</strong> → 将堆中的字符串对象添加到常量池（若池中不存在）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>**避免滥用 <code>new String()</code>**：无特殊需求时，直接用字面量赋值。</li>
<li><strong><code>intern()</code> 慎用</strong>：可能增加常量池内存压力，需权衡性能。</li>
</ul>
<h3 id="【简单】String-s-new-String-abc-创建了几个字符串对象？"><a href="#【简单】String-s-new-String-abc-创建了几个字符串对象？" class="headerlink" title="【简单】String s = new String(&quot;abc&quot;) 创建了几个字符串对象？"></a>【简单】<code>String s = new String(&quot;abc&quot;)</code> 创建了几个字符串对象？</h3><p><code>new String(&quot;abc&quot;)</code> 可能创建1~2个对象（取决于常量池是否已存在”abc”），但堆中的新对象必定创建。</p>
<ul>
<li><strong>常量池已存在”abc”<strong>：</strong>1个对象</strong>（仅堆中的 <code>new String</code>）</li>
<li><strong>常量池不存在”abc”<strong>：</strong>2个对象</strong>（常量池的”abc” + 堆中的 <code>new String</code>）</li>
</ul>
<h3 id="【简单】String-intern-方法有什么用？"><a href="#【简单】String-intern-方法有什么用？" class="headerlink" title="【简单】String#intern 方法有什么用？"></a>【简单】String#intern 方法有什么用？</h3><p>String#intern 方法的<strong>作用</strong>有：</p>
<ul>
<li><strong>强制字符串入池</strong>：将堆中的 <code>String</code> 对象添加到字符串常量池（若池中不存在）</li>
<li><strong>返回池中引用</strong>：保证相同内容的字符串始终返回同一内存地址</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><strong>JDK7+ 优化</strong>：常量池从方法区移至堆内存，减少内存溢出风险。</li>
<li><strong>慎用场景</strong>：<ul>
<li>避免对动态生成的短生命周期字符串使用（可能导致池膨胀）</li>
<li>优先用于高频使用的静态字符串（如配置键值）</li>
</ul>
</li>
</ul>
<h3 id="【简单】String-类型的变量和常量做“-”运算时会发生什么？"><a href="#【简单】String-类型的变量和常量做“-”运算时会发生什么？" class="headerlink" title="【简单】String 类型的变量和常量做“+”运算时会发生什么？"></a>【简单】String 类型的变量和常量做“+”运算时会发生什么？</h3><p><strong>常量相加编译期优化，变量相加隐式转 <code>StringBuilder</code>，循环拼接必须显式使用 <code>StringBuilder</code> 避免性能损耗。</strong></p>
<p><strong>常量折叠（编译期优化）</strong></p>
<ul>
<li><strong>纯常量运算</strong>（如 <code>&quot;a&quot;+&quot;b&quot;</code>）→ 直接合并为 <code>&quot;ab&quot;</code>，仅存于常量池</li>
<li><strong>final 变量</strong> 视为常量，同样触发优化</li>
</ul>
<p><strong>变量拼接（运行时行为）</strong></p>
<ul>
<li><strong>含变量的运算</strong>（如 <code>str + &quot;b&quot;</code>）→ 隐式转换为 <code>StringBuilder</code> 操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际执行逻辑</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).append(<span class="string">&quot;b&quot;</span>).toString()</span><br></pre></td></tr></table></figure></li>
<li><strong>每次运算</strong> 生成临时 <code>StringBuilder</code> 和最终 <code>String</code> 对象</li>
</ul>
<p><strong>性能关键差异</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>内存&#x2F;性能表现</th>
<th>优化建议</th>
</tr>
</thead>
<tbody><tr>
<td>常量+常量</td>
<td>零运行时开销</td>
<td>无需处理</td>
</tr>
<tr>
<td>单次变量+常量</td>
<td>1次 <code>StringBuilder</code> 创建</td>
<td>可接受</td>
</tr>
<tr>
<td><strong>循环内拼接</strong></td>
<td>多次创建 <code>StringBuilder</code>（性能陷阱）</td>
<td><strong>必须显式用 <code>StringBuilder</code></strong></td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ul>
<li><p><strong>简单拼接</strong>：直接使用 <code>+</code>（可读性优先）</p>
</li>
<li><p><strong>循环&#x2F;批量拼接</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确写法</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String str : list) sb.append(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误写法（低效）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (String str : list) s += str; <span class="comment">// 每次循环隐式新建 StringBuilder</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/13b714a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/13b714a7/" class="post-title-link" itemprop="url">Java 容器面试一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-容器面试一"><a href="#Java-容器面试一" class="headerlink" title="Java 容器面试一"></a>Java 容器面试一</h1><h2 id="Java-容器简介"><a href="#Java-容器简介" class="headerlink" title="Java 容器简介"></a>Java 容器简介</h2><h3 id="【简单】Java-中有哪些集合类？"><a href="#【简单】Java-中有哪些集合类？" class="headerlink" title="【简单】Java 中有哪些集合类？"></a>【简单】Java 中有哪些集合类？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/java-container-structure.png" alt="img"></p>
<p>Java 容器类主要位于 <code>java.util</code> 包，分为 <strong>Collection</strong> 和 <strong>Map</strong> 两大类：</p>
<ul>
<li><strong>Collection（存储独立元素）</strong><ul>
<li><strong>List（有序、可重复）</strong><ul>
<li><strong>ArrayList</strong>：基于 <code>Object[]</code> 动态数组，查询快，增删慢</li>
<li><strong>LinkedList</strong>：基于<strong>双链表</strong>（JDK1.6 前是循环链表，1.7 取消循环），增删快，查询慢</li>
<li><strong>Vector</strong>：线程安全的 <code>Object[]</code> 动态数组（已过时，推荐 <code>ArrayList</code> + <code>Collections.synchronizedList</code>）</li>
</ul>
</li>
<li><strong>Set（无序、不可重复）</strong><ul>
<li><strong>HashSet</strong>：基于 <code>HashMap</code> 实现，不保证顺序</li>
<li><strong>LinkedHashSet</strong>：基于 <code>LinkedHashMap</code>，维护<strong>插入顺序</strong></li>
<li><strong>TreeSet</strong>：基于 <code>TreeMap</code>，支持<strong>自然排序</strong>或<strong>自定义 <code>Comparator</code></strong></li>
</ul>
</li>
<li><strong>Queue（队列，FIFO 或优先级）</strong><ul>
<li><strong>ArrayDeque</strong>：基于动态数组，实现<strong>栈和队列</strong></li>
<li><strong>PriorityQueue</strong>：基于堆，<strong>优先级队列</strong>（按 <code>Comparator</code> 排序）</li>
<li><strong>LinkedList</strong>：也可作为队列&#x2F;双端队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map（键值对存储）</strong><ul>
<li><strong>HashMap</strong>：基于哈希表，<strong>无序</strong>，查找高效（最常用）</li>
<li><strong>LinkedHashMap</strong>：继承 <code>HashMap</code>，额外维护<strong>双向链表</strong>，保持<strong>插入顺序</strong>或<strong>访问顺序</strong></li>
<li><strong>TreeMap</strong>：基于红黑树，<strong>键有序</strong>（自然排序或 <code>Comparator</code>）</li>
<li><strong>Hashtable</strong>：线程安全（<code>synchronized</code> 修饰方法），但性能差，已被 <code>ConcurrentHashMap</code> 取代</li>
<li><strong>ConcurrentHashMap</strong>：分段锁（JDK7）或 CAS + <code>synchronized</code>（JDK8+），高并发优化</li>
</ul>
</li>
<li><strong>工具类</strong><ul>
<li><strong>Collections</strong>：提供集合操作（排序、查找、同步化等）</li>
<li><strong>Arrays</strong>：提供数组操作（排序、二分查找等）</li>
<li><strong>Stream（Java 8+）</strong>：支持函数式编程的流式处理</li>
</ul>
</li>
</ul>
<p><strong>关键区别</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>主要实现类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>List</strong></td>
<td>有序、可重复</td>
<td><code>ArrayList</code>、<code>LinkedList</code></td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>无序、不可重复</td>
<td><code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></td>
</tr>
<tr>
<td><strong>Queue</strong></td>
<td>队列&#x2F;栈</td>
<td><code>ArrayDeque</code>、<code>PriorityQueue</code></td>
</tr>
<tr>
<td><strong>Map</strong></td>
<td>键值对</td>
<td><code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code></td>
</tr>
</tbody></table>
<p><strong>线程安全</strong>：</p>
<ul>
<li>单线程：<code>ArrayList</code>、<code>HashMap</code></li>
<li>多线程：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code></li>
</ul>
<h3 id="【简单】Comparable-和-Comparator-有什么区别？"><a href="#【简单】Comparable-和-Comparator-有什么区别？" class="headerlink" title="【简单】Comparable 和 Comparator 有什么区别？"></a>【简单】Comparable 和 Comparator 有什么区别？</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用。</p>
<ul>
<li><strong>Comparable</strong> → “我能比较”（类自己实现的比较能力）</li>
<li><strong>Comparator</strong> → “比较器”（外部提供的比较工具）</li>
</ul>
<p>两者通常一起使用，为Java对象提供灵活多样的排序能力。</p>
<p><strong>Comparable vs. Comparator</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody><tr>
<td><strong>包位置</strong></td>
<td>java.lang</td>
<td>java.util</td>
</tr>
<tr>
<td><strong>接口方法</strong></td>
<td>compareTo(T o)</td>
<td>compare(T o1, T o2)</td>
</tr>
<tr>
<td><strong>排序逻辑位置</strong></td>
<td>定义在要排序的类内部</td>
<td>定义在单独的类或匿名类中</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>类的”自然排序”</td>
<td>多种排序方式或无法修改类时的排序</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><code>Collections.sort(list)</code></td>
<td><code>Collections.sort(list, comparator)</code></td>
</tr>
<tr>
<td><strong>影响范围</strong></td>
<td>修改类的原始定义</td>
<td>不修改原有类</td>
</tr>
</tbody></table>
<p><strong>设计目的不同</strong></p>
<ul>
<li><code>Comparable</code>：定义对象的<strong>自然排序</strong>（如String按字母顺序，Integer按数值大小）</li>
<li><code>Comparator</code>：定义<strong>多种排序策略</strong>或为无法修改源代码的类提供排序</li>
</ul>
<p><strong>实现方式不同</strong></p>
<ul>
<li><code>Comparable</code>：需要修改类本身，实现<code>compareTo()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Comparator</code>：独立实现，通常使用匿名类或lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; byName = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());</span><br></pre></td></tr></table></figure>

<p><strong>使用场景选择</strong></p>
<ul>
<li>用<code>Comparable</code>当：<ul>
<li>类有明确的自然排序标准</li>
<li>你能修改类的源代码</li>
<li>只需要一种主要排序方式</li>
</ul>
</li>
<li>用<code>Comparator</code>当：<ul>
<li>需要多种排序方式（如按姓名、年龄、工资等）</li>
<li>不能修改类的源代码（如第三方库的类）</li>
<li>需要临时或特殊的排序规则</li>
</ul>
</li>
</ul>
<p><strong>Java 8+的便利支持</strong></p>
<ul>
<li>Comparator提供了许多方便的静态方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多级排序</span></span><br><span class="line">Comparator&lt;Person&gt; comparator =</span><br><span class="line">    Comparator.comparing(Person::getLastName)</span><br><span class="line">              .thenComparing(Person::getFirstName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序排序</span></span><br><span class="line">Comparator&lt;Person&gt; reverseAge =</span><br><span class="line">    Comparator.comparingInt(Person::getAge).reversed();</span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="【简单】ArrayList-和-Array（数组）的区别？"><a href="#【简单】ArrayList-和-Array（数组）的区别？" class="headerlink" title="【简单】ArrayList 和 Array（数组）的区别？"></a>【简单】ArrayList 和 Array（数组）的区别？</h3><p><strong>ArrayList vs. 数组</strong></p>
<table>
<thead>
<tr>
<th><strong>对比点</strong></th>
<th><strong>数组 (Array)</strong></th>
<th><strong>ArrayList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>长度可变性</strong></td>
<td>固定长度，创建后无法调整大小</td>
<td>动态扩容（默认扩容1.5倍）</td>
</tr>
<tr>
<td><strong>存储类型</strong></td>
<td>支持基本类型（<code>int[]</code>）和对象类型</td>
<td>仅支持引用类型（基本类型需装箱，如 <code>Integer</code>）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（无额外对象开销）</td>
<td>有额外内存开销（记录大小、扩容预留空间等）</td>
</tr>
<tr>
<td><strong>访问方式</strong></td>
<td>通过索引直接访问（<code>arr[0]</code>）</td>
<td>通过 <code>get(index)</code>&#x2F;<code>set(index)</code> 方法访问</td>
</tr>
<tr>
<td><strong>操作效率</strong></td>
<td>- 查询：O(1)（极快）<br>- 增删：O(n)（需移动元素）</td>
<td>- 查询：O(1)（底层是数组）<br>- 增删：<br> - 尾部操作：O(1)<br> - 中间操作：O(n)（需移动元素）</td>
</tr>
<tr>
<td><strong>功能方法</strong></td>
<td>功能简单（依赖 <code>Arrays</code> 工具类）</td>
<td>提供丰富方法（<code>add()</code>、<code>remove()</code>、<code>contains()</code> 等）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全（需用 <code>Collections.synchronizedList</code> 包装）</td>
</tr>
<tr>
<td><strong>泛型支持</strong></td>
<td>不支持泛型（类型检查在运行时）</td>
<td>支持泛型（编译时类型安全）</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：</p>
<ul>
<li><strong>动态性</strong>：<code>ArrayList</code> 自动扩容，数组长度固定。</li>
<li><strong>类型支持</strong>：数组可直接存基本类型，<code>ArrayList</code> 需包装类。</li>
<li><strong>性能</strong>：<ul>
<li>数组的随机访问稍快（少一次方法调用）。</li>
<li><code>ArrayList</code> 的尾部插入高效，但中间插入&#x2F;删除需移动元素。</li>
</ul>
</li>
<li><strong>功能</strong>：<code>ArrayList</code> 提供更多便捷方法（如迭代、搜索）。</li>
<li><strong>内存</strong>：数组更节省内存，<code>ArrayList</code> 有额外结构开销。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>选数组</strong>：需极致性能、固定长度或存储基本类型时（如数学计算）。</li>
<li><strong>选ArrayList</strong>：需要动态大小、便捷操作或泛型安全时（大多数业务场景）。</li>
</ul>
<h3 id="【简单】ArrayList-可以添加-null-值吗？"><a href="#【简单】ArrayList-可以添加-null-值吗？" class="headerlink" title="【简单】ArrayList 可以添加 null 值吗？"></a>【简单】ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> <strong>可以添加任意数量的 <code>null</code> 值</strong>，包括重复 <code>null</code>，但需谨慎处理潜在的空指针问题。</p>
<p><code>ArrayList</code>底层基于 <code>Object[]</code> 数组实现，天然支持 <code>null</code>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>**可能引发 <code>NullPointerException</code>**：<ul>
<li>直接调用 <code>null</code> 的方法（如 <code>list.get(0).length()</code>）会报错。</li>
<li>使用 <code>contains(null)</code> 或遍历时需判空。</li>
</ul>
</li>
<li><strong>慎用于特定场景</strong>：如数据库映射、JSON 序列化工具可能对 <code>null</code> 有特殊限制。</li>
</ul>
<p><strong>与其他容器对比</strong>：</p>
<ul>
<li><strong>HashSet</strong>：允许一个 <code>null</code>。</li>
<li><strong>TreeSet</strong>：若用自然排序，添加 <code>null</code> 会抛 <code>NullPointerException</code>。</li>
<li><strong>HashMap</strong>：允许 <code>null</code> 键和值。</li>
<li><strong>Hashtable</strong>：禁止 <code>null</code> 键和值。</li>
</ul>
<p><strong>建议</strong>：</p>
<ul>
<li>明确是否需要 <code>null</code>，避免滥用导致代码健壮性问题。</li>
<li>必要时用 <code>Optional</code> 或默认值替代 <code>null</code>。</li>
</ul>
<h3 id="【简单】ArrayList-和-LinkedList-有什么区别？"><a href="#【简单】ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="【简单】ArrayList 和 LinkedList 有什么区别？"></a>【简单】ArrayList 和 LinkedList 有什么区别？</h3><p><strong><code>ArrayList</code> vs. <code>LinkedList</code></strong></p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>ArrayList</strong></th>
<th><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td>动态数组（<code>Object[]</code>）</td>
<td>双向链表（<code>Node</code> 节点）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（连续内存）</td>
<td>更高（每个元素需额外存储前后节点指针）</td>
</tr>
<tr>
<td><strong>随机访问性能</strong></td>
<td>⚡ **O(1)**（通过索引直接访问）</td>
<td>🐢 **O(n)**（需遍历链表）</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除性能</strong></td>
<td>- 尾部操作：⚡ <strong>O(1)</strong><br>- 中间&#x2F;头部操作：🐢 **O(n)**（需移动元素）</td>
<td>- 头尾操作：⚡ <strong>O(1)</strong><br>- 中间操作：🐢 **O(n)**（需遍历定位）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 频繁随机访问<br>- 数据量稳定或尾部操作多</td>
<td>- 频繁头尾插入&#x2F;删除<br>- 数据动态性强</td>
</tr>
<tr>
<td><strong>额外功能</strong></td>
<td>仅基础列表操作</td>
<td>实现了 <code>Deque</code> 接口（可作队列&#x2F;栈使用）</td>
</tr>
<tr>
<td><strong>空间局部性</strong></td>
<td>✅ 更好（CPU 缓存友好）</td>
<td>❌ 较差（节点分散存储）</td>
</tr>
</tbody></table>
<p><strong>对比小结</strong>：<br>List<code> 需遍历链表。 2. **增删效率**：</code>ArrayList<code> 尾部插入快，中间/头部插入慢；</code>Lin</p>
<ol>
<li><strong>访问速度</strong>：<code>ArrayList</code> 随机访问极快（数组索引），<code>LinkedkedList</code> 头尾插入快，中间插入仍需遍历。</li>
<li><strong>内存开销</strong>：<code>LinkedList</code> 每个元素多消耗 2 个指针空间（前驱+后继）。</li>
<li><strong>功能扩展</strong>：<code>LinkedList</code> 支持队列&#x2F;栈操作（如 <code>addFirst()</code>, <code>pollLast()</code>）。</li>
</ol>
<p><strong>选型建议</strong>：</p>
<ul>
<li>优先用 **<code>ArrayList</code>**（大多数场景性能更优）。</li>
<li>仅当需要频繁在 <strong>头部&#x2F;中间插入删除</strong>，或需要 <strong>队列&#x2F;栈功能</strong> 时选 <code>LinkedList</code>。</li>
</ul>
<blockquote>
<p>💡 <strong>Java 实践提示</strong>：</p>
<ul>
<li>默认情况下，<code>Collections.synchronizedList</code> 包装的 <code>ArrayList</code> 比 <code>LinkedList</code> 线程安全开销更低。</li>
<li>Java 8+ 的 <code>Stream</code> 操作在 <code>ArrayList</code> 上效率更高。</li>
</ul>
</blockquote>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="【简单】HashSet、LinkedHashSet-和-TreeSet-有什么区别？"><a href="#【简单】HashSet、LinkedHashSet-和-TreeSet-有什么区别？" class="headerlink" title="【简单】HashSet、LinkedHashSet 和 TreeSet 有什么区别？"></a>【简单】HashSet、LinkedHashSet 和 TreeSet 有什么区别？</h3><table>
<thead>
<tr>
<th>特性</th>
<th>HashSet</th>
<th>LinkedHashSet</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层实现</strong></td>
<td>哈希表 (HashMap)</td>
<td>哈希表 + 链表</td>
<td>红黑树</td>
</tr>
<tr>
<td><strong>排序保证</strong></td>
<td>无顺序</td>
<td>插入顺序</td>
<td>自然顺序&#x2F;自定义排序</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>添加&#x2F;删除&#x2F;查找: O(1)</td>
<td>添加&#x2F;删除&#x2F;查找: O(1)</td>
<td>添加&#x2F;删除&#x2F;查找: O(log n)</td>
</tr>
<tr>
<td><strong>允许null元素</strong></td>
<td>允许1个null</td>
<td>允许1个null</td>
<td>不允许(除非自定义Comparator允许)</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>性能特点</strong></td>
<td>最快的基础操作</td>
<td>比HashSet稍慢但保持顺序</td>
<td>最慢但自动排序</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>只需唯一性不关心顺序</td>
<td>需要保持插入顺序</td>
<td>需要排序的集合</td>
</tr>
</tbody></table>
<p><strong>顺序特性</strong></p>
<ul>
<li><code>HashSet</code>：完全不保证任何顺序（基于哈希值存储）</li>
<li><code>LinkedHashSet</code>：维护元素<strong>插入顺序</strong>（迭代时按插入顺序返回）</li>
<li><code>TreeSet</code>：根据元素的<strong>自然顺序</strong>或<strong>Comparator</strong>进行排序</li>
</ul>
<p><strong>性能比较</strong></p>
<ul>
<li><strong>操作速度</strong>：HashSet ≈ LinkedHashSet &gt; TreeSet</li>
<li><strong>内存占用</strong>：LinkedHashSet &gt; HashSet &gt; TreeSet</li>
<li><strong>迭代性能</strong>：LinkedHashSet最优（顺序访问快）</li>
</ul>
<p><strong>实现原理</strong></p>
<ul>
<li><code>HashSet</code>：基于HashMap实现，只使用键</li>
<li><code>LinkedHashSet</code>：继承HashSet，通过链表维护插入顺序</li>
<li><code>TreeSet</code>：基于TreeMap实现（红黑树结构）</li>
</ul>
<p><strong>构造方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet</span></span><br><span class="line">Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet</span></span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet - 自然排序</span></span><br><span class="line">Set&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet - 自定义排序</span></span><br><span class="line">Set&lt;String&gt; customTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p><strong>使用场景建议</strong></p>
<ul>
<li>需要<strong>最快查询</strong>且不关心顺序 → HashSet</li>
<li>需要<strong>保持插入顺序</strong> → LinkedHashSet</li>
<li>需要<strong>自动排序</strong>或<strong>范围查询</strong> → TreeSet</li>
<li>需要<strong>频繁迭代</strong> → LinkedHashSet</li>
</ul>
<p><strong>特殊注意事项</strong></p>
<ul>
<li><p><strong>相等性判断</strong>：</p>
<ul>
<li>三者都使用<code>equals()</code>方法判断元素是否相同</li>
<li>TreeSet同时会使用<code>compareTo()</code>或<code>compare()</code>方法（必须与equals逻辑一致）</li>
</ul>
</li>
<li><p><strong>TreeSet排序规则</strong>：</p>
<ul>
<li>元素必须实现<code>Comparable</code>接口，或在构造时提供<code>Comparator</code></li>
<li>否则会抛出<code>ClassCastException</code></li>
</ul>
</li>
<li><p><strong>线程安全替代方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; syncSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; syncTreeSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<p>选择哪种Set实现取决于你的具体需求：要速度（HashSet）、要插入顺序（LinkedHashSet）还是要自动排序（TreeSet）。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="【简单】Queue-与-Deque-有什么区别？"><a href="#【简单】Queue-与-Deque-有什么区别？" class="headerlink" title="【简单】Queue 与 Deque 有什么区别？"></a>【简单】Queue 与 Deque 有什么区别？</h3><p>::: info Queue vs. Deque<br>:::</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Queue (队列)</th>
<th>Deque (双端队列)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>进出原则</strong></td>
<td>先进先出 (FIFO)</td>
<td>两端都可进出 (FIFO + LIFO)</td>
</tr>
<tr>
<td><strong>主要操作</strong></td>
<td>队尾入队(add&#x2F;offer)，队首出队(remove&#x2F;poll)</td>
<td>支持队首&#x2F;队尾的入队和出队操作</td>
</tr>
<tr>
<td><strong>继承关系</strong></td>
<td>基础接口</td>
<td>继承自 Queue 接口</td>
</tr>
<tr>
<td><strong>代表子类</strong></td>
<td>LinkedList, PriorityQueue</td>
<td>ArrayDeque, LinkedList</td>
</tr>
<tr>
<td><strong>特殊功能</strong></td>
<td>-</td>
<td>支持栈操作(push&#x2F;pop&#x2F;peek)</td>
</tr>
</tbody></table>
<p><strong>基本操作对比</strong></p>
<p>::: code-tabs#重载和重写的示例</p>
<p>@tab <strong>Queue 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue.offer(e);  <span class="comment">// 队尾添加（推荐）</span></span><br><span class="line">queue.add(e);    <span class="comment">// 队尾添加（可能抛异常）</span></span><br><span class="line">queue.poll();    <span class="comment">// 队首移除并返回（推荐）</span></span><br><span class="line">queue.remove();  <span class="comment">// 队首移除并返回（可能抛异常）</span></span><br><span class="line">queue.peek();    <span class="comment">// 查看队首（不移除）</span></span><br><span class="line">queue.element(); <span class="comment">// 查看队首（可能抛异常）</span></span><br></pre></td></tr></table></figure>

<p>@tab <strong>Deque 扩展操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队首操作</span></span><br><span class="line">deque.offerFirst(e);  deque.addFirst(e);</span><br><span class="line">deque.pollFirst();    deque.removeFirst();</span><br><span class="line">deque.peekFirst();    deque.getFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾操作</span></span><br><span class="line">deque.offerLast(e);   deque.addLast(e);</span><br><span class="line">deque.pollLast();     deque.removeLast();</span><br><span class="line">deque.peekLast();     deque.getLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈操作</span></span><br><span class="line">deque.push(e);        <span class="comment">// = addFirst(e)</span></span><br><span class="line">deque.pop();          <span class="comment">// = removeFirst()</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<p><strong>使用场景差异</strong></p>
<ul>
<li><strong>Queue 适用场景（标准的先进先出场景）</strong>：<ul>
<li>任务调度系统（先来先服务）</li>
<li>消息队列（生产者-消费者模型）</li>
<li>广度优先搜索（BFS）</li>
</ul>
</li>
<li><strong>Deque 适用场景（需要两端操作的场景）</strong>：<ul>
<li>撤销操作历史（两端添加，一端移除）</li>
<li>滑动窗口算法</li>
<li>可同时作为队列和栈使用</li>
<li>工作窃取算法（如ForkJoinPool使用Deque）</li>
<li>实现高效的头尾操作（ArrayDeque比LinkedList更高效）</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li>需要<strong>标准队列行为</strong> → 选择 Queue</li>
<li>需要<strong>两端操作</strong>或<strong>栈功能</strong> → 选择 Deque</li>
<li>需要<strong>优先级排序</strong> → 使用 PriorityQueue（Queue实现）</li>
<li>追求<strong>高性能</strong> → 优先考虑 ArrayDeque（优于 LinkedList）</li>
</ul>
</blockquote>
<p><strong>性能特点</strong></p>
<ul>
<li><code>ArrayDeque</code>（Deque实现）比<code>LinkedList</code>：<ul>
<li>内存更紧凑（数组实现）</li>
<li>大多数操作更高效（O(1)时间）</li>
<li>但不适合频繁的中间插入&#x2F;删除</li>
</ul>
</li>
<li><code>PriorityQueue</code>（Queue实现）：<ul>
<li>基于堆结构</li>
<li>保证每次取出的都是优先级最高的元素（O(log n)时间）</li>
</ul>
</li>
</ul>
<p><strong>线程安全注意</strong></p>
<ul>
<li>两者主要实现类（LinkedList&#x2F;ArrayDeque）都<strong>非线程安全</strong></li>
<li>线程安全替代方案：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; safeQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">Deque&lt;String&gt; safeDeque = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="【简单】ArrayDeque-与-LinkedList-有什么区别？"><a href="#【简单】ArrayDeque-与-LinkedList-有什么区别？" class="headerlink" title="【简单】ArrayDeque 与 LinkedList 有什么区别？"></a>【简单】ArrayDeque 与 LinkedList 有什么区别？</h3><ul>
<li>**性能优先选 <code>ArrayDeque</code>**：队列&#x2F;栈场景，追求更高吞吐和更低内存。</li>
<li>**功能灵活选 <code>LinkedList</code>**：需要中间操作、随机访问或混合数据结构时。</li>
</ul>
<p>以下是 <strong>ArrayDeque</strong> 和 <strong>LinkedList</strong> 的对比表格，清晰概括两者的核心差异：</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>ArrayDeque</strong></th>
<th><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td>动态数组（循环数组）</td>
<td>双向链表</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更低（连续存储，无节点开销）</td>
<td>更高（每个元素需存储前后节点引用）</td>
</tr>
<tr>
<td><strong>头部&#x2F;尾部操作</strong></td>
<td><code>O(1)</code>，常数时间更优</td>
<td><code>O(1)</code>，但实际更慢（需操作节点）</td>
</tr>
<tr>
<td><strong>中间插入&#x2F;删除</strong></td>
<td><code>O(n)</code>（需移动元素）</td>
<td><code>O(1)</code>（已知位置时）</td>
</tr>
<tr>
<td><strong>随机访问</strong></td>
<td>理论上 <code>O(1)</code>，但通常不支持直接索引操作</td>
<td><code>O(n)</code>（需遍历链表）</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>动态扩容（默认翻倍），扩容时有开销</td>
<td>无扩容概念，按需分配节点</td>
</tr>
<tr>
<td><strong>功能支持</strong></td>
<td>仅双端队列操作（<code>Deque</code>）</td>
<td>同时实现 <code>List</code> 和 <code>Deque</code>，支持索引和中间操作</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>迭代效率</strong></td>
<td>更高（连续内存访问）</td>
<td>较低（非连续内存访问）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高频双端操作（如栈、队列）</td>
<td>需要中间操作或混合 <code>List/Deque</code> 需求的场景</td>
</tr>
</tbody></table>
<h3 id="【简单】PriorityQueue-有什么用？"><a href="#【简单】PriorityQueue-有什么用？" class="headerlink" title="【简单】PriorityQueue 有什么用？"></a>【简单】PriorityQueue 有什么用？</h3><p>PriorityQueue 是自动排序的堆结构队列，默认小顶堆，适用优先级调度，但线程不安全。</p>
<p><strong>基本特性</strong></p>
<ul>
<li><strong>基于堆（默认小顶堆）</strong>，元素按优先级出队（最小&#x2F;最大值先出）。</li>
<li><strong>无界队列</strong>（自动扩容），但初始容量为 <code>11</code>。</li>
<li>**不允许 <code>null</code>**，且元素需实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
</ul>
<p><strong>关键操作</strong>  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(E e)</code> &#x2F; <code>offer(E e)</code></td>
<td>O(log n)</td>
<td>插入元素，触发堆调整。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>O(log n)</td>
<td>移除并返回队首（优先级最高）。</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>O(1)</td>
<td>查看队首但不移除。</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>O(n)</td>
<td>删除指定元素（需遍历堆）。</td>
</tr>
</tbody></table>
<p><strong>排序规则</strong></p>
<ul>
<li><strong>默认自然排序</strong>（元素需实现 <code>Comparable</code>）。</li>
<li><strong>自定义排序</strong>：通过 <code>Comparator</code> 指定（如大顶堆）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>任务调度</strong>（按优先级执行）。</li>
<li><strong>Top K 问题</strong>（维护前 K 个最大&#x2F;最小值）。</li>
<li><strong>Dijkstra 算法</strong>（优先处理最短路径）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>非线程安全</strong>：多线程需用 <code>PriorityBlockingQueue</code>。</li>
<li><strong>迭代无序</strong>：遍历顺序不等于优先级顺序。</li>
<li><strong>性能权衡</strong>：插入&#x2F;删除 O(log n)，但查找 O(n)。</li>
</ul>
<h3 id="【简单】BlockingQueue-有什么用？"><a href="#【简单】BlockingQueue-有什么用？" class="headerlink" title="【简单】BlockingQueue 有什么用？"></a>【简单】BlockingQueue 有什么用？</h3><p><strong>BlockingQueue 是线程安全的队列</strong>，支持阻塞操作（队列满时阻塞插入，空时阻塞取出）。主要用于<strong>生产者-消费者模型</strong>，协调多线程数据交换。</p>
<p><strong>关键方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>put(E e)</code></td>
<td>队列满时<strong>阻塞</strong>，直到有空间插入。</td>
</tr>
<tr>
<td><code>take()</code></td>
<td>队列空时<strong>阻塞</strong>，直到有元素可取。</td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>非阻塞插入，成功返回 <code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>非阻塞取出，有元素返回元素，无元素返回 <code>null</code>。</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>查看队首元素但不移除（无元素返回 <code>null</code>）。</td>
</tr>
</tbody></table>
<p><strong>常见实现类</strong></p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：固定大小数组，单锁，适合低并发。</li>
<li>**<code>LinkedBlockingQueue</code>**：链表，双锁（高并发），默认几乎无界。</li>
<li>**<code>PriorityBlockingQueue</code>**：优先级队列（堆实现），无界。</li>
<li>**<code>SynchronousQueue</code>**：不存储元素，直接传递任务（一对一通信）。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>任务调度</strong>（线程池任务队列）。</li>
<li><strong>数据缓冲</strong>（生产者-消费者模型）。</li>
<li><strong>流量控制</strong>（通过固定容量限制并发）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>线程安全</strong>：所有实现均线程安全，但需注意 <code>peek()</code> 和 <code>poll()</code> 的竞态条件。</li>
<li><strong>阻塞策略</strong>：<code>put()</code>&#x2F;<code>take()</code> 会阻塞，<code>offer()</code>&#x2F;<code>poll()</code> 可设置超时。</li>
<li><strong>无界队列风险</strong>：<code>LinkedBlockingQueue</code> 默认无界，可能导致 <code>OOM</code>，建议设置容量。</li>
</ul>
<p><strong>一句话总结</strong>： 多线程间安全传递数据的阻塞队列，核心方法是 <code>put()</code>（阻塞插入）和 <code>take()</code>（阻塞取出），按场景选实现类。</p>
<h3 id="【中等】ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#【中等】ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="【中等】ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"></a>【中等】ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 都是 Java 并发包（<code>java.util.concurrent</code>）中的<strong>线程安全阻塞队列</strong>，但它们在底层实现、性能和适用场景上有显著区别。</p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：固定容量，单锁，适合低并发或内存敏感场景。</li>
<li>**<code>LinkedBlockingQueue</code>**：动态扩容，双锁，适合高并发和高吞吐场景。</li>
<li>**避免 <code>OOM</code>**：如果使用 <code>LinkedBlockingQueue</code>，建议设置合理容量（默认 <code>MAX_VALUE</code> 可能导致内存问题）。</li>
</ul>
<p><strong><code>ArrayBlockingQueue</code> vs. <code>LinkedBlockingQueue</code></strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
<th><strong>LinkedBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td><strong>固定大小的数组</strong>（循环队列）</td>
<td><strong>链表</strong>（可动态扩容）</td>
</tr>
<tr>
<td><strong>初始化容量</strong></td>
<td><strong>必须指定容量</strong>（无默认构造方法）</td>
<td>可选指定容量（默认 <code>Integer.MAX_VALUE</code>）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（连续存储）</td>
<td>稍高（每个节点存储前后指针）</td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td><strong>单锁（入队和出队共用同一把锁）</strong></td>
<td><strong>双锁（入队和出队分离锁，减少竞争）</strong></td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>较低（锁竞争更激烈）</td>
<td>较高（读写分离，并发性能更好）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>固定大小队列，避免 OOM</td>
<td>高并发、动态扩容场景</td>
</tr>
</tbody></table>
<p><strong>底层数据结构</strong></p>
<ul>
<li><p><strong><code>ArrayBlockingQueue</code></strong></p>
<ul>
<li>基于<strong>数组</strong>（循环队列），初始化时必须指定固定容量。</li>
<li>存储连续，内存局部性好，但扩容需重建数组（不支持动态扩容）。</li>
</ul>
</li>
<li><p><strong><code>LinkedBlockingQueue</code></strong></p>
<ul>
<li>基于<strong>链表</strong>，默认容量 <code>Integer.MAX_VALUE</code>（几乎无界）。</li>
<li>可动态增长，但每个节点需额外存储前后指针，内存开销稍大。</li>
</ul>
</li>
</ul>
<p><strong>锁机制</strong></p>
<ul>
<li><p><strong><code>ArrayBlockingQueue</code></strong></p>
<ul>
<li>使用<strong>单锁</strong>（<code>ReentrantLock</code>），入队和出队操作共用同一把锁，竞争较激烈。</li>
<li>适合<strong>低并发</strong>或<strong>容量固定</strong>的场景。</li>
</ul>
</li>
<li><p><strong><code>LinkedBlockingQueue</code></strong></p>
<ul>
<li>采用<strong>双锁</strong>（<code>putLock</code> 和 <code>takeLock</code>），入队和出队操作互不阻塞。</li>
<li><strong>高并发</strong>下吞吐量更高（如生产者-消费者模型）。</li>
</ul>
</li>
</ul>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
<th><strong>LinkedBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>入队（<code>put</code>）</strong></td>
<td>较慢（单锁竞争）</td>
<td>更快（双锁分离）</td>
</tr>
<tr>
<td><strong>出队（<code>take</code>）</strong></td>
<td>较慢（单锁竞争）</td>
<td>更快（双锁分离）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑</td>
<td>稍高（链表节点开销）</td>
</tr>
</tbody></table>
<p><strong>使用场景建议</strong></p>
<p><strong>选择 <code>ArrayBlockingQueue</code> 的情况</strong>：</p>
<ul>
<li>✅ <strong>队列大小固定</strong>，防止内存耗尽（如任务队列有严格上限）。</li>
<li>✅ <strong>低&#x2F;中并发</strong>，且对内存占用敏感。</li>
</ul>
<p><strong>选择 <code>LinkedBlockingQueue</code> 的情况</strong>：</p>
<ul>
<li>✅ <strong>高并发</strong>（生产者-消费者模型）。</li>
<li>✅ <strong>队列大小不固定</strong>（默认几乎无界，但可手动指定容量）。</li>
<li>✅ <strong>需要更高的吞吐量</strong>（双锁机制减少竞争）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a626f515/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a626f515/" class="post-title-link" itemprop="url">Java 容器面试三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-容器面试三"><a href="#Java-容器面试三" class="headerlink" title="Java 容器面试三"></a>Java 容器面试三</h1><h2 id="Java-容器工具类"><a href="#Java-容器工具类" class="headerlink" title="Java 容器工具类"></a>Java 容器工具类</h2><p><strong><code>Collections</code> 工具类常用方法</strong>:</p>
<ul>
<li>排序</li>
<li>查找，替换操作</li>
<li>同步控制（不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合）</li>
</ul>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由 Comparator 控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当 distance 为正数时，将 list 后 distance 个元素整体移到前面。当 distance 为负数时，将 list 的前 distance 个元素整体移到后面</span></span><br></pre></td></tr></table></figure>

<h3 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span>(List list, <span class="built_in">Object</span> <span class="built_in">key</span>)<span class="comment">//对 List 进行二分查找，返回索引，注意 List 必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">max</span>(Collection coll)<span class="comment">//根据元素的自然顺序，返回最大的元素。 类比 int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">max</span>(Collection coll, Comparator c)<span class="comment">//根据定制排序，返回最大元素，排序规则由 Comparatator 类控制。类比 int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">fill</span>(List list, <span class="built_in">Object</span> obj)<span class="comment">//用指定的元素代替指定 list 中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span>(Collection c, <span class="built_in">Object</span> o)<span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span>(List list, List target)<span class="comment">//统计 target 在 list 中第一次出现的索引，找不到则返回-1，类比 int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span>(List list, <span class="built_in">Object</span> oldVal, <span class="built_in">Object</span> newVal)<span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>

<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt;  c)</span></span> <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line"><span class="function"><span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line"><span class="function"><span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span> <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line"><span class="function"><span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span> <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>

<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p>
</blockquote>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code>、<code>ConcurrentHashMap</code>…）。</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">size</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="built_in">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="built_in">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">final <span class="built_in">long</span> <span class="title">sumCount</span>()</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="built_in">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isEmpty</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span><span class="type"></span> ArrayList&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span><span class="type"></span> Person(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span><span class="type"></span> Person(<span class="string">&quot;martin&quot;</span>,<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person:<span class="type"></span>:getName, Person:<span class="type"></span>:getPhoneNumber));</span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="built_in">Map</span>&lt;K, U&gt;&gt;</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(<span class="built_in">Function</span>&lt;? super T, ? <span class="keyword">extends</span> K&gt; keyMapper,</span><br><span class="line">                            <span class="built_in">Function</span>&lt;? super T, ? <span class="keyword">extends</span> U&gt; valueMapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">    BiConsumer&lt;M, T&gt; <span class="function"><span class="title">accumulator</span></span></span><br><span class="line"><span class="function">            = <span class="params">(<span class="keyword">map</span>, element)</span> -&gt;</span> <span class="keyword">map</span>.merge(keyMapper.apply(element),</span><br><span class="line">                                          valueMapper.apply(element), mergeFunction);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<blockquote>
<p>如果你还不了解 Java 8 新特性的话，请看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw">《Java8 新特性总结》</a> 。</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span>(K <span class="built_in">key</span>, V value,</span><br><span class="line">        BiFunction&lt;? <span class="variable">super</span> V, ? <span class="variable">super</span> V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    Objects.<span class="property">requireNonNull</span>(remappingFunction);</span><br><span class="line">    Objects.<span class="property">requireNonNull</span>(value);</span><br><span class="line">    V oldValue = <span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    V newValue = (oldValue == <span class="literal">null</span>) ? value :</span><br><span class="line">               remappingFunction.<span class="property">apply</span>(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">remove</span>(<span class="built_in">key</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">put</span>(<span class="built_in">key</span>, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span>(<span class="params">T obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p>
</blockquote>
<p>通过反编译你会发现 foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12470446.html">什么是 fail-fast</a> 。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素，如</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.<span class="keyword">add</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(<span class="keyword">filter</span> -&gt; <span class="keyword">filter</span> % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除 list 中的所有偶数 */</span></span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>
<li>……</li>
</ul>
<h2 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> static &lt;T&gt; <span class="built_in">Set</span>&lt;T&gt; removeDuplicateBySet(<span class="built_in">List</span>&lt;T&gt; <span class="built_in">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(<span class="built_in">data</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">new</span> HashSet&lt;&gt;(<span class="built_in">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> static &lt;T&gt; <span class="built_in">List</span>&lt;T&gt; removeDuplicateByList(<span class="built_in">List</span>&lt;T&gt; <span class="built_in">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(<span class="built_in">data</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">List</span>&lt;T&gt; result = <span class="literal">new</span> ArrayList&lt;&gt;(<span class="built_in">data</span>.size());</span><br><span class="line">    for (T current : <span class="built_in">data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.contains(current)) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>
<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="built_in">HashMap</span>&lt;E,<span class="built_in">Object</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span>(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="property">containsKey</span>(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>
<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span>(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">indexOf</span>(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span>(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.<span class="property">equals</span>(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
</blockquote>
<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> [] s= <span class="keyword">new</span> <span class="type">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;<span class="type">String</span>&gt; list = Arrays.<span class="built_in">asList</span>(s);</span><br><span class="line">Collections.<span class="built_in">reverse</span>(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.<span class="built_in">toArray</span>(<span class="keyword">new</span> <span class="type">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<a target="_blank" rel="noopener" href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p>
</blockquote>
<p>我在之前的一个项目中就遇到一个类似的坑。</p>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span><span class="punctuation">[</span><span class="punctuation">]</span> <span class="variable">myArray</span> <span class="operator">=</span> <span class="punctuation">&#123;</span><span class="string">&quot;Apple&quot;</span><span class="operator">,</span> <span class="string">&quot;Banana&quot;</span><span class="operator">,</span> <span class="string">&quot;Orange&quot;</span><span class="punctuation">&#125;</span><span class="operator">;</span></span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="built_in">Arrays</span><span class="operator">.</span><span class="variable">asList</span><span class="punctuation">(</span><span class="variable">myArray</span><span class="punctuation">)</span><span class="operator">;</span></span><br><span class="line"><span class="operator">//</span>上面两个语句等价于下面一条语句</span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="built_in">Arrays</span><span class="operator">.</span><span class="variable">asList</span><span class="punctuation">(</span><span class="string">&quot;Apple&quot;</span><span class="operator">,</span><span class="string">&quot;Banana&quot;</span><span class="operator">,</span> <span class="string">&quot;Orange&quot;</span><span class="punctuation">)</span><span class="operator">;</span></span><br></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的 API 之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray() 结合使用。返回的 List 是可序列化并实现 RandomAccess 接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">asList</span>(<span class="params">T... a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来总结一下使用注意事项。</p>
<p><strong>问题一、不能直接使用 Arrays.asList 来转换基本类型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">log.info(<span class="string">&quot;list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;&quot;</span>, list, list.size(), list.get(<span class="number">0</span>).getClass());</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，通过 <code>Arrays.asList</code> 将 <code>int[]</code> 数组初始化为 <code>List</code> 后。这个<code>List</code> 包含的其实是一个 <code>int</code> 数组，整个 <code>List</code> 的元素个数是 1，元素类型是整数数组。</p>
<p>其原因是，只能是把 int 装箱为 Integer，不可能把 int 数组装箱为 Integer 数组。我们知 道，Arrays.asList 方法传入的是一个泛型 T 类型可变参数，最终 int 数组整体作为了一个 对象成为了泛型类型 T</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接遍历这样的 List 必然会出现 Bug。</p>
<p><strong>问题二、使用集合的修改方法：<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<p>Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类。这个内部类继承自 AbstractList 类，但没有覆写父类的 add、remove、clear 方法，而父类中的这几个方法默认会抛出 UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">list.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">list.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">list.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.<span class="property">io</span>.<span class="property">Serializable</span></span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span>(<span class="params">int index</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span>(<span class="params">int index, E element</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> int <span class="title function_">indexOf</span>(<span class="params"><span class="title class_">Object</span> o</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">contains</span>(<span class="params"><span class="title class_">Object</span> o</span>) &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">forEach</span>(<span class="params"><span class="title class_">Consumer</span>&lt;? <span class="variable language_">super</span> E&gt; action</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">replaceAll</span>(<span class="params"><span class="title class_">UnaryOperator</span>&lt;E&gt; operator</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">sort</span>(<span class="params"><span class="title class_">Comparator</span>&lt;? <span class="variable language_">super</span> E&gt; c</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">add</span>(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> index, E element</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>()</span> &#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span>(<span class="params"><span class="built_in">int</span> fromIndex, <span class="built_in">int</span> toIndex</span>)</span> &#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p>
<p>1、手动实现工具类</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line">static &lt;T&gt; List&lt;T&gt; <span class="built_in">array</span>ToList(<span class="keyword">final</span> T[] <span class="built_in">array</span>) &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = new ArrayList&lt;T&gt;(<span class="built_in">array</span>.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : <span class="built_in">array</span>) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">array</span>ToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p>2、最简便的方法</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.<span class="keyword">asList</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>3、使用 Java8 的 <code>Stream</code>（推荐）</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖 boxed 的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br></pre></td></tr></table></figure>

<p>4、使用 Guava</p>
<p>对于不可变集合，你可以使用 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code></a> 类及其 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code></a> 与 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code></a> 工厂方法：（参数不能为空）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">String</span>&gt; il = ImmutableList.<span class="built_in">of</span>(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;<span class="type">String</span>&gt; il = ImmutableList.<span class="built_in">copyOf</span>(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code></a> 类及其 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code></a> 工厂方法：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(another<span class="class">ListOrCollection);</span>    // from collection</span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               // from<span class="built_in"> array</span></span><br><span class="line"><span class="built_in"></span>List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); // from varargs</span><br></pre></td></tr></table></figure>

<p>5、使用 Apache Commons Collections</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">CollectionUtils.<span class="property">addAll</span>(list, <span class="built_in">str</span>);</span><br></pre></td></tr></table></figure>

<p>6、 使用 Java9 的 <code>List.of()</code>方法</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[]<span class="built_in"> array </span>= &#123;1, 2, 3&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>

<h2 id="使用-List-subList-进行切片操作居然会导致-OOM"><a href="#使用-List-subList-进行切片操作居然会导致-OOM" class="headerlink" title="使用 List.subList 进行切片操作居然会导致 OOM"></a>使用 List.subList 进行切片操作居然会导致 OOM</h2><p>List.subList 返回的子 List 不是一个普通的 ArrayList。这个子 List 可以认为是原始 List 的视图，会和原始 List 相互影响。如果不注意，很可能会因此产生 OOM 问题。</p>
<p>如下代码所示，定义一个名为 data 的静态 List 来存放 Integer 的 List，[也就是说 data 的成员本身是包含了多个数字的 List。循环 1000 次，每次都从一个具有 10 万个 Integer 的 List 中，使用 subList 方法获得一个只包含一个数字的子 List，并把这个子 List 加入 data 变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100000</span>).boxed().collect(Collectors.toList());</span><br><span class="line">        data.add(rawList.subList(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为它始终被 subList 方法返回的 List 强引用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/670b8cb5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/670b8cb5/" class="post-title-link" itemprop="url">Java 容器面试二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-容器面试二"><a href="#Java-容器面试二" class="headerlink" title="Java 容器面试二"></a>Java 容器面试二</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="【中等】HashMap-和-Hashtable-有什么区别？"><a href="#【中等】HashMap-和-Hashtable-有什么区别？" class="headerlink" title="【中等】HashMap 和 Hashtable 有什么区别？"></a>【中等】HashMap 和 Hashtable 有什么区别？</h3><p><code>HashMap</code> 更高效且灵活，<code>Hashtable</code> 线程安全但过时，推荐用 <code>ConcurrentHashMap</code> 替代。</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>HashMap</strong> (JDK 1.2+)</th>
<th><strong>Hashtable</strong> (JDK 1.0)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全</strong></td>
<td>❌ 非线程安全（需额外同步）</td>
<td>✅ 线程安全（方法用 <code>synchronized</code> 修饰）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>⚡ 更高（无锁竞争）</td>
<td>⏳ 较低（同步开销）</td>
</tr>
<tr>
<td><strong>Null 键&#x2F;值</strong></td>
<td>✅ 允许 <code>null</code> 键和值</td>
<td>❌ 不允许 <code>null</code></td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td>**<code>fail-fast</code>**（快速失败，并发修改抛异常）</td>
<td>**<code>enumerator</code>**（不抛异常）</td>
</tr>
<tr>
<td><strong>继承体系</strong></td>
<td>继承 <code>AbstractMap</code></td>
<td>继承 <code>Dictionary</code>（已过时）</td>
</tr>
<tr>
<td><strong>初始容量与扩容</strong></td>
<td>默认 16，扩容为 2 倍</td>
<td>默认 11，扩容为 2 倍 + 1</td>
</tr>
<tr>
<td><strong>哈希冲突解决</strong></td>
<td>链表 + 红黑树（JDK 8+）</td>
<td>仅链表</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong>：</p>
<ul>
<li>**优先用 <code>HashMap</code>**：大多数场景（性能更好），搭配 <code>Collections.synchronizedMap()</code> 或 <code>ConcurrentHashMap</code> 实现线程安全。</li>
<li><strong><code>Hashtable</code> 适用场景</strong>：遗留系统兼容，或需要简单线程安全且不介意性能损耗时（现代开发已少用）。</li>
</ul>
<h3 id="【中等】对比一下-HashMap-和-HashSet？"><a href="#【中等】对比一下-HashMap-和-HashSet？" class="headerlink" title="【中等】对比一下 HashMap 和 HashSet？"></a>【中等】对比一下 HashMap 和 HashSet？</h3><ul>
<li><code>HashMap</code> 是 <strong>键值对容器</strong>，适合快速键值查询。</li>
<li><code>HashSet</code> 是 <strong>唯一元素集合</strong>，基于 <code>HashMap</code> 实现，仅关注元素是否存在。</li>
</ul>
<p><strong>核心区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>HashSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据结构</strong></td>
<td>哈希表（键值对存储）</td>
<td>基于 <code>HashMap</code>（仅用键，值固定为虚拟对象）</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>键（Key） + 值（Value）</td>
<td>仅存储元素（Key）</td>
</tr>
<tr>
<td><strong>重复规则</strong></td>
<td><strong>Key 不可重复</strong>（Value 可重复）</td>
<td><strong>元素（Key）不可重复</strong></td>
</tr>
<tr>
<td><strong>Null 支持</strong></td>
<td>允许 1 个 <code>null</code> 键和多个 <code>null</code> 值</td>
<td>允许 1 个 <code>null</code> 元素</td>
</tr>
</tbody></table>
<p><strong>常用方法对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>HashSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>添加元素</strong></td>
<td><code>put(key, value)</code></td>
<td><code>add(element)</code></td>
</tr>
<tr>
<td><strong>查询元素</strong></td>
<td><code>get(key)</code>（返回值）</td>
<td><code>contains(element)</code>（返回布尔值）</td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td><code>remove(key)</code></td>
<td><code>remove(element)</code></td>
</tr>
</tbody></table>
<p><strong>底层机制</strong></p>
<p><code>HashSet</code> 内部直接使用 <code>HashMap</code> 实现，元素作为 <code>Key</code>，值固定为一个虚拟的 <code>PRESENT</code> 对象（占位符）。</p>
<p>两者均依赖哈希表，平均时间复杂度为 <code>O(1)</code>（冲突时可能退化为 <code>O(n)</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 的简化实现（本质是 HashMap 的包装）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map;  <span class="comment">// 键存储元素，值固定为 PRESENT</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;  <span class="comment">// 若 Key 已存在，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ul>
<li>**<code>HashMap</code>**：需通过键快速访问值的场景（如缓存、数据库索引）。 示例：<code>用户 ID → 用户详细信息</code>。</li>
<li>**<code>HashSet</code>**： 需存储唯一元素的集合（如去重、黑名单）。示例：<code>IP 黑名单</code>、<code>单词去重</code>。</li>
</ul>
<h3 id="【中等】HashMap、TreeMap、LinkedHashMap-有什么区别？"><a href="#【中等】HashMap、TreeMap、LinkedHashMap-有什么区别？" class="headerlink" title="【中等】HashMap、TreeMap、LinkedHashMap 有什么区别？"></a>【中等】HashMap、TreeMap、LinkedHashMap 有什么区别？</h3><p><strong>核心特性</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>TreeMap</strong></th>
<th><strong>LinkedHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层结构</strong></td>
<td>哈希表（数组+链表&#x2F;红黑树）</td>
<td>红黑树（平衡二叉搜索树）</td>
<td>哈希表 + 双向链表</td>
</tr>
<tr>
<td><strong>顺序性</strong></td>
<td>无序</td>
<td>按键的自然顺序或自定义顺序排序</td>
<td>保持插入顺序或访问顺序（LRU）</td>
</tr>
<tr>
<td><strong>null 支持</strong></td>
<td>允许 1 个 null 键和多个 null 值</td>
<td>不允许 null 键（除非自定义比较器）</td>
<td>同 HashMap</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>平均 O(1)</td>
<td>增删查 O(log n)</td>
<td>平均 O(1)</td>
</tr>
</tbody></table>
<p><strong>排序与顺序</strong></p>
<ul>
<li><strong>HashMap</strong>：完全无序，迭代顺序不可预测。</li>
<li><strong>TreeMap</strong>：默认按键的自然顺序排序（Key 需实现<code>Comparable</code>）。可通过<code>Comparator</code>自定义排序规则。</li>
<li><strong>LinkedHashMap</strong>：默认保持<strong>插入顺序</strong>。可配置为<strong>访问顺序</strong>（最近最少使用 LRU）。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>HashMap</strong>：<ul>
<li>需要最高效的查找、插入和删除操作。</li>
<li>不关心元素的顺序。</li>
<li>示例：缓存、快速查找表。</li>
</ul>
</li>
<li><strong>TreeMap</strong>：<ul>
<li>需要元素按键排序。</li>
<li>需要范围查询（如<code>subMap()</code>、<code>headMap()</code>、<code>tailMap()</code>）。</li>
<li>示例：字典、有序事件调度。</li>
</ul>
</li>
<li><strong>LinkedHashMap</strong>：<ul>
<li>需要保持插入顺序或实现 LRU 缓存。</li>
<li>示例：记录访问顺序的缓存、需要按插入顺序迭代的场景。</li>
</ul>
</li>
</ul>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>TreeMap</strong></th>
<th><strong>LinkedHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>迭代顺序</strong></td>
<td>无序</td>
<td>有序（Key）</td>
<td>插入&#x2F;访问顺序</td>
</tr>
</tbody></table>
<p><strong>选择依据</strong></p>
<ul>
<li>要<strong>速度</strong>：选<code>HashMap</code>。</li>
<li>要<strong>排序</strong>：选<code>TreeMap</code>。</li>
<li>要<strong>顺序</strong>（插入或访问顺序）：选<code>LinkedHashMap</code>。</li>
</ul>
<p><strong>扩展</strong></p>
<ul>
<li><code>LinkedHashMap</code>可通过<code>accessOrder</code>参数实现 LRU 缓存。</li>
<li><code>TreeMap</code>支持丰富的导航方法（如<code>ceilingKey()</code>、<code>floorKey()</code>）。</li>
</ul>
<h3 id="【困难】HashMap-底层实现原理是什么？"><a href="#【困难】HashMap-底层实现原理是什么？" class="headerlink" title="【困难】HashMap 底层实现原理是什么？"></a>【困难】HashMap 底层实现原理是什么？</h3><p>HashMap 通过哈希函数定位桶，用链表和红黑树解决冲突，动态扩容平衡性能，但非线程安全。</p>
<p><strong>数据结构</strong></p>
<p>HashMap 的数据结构是：<strong>数组 + 链表（JDK 8 以前）</strong> ；<strong>数组 + 链表 + 红黑树（JDK 8+）</strong></p>
<ul>
<li><strong>数组（桶）</strong>：<code>Node&lt;K,V&gt;[] table</code>，初始长度默认为 <code>16</code>。</li>
<li><strong>链表</strong>：相同哈希值的元素组成链表，以解决哈希冲突（拉链地址法）。</li>
<li><strong>红黑树</strong>：当链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转为红黑树（提升查询效率至 <code>O(log n)</code>）。</li>
</ul>
<p><strong>哈希计算</strong></p>
<ul>
<li><p><strong>计算哈希值</strong>：高位与低位异或，使哈希分布更均匀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 8 的哈希扰动函数（减少碰撞）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算桶索引</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (table.length - <span class="number">1</span>) &amp; hash;  <span class="comment">// 等价于 hash % table.length</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>解决哈希冲突</strong></p>
<ul>
<li><strong>拉链地址法</strong>：冲突的键值对以链表形式存储在同一桶中。</li>
<li><strong>红黑树优化</strong>：长链表（≥8）转为红黑树，避免极端情况下性能退化至 <code>O(n)</code>。</li>
</ul>
<p><strong>扩容机制（Rehash）</strong></p>
<ul>
<li><strong>触发条件</strong>：当元素数量 &gt; <code>容量 × 负载因子</code>（默认负载因子 0.75，容量 16 时阈值为 12）。</li>
<li><strong>扩容操作</strong>：<ul>
<li>新建 2 倍大小的数组（<code>newCap = oldCap &lt;&lt; 1</code>）。</li>
<li>重新计算键的索引位置（<code>newIndex = (newCap - 1) &amp; hash</code>）。</li>
<li><strong>JDK 8 优化</strong>：无需重新计算哈希，<strong>通过高位掩码判断新索引位置</strong>（<code>原索引</code> 或 <code>原索引 + oldCap</code>）。</li>
</ul>
</li>
</ul>
<p><strong>关键参数</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>默认值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>初始容量</td>
<td>16</td>
<td>必须为 2 的幂（方便位运算计算索引）。</td>
</tr>
<tr>
<td>负载因子（Load Factor）</td>
<td>0.75</td>
<td>权衡空间与时间效率（过高增加冲突，过低浪费内存）。</td>
</tr>
<tr>
<td>树化阈值</td>
<td>8（链表 → 红黑树）</td>
<td>需同时满足数组长度 ≥ 64，否则优先扩容。</td>
</tr>
<tr>
<td>退化阈值</td>
<td>6（红黑树 → 链表）</td>
<td>扩容或删除节点时检查。</td>
</tr>
</tbody></table>
<p><strong>线程安全问题</strong></p>
<ul>
<li><strong>非线程安全</strong>：多线程下可能导致：<ul>
<li><strong>死循环</strong>（JDK 7 头插法扩容时产生环形链表）。</li>
<li><strong>数据丢失</strong>（并发插入覆盖节点）。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <code>ConcurrentHashMap</code>。</li>
<li>或通过 <code>Collections.synchronizedMap()</code> 包装。</li>
</ul>
</li>
</ul>
<p><strong>JDK 8 的优化</strong></p>
<ul>
<li><strong>链表 → 红黑树</strong>：解决哈希攻击导致的性能退化。</li>
<li><strong>尾插法</strong>：扩容时保持链表顺序，避免环形链表。</li>
<li><strong>高位掩码优化扩容</strong>：减少哈希重计算开销。</li>
</ul>
<p><strong>PUT 流程源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 数组为空时初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2. 计算索引，若桶为空直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 处理哈希冲突（链表/红黑树）</span></span><br><span class="line">        <span class="comment">// ...（省略冲突处理逻辑）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 检查扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【困难】HashMap-为什么线程不安全？"><a href="#【困难】HashMap-为什么线程不安全？" class="headerlink" title="【困难】HashMap 为什么线程不安全？"></a>【困难】HashMap 为什么线程不安全？</h3><p>HashMap 在多线程环境下会出现：</p>
<ul>
<li><strong>JDK 7</strong>：死循环 + 数据丢失（头插法导致）。</li>
<li>**JDK 8+**：数据丢失 + 脏读（无死循环，但依然非线程安全）。</li>
<li><strong>替代方案</strong>：高并发场景始终优先选择 <code>ConcurrentHashMap</code>。</li>
</ul>
<p><strong>一句话</strong>：HashMap 的线程不安全源于非原子操作和并发修改冲突，多线程环境下必须使用同步机制。</p>
<p><strong>（1）并发修改导致数据丢失</strong></p>
<p><strong>问题场景（JDK 8+）</strong></p>
<ul>
<li>两个线程同时执行 <code>put()</code>，计算出的 <strong>桶索引相同</strong>，且该位置为 <code>null</code>。</li>
<li><strong>预期</strong>：两个键值对都成功插入。</li>
<li><strong>实际</strong>：后一个线程的 <code>put</code> 可能覆盖前一个线程的写入，导致数据丢失。</li>
</ul>
<p>示例代码（伪并发）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 1 和线程 2 同时执行：</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) &#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）JDK 7 扩容死循环问题</strong></p>
<p><strong>问题原因（仅 JDK 7）</strong></p>
<ul>
<li>扩容时采用 <strong>头插法</strong> 迁移链表，多线程并发可能导致 <strong>环形链表</strong>。</li>
<li>后续调用 <code>get()</code> 或 <code>put()</code> 时，遍历链表进入死循环（CPU 100%）。</li>
</ul>
<p>示意图：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span>：<span class="selector-tag">A</span> -&gt; <span class="selector-tag">B</span> → null</span><br><span class="line">线程 <span class="number">2</span>：<span class="selector-tag">B</span> -&gt; <span class="selector-tag">A</span> → null</span><br><span class="line">最终：<span class="selector-tag">A</span> ⇄ <span class="selector-tag">B</span>（环形链表）</span><br></pre></td></tr></table></figure>

<p><strong>（3）并发扩容导致数据错乱</strong></p>
<p>多个线程同时触发 <code>resize()</code>，可能导致：</p>
<ul>
<li><strong>部分节点丢失</strong>（未正确迁移到新数组）。</li>
<li><strong>链表断裂</strong>（节点 <code>next</code> 指针被错误修改）。</li>
</ul>
<p><strong>（4）非原子操作导致脏读</strong></p>
<p><code>size++</code>、<code>modCount++</code> 等操作非原子性，可能导致：</p>
<ul>
<li><code>size</code> 不准确（影响扩容判断）。</li>
<li>迭代时触发 <code>ConcurrentModificationException</code>（快速失败机制）。</li>
</ul>
<p><strong>解决方案</strong></p>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据丢失&#x2F;覆盖</td>
<td>使用 <code>ConcurrentHashMap</code>（CAS + 分段锁）</td>
</tr>
<tr>
<td>死循环（JDK 7）</td>
<td>升级到 JDK 8+（改用尾插法）</td>
</tr>
<tr>
<td>脏读</td>
<td>用 <code>Collections.synchronizedMap()</code> 包装</td>
</tr>
</tbody></table>
<h3 id="【中等】WeakHashMap-有什么用？"><a href="#【中等】WeakHashMap-有什么用？" class="headerlink" title="【中等】WeakHashMap 有什么用？"></a>【中等】WeakHashMap 有什么用？</h3><p><code>WeakHashMap</code> 通过弱引用键实现自动清理，适合管理临时性、生命周期与键对象绑定的数据，但需注意值对象的引用管理和线程安全问题。</p>
<p><strong>基于弱引用的键（Key）管理</strong></p>
<ul>
<li><strong>键是弱引用</strong>：当 <code>WeakHashMap</code> 的键（Key）不再被其他强引用指向时，该键值对会被垃圾回收器自动回收，避免内存泄漏。</li>
<li><strong>适用场景</strong>：适合存储与对象生命周期相关的临时数据（如缓存），当键对象外部不再使用时，自动清理对应条目。</li>
</ul>
<p><strong>自动清理无引用键值对</strong></p>
<ul>
<li><strong>依赖垃圾回收机制</strong>：当键对象仅被 <code>WeakHashMap</code> 弱引用时，GC 会回收该键，并移除对应的键值对（通过内部 <code>ReferenceQueue</code> 机制触发清理）。</li>
<li><strong>无需手动移除</strong>：与普通 <code>HashMap</code> 不同，无需显式调用 <code>remove()</code> 方法避免内存泄漏。</li>
</ul>
<p><strong>典型应用场景</strong></p>
<ul>
<li><strong>缓存系统</strong>：缓存数据时，若缓存键（如临时对象）不再使用，自动释放对应值（如大对象），防止内存堆积。</li>
<li><strong>监听器&#x2F;元数据存储</strong>：存储对象的附加信息，当对象销毁时，关联数据自动清除。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>值（Value）不是弱引用</strong>：仅键是弱引用，值仍可能因强引用导致内存泄漏（需确保值未在其他地方被强引用）。</li>
<li><strong>非线程安全</strong>：需外部同步（如使用 <code>Collections.synchronizedMap</code>）。</li>
<li><strong>不可预测的清理时机</strong>：依赖 GC 运行，条目移除时机不确定。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WeakHashMap&lt;Object, String&gt; weakMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">weakMap.put(key, <span class="string">&quot;Value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 key 的强引用置为 null，且发生 GC 后，weakMap 中的条目会被自动移除</span></span><br><span class="line">key = <span class="literal">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 仅示例，实际中不推荐显式调用 GC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 weakMap 可能已为空（条目被回收）</span></span><br></pre></td></tr></table></figure>

<h3 id="【中等】ConcurrentHashMap-和-Hashtable-有什么区别？"><a href="#【中等】ConcurrentHashMap-和-Hashtable-有什么区别？" class="headerlink" title="【中等】ConcurrentHashMap 和 Hashtable 有什么区别？"></a>【中等】ConcurrentHashMap 和 Hashtable 有什么区别？</h3><ul>
<li>**优先使用 <code>ConcurrentHashMap</code>**：适用于现代高并发程序，性能更优。</li>
<li>**避免 <code>Hashtable</code>**：除非维护历史代码，否则建议替换为 <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code>（非高并发场景）。</li>
</ul>
<p>以下是 <strong>ConcurrentHashMap 和 Hashtable 的区别对比表格</strong>，清晰展示核心差异：</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Hashtable</strong></th>
<th><strong>ConcurrentHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全实现</strong></td>
<td>全表锁（<code>synchronized</code> 方法）</td>
<td><strong>分段锁（JDK7）</strong> 或 <strong>CAS + <code>synchronized</code>（JDK8+）</strong></td>
</tr>
<tr>
<td><strong>并发性能</strong></td>
<td>低（串行化操作，高并发时阻塞严重）</td>
<td>高（读写并发优化，锁粒度更细）</td>
</tr>
<tr>
<td><strong>Null 支持</strong></td>
<td><strong>不允许</strong> <code>null</code> 键或值（抛出异常）</td>
<td><strong>不允许</strong> <code>null</code> 键或值（避免并发歧义）</td>
</tr>
<tr>
<td><strong>迭代器行为</strong></td>
<td>强一致性（修改会抛 <code>ConcurrentModificationException</code>）</td>
<td>弱一致性（可能部分反映修改，不抛异常）</td>
</tr>
<tr>
<td><strong>版本与演进</strong></td>
<td>JDK1.0 遗留类，已过时</td>
<td>JDK1.5 引入，持续优化（如 JDK8 改用 CAS）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>旧代码兼容（不推荐新项目使用）</td>
<td><strong>高并发首选</strong>（缓存、计数器等场景）</td>
</tr>
</tbody></table>
<h3 id="【困难】ConcurrentHashMap-的底层实现原理是什么？"><a href="#【困难】ConcurrentHashMap-的底层实现原理是什么？" class="headerlink" title="【困难】ConcurrentHashMap 的底层实现原理是什么？"></a>【困难】ConcurrentHashMap 的底层实现原理是什么？</h3><p><code>ConcurrentHashMap</code> 是 Java 并发编程中最常用的线程安全 <code>Map</code>，其底层实现经历了 <strong>JDK7（分段锁）</strong> 和 <strong>JDK8+（CAS + <code>synchronized</code> 优化）</strong> 两个重要阶段。以下是核心实现原理：</p>
<p>::: info JDK7 中，ConcurrentHashMap 的实现原理是什么？<br>:::</p>
<p>JDK7 中，<code>ConcurrentHashMap</code> 的核心实现思想是：将整个哈希表分成多个 <code>Segment</code>（默认 16 个），每个 <code>Segment</code> 是一个独立的 <code>HashEntry</code> 数组，<strong>锁粒度细化到<code>Segment</code> 级别</strong>，不同 <code>Segment</code> 可并发操作。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">  ├── Segment[]（默认 <span class="number">16</span> 个，每个 Segment 继承 ReentrantLock）</span><br><span class="line">  │    └── HashEntry[]（链表结构，存储键值对）</span><br><span class="line">  └── 全局的并发控制参数（如 loadFactor）</span><br></pre></td></tr></table></figure>

<p><strong>关键特点</strong></p>
<ul>
<li><strong>锁分段（Segment Locking）</strong><ul>
<li>写操作仅锁对应的 <code>Segment</code>，其他 <code>Segment</code> 仍可并发访问。</li>
<li>读操作无锁（<code>HashEntry</code> 的 <code>value</code> 用 <code>volatile</code> 修饰，保证可见性）。</li>
</ul>
</li>
<li><strong>并发度（Concurrency Level）</strong><ul>
<li>默认 16 个 <code>Segment</code>，即最多支持 16 个线程并发写。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>内存占用较高（每个 <code>Segment</code> 独立维护数组）。</li>
<li>查询时需要两次哈希计算（先定位 <code>Segment</code>，再定位 <code>HashEntry</code>）。</li>
</ul>
<p>::: info JDK8 中，ConcurrentHashMap 的实现原理是什么？<br>:::</p>
<p>JDK8 中，<code>ConcurrentHashMap</code> 的核心实现思想是：抛弃 <code>Segment</code>，改用 <strong><code>Node</code> 数组 + 链表&#x2F;红黑树</strong>，锁粒度细化到 <strong>单个桶（链表头节点）</strong>，并引入 <strong>CAS（无锁化）</strong> 和 <code>synchronized</code> 结合的方式提升并发性能。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">  ├── Node[] table（数组 + 链表/红黑树）</span><br><span class="line">  │    ├── Node（普通链表节点）</span><br><span class="line">  │    └── TreeBin（红黑树封装，维护平衡）</span><br><span class="line">  └── <span class="keyword">volatile</span> 变量（如 sizeCtl，控制扩容）</span><br></pre></td></tr></table></figure>

<p><strong>关键优化</strong></p>
<ul>
<li><p><strong>锁粒度更细（桶级别锁）</strong></p>
<ul>
<li>写操作仅锁当前桶（链表头节点），其他桶仍可并发访问。</li>
<li>读操作完全无锁（<code>Node</code> 的 <code>value</code> 和 <code>next</code> 用 <code>volatile</code> 修饰）。</li>
</ul>
</li>
<li><p><strong>CAS + <code>synchronized</code> 结合</strong></p>
<ul>
<li><strong>插入数据</strong>：先尝试 CAS 无锁插入，失败后 <code>synchronized</code> 锁住头节点。</li>
<li><strong>扩容</strong>：支持多线程协同扩容（通过 <code>sizeCtl</code> 标志位控制）。</li>
</ul>
</li>
<li><p><strong>链表转红黑树（优化查询）</strong></p>
<ul>
<li>当链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转为红黑树（<code>TreeBin</code>），防止哈希冲突导致性能退化。</li>
</ul>
</li>
<li><p><strong>更高效的计算方式</strong></p>
<ul>
<li>使用 <code>spread()</code> 方法优化哈希计算，减少冲突。</li>
<li><code>size()</code> 方法通过 <code>CounterCell</code> 分段统计，避免全局锁。</li>
</ul>
</li>
</ul>
<p>::: info JDK8 中，ConcurrentHashMap 关键操作流程是怎样的？<br>:::</p>
<p><strong>（1）PUT 操作（JDK8）</strong></p>
<ol>
<li>计算 <code>key</code> 的哈希，定位到桶（数组下标）。</li>
<li>如果桶为空，<strong>CAS 插入新节点</strong>（无锁化）。</li>
<li>如果桶不为空，<code>synchronized</code> 锁住头节点，处理链表或红黑树插入。</li>
<li>如果链表长度 ≥ 8，尝试转红黑树。</li>
</ol>
<p><strong>（2）GET 操作（完全无锁）</strong></p>
<ol>
<li>计算 <code>key</code> 的哈希，定位到桶。</li>
<li>遍历链表或红黑树（依赖 <code>volatile</code> 保证可见性）。</li>
</ol>
<p><strong>（3）扩容（多线程协同）</strong></p>
<ol>
<li>当元素数量超过阈值（<code>sizeCtl</code>），触发扩容。</li>
<li>其他线程检测到扩容时，可协助迁移数据（<code>transfer</code> 方法）。</li>
</ol>
<p>::: info ConcurrentHashMap 在 JDK7 和 JDK8 中的实现有哪些差异？<br>:::</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>JDK7（分段锁）</strong></th>
<th><strong>JDK8+（CAS + <code>synchronized</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁粒度</strong></td>
<td>Segment 级别（粗粒度）</td>
<td>桶级别（更细粒度）</td>
</tr>
<tr>
<td><strong>并发度</strong></td>
<td>固定 16 个 Segment</td>
<td>动态调整，更高并发</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较高（每个 Segment 维护数组）</td>
<td>更低（单层 Node 数组）</td>
</tr>
<tr>
<td><strong>哈希冲突处理</strong></td>
<td>链表</td>
<td>链表 + 红黑树（优化查询）</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>单 Segment 扩容</td>
<td>多线程协同扩容</td>
</tr>
</tbody></table>
<p><strong>小结</strong></p>
<p><strong>JDK7</strong>：分段锁降低冲突，但并发度固定，内存开销大。</p>
<p>**JDK8+**：</p>
<ul>
<li>更细粒度的锁（桶级别），CAS 无锁化优化。</li>
<li>红黑树优化极端哈希冲突场景。</li>
<li>多线程协同扩容，提升性能。</li>
</ul>
<p><strong>适用场景</strong>：高并发读写（如缓存、计数器），是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap()</code> 的现代替代方案。</p>
<h3 id="【中等】ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#【中等】ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="【中等】ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>【中等】ConcurrentHashMap 为什么 key 和 value 不能为 null？</h3><p><code>ConcurrentHashMap</code> 在设计上明确禁止 <code>null</code> 作为 <strong>key</strong> 或 <strong>value</strong>，而普通的 <code>HashMap</code> 是允许的。</p>
<p><strong><code>ConcurrentHashMap</code> 禁止 <code>null</code> 是为了避免并发场景下的二义性问题</strong>。</p>
<ul>
<li><strong>替代方案</strong>：使用特殊标记（如 <code>Optional</code>）或额外方法（如 <code>containsKey()</code>）明确语义。</li>
<li><strong>设计一致性</strong>：延续 <code>Hashtable</code> 的严格约束，确保线程安全行为的清晰性。</li>
</ul>
<p>如果业务必须使用 <code>null</code>，可以考虑：</p>
<ul>
<li>使用 <code>HashMap</code> + 外部同步（如 <code>synchronized</code>）。</li>
<li>用 <code>Optional</code> 或自定义空对象代替 <code>null</code>。</li>
</ul>
<p><code>ConcurrentHashMap</code> 禁止 <code>null</code> 的详细原因如下：</p>
<p><strong>（1）并发场景下的歧义问题（核心原因）</strong></p>
<p><code>ConcurrentHashMap</code> 是线程安全的，但在高并发环境下，<code>null</code> 值会导致 <strong>二义性（Ambiguity）</strong>，无法区分：</p>
<ul>
<li><strong>Key 不存在</strong>（返回 <code>null</code>）。</li>
<li>**Key 存在，但 Value 本身就是 <code>null</code>**。</li>
</ul>
<p>示例场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.get(<span class="string">&quot;non_existent_key&quot;</span>);  <span class="comment">// 返回 null（表示 key 不存在）</span></span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="literal">null</span>);        <span class="comment">// 如果允许，这里存储 null 值</span></span><br><span class="line">map.get(<span class="string">&quot;key&quot;</span>);              <span class="comment">// 仍然返回 null，无法区分是 &quot;key 不存在&quot; 还是 &quot;value 是 null&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：在并发环境下，这种歧义会导致业务逻辑错误（比如缓存系统无法判断数据是否有效）。</p>
<p><strong>（2）<code>HashMap</code> 为什么允许 <code>null</code>？</strong></p>
<p><code>HashMap</code> 是单线程使用的，开发者可以自行约束 <code>null</code> 的使用逻辑，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.get(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 明确知道是 key 不存在，或者 value 是 null（需业务逻辑保证）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在并发环境下，这种约束不可靠，因为其他线程可能同时修改数据。</p>
<p><strong>（3）<code>ConcurrentHashMap</code> 的设计哲学</strong></p>
<p>为了保证 <strong>线程安全</strong> 和 <strong>明确语义</strong>，<code>ConcurrentHashMap</code> 直接禁止 <code>null</code>，强制开发者：</p>
<ul>
<li>**用特殊占位符（如 <code>Optional.empty()</code>）代替 <code>null</code>**。</li>
<li><strong>显式处理 <code>key</code> 不存在的情况</strong>（如 <code>containsKey()</code> 检查）。</li>
</ul>
<p>替代方案示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Optional&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, Optional.empty());  <span class="comment">// 用 Optional 表示空值</span></span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// key 不存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; value = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// value 是 &quot;逻辑上的 null&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）历史原因（兼容性）</strong></p>
<ul>
<li><code>Hashtable</code>（早期线程安全 <code>Map</code>）也不允许 <code>null</code>，<code>ConcurrentHashMap</code> 延续了这一设计。</li>
<li>如果允许 <code>null</code>，会导致从 <code>Hashtable</code> 迁移到 <code>ConcurrentHashMap</code> 时出现兼容性问题。</li>
</ul>
<p>（5）对比其他 Map</p>
<table>
<thead>
<tr>
<th><strong>Map 类型</strong></th>
<th><strong>允许 <code>null</code> Key</strong></th>
<th><strong>允许 <code>null</code> Value</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>单线程使用，无并发歧义</td>
</tr>
<tr>
<td><code>Hashtable</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>线程安全，避免歧义</td>
</tr>
<tr>
<td><code>ConcurrentHashMap</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>并发安全，避免歧义</td>
</tr>
<tr>
<td><code>Collections.synchronizedMap</code></td>
<td>取决于底层 Map</td>
<td>取决于底层 Map</td>
<td>包装类，行为与被包装 Map 一致</td>
</tr>
</tbody></table>
<h3 id="【中等】ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#【中等】ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="【中等】ConcurrentHashMap 能保证复合操作的原子性吗？"></a>【中等】ConcurrentHashMap 能保证复合操作的原子性吗？</h3><p><strong>ConcurrentHashMap 不能保证复合操作的原子性</strong>，尽管它本身提供了高并发性能和线程安全的单个操作。</p>
<p><strong>说明如下</strong>：</p>
<p><strong>单个操作的原子性</strong>：</p>
<ul>
<li><code>put()</code>, <code>get()</code>, <code>remove()</code> 等单个操作是线程安全的</li>
<li>这些操作在内部使用分段锁或 CAS 操作保证原子性</li>
</ul>
<p><strong>复合操作的非原子性</strong>：</p>
<p>像【检查然后执行（check-then-act）】这样的复合操作不是原子的。例如：<code>if (!map.containsKey(key)) &#123; map.put(key, value); &#125;</code>，在检查和方法调用之间，其他线程可能已经修改了 <code>map</code>。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用 <code>putIfAbsent()</code>, <code>computeIfAbsent()</code>, <code>computeIfPresent()</code> 等原子性复合方法</li>
<li>使用显式同步（但会降低并发性能）</li>
<li>使用 <code>compute()</code> 方法原子性地更新值</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原子性复合操作 - 不安全</span></span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);  <span class="comment">// 可能有竞态条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子性替代方案</span></span><br><span class="line">map.putIfAbsent(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 computeIfAbsent</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&quot;key&quot;</span>, k -&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>总结：ConcurrentHashMap 只保证单个方法的原子性，复合操作需要特别处理才能保证线程安全。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b2f6beb8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b2f6beb8/" class="post-title-link" itemprop="url">Java 虚拟机面试一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-虚拟机面试一"><a href="#Java-虚拟机面试一" class="headerlink" title="Java 虚拟机面试一"></a>Java 虚拟机面试一</h1><h2 id="JVM-简介"><a href="#JVM-简介" class="headerlink" title="JVM 简介"></a>JVM 简介</h2><h3 id="【中等】JVM-由哪些部分组成？"><a href="#【中等】JVM-由哪些部分组成？" class="headerlink" title="【中等】JVM 由哪些部分组成？"></a>【中等】JVM 由哪些部分组成？</h3><p><strong>类加载→内存分配→执行引擎运行→GC 回收内存</strong>，通过 JNI 与外部交互。</p>
<p>JVM（Java 虚拟机）主要由以下核心部分组成：</p>
<ul>
<li><strong>类加载子系统</strong>：负责加载、验证、准备、解析和初始化类文件（.class）。</li>
<li><strong>运行时数据区</strong>：<ul>
<li><strong>方法区</strong>：存储类元数据、常量池等。</li>
<li><strong>堆</strong>：存放对象实例（主 GC 区域）。</li>
<li><strong>虚拟机栈</strong>：存储方法调用的栈帧（局部变量、操作数栈等）。</li>
<li><strong>本地方法栈</strong>：为 Native 方法服务。</li>
<li><strong>程序计数器</strong>：记录当前线程执行的字节码位置。</li>
</ul>
</li>
<li><strong>执行引擎</strong>：解释或编译字节码为机器码执行（含 JIT 编译器）。<ul>
<li><strong>解释器（Interpreter）</strong>：逐行解释执行字节码（启动快，执行慢）。</li>
<li><strong>即时编译器（JIT Compiler）</strong>：将热点代码（频繁执行的代码）编译为本地机器码（如 HotSpot 的 C1、C2 编译器）。</li>
<li><strong>垃圾回收器（GC）</strong>：自动回收堆中无用的对象（如 Serial、Parallel、G1、ZGC 等算法）。</li>
</ul>
</li>
<li><strong>本地方法接口（JNI）</strong>：调用 C&#x2F;C++实现的 Native 方法。</li>
<li><strong>本地方法库（Native Libraries）</strong>：由其他语言（如 C&#x2F;C++）编写的库，供 JNI 调用（如文件操作、网络通信等底层功能）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-hotspot-architecture.png"></p>
<h3 id="【中等】Java-是如何实现跨平台的？"><a href="#【中等】Java-是如何实现跨平台的？" class="headerlink" title="【中等】Java 是如何实现跨平台的？"></a>【中等】Java 是如何实现跨平台的？</h3><p>Java 实现跨平台的本质是：<strong>源码 → 统一字节码 → JVM 按需转换为目标平台机器码</strong>，通过分层抽象实现跨平台。</p>
<p>Java <strong>【一次编写，到处执行（Write Once, Run Anywhere）】</strong> 的要点：</p>
<ul>
<li><strong>JVM（Java 虚拟机）—— 统一运行环境</strong><ul>
<li>不同操作系统（Windows&#x2F;Linux&#x2F;macOS）安装对应的 JVM，<strong>屏蔽底层硬件和系统差异</strong>。</li>
<li>JVM 负责加载、验证并执行字节码，确保相同字节码在不同平台表现一致。</li>
</ul>
</li>
<li><strong>字节码（Bytecode）—— 平台无关的中间代码</strong><ul>
<li>Java 代码编译成<strong>平台无关的字节码（.class 文件）</strong>，而非直接生成机器码。</li>
<li>由 JVM 解释或 JIT 编译为当前平台的机器指令。</li>
</ul>
</li>
<li><strong>标准化的 Java API</strong>：提供统一的 API（如 <code>java.io</code>、<code>java.net</code>），底层通过 JVM 适配不同操作系统的具体实现。</li>
<li><strong>严格的规范与兼容性</strong>：JVM 规范（如字节码格式、内存管理）和 Java 语言规范由 Oracle 统一制定，确保各厂商实现的 JVM 行为一致。</li>
</ul>
<p><strong>例外情况（需注意）</strong></p>
<ul>
<li><strong>JNI（本地方法调用）</strong>：依赖系统原生库时，需为不同平台编译对应的动态库（如 <code>.dll</code>、<code>.so</code>）。</li>
<li><strong>平台相关细节</strong>：如文件路径分隔符、字符编码、GUI 渲染等可能需要适配。</li>
</ul>
<h3 id="【中等】说说-Java-的执行流程？"><a href="#【中等】说说-Java-的执行流程？" class="headerlink" title="【中等】说说 Java 的执行流程？"></a>【中等】说说 Java 的执行流程？</h3><p>Java 程序的执行流程经历了从编译到字节码的生成，再到类加载和 JIT 编译的过程，最终在 JVM 中执行。并且在程序运行过程中，JVM 负责内存管理、垃圾回收和线程调度等工作。</p>
<p>主要流程如下：</p>
<ol>
<li><strong>编写 Java 源代码</strong>：编写 <code>.java</code> 文件。</li>
<li><strong>编译</strong>：Java 编译器（javac） 将 <code>.java</code> 文件编译为 <code>.class</code> 文件（字节码）。</li>
<li><strong>类加载</strong>：JVM 通过类加载子系统加载 <code>.class</code> 文件到内存。<ol>
<li><strong>加载</strong>：采用双亲委派机制，分层级加载字节码。</li>
<li><strong>链接</strong><ol>
<li><strong>验证</strong>：检查字节码合法性（如魔数 <code>0xCAFEBABE</code>）。</li>
<li><strong>准备</strong>：为静态变量分配内存并赋默认值（如 <code>static int a</code> 初始化为 <code>0</code>）。</li>
<li><strong>解析</strong>：将符号引用（如类名、方法名）转为直接引用（内存地址）。</li>
</ol>
</li>
<li><strong>初始化</strong>：执行静态代码块（<code>static&#123;&#125;</code>）和静态变量赋值（如 <code>static int a = 1;</code>）。</li>
</ol>
</li>
<li><strong>存储运行时数据区</strong>：加载后的类信息存储到内存区域。<ul>
<li><strong>方法区</strong>：存储类结构（如 <code>HelloWorld</code> 的类名、方法定义、常量池）。</li>
<li><strong>堆</strong>：存放对象实例（如 <code>String</code> 对象）。</li>
<li><strong>虚拟机栈</strong>：线程私有，存储 <code>main()</code> 方法的栈帧（局部变量、操作数栈等）。</li>
<li><strong>程序计数器</strong>：记录当前线程执行的字节码指令地址。</li>
</ul>
</li>
<li><strong>执行阶段</strong><ul>
<li><strong>解释执行</strong>：逐行解释字节码指令（如 <code>invokestatic</code> 调用 <code>System.out.println</code>）。启动快，执行效率低。</li>
<li><strong>本地方法调用（JNI）</strong>：若调用 <code>native</code> 方法（如 <code>Object.clone()</code>），通过 <strong>JNI</strong> 执行本地库（C&#x2F;C++）代码。</li>
<li><strong>JIT 编译优化（可选）</strong>：将热点代码（频繁执行的方法）编译为本地机器码。相关优化技术：<strong>方法内联</strong>、<strong>逃逸分析</strong>等。</li>
</ul>
</li>
<li><strong>垃圾回收</strong>：JVM 管理内存，并回收不再使用的对象。</li>
<li><strong>程序结束</strong>：main 方法结束，退出程序。</li>
</ol>
<h3 id="【中等】什么是-JIT"><a href="#【中等】什么是-JIT" class="headerlink" title="【中等】什么是 JIT?"></a>【中等】什么是 JIT?</h3><p><strong>JIT（Just-In-Time Compilation，即时编译）</strong>在运行时将<strong>热点代码</strong>（频繁执行的字节码）动态编译为<strong>本地机器码</strong>，提升执行效率。</p>
<ul>
<li><strong>JIT 是 Java 高性能的关键</strong>：通过运行时编译热点代码，平衡解释执行的灵活性和原生代码的速度。</li>
<li><strong>核心优化</strong>：方法内联、逃逸分析、分层编译。</li>
<li><strong>调优方向</strong>：根据应用特点调整编译阈值、代码缓存大小。</li>
</ul>
<p><strong>与解释器的区别</strong>：</p>
<ul>
<li><strong>解释器</strong>：逐行解释执行字节码，启动快但运行慢。</li>
<li><strong>JIT</strong>：编译后直接执行机器码，运行快但有编译开销。</li>
</ul>
<p><strong>JIT 作用</strong></p>
<ul>
<li><strong>性能优化</strong>：对重复执行的代码（如循环、高频方法）编译为机器码，避免重复解释。</li>
<li><strong>自适应优化</strong>：根据运行时数据（如方法调用次数、分支预测）动态优化代码。</li>
</ul>
<p><strong>JIT 工作流程</strong></p>
<ul>
<li><strong>热点检测</strong>：通过计数器统计方法调用次数或循环执行次数（如 <code>-XX:CompileThreshold</code> 默认阈值 10000）。</li>
<li><strong>编译优化</strong>：将热点字节码编译为机器码，存入<strong>代码缓存（Code Cache）</strong>。</li>
<li><strong>替换执行</strong>：后续调用直接执行编译后的机器码。</li>
</ul>
<p><strong>JIT 优化技术</strong></p>
<ul>
<li><strong>方法内联（Inlining）</strong>：将小方法调用替换为方法体代码（如 <code>-XX:+InlineSmallMethods</code>）。</li>
<li><strong>逃逸分析（Escape Analysis）</strong>：判断对象作用域，优化为栈分配或标量替换。</li>
<li><strong>JIT 分层编译（Tiered Compilation）</strong><ul>
<li><strong>混合模式</strong>：结合解释器、C1（Client Compiler）和 C2（Server Compiler）：<ul>
<li><strong>C1</strong>：快速编译，优化启动速度（如 <code>-client</code> 模式）。</li>
<li><strong>C2</strong>：深度优化，提升峰值性能（如 <code>-server</code> 模式）。</li>
</ul>
</li>
<li><strong>JDK 8+ 默认启用</strong>：<code>-XX:+TieredCompilation</code>。</li>
</ul>
</li>
<li><strong>循环展开（Loop Unrolling）</strong>：减少循环控制开销。</li>
<li><strong>去虚拟化（Devirtualization）</strong>：将虚方法调用转为直接调用。</li>
</ul>
<p><strong>JIT 关键参数</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>-XX:+UseJIT</code></td>
<td>启用 JIT（默认开启）</td>
</tr>
<tr>
<td><code>-XX:CompileThreshold=10000</code></td>
<td>触发 JIT 编译的方法调用阈值</td>
</tr>
<tr>
<td><code>-XX:+PrintCompilation</code></td>
<td>打印 JIT 编译日志</td>
</tr>
<tr>
<td><code>-XX:ReservedCodeCacheSize</code></td>
<td>设置代码缓存大小（默认 240MB）</td>
</tr>
<tr>
<td><code>-XX:+TieredCompilation</code></td>
<td>启用分层编译（JDK 8+ 默认）</td>
</tr>
</tbody></table>
<p><strong>JIT 特点</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li>显著提升热点代码性能（接近原生代码速度）。</li>
<li>自适应优化更灵活。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>编译开销导致<strong>启动变慢</strong>（如短生命周期应用不适用）。</li>
<li>代码缓存占用内存。</li>
</ul>
</li>
</ul>
<p><strong>JIT 适用场景</strong></p>
<ul>
<li><strong>长期运行应用</strong>：如 Web 服务、大数据处理（JIT 优势明显）。</li>
<li><strong>短时任务</strong>：如命令行工具，解释器可能更高效。</li>
</ul>
<h3 id="【困难】什么是逃逸分析？"><a href="#【困难】什么是逃逸分析？" class="headerlink" title="【困难】什么是逃逸分析？"></a>【困难】什么是逃逸分析？</h3><p><strong>逃逸分析</strong> 是 JVM 在 <strong>即时编译（JIT）阶段</strong> 进行的一种优化技术，用于分析对象的动态作用域，判断对象是否会“逃逸”出当前方法或线程，从而决定是否可以进行栈上分配、锁消除或标量替换等优化。</p>
<p>逃逸分析通过判断对象作用域，实现<strong>栈分配、锁消除、标量替换</strong>等优化，是 JVM 提升性能的关键技术之一，尤其在高频代码中效果显著。</p>
<ul>
<li><strong>逃逸对象（Escape）</strong></li>
<li><strong>方法逃逸</strong>：对象被其他方法引用（如作为参数传递或返回值）。<ul>
<li><strong>线程逃逸</strong>：对象被其他线程访问（如赋值给静态变量或共享实例变量）。</li>
</ul>
</li>
<li><strong>非逃逸对象（Non-Escaping）</strong>：对象仅在当前方法内创建和使用，未被外部引用。</li>
</ul>
<p><strong>逃逸分析的优化场景</strong></p>
<ul>
<li><strong>栈上分配（Stack Allocation）</strong><ul>
<li>对于<strong>非逃逸对象</strong>，JVM 直接在栈帧中分配内存（而非堆），对象随方法调用结束自动销毁，减少 GC 压力。</li>
<li>_示例_：方法内部的临时对象。</li>
</ul>
</li>
<li><strong>标量替换（Scalar Replacement）</strong><ul>
<li>将非逃逸对象的字段拆解为局部变量（标量），避免创建完整对象。</li>
<li>_示例_：<code>Point</code> 对象的 <code>x</code>、<code>y</code> 字段被替换为两个局部变量。</li>
</ul>
</li>
<li><strong>锁消除（Lock Elision）</strong><ul>
<li>若对象未线程逃逸且同步块无竞争，JVM 会移除不必要的锁（如 <code>synchronized</code>）。</li>
<li>_示例_：局部 <code>StringBuffer</code> 的同步操作会被优化掉。</li>
</ul>
</li>
</ul>
<p><strong>逃逸分析的触发条件</strong></p>
<ul>
<li>需 JVM 启用逃逸分析（默认开启）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis  <span class="comment"># 开启（默认）</span></span><br><span class="line">-XX:-DoEscapeAnalysis  <span class="comment"># 关闭</span></span><br></pre></td></tr></table></figure></li>
<li>配合 JIT 编译器（如 C2）在热点代码中应用。</li>
</ul>
<p><strong>性能影响</strong></p>
<ul>
<li><strong>优点</strong>：减少堆分配、降低 GC 开销、提升局部性。</li>
<li><strong>限制</strong>：分析本身有开销，复杂对象可能无法优化。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非逃逸对象（可能被栈分配或标量替换）</span></span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(p.x + p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="built_in">this</span>.x = x; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【困难】什么是-AOT？"><a href="#【困难】什么是-AOT？" class="headerlink" title="【困难】什么是 AOT？"></a>【困难】什么是 AOT？</h3><p>::: info 什么是 AOT？<br>:::</p>
<p>Java 9 引入 <strong>AOT（Ahead of Time Compilation，提前编译）</strong> 。AOT 模式下，<strong>程序运行前直接编译为机器码</strong>（类似 C&#x2F;C++&#x2F;Rust）。</p>
<p>::: info AOT 和 JIT 有什么区别？<br>:::</p>
<p><strong>AOT vs. JIT</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>AOT</strong></th>
<th align="left"><strong>JIT</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>启动速度</strong></td>
<td align="left">⭐⭐⭐（极快）</td>
<td align="left">⭐（依赖预热）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">⭐⭐⭐（低）</td>
<td align="left">⭐⭐（较高）</td>
</tr>
<tr>
<td align="left"><strong>峰值性能</strong></td>
<td align="left">⭐⭐（静态优化）</td>
<td align="left">⭐⭐⭐（动态优化）</td>
</tr>
<tr>
<td align="left"><strong>动态支持</strong></td>
<td align="left">❌（受限）</td>
<td align="left">✅（完整支持）</td>
</tr>
<tr>
<td align="left"><strong>适合场景</strong></td>
<td align="left">云原生&#x2F;微服务</td>
<td align="left">高吞吐&#x2F;动态框架</td>
</tr>
</tbody></table>
<p>提到 AOT 就不得不提 <a target="_blank" rel="noopener" href="https://www.graalvm.org/">GraalVM</a> 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 <a target="_blank" rel="noopener" href="https://www.graalvm.org/latest/docs/">GraalVM 的官方文档</a>。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：</p>
<p>::: tip 扩展</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></li>
<li>[走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解](<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96">https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/走向-native-化</a> springdubbo-aot-技术示例与原理讲解&#x2F;)</li>
</ul>
<p>:::</p>
<p>::: info 既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？<br>:::</p>
<p><strong>AOT 的局限性在于不支持动态特性</strong>：</p>
<ul>
<li>不支持反射、动态代理、运行时类加载、JNI 等</li>
<li>影响框架兼容性（如 Spring、CGLIB 依赖 ASM 技术生成动态字节码）</li>
</ul>
<p><strong>AOT 的适用场景</strong>：</p>
<ul>
<li><strong>适合</strong>：启动敏感的微服务、云原生应用</li>
<li><strong>不适合</strong>：需动态特性的复杂框架或高频优化的长运行任务</li>
</ul>
<h2 id="JVM-内存管理"><a href="#JVM-内存管理" class="headerlink" title="JVM 内存管理"></a>JVM 内存管理</h2><h3 id="【困难】JVM-的内存区域是如何划分的？"><a href="#【困难】JVM-的内存区域是如何划分的？" class="headerlink" title="【困难】JVM 的内存区域是如何划分的？"></a>【困难】JVM 的内存区域是如何划分的？</h3><p>JDK7 和 JDK8 的 JVM 的内存区域划分有所不同，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202505070632861.png"></p>
<p><strong>线程私有区域</strong></p>
<ul>
<li><strong>程序计数器</strong><ul>
<li>记录当前线程执行的字节码指令地址（Native 方法时为<code>undefined</code>）。</li>
<li><strong>JVM 中唯一无 OOM 的区域</strong>。</li>
</ul>
</li>
<li><strong>虚拟机栈</strong><ul>
<li>存储方法调用的<strong>栈帧</strong>（局部变量表、操作数栈、动态链接、返回地址）。<ul>
<li><strong>局部变量表</strong>：用于存放方法参数和方法内部定义的局部变量。</li>
<li><strong>操作数栈</strong>：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</li>
<li><strong>动态连接</strong> - 用于一个方法调用其他方法的场景。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>；另一部分将在每一次的运行期间转化为直接应用，这部分称为<strong>动态连接</strong>。</li>
<li><strong>方法返回地址</strong> - 用于返回方法被调用的位置，恢复上层方法的局部变量和操作数栈。Java 方法有两种返回方式，一种是 <code>return</code> 语句正常返回，一种是抛出异常。无论采用何种退出方式，都会导致栈帧被弹出。也就是说，栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</li>
</ul>
</li>
<li>异常：<code>StackOverflowError</code>（栈深度超限）、<code>OOM</code>（扩展失败）。</li>
<li>可以通过 <code>-Xss</code> 指定占内存大小</li>
</ul>
</li>
<li><strong>本地方法栈</strong>：与虚拟机栈的作用非常相似，二者区别仅在于：<strong>虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务</strong>。</li>
</ul>
<p><strong>线程共享区域</strong></p>
<ul>
<li><strong>堆（Heap）</strong><ul>
<li>存放<strong>所有对象实例和数组</strong>，是 GC 主战场。</li>
<li>分区：新生代（Eden+Survivor）、老年代。</li>
<li>异常：OOM: Java heap space（对象过多或内存泄漏）。</li>
</ul>
</li>
<li><strong>字符串常量池</strong>：用于存储字符串字面量，位于堆内存中的一块特殊区域。通过 String 类的 intern() 方法可以将字符串键入到字符串常量池。</li>
<li><strong>方法区（JDK 8+：元空间）</strong><ul>
<li>存储类元信息、运行时常量池、静态变量（JDK 7 后移至堆）。</li>
<li><strong>JDK 8 用元空间（本地内存）替代永久代</strong>，默认无上限。</li>
<li>异常：<code>OOM</code>（加载过多类）。</li>
</ul>
</li>
<li><strong>运行时常量池</strong>：Class 文件中存储编译时生成的常量信息，并在类加载时进入 JVM 方法区。</li>
</ul>
<p><strong>直接内存（非 JVM 规范）</strong></p>
<p>直接内存是 JVM 堆外的本地内存。具有读写快、无 GC 开销，需手动管理的特性。</p>
<ul>
<li>分配：ByteBuffer.allocateDirect()</li>
<li>清理：DirectBuffer.cleaner().clean()</li>
<li>场景：高频 I&#x2F;O（如 NIO、Netty、MMAP）</li>
<li>异常：Direct buffer memory</li>
<li>JVM 参数：可以通过 <code>-XX:MaxDirectMemorySize</code> 设置直接内存大小，如果无设置，默认大小等于 <code>-Xmx</code> 值。</li>
</ul>
<h3 id="【困难】JVM-产生-OOM-有哪几种情况？"><a href="#【困难】JVM-产生-OOM-有哪几种情况？" class="headerlink" title="【困难】JVM 产生 OOM 有哪几种情况？"></a>【困难】JVM 产生 OOM 有哪几种情况？</h3><p>JVM 发生 <strong>OutOfMemoryError（OOM）</strong> 的原因多种多样，主要与内存区域划分和对象分配机制相关。以下是所有可能的 OOM 类型及其触发条件、典型案例和排查方法：</p>
<h4 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h4><ul>
<li><p><strong>触发条件</strong>：<strong>堆内存不足</strong>，无法分配新对象。</p>
</li>
<li><p><strong>常见原因</strong>：</p>
<ul>
<li>内存泄漏（如静态容器持续增长、未关闭的资源）。</li>
<li>堆内存设置过小（<code>-Xmx</code> 值不合理）。</li>
<li>大对象（如一次性加载超大文件到内存）。</li>
</ul>
</li>
<li><p><strong>案例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 持续分配 1MB 数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方向</strong>：</p>
<ul>
<li>检查 <code>-Xmx</code> 和 <code>-Xms</code> 参数是否合理。</li>
<li>使用 <code>jmap -histo:live &lt;pid&gt;</code> 或 <strong>MAT（Memory Analyzer Tool）</strong> 分析堆转储（<code>-XX:+HeapDumpOnOutOfMemoryError</code>）。</li>
</ul>
</li>
</ul>
<h4 id="Metaspace（JDK-8-及以后）"><a href="#Metaspace（JDK-8-及以后）" class="headerlink" title="Metaspace（JDK 8 及以后）"></a>Metaspace（JDK 8 及以后）</h4><ul>
<li><p><strong>触发条件</strong>：<strong>元空间（Metaspace）不足</strong>，无法加载新的类信息。</p>
</li>
<li><p><strong>常见原因</strong>：</p>
<ul>
<li>动态生成大量类（如反射、CGLIB、动态代理）。</li>
<li>未设置元空间上限（默认依赖本地内存，可能耗尽）。</li>
</ul>
</li>
<li><p><strong>案例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>(); <span class="comment">// CGLIB 动态生成类</span></span><br><span class="line">    enhancer.setSuperclass(OOM.class);</span><br><span class="line">    enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解决方向</strong>：</p>
<ul>
<li>调整元空间大小：<code>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</code>。</li>
<li>检查类加载器泄漏（如热部署未清理旧类）。</li>
</ul>
</li>
</ul>
<h4 id="PermGen-space（JDK-7-及以前）"><a href="#PermGen-space（JDK-7-及以前）" class="headerlink" title="PermGen space（JDK 7 及以前）"></a>PermGen space（JDK 7 及以前）</h4><ul>
<li><strong>类似 Metaspace</strong>，但发生在永久代（PermGen），JDK 8 后被元空间取代。</li>
<li><strong>常见原因</strong>：大量字符串常量或类加载未卸载。</li>
</ul>
<h4 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h4><ul>
<li><p><strong>触发条件</strong>：<strong>直接内存（堆外内存）耗尽</strong>。</p>
</li>
<li><p><strong>常见原因</strong>：</p>
<ul>
<li>NIO 的 <code>ByteBuffer.allocateDirect()</code> 未释放。</li>
<li>直接内存上限过小（<code>-XX:MaxDirectMemorySize</code>）。</li>
</ul>
</li>
<li><p><strong>案例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    buffers.add(ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span>)); <span class="comment">// 1MB 直接内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>解决方向</strong>：</p>
<ul>
<li>显式调用 <code>((DirectBuffer) buffer).cleaner().clean()</code> 或复用缓冲区。</li>
<li>增加 <code>-XX:MaxDirectMemorySize=1G</code>。</li>
</ul>
</li>
</ul>
<h4 id="Unable-to-create-new-native-thread"><a href="#Unable-to-create-new-native-thread" class="headerlink" title="Unable to create new native thread"></a>Unable to create new native thread</h4><ul>
<li><p><strong>触发条件</strong>：<strong>线程数超过系统限制</strong>（非堆内存问题）。</p>
</li>
<li><p><strong>常见原因</strong>：</p>
<ul>
<li>线程池配置不合理（如无界线程池）。</li>
<li>系统级限制（<code>ulimit -u</code> 查看用户最大线程数）。</li>
</ul>
</li>
<li><p><strong>案例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100000</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方向</strong>：</p>
<ul>
<li>改用线程池（如 <code>ThreadPoolExecutor</code>）。</li>
<li>调整系统限制（Linux 下修改 <code>/etc/security/limits.conf</code>）。</li>
</ul>
</li>
</ul>
<h4 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h4><ul>
<li><strong>触发条件</strong>：GC 耗时超过 98% 且回收内存不足 2%（JVM 自我保护）。</li>
<li><strong>本质原因</strong>：堆内存几乎耗尽，GC 无效循环。</li>
<li><strong>解决方向</strong>：<ul>
<li>同 <code>heap space</code> 排查内存泄漏。</li>
<li>关闭保护机制（不推荐）：<code>-XX:-UseGCOverheadLimit</code>。</li>
</ul>
</li>
</ul>
<h4 id="CodeCache-is-full（JIT-编译代码缓存满）"><a href="#CodeCache-is-full（JIT-编译代码缓存满）" class="headerlink" title="CodeCache is full（JIT 编译代码缓存满）"></a>CodeCache is full（JIT 编译代码缓存满）</h4><ul>
<li><strong>触发条件</strong>：JIT 编译的本地代码超出缓存区（<code>-XX:ReservedCodeCacheSize</code>）。</li>
<li><strong>常见原因</strong>：动态生成大量方法（如频繁调用反射）。</li>
<li><strong>解决方向</strong>：<ul>
<li>增加缓存：<code>-XX:ReservedCodeCacheSize=256M</code>。</li>
<li>关闭分层编译：<code>-XX:-TieredCompilation</code>。</li>
</ul>
</li>
</ul>
<h4 id="Requested-array-size-exceeds-VM-limit"><a href="#Requested-array-size-exceeds-VM-limit" class="headerlink" title="Requested array size exceeds VM limit"></a>Requested array size exceeds VM limit</h4><ul>
<li><p><strong>触发条件</strong>：尝试分配超过 JVM 限制的数组（如 <code>Integer.MAX_VALUE - 2</code>）。</p>
</li>
<li><p><strong>案例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE]; <span class="comment">// 直接崩溃</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方向</strong>：检查代码中不合理的数组分配逻辑。</p>
</li>
</ul>
<h4 id="OOM-类型速查表"><a href="#OOM-类型速查表" class="headerlink" title="OOM 类型速查表"></a>OOM 类型速查表</h4><table>
<thead>
<tr>
<th>OOM 类型</th>
<th>关联内存区域</th>
<th>典型原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>Java heap space</code></td>
<td>堆</td>
<td>内存泄漏&#x2F;堆太小</td>
</tr>
<tr>
<td><code>Metaspace</code> &#x2F; <code>PermGen space</code></td>
<td>元空间&#x2F;永久代</td>
<td>类加载爆炸</td>
</tr>
<tr>
<td><code>Unable to create native thread</code></td>
<td>系统线程数</td>
<td>线程池失控&#x2F;系统限制</td>
</tr>
<tr>
<td><code>Direct buffer memory</code></td>
<td>堆外内存</td>
<td>NIO Buffer 未释放</td>
</tr>
<tr>
<td><code>GC overhead limit exceeded</code></td>
<td>堆</td>
<td>GC 无效循环</td>
</tr>
<tr>
<td><code>CodeCache is full</code></td>
<td>JIT 代码缓存</td>
<td>动态方法过多</td>
</tr>
<tr>
<td><code>Requested array size exceeds VM</code></td>
<td>堆</td>
<td>超大数组分配</td>
</tr>
</tbody></table>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="【中等】Java-里的对象在虚拟机里面是怎么存储的？"><a href="#【中等】Java-里的对象在虚拟机里面是怎么存储的？" class="headerlink" title="【中等】Java 里的对象在虚拟机里面是怎么存储的？"></a>【中等】Java 里的对象在虚拟机里面是怎么存储的？</h3><p>64 位 JVM 中，一个空<code>Object</code>占 16 字节（12 字节头 + 4 字节填充）。</p>
<p>每个 Java 对象在堆内存中分为 <strong>3 个部分</strong>：</p>
<ul>
<li><strong>对象头（Header）</strong><ul>
<li><strong>Mark Word</strong>：存储哈希码、GC 年龄、锁状态（如偏向锁信息）。</li>
<li><strong>Class Pointer</strong>：指向类元数据的指针（压缩后占 4 字节，否则 8 字节）。</li>
</ul>
</li>
<li><strong>实例数据（Fields）</strong>：对象的所有成员变量（包括继承的字段），按类型对齐存储。</li>
<li><strong>对齐填充（Padding）</strong>：确保对象大小为 8 字节的整数倍（优化 CPU 缓存行访问）。</li>
</ul>
<p><strong>对象分配策略</strong></p>
<ul>
<li><strong>新生代分配</strong>：大多数对象优先分配在** Eden 区**（若开启 TLAB，线程先分配至私有缓冲区）。触发 Young GC 后，存活对象移至 Survivor 区或晋升老年代。</li>
<li><strong>老年代分配</strong>：大对象（如<code>-XX:PretenureSizeThreshold=1MB</code>）直接进入老年代。长期存活对象（年龄 &gt; <code>MaxTenuringThreshold</code>）从 Survivor 晋升。</li>
</ul>
<p><strong>分配方式</strong>：</p>
<ul>
<li><strong>指针碰撞</strong>（堆内存规整时，如 Serial 收集器）。</li>
<li><strong>空闲列表</strong>（堆内存碎片化时，如 CMS 收集器）。</li>
</ul>
<h3 id="【中等】Java-类的生命周期是怎样的？"><a href="#【中等】Java-类的生命周期是怎样的？" class="headerlink" title="【中等】Java 类的生命周期是怎样的？"></a>【中等】Java 类的生命周期是怎样的？</h3><p>Java 类的生命周期可以分为 7 个阶段：加载 → 链接（验证→准备→解析） → 初始化 → 使用 → （可能）卸载。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202505070635024.png"></p>
<ul>
<li><strong>加载（Loading）</strong><ul>
<li>读取 <code>.class</code> 文件，生成 <code>Class&lt;?&gt;</code> 对象。</li>
<li>触发条件：<code>new</code>、访问静态成员、反射等。</li>
</ul>
</li>
<li><strong>链接（Linking）</strong><ul>
<li><strong>验证（Verification）</strong>：检查字节码合法性（如魔数、继承规则）。</li>
<li><strong>准备（Preparation）</strong>：为 <code>static</code> 变量分配内存，赋默认值（如 <code>int</code> 为 <code>0</code>）。</li>
<li><strong>解析（Resolution）</strong>：将符号引用（如类名）转为直接引用（内存地址）。</li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong><ul>
<li>执行 <code>&lt;clinit&gt;()</code>，完成 <code>static</code> 赋值和静态代码块。</li>
<li>触发条件：首次 <code>new</code>、访问非 <code>final</code> 静态变量、反射初始化等。</li>
</ul>
</li>
<li><strong>使用（Using）</strong><ul>
<li>正常调用方法、创建实例。</li>
</ul>
</li>
<li><strong>卸载（Unloading）</strong><ul>
<li>条件：类无实例、<code>ClassLoader</code> 被回收、无 <code>Class&lt;?&gt;</code> 引用。</li>
<li>典型场景：动态加载的类（如热部署）。</li>
</ul>
</li>
</ul>
<h3 id="【困难】什么是类加载器吗？"><a href="#【困难】什么是类加载器吗？" class="headerlink" title="【困难】什么是类加载器吗？"></a>【困难】什么是类加载器吗？</h3><p>Java 类加载器是 <strong>JVM（Java 虚拟机）</strong> 的核心组件之一，负责在运行时动态加载 Java 类（<code>.class</code> 文件）到内存，并生成对应的 <code>Class&lt;?&gt;</code> 对象。</p>
<h4 id="类加载器层次结构"><a href="#类加载器层次结构" class="headerlink" title="类加载器层次结构"></a>类加载器层次结构</h4><p>类加载器采用 <strong>“双亲委派模型”</strong> 进行层次化管理，确保类的唯一性和安全性。按层级自上而下有 4 种类加载器：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200617115936.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">类加载器</th>
<th align="left">加载范围</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Bootstrap ClassLoader</strong>（启动类加载器）</td>
<td align="left"><code>JRE/lib</code> 或 <code>-Xbootclasspath</code></td>
<td align="left">由 C++ 实现，是 JVM 的一部分，无 Java 父类加载器</td>
</tr>
<tr>
<td align="left"><strong>Extension ClassLoader</strong>（扩展类加载器）</td>
<td align="left"><code>JRE/lib/ext</code> 或 <code>-Djava.ext.dirs</code></td>
<td align="left">加载 Java 扩展库（如 <code>javax.*</code>）</td>
</tr>
<tr>
<td align="left"><strong>Application ClassLoader</strong>（应用类加载器）</td>
<td align="left"><code>-Djava.class.path</code> 或 <code>-cp</code> 或 <code>-classpath</code></td>
<td align="left">默认加载用户编写的类（<code>main()</code> 方法所在类）</td>
</tr>
<tr>
<td align="left"><strong>Custom ClassLoader</strong>（自定义类加载器）</td>
<td align="left">用户自定义路径（如网络、加密类）</td>
<td align="left">可继承 <code>ClassLoader</code> 实现个性化加载逻辑</td>
</tr>
</tbody></table>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型（Parents Delegation Model）要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202505070634474.png"></p>
<p><strong>工作原理</strong>：<strong>只有当父类加载器加载失败的情况下，才会用子类加载器去加载类</strong>。</p>
<p><strong>优势</strong></p>
<ul>
<li><strong>避免重复加载</strong>：双亲委派模型使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而确保类在 JVM 中唯一（如 <code>java.lang.Object</code> 只由 <code>Bootstrap</code> 加载）。</li>
<li><strong>安全性</strong>：防止用户伪造核心类（如自定义 <code>java.lang.String</code> 会被父类加载器拦截）。</li>
</ul>
<p>以下是抽象类 <code>java.lang.ClassLoader</code> 的代码片段，其中的 <code>loadClass()</code> 方法运行过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器加载失败，会抛出 ClassNotFoundException</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】</p>
<ul>
<li>先检查类是否已经加载过，如果没有则让父类加载器去加载。</li>
<li>当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。</li>
</ul>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h3 id="【中等】Java-是编译型语言还是解释型语言？"><a href="#【中等】Java-是编译型语言还是解释型语言？" class="headerlink" title="【中等】Java 是编译型语言还是解释型语言？"></a>【中等】Java 是编译型语言还是解释型语言？</h3><p>结论：<strong>Java 既是编译型语言，也是解释型语言</strong>。</p>
<p>::: info 什么是编译型语言？什么是解释型语言？<br>:::</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80"><strong>编译型语言</strong></a> - 程序在执行之前<strong>需要一个专门的编译过程，把程序编译成为机器语言的文件</strong>，运行时不需要重新翻译，直接使用编译的结果就行了。一般情况下，编译型语言的执行速度比较快，开发效率比较低。常见的编译型语言有 C、C++、Go 等。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80"><strong>解释型语言</strong></a> - 程序不需要编译，只是在程序运行时通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a> ，将代码一句一句解释为机器代码后再执行。一般情况下，解释型语言的执行速度比较慢，开发效率比较高。常见的解释型语言有 JavaScript、Python、Ruby 等。</li>
</ul>
<p>::: info 为什么说 Java 既是编译型语言，也是解释型语言？<br>:::</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因此，我们说 Java 是编译和解释并存的。</p>
<ul>
<li><strong>编译</strong>：源码 → 字节码（<code>.java</code> → <code>.class</code>）。</li>
<li><strong>解释&#x2F;JIT</strong>：字节码 → 机器码（解释执行 + 热点代码编译优化）。</li>
</ul>
<p>Java 的源代码，首先，<strong>通过 Javac 编译成为字节码（bytecode）</strong>，即 <code>*.java</code> 文件转为 <code>*.class</code> 文件；然后，在运行时，<strong>通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码来执行</strong>。正是由于 JVM 这套机制，使得 Java 可以【<strong>一次编写，到处执行（Write Once, Run Anywhere）</strong>】。</p>
<p>为了改善解释语言的效率而发展出的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译</a> 技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a> 。到执行期时，再将字节码直译，之后执行。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Java">Java</a> 与 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LLVM">LLVM</a> 是这种技术的代表产物。常见的 JVM（如 Hotspot JVM），都提供了 JIT（Just-In-Time）编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于<strong>编译执行</strong>，而不是解释执行了。</p>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java 即时编译器原理解析及实践</a></p>
<p>:::</p>
<h3 id="【中等】什么是-Java-字节码？它与机器码有什么区别？"><a href="#【中等】什么是-Java-字节码？它与机器码有什么区别？" class="headerlink" title="【中等】什么是 Java 字节码？它与机器码有什么区别？"></a>【中等】什么是 Java 字节码？它与机器码有什么区别？</h3><p>Java 字节码（Java Bytecode）是 Java 源代码编译后生成的中间代码，它是 Java 虚拟机（JVM）执行的指令集。<strong>JVM 通过解释器或即时编译（JIT）将字节码转换为机器码执行</strong>。字节码是 Java 实现【<strong>一次编写，到处执行（Write Once, Run Anywhere）</strong>】的核心技术之一。</p>
<p>机器码是直接由 CPU 执行的二进制指令。</p>
<p><strong>Java 字节码要点</strong>：</p>
<ul>
<li><strong>基本概念</strong><ul>
<li>平台无关的中间代码，存储在 <code>.class</code> 文件中。</li>
<li>包含类结构、字段、方法及对应的字节码指令。</li>
</ul>
</li>
<li><strong>指令集</strong>：包含加载（<code>aload</code>&#x2F;<code>iload</code>）、存储（<code>astore</code>）、运算（<code>iadd</code>）、控制流（<code>if_icmpgt</code>）等操作。</li>
<li><strong>执行方式</strong><ul>
<li><strong>解释执行</strong>：JVM 逐条解释字节码。</li>
<li><strong>JIT 编译</strong>：热点代码动态编译为机器码优化性能。</li>
</ul>
</li>
<li><strong>动态能力</strong><ul>
<li><strong>反射</strong>：运行时动态解析&#x2F;修改字节码（如生成代理类）。</li>
<li><strong>字节码增强</strong>：框架（Spring AOP 等）通过 ASM、Javassist 等工具修改字节码，实现 AOP 等功能。</li>
</ul>
</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团 - 字节码增强技术探索</a></p>
<p>:::</p>
<h3 id="【中等】-class-文件的结构包含哪些主要部分？"><a href="#【中等】-class-文件的结构包含哪些主要部分？" class="headerlink" title="【中等】.class 文件的结构包含哪些主要部分？"></a>【中等】.class 文件的结构包含哪些主要部分？</h3><ul>
<li>魔数 (Magic Number)</li>
<li>版本信息</li>
<li>常量池 (Constant Pool)</li>
<li>访问标志</li>
<li>类索引、父类索引和接口索引</li>
<li>字段表</li>
<li>方法表</li>
<li>属性表</li>
</ul>
<h3 id="【中等】如何查看-Java-字节码？常用工具有哪些？"><a href="#【中等】如何查看-Java-字节码？常用工具有哪些？" class="headerlink" title="【中等】如何查看 Java 字节码？常用工具有哪些？"></a>【中等】如何查看 Java 字节码？常用工具有哪些？</h3><ul>
<li>javap (JDK 自带）</li>
<li>ASM</li>
<li>Bytecode Viewer</li>
<li>JBE (Java Bytecode Editor)</li>
</ul>
<h3 id="【中等】Java-字节码有哪些典型应用场景？"><a href="#【中等】Java-字节码有哪些典型应用场景？" class="headerlink" title="【中等】Java 字节码有哪些典型应用场景？"></a>【中等】Java 字节码有哪些典型应用场景？</h3><ul>
<li><strong>性能优化</strong>：JIT 编译、方法内联、热点代码分析</li>
<li><strong>AOP 与动态代理</strong>：Spring AOP、CGLIB、JDK 动态代理</li>
<li><strong>ORM 与懒加载</strong>：Hibernate 字节码增强实现延迟加载</li>
<li><strong>代码分析与安全</strong>：静态分析（FindBugs）、漏洞检测、代码混淆</li>
<li><strong>热部署与热修复</strong>：JRebel、阿里 Sophix（运行时替换字节码）</li>
<li><strong>动态语言支持</strong>：Groovy、Kotlin 等 JVM 语言编译成字节码</li>
<li><strong>Mock 测试</strong>：Mockito 动态生成 Mock 类字节码</li>
<li><strong>序列化优化</strong>：Jackson、FastJSON 使用字节码加速反射</li>
<li><strong>调试与监控</strong>：Arthas、JProfiler 插桩分析执行情况</li>
<li><strong>JVM 研究与学习</strong>：理解 Java 语法底层实现（如<code>try-with-resources</code>、<code>lambda</code>）</li>
</ul>
<p><strong>核心作用</strong>：</p>
<ul>
<li><strong>运行时增强</strong>（AOP、代理）</li>
<li><strong>性能优化</strong>（JIT、减少反射开销）</li>
<li><strong>动态能力</strong>（热修复、Mock 测试）</li>
<li><strong>跨语言支持</strong>（JVM 生态多语言）</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="【简单】JDK-内置了哪些工具？"><a href="#【简单】JDK-内置了哪些工具？" class="headerlink" title="【简单】JDK 内置了哪些工具？"></a>【简单】JDK 内置了哪些工具？</h3><p>以下是较常用的 JDK 命令行工具：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>jps</code></td>
<td>查看 Java 进程。显示系统内的所有 JVM 进程。</td>
</tr>
<tr>
<td><code>jstat</code></td>
<td>JVM 统计监控工具。监控虚拟机运行时状态信息，它可以显示出 JVM 进程中的类装载、内存、GC、JIT 编译等运行数据。</td>
</tr>
<tr>
<td><code>jmap</code></td>
<td>生成内存快照（Heap Dump）。用于打印 JVM 进程对象直方图、类加载统计。并且可以生成堆转储快照（一般称为 heapdump 或 dump 文件）。</td>
</tr>
<tr>
<td><code>jstack</code></td>
<td>线程堆栈分析（排查死锁、线程阻塞）。用于打印 JVM 进程的线程和锁的情况。并且可以生成线程快照（一般称为 threaddump 或 javacore 文件）。</td>
</tr>
<tr>
<td><code>jhat</code></td>
<td>用来分析 jmap 生成的 dump 文件。</td>
</tr>
<tr>
<td><code>jinfo</code></td>
<td>查看&#x2F;修改 JVM 运行参数。用于实时查看和调整 JVM 进程参数。</td>
</tr>
</tbody></table>
<p>扩展命令行工具：</p>
<ul>
<li><strong>Arthas</strong>：<strong>Arthas 是阿里开源的 Java 诊断工具</strong>，无需重启应用，实时<strong>监控方法调用、查看类加载、分析性能瓶颈、热修复代码</strong>，快速定位线上问题（如 CPU 飙高、内存泄漏、方法阻塞等）。</li>
</ul>
<p>以下是较常见的 JVM GUI 工具：</p>
<table>
<thead>
<tr>
<th align="left"><strong>工具名称</strong></th>
<th align="left"><strong>主要功能</strong></th>
<th align="left"><strong>适用场景</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>VisualVM</strong></td>
<td align="left">- 监控内存、CPU、线程、GC - 堆转储分析 - 插件扩展（如 MBeans 监控）</td>
<td align="left">开发调试、性能分析</td>
<td align="left">免费、轻量、JDK 自带</td>
<td align="left">功能较基础，对大堆支持有限</td>
</tr>
<tr>
<td align="left"><strong>JConsole</strong></td>
<td align="left">- 监控堆、类、线程、MBean - 简单的 GC 分析</td>
<td align="left">快速监控 JVM 状态</td>
<td align="left">JDK 自带，使用简单</td>
<td align="left">功能较少，无法深入分析</td>
</tr>
<tr>
<td align="left"><strong>Eclipse MAT</strong> (Memory Analyzer Tool)</td>
<td align="left">- 分析堆转储（<code>heapdump</code>） - 检测内存泄漏、大对象</td>
<td align="left">内存泄漏排查、OOM 分析</td>
<td align="left">强大的内存分析能力，可视化展示对象引用链</td>
<td align="left">需要手动导出堆转储，对超大堆分析较慢</td>
</tr>
<tr>
<td align="left"><strong>JProfiler</strong></td>
<td align="left">- CPU 分析、内存分析、线程分析 - 实时监控、方法级调用追踪</td>
<td align="left">企业级性能调优、生产环境监控</td>
<td align="left">功能全面，支持多种分析模式</td>
<td align="left">商业软件（付费），学习成本较高</td>
</tr>
<tr>
<td align="left"><strong>Java Mission Control</strong> (JMC)</td>
<td align="left">- 实时监控 JVM - 飞行记录（Flight Recorder） - 低开销性能分析</td>
<td align="left">生产环境监控、性能诊断</td>
<td align="left">JDK 商业版自带，低开销</td>
<td align="left">部分功能需商业授权（Oracle JDK）</td>
</tr>
</tbody></table>
<h3 id="【中等】常用的-JVM-配置参数有哪些？"><a href="#【中等】常用的-JVM-配置参数有哪些？" class="headerlink" title="【中等】常用的 JVM 配置参数有哪些？"></a>【中等】常用的 JVM 配置参数有哪些？</h3><p><strong>内存相关参数</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-Xss</code></td>
<td align="left">设置每个线程的栈大小</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-Xms</code></td>
<td align="left">初始堆大小</td>
<td align="left">避免堆动态扩展带来的性能波动</td>
</tr>
<tr>
<td align="left"><code>-Xmx</code></td>
<td align="left">最大堆大小</td>
<td align="left">防止 OOM，需留 20% 系统内存余量</td>
</tr>
<tr>
<td align="left"><code>-Xmn</code></td>
<td align="left">新生代大小（建议占堆 1&#x2F;3~1&#x2F;2）</td>
<td align="left">优化 GC 频率和停顿时间</td>
</tr>
<tr>
<td align="left"><code>-XX:PermSize</code></td>
<td align="left">永久代空间的初始值</td>
<td align="left">Java 7 及以前用于设置方法区大小，Java 8 废弃</td>
</tr>
<tr>
<td align="left"><code>-XX:MaxPermSize</code></td>
<td align="left">永久代空间的最大值</td>
<td align="left">Java 7 及以前用于设置方法区大小，Java 8 废弃</td>
</tr>
<tr>
<td align="left"><code>-XX:MetaspaceSize</code></td>
<td align="left">元空间初始大小（JDK8+）</td>
<td align="left">避免频繁 Full GC 扩容</td>
</tr>
<tr>
<td align="left"><code>-XX:MaxMetaspaceSize</code></td>
<td align="left">元空间最大大小（默认无限制）</td>
<td align="left">防止元空间占用过多内存</td>
</tr>
<tr>
<td align="left"><code>-XX:+UseCompressedOops</code></td>
<td align="left">启用压缩指针（64位系统默认开启）</td>
<td align="left">减少内存占用（堆 &lt; 32GB 时有效）</td>
</tr>
<tr>
<td align="left"><code>-XX:NewRatio</code></td>
<td align="left">新生代与年老代的比例（默认为 2）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:SurvivorRatio</code></td>
<td align="left">Eden 区与 Survivor 区比例（默认 8:1:1）</td>
<td align="left">调整新生代对象晋升速度</td>
</tr>
</tbody></table>
<p><strong>GC 相关参数</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>示例&#x2F;默认值</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-XX:+UseG1GC</code></td>
<td align="left">启用 G1 垃圾收集器（JDK9+ 默认）</td>
<td align="left"><code>-XX:+UseG1GC</code></td>
<td align="left">大堆（&gt;4GB）低延迟场景</td>
</tr>
<tr>
<td align="left"><code>-XX:MaxGCPauseMillis</code></td>
<td align="left">G1 最大停顿时间目标（毫秒）</td>
<td align="left"><code>-XX:MaxGCPauseMillis=200</code></td>
<td align="left">控制 GC 延迟</td>
</tr>
<tr>
<td align="left"><code>-XX:ParallelGCThreads</code></td>
<td align="left">并行 GC 线程数（默认&#x3D;CPU 核数）</td>
<td align="left"><code>-XX:ParallelGCThreads=4</code></td>
<td align="left">多核服务器优化 GC 效率</td>
</tr>
<tr>
<td align="left"><code>-XX:+UseConcMarkSweepGC</code></td>
<td align="left">启用 CMS 收集器（已废弃，JDK14 移除）</td>
<td align="left">不推荐使用</td>
<td align="left">老年代低延迟（历史项目）</td>
</tr>
<tr>
<td align="left"><code>-XX:+PrintGCDetails</code></td>
<td align="left">打印详细 GC 日志</td>
<td align="left">配合 <code>-Xloggc:/path/gc.log</code></td>
<td align="left">调试 GC 问题</td>
</tr>
<tr>
<td align="left"><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>
<td align="left">OOM 时自动生成堆转储文件</td>
<td align="left"><code>-XX:HeapDumpPath=/path/dump.hprof</code></td>
<td align="left">内存泄漏分析</td>
</tr>
</tbody></table>
<h3 id="【中等】如何在-Java-中进行内存泄漏分析？"><a href="#【中等】如何在-Java-中进行内存泄漏分析？" class="headerlink" title="【中等】如何在 Java 中进行内存泄漏分析？"></a>【中等】如何在 Java 中进行内存泄漏分析？</h3><ul>
<li>内存泄漏的本质是<strong>对象被意外持有无法回收</strong>，通过引用链分析找到“谁在引用它”。</li>
<li>生产环境优先配置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 防患未然。</li>
</ul>
<h4 id="确认内存泄漏现象"><a href="#确认内存泄漏现象" class="headerlink" title="确认内存泄漏现象"></a>确认内存泄漏现象</h4><ul>
<li>堆内存持续增长（通过 <code>jstat -gcutil &lt;pid&gt;</code> 观察 <code>Old Gen</code> 或 <code>Metaspace</code> 使用率）。</li>
<li>Full GC 频繁但无法回收内存（<code>jstat</code> 显示 <code>Full GC</code> 次数增加）。</li>
<li>最终触发 <code>OutOfMemoryError: Java heap space</code>。</li>
</ul>
<h4 id="获取内存快照"><a href="#获取内存快照" class="headerlink" title="获取内存快照"></a>获取内存快照</h4><p><strong>方法 1：主动触发堆转储（Heap Dump）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 jmap 导出堆转储文件（需进程权限）</span></span><br><span class="line">jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或配置 JVM 参数自动生成（OOM 时触发）</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/heap.hprof</span><br></pre></td></tr></table></figure>

<p><strong>方法 2：通过工具生成</strong></p>
<ul>
<li><strong>VisualVM</strong>：右键进程 → “Heap Dump”。</li>
<li><strong>JConsole</strong>：”MBeans” → “com.sun.management” → “HotSpotDiagnostic” → “dumpHeap”。</li>
</ul>
<h4 id="分析堆转储文件"><a href="#分析堆转储文件" class="headerlink" title="分析堆转储文件"></a>分析堆转储文件</h4><p><strong>工具选择</strong></p>
<table>
<thead>
<tr>
<th><strong>工具</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Eclipse MAT</strong></td>
<td>功能强大，支持对象引用链分析、泄漏嫌疑报告（推荐首选）。</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>基础分析，适合快速查看大对象分布。</td>
</tr>
<tr>
<td><strong>JProfiler</strong></td>
<td>商业工具，可视化交互好，支持实时监控。</td>
</tr>
</tbody></table>
<p><strong>MAT 关键操作步骤</strong></p>
<ol>
<li><strong>打开堆转储文件</strong>：<code>File</code> → <code>Open Heap Dump</code>。</li>
<li><strong>查看泄漏报告</strong>：<ul>
<li>首页会提示 <code>Leak Suspects</code>（泄漏嫌疑对象）。</li>
<li>示例报告：<code>&quot;java.lang.Thread&quot; instances retained by thread stack</code>（线程未释放）。</li>
</ul>
</li>
<li><strong>分析对象引用链</strong>：<ul>
<li>右键对象 → <code>Path to GC Roots</code> → <code>exclude weak/soft references</code>（排除弱引用）。</li>
<li>查找意外被持有的对象（如静态集合、未关闭的资源）。</li>
</ul>
</li>
<li><strong>统计对象占比</strong>：<code>Histogram</code> 视图按类&#x2F;包名分组，排序 <code>Retained Heap</code>（对象总占用内存）。</li>
</ol>
<h4 id="常见内存泄漏场景与修复"><a href="#常见内存泄漏场景与修复" class="headerlink" title="常见内存泄漏场景与修复"></a>常见内存泄漏场景与修复</h4><table>
<thead>
<tr>
<th><strong>泄漏类型</strong></th>
<th><strong>典型原因</strong></th>
<th><strong>修复方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态集合</strong></td>
<td>静态 <code>Map</code>&#x2F;<code>List</code> 持续添加对象未清除。</td>
<td>使用弱引用（<code>WeakHashMap</code>）或定期清理。</td>
</tr>
<tr>
<td><strong>未关闭资源</strong></td>
<td>数据库连接、文件流未调用 <code>close()</code>。</td>
<td>用 <code>try-with-resources</code> 自动关闭。</td>
</tr>
<tr>
<td><strong>线程未终止</strong></td>
<td>线程池或 <code>Thread</code> 未销毁（如定时任务）。</td>
<td>调用 <code>shutdown()</code> 或设为守护线程。</td>
</tr>
<tr>
<td><strong>缓存未清理</strong></td>
<td>本地缓存（如 Guava Cache）无过期策略。</td>
<td>设置大小限制或过期时间。</td>
</tr>
<tr>
<td><strong>监听器未注销</strong></td>
<td>事件监听器未移除（如 Spring Bean）。</td>
<td>在销毁时手动注销监听器。</td>
</tr>
</tbody></table>
<h4 id="实时诊断工具（无需堆转储）"><a href="#实时诊断工具（无需堆转储）" class="headerlink" title="实时诊断工具（无需堆转储）"></a>实时诊断工具（无需堆转储）</h4><p><strong>Arthas（阿里开源）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控对象增长</span></span><br><span class="line">watch java.util.HashMap size <span class="string">&#x27;&#123;params,returnObj&#125;&#x27;</span> -n 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看类实例数量</span></span><br><span class="line">sc -d *MyClass | grep classLoaderHash</span><br><span class="line">jad --source-only com.example.LeakClass &gt; LeakClass.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成火焰图分析 CPU/内存</span></span><br><span class="line">profiler start -d 30 -f /tmp/flamegraph.html</span><br></pre></td></tr></table></figure>

<p><strong>JVisualVM</strong>：安装 <strong>VisualGC</strong> 插件，实时观察各内存区域变化。</p>
<h3 id="【中等】如何对-Java-的垃圾回收进行调优？"><a href="#【中等】如何对-Java-的垃圾回收进行调优？" class="headerlink" title="【中等】如何对 Java 的垃圾回收进行调优？"></a>【中等】如何对 Java 的垃圾回收进行调优？</h3><h4 id="调优核心目标"><a href="#调优核心目标" class="headerlink" title="调优核心目标"></a>调优核心目标</h4><ul>
<li><strong>降低延迟（Latency）</strong>：减少 GC 停顿时间（STW），提升响应速度。</li>
<li><strong>提高吞吐量（Throughput）</strong>：最大化应用处理业务的时间占比（GC 时间占比最小化）。</li>
<li><strong>控制内存占用（Footprint）</strong>：合理分配堆内存，避免浪费或频繁扩容。</li>
</ul>
<h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><ul>
<li><strong>数据驱动</strong>：基于监控而非猜测调整参数。</li>
<li><strong>渐进式修改</strong>：每次只改一个参数，观察效果。</li>
<li><strong>权衡取舍</strong>：低延迟可能牺牲吞吐量，需根据业务需求选择。</li>
</ul>
<p>通过以上步骤，可系统性地优化 Java GC 性能，解决停顿时间长、吞吐不足等问题。</p>
<h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><p><strong>监控与基线分析</strong></p>
<ul>
<li><strong>工具</strong>：<ul>
<li><code>jstat -gcutil &lt;pid&gt;</code>：实时监控 GC 各区域使用率。</li>
<li><code>GC 日志</code>：通过 <code>-Xlog:gc*</code> 或 <code>-XX:+PrintGCDetails</code> 记录详细 GC 行为。</li>
<li><strong>VisualVM</strong>&#x2F;<strong>Grafana + Prometheus</strong>：可视化内存和 GC 趋势。</li>
</ul>
</li>
<li><strong>关键指标</strong>：Young GC &#x2F; Full GC 频率、平均停顿时间、吞吐量（<code>1 - GC时间/总时间</code>）。</li>
</ul>
<p><strong>选择垃圾收集器</strong></p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>关键参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>G1 GC</strong></td>
<td>平衡延迟与吞吐（JDK8+ 默认）</td>
<td><code>-XX:MaxGCPauseMillis=200</code>（目标停顿时间）</td>
</tr>
<tr>
<td><strong>ZGC</strong></td>
<td>超低延迟（JDK11+，大堆）</td>
<td><code>-XX:+UseZGC -Xmx&gt;8G</code></td>
</tr>
<tr>
<td><strong>Parallel GC</strong></td>
<td>高吞吐量（批处理任务）</td>
<td><code>-XX:+UseParallelGC -XX:ParallelGCThreads=8</code></td>
</tr>
</tbody></table>
<p><strong>堆内存分配优化</strong></p>
<ul>
<li><strong>总堆大小</strong>（<code>-Xms</code>&#x2F;<code>-Xmx</code>）：<ul>
<li>建议设为物理内存的 50%~70%（预留空间给 OS 和其他进程）。</li>
<li>容器化环境需启用 <code>-XX:+UseContainerSupport</code>。</li>
</ul>
</li>
<li><strong>新生代与老年代比例</strong>：G1 无需手动设置（自动调整），Parallel GC 可设 <code>-Xmn</code>（如堆的 1&#x2F;3）。</li>
</ul>
<p><strong>关键参数调优</strong></p>
<ul>
<li><p><strong>G1 专用参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=45  <span class="comment"># 老年代占用阈值触发Mixed GC</span></span><br><span class="line">-XX:G1NewSizePercent=20               <span class="comment"># 新生代最小占比</span></span><br><span class="line">-XX:G1MaxNewSizePercent=50            <span class="comment"># 新生代最大占比</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通用参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=512M                <span class="comment"># 避免元空间动态扩容</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError       <span class="comment"># OOM时自动转储内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>避免常见陷阱</strong></p>
<ul>
<li><strong>Full GC 频繁</strong>：<ul>
<li>检查老年代对象晋升过快（调整 <code>-XX:MaxTenuringThreshold</code>）。</li>
<li>避免大对象直接进入老年代（如 <code>-XX:G1HeapRegionSize</code> 适配对象大小）。</li>
</ul>
</li>
<li><strong>MetaSpace OOM</strong>：<ul>
<li>增加 <code>-XX:MaxMetaspaceSize</code>（如 <code>1G</code>），并检查动态类生成（反射&#x2F;CGLIB）。</li>
</ul>
</li>
</ul>
<p><strong>验证与迭代</strong></p>
<ul>
<li><strong>压测对比</strong>：使用相同负载对比调优前后的 GC 日志。</li>
<li><strong>持续监控</strong>：生产环境通过 APM（如 SkyWalking）观察长周期效果。</li>
</ul>
<p><strong>调优示例</strong></p>
<p><strong>场景：Web 服务（低延迟优先）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># G1 GC 配置示例</span></span><br><span class="line">-Xms4G -Xmx4G</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:MaxGCPauseMillis=150</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=40</span><br><span class="line">-XX:G1HeapRegionSize=4M</span><br><span class="line">-Xlog:gc*,gc+heap=debug:file=gc.log:<span class="keyword">time</span>,<span class="built_in">uptime</span></span><br></pre></td></tr></table></figure>

<p><strong>场景：大数据计算（高吞吐优先）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parallel GC 配置示例</span></span><br><span class="line">-Xms8G -Xmx8G</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:ParallelGCThreads=4</span><br><span class="line">-XX:MaxGCPauseMillis=500</span><br><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment"># 自动调整新生代/老年代比例</span></span><br></pre></td></tr></table></figure>

<h4 id="高级工具"><a href="#高级工具" class="headerlink" title="高级工具"></a>高级工具</h4><ul>
<li><p><strong>JFR（Java Flight Recorder）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StartFlightRecording=duration=60s,settings=profile,jfr=memory=on</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arthas</strong>：实时诊断内存泄漏（如 <code>heapdump</code> 命令）。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f38610f8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f38610f8/" class="post-title-link" itemprop="url">Java 基础面试一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-18 22:46:20" itemprop="dateCreated datePublished" datetime="2024-06-18T22:46:20+08:00">2024-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-基础面试一"><a href="#Java-基础面试一" class="headerlink" title="Java 基础面试一"></a>Java 基础面试一</h1><h2 id="Java-常识"><a href="#Java-常识" class="headerlink" title="Java 常识"></a>Java 常识</h2><h3 id="【简单】Java-语言有什么优势？"><a href="#【简单】Java-语言有什么优势？" class="headerlink" title="【简单】Java 语言有什么优势？"></a>【简单】Java 语言有什么优势？</h3><ul>
<li><strong>跨平台</strong>：【<strong>一次编写，到处执行（Write Once, Run Anywhere）</strong>】——JVM 执行字节码。</li>
<li><strong>自动垃圾回收</strong>：垃圾回收（GC）减少内存泄漏风险。</li>
<li><strong>强大生态</strong>：Spring、Hadoop、Android 等广泛支持。</li>
<li><strong>面向对象</strong>：支持封装、继承、多态，代码结构清晰易维护。</li>
<li><strong>高性能</strong>：JIT 编译优化，多线程支持高并发。</li>
<li><strong>健壮安全</strong>：强类型检查、异常处理、JVM 安全机制。</li>
</ul>
<h3 id="【简单】Oracle-JDK-和-Open-JDK-有什么区别？"><a href="#【简单】Oracle-JDK-和-Open-JDK-有什么区别？" class="headerlink" title="【简单】Oracle JDK 和 Open JDK 有什么区别？"></a>【简单】Oracle JDK 和 Open JDK 有什么区别？</h3><table>
<thead>
<tr>
<th></th>
<th>OpenJDK</th>
<th>Oracle JDK</th>
</tr>
</thead>
<tbody><tr>
<td>是否开源</td>
<td>完全开源</td>
<td>闭源</td>
</tr>
<tr>
<td>是否免费</td>
<td>完全免费</td>
<td>JDK8u221 之后存在限制</td>
</tr>
<tr>
<td>更新频率</td>
<td>一般每 3 个月发布一个版本；不提供 LTS 服务</td>
<td>一般每 6 个月发布一个版本；大概每三年推出一个 LTS 版本</td>
</tr>
<tr>
<td>功能性</td>
<td>Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致</td>
<td></td>
</tr>
<tr>
<td>协议</td>
<td>GPL v2</td>
<td>BCL&#x2F;OTN</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504030804687.png"></p>
<h3 id="【简单】Java-SE-和-Java-EE-有什么区别？"><a href="#【简单】Java-SE-和-Java-EE-有什么区别？" class="headerlink" title="【简单】Java SE 和 Java EE 有什么区别？"></a>【简单】Java SE 和 Java EE 有什么区别？</h3><p>Java 技术既是一种编程语言，又是一种平台。Java 编程语言是一种具有特定语法和风格的高级面向对象语言。Java 平台是 Java 编程语言应用程序运行的特定环境。</p>
<ul>
<li><strong>Java SE</strong>（Java Platform, Standard Edition） - <strong>Java 平台标准版</strong>。Java SE 的 API 提供了 Java 编程语言的核心功能。它定义了从 Java 编程语言的基本类型和对象到用于网络、安全、数据库访问、图形用户界面 (GUI) 开发和 XML 解析的高级类的所有内容。除了核心 API 之外，Java SE 平台还包括虚拟机、开发工具、部署技术以及 Java 技术应用程序中常用的其他类库和工具包。</li>
<li><strong>Java EE</strong>（Java Platform, Enterprise Edition） - <strong>Java 平台企业版</strong>。Java EE 构建在 Java SE 基础之上。 Java EE 定义了企业级应用程序开发和部署的标准和规范，如：Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html"><strong>Your First Cup</strong></a></p>
<p>:::</p>
<h3 id="【简单】JDK、JRE、JVM-之间有什么关系？"><a href="#【简单】JDK、JRE、JVM-之间有什么关系？" class="headerlink" title="【简单】JDK、JRE、JVM 之间有什么关系？"></a>【简单】JDK、JRE、JVM 之间有什么关系？</h3><p>JDK、JRE、JVM 的定义和简介：</p>
<ul>
<li><strong>JVM</strong> - Java Virtual Machine 的缩写，即 Java 虚拟机。JVM 是运行 Java 字节码的虚拟机。JVM 不理解 Java 源代码，这就是为什么要将 <code>*.java</code> 文件编译为 JVM 可理解的 <code>*.class</code> 文件（字节码）。Java 有一句著名的口号：“<strong>Write Once, Run Anywhere（一次编写，随处运行）</strong>”，JVM 正是其核心所在。实际上，JVM 针对不同的系统（Windows、Linux、MacOS）有不同的实现，目的在于用相同的字节码执行同样的结果。</li>
<li><strong>JRE</strong> - Java Runtime Environment 的缩写，即 Java 运行时环境。它是运行已编译 Java 程序所需的一切的软件包，主要包括 JVM、Java 类库（Class Library）、Java 命令和其他基础结构。但是，它不能用于创建新程序。</li>
<li><strong>JDK</strong> - Java Development Kit 的缩写，即 Java SDK。它不仅包含 JRE 的所有功能，还包含编译器 (javac) 和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li>
</ul>
<p>总结来说，JDK、JRE、JVM 三者的关系是：JDK &gt; JRE &gt; JVM</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JDK</span> = JRE + 开发/调试工具</span><br><span class="line"><span class="attr">JRE</span> = JVM + Java 类库 + Java 运行库</span><br><span class="line"><span class="attr">JVM</span> = 类加载系统 + 运行时内存区域 + 执行引擎</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504030804019.png"></p>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre">stackoverflow 高票问题 - What is the difference between JDK and JRE?</a></p>
<p>:::</p>
<h3 id="【中等】Java-如何调用外部可执行程序或系统命令？"><a href="#【中等】Java-如何调用外部可执行程序或系统命令？" class="headerlink" title="【中等】Java 如何调用外部可执行程序或系统命令？"></a>【中等】Java 如何调用外部可执行程序或系统命令？</h3><p>Java 提供了两种调用外部可执行程序或系统命令的方式：</p>
<ul>
<li><code>ProcessBuilder</code></li>
<li><code>Runtime.exec()</code></li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46487331/article/details/128827908">https://blog.csdn.net/m0_46487331/article/details/128827908</a></p>
<p>:::</p>
<h2 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h2><h3 id="【简单】Java-有几种注释形式？"><a href="#【简单】Java-有几种注释形式？" class="headerlink" title="【简单】Java 有几种注释形式？"></a>【简单】Java 有几种注释形式？</h3><p>注释用于在源代码中解释代码的作用，可以增强程序的可读性，可维护性。 空白行，或者注释的内容，都会被 Java 编译器忽略掉。</p>
<p>Java 注释主要有三种类型：</p>
<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释（JavaDoc）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文档注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        多行注释</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【简单】Java-有哪些标识符命名规则？"><a href="#【简单】Java-有哪些标识符命名规则？" class="headerlink" title="【简单】Java 有哪些标识符命名规则？"></a>【简单】Java 有哪些标识符命名规则？</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p><strong>标识符基本规则</strong></p>
<ul>
<li><strong>组成元素</strong>：类名、变量名、方法名等统称为标识符</li>
<li><strong>允许字符</strong>：可包含字母、数字、<code>$</code>、<code>_</code></li>
<li><strong>首字符要求</strong>：不能以数字开头</li>
<li><strong>禁止关键字</strong>：如 <code>class</code>、<code>public</code> 等保留字不可作为标识符</li>
<li><strong>大小写敏感</strong>：<code>age</code> 和 <code>Age</code> 被视为不同标识符</li>
</ul>
<p><strong>命名规范</strong></p>
<p>在 Java 中，标识符通常遵循 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰命名法</a>。</p>
<table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>命名法</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类&#x2F;接口名</strong></td>
<td align="left">大驼峰（Upper CamelCase）</td>
<td align="left"><code>StudentInfo</code>、<code>UserService</code></td>
</tr>
<tr>
<td align="left"><strong>方法&#x2F;变量名</strong></td>
<td align="left">小驼峰（Lower CamelCase）</td>
<td align="left"><code>getUserName()</code>、<code>studentAge</code></td>
</tr>
<tr>
<td align="left"><strong>常量名</strong></td>
<td align="left">全大写蛇形（SNAKE_CASE）</td>
<td align="left"><code>MAX_SIZE</code>、<code>DEFAULT_TIMEOUT</code></td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li>**避免使用 <code>$</code>**：虽然合法，但通常用于编译器生成代码</li>
<li><strong>无长度限制</strong>：但应保持简洁且语义明确（如用 <code>count</code> 而非 <code>c</code>）</li>
<li><strong>Unicode 支持</strong>：可使用中文等字符（但不推荐）</li>
</ul>
<h3 id="【简单】Java-中有哪些关键字？"><a href="#【简单】Java-中有哪些关键字？" class="headerlink" title="【简单】Java 中有哪些关键字？"></a>【简单】Java 中有哪些关键字？</h3><p>下面列出了 Java 保留字，这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>访问级别修饰符</td>
<td>private、protected、public、default</td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile、enum</td>
</tr>
<tr>
<td>程序控制语句</td>
<td>break、continue、return、do、while、if、else、for、instanceof、switch、case</td>
</tr>
<tr>
<td>错误处理</td>
<td>assert、try、catch、throw、throws、finally</td>
</tr>
<tr>
<td>包相关</td>
<td>import、package</td>
</tr>
<tr>
<td>数据类型</td>
<td>boolean、byte、char、short、int、long、float、double、enum</td>
</tr>
<tr>
<td>变量引用</td>
<td>super、this、void</td>
</tr>
<tr>
<td>其他保留字</td>
<td>goto、const</td>
</tr>
</tbody></table>
<p>::: warning</p>
<p>Java 的 <code>null</code> 不是关键字，类似于 <code>true</code> 和 <code>false</code>，它是一个字面常量，不允许作为标识符使用。</p>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p>
<p>:::</p>
<h3 id="【中等】如果移位操作位数超限会怎样？"><a href="#【中等】如果移位操作位数超限会怎样？" class="headerlink" title="【中等】如果移位操作位数超限会怎样？"></a>【中等】如果移位操作位数超限会怎样？</h3><p><strong>移位位数处理机制</strong></p>
<p>Java 对移位位数超限的处理采用<strong>隐式取模运算</strong>：</p>
<ul>
<li><strong><code>int</code> 类型（32 位）</strong>：实际移位位数 &#x3D; <code>指定位数 % 32</code><ul>
<li>例如：<code>x &lt;&lt; 42</code> → 实际左移 <code>42 % 32 = 10</code> 位</li>
</ul>
</li>
<li><strong><code>long</code> 类型（64 位）</strong>：实际移位位数 &#x3D; <code>指定位数 % 64</code><ul>
<li>例如：<code>x &lt;&lt; 100</code> → 实际左移 <code>100 % 64 = 36</code> 位</li>
</ul>
</li>
</ul>
<p><strong>位操作统一规则</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>操作符</strong></th>
<th align="left"><strong>示例</strong></th>
<th align="left"><strong>等效操作</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;&lt;</code></td>
<td align="left"><code>x &lt;&lt; 35</code></td>
<td align="left"><code>x &lt;&lt; 3</code> (35%32&#x3D;3)</td>
<td align="left">左移，低位补 0</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;</code></td>
<td align="left"><code>x &gt;&gt; 35</code></td>
<td align="left"><code>x &gt;&gt; 3</code> (35%32&#x3D;3)</td>
<td align="left">右移，高位补符号位（算术右移）</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;&gt;</code></td>
<td align="left"><code>x &gt;&gt;&gt; 35</code></td>
<td align="left"><code>x &gt;&gt;&gt; 3</code> (35%32&#x3D;3)</td>
<td align="left">无符号右移，高位补 0</td>
</tr>
</tbody></table>
<p><strong>底层原理</strong></p>
<ul>
<li><strong>硬件优化</strong>：CPU 执行移位指令时，实际只使用指定位数的低 5 位（int）或低 6 位（long），与 Java 的取模规则一致。</li>
<li><strong>安全设计</strong>：避免无效的大位数移位（如 <code>x &lt;&lt; 1000</code>）导致不可预测行为。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 二进制全 1（32 个 1）</span></span><br><span class="line">System.out.println(i &lt;&lt; <span class="number">10</span>);  <span class="comment">// 左移 10 位，输出 -1024</span></span><br><span class="line">System.out.println(i &lt;&lt; <span class="number">42</span>);  <span class="comment">// 等效左移 10 位（42%32=10），同样输出 -1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">System.out.println(l &lt;&lt; <span class="number">70</span>);  <span class="comment">// 等效左移 6 位（70%64=6），输出 -64</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊情况</strong></p>
<ul>
<li><strong>移位 0 位</strong>：任何 <code>x &lt;&lt; 32</code> 或 <code>x &gt;&gt; 64</code> 等效不移位（因 <code>32%32=0</code>，<code>64%64=0</code>）。</li>
<li><strong>负数移位</strong>：移位位数可为负数，但会通过取模转为正数（如 <code>x &lt;&lt; -6</code> → <code>x &lt;&lt; 26</code>，因 <code>-6 % 32 = 26</code>）。</li>
</ul>
<p>::: info 为什么这样设计？<br>:::</p>
<ul>
<li><strong>兼容性</strong>：与 C&#x2F;C++的移位行为一致。</li>
<li><strong>性能</strong>：直接映射到 CPU 指令，无需额外检查。</li>
<li><strong>确定性</strong>：保证结果可预测，避免未定义行为。</li>
</ul>
<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2><h3 id="【简单】Java-有哪些值类型？"><a href="#【简单】Java-有哪些值类型？" class="headerlink" title="【简单】Java 有哪些值类型？"></a>【简单】Java 有哪些值类型？</h3><p>Java 中的数据类型有两类：</p>
<ul>
<li>值类型（又叫内置数据类型，基本数据类型）</li>
<li>引用类型（除值类型以外，都是引用类型，包括 <code>String</code>、数组等）</li>
</ul>
<p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类：布尔型、字符型、整数型、浮点型。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>分类</th>
<th>大小</th>
<th>默认值</th>
<th>取值范围</th>
<th>包装类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><strong>布尔型</strong></td>
<td>-</td>
<td><code>false</code></td>
<td><code>false, true</code></td>
<td>Boolean</td>
<td><code>boolean</code> 的大小，是由具体的 JVM 实现来决定的</td>
</tr>
<tr>
<td><code>char</code></td>
<td><strong>字符型</strong></td>
<td>16 bit</td>
<td><code>&#39;u0000&#39;</code></td>
<td><code>[0, 2^16 - 1]</code></td>
<td>Character</td>
<td>存储 Unicode 码，用单引号赋值</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><strong>整数型</strong></td>
<td>8 bit</td>
<td><code>0</code></td>
<td><code>[-2^7, 2^7 - 1]</code></td>
<td>Byte</td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><strong>整数型</strong></td>
<td>16 bit</td>
<td><code>0</code></td>
<td><code>[-2^15, 2^15 - 1]</code></td>
<td>Short</td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><strong>整数型</strong></td>
<td>32 bit</td>
<td><code>0</code></td>
<td><code>[-2^31, 2^31 - 1]</code></td>
<td>Integer</td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><strong>整数型</strong></td>
<td>64 bit</td>
<td><code>0L</code></td>
<td><code>[-2^63, 2^63 - 1]</code></td>
<td>Long</td>
<td>赋值时一般在数字后加上 <code>l</code> 或 <code>L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><strong>浮点型</strong></td>
<td>32 bit</td>
<td><code>0.0f</code></td>
<td><code>[2^-149, 2^128 - 1]</code></td>
<td>Float</td>
<td>赋值时必须在数字后加上 <code>f</code> 或 <code>F</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><strong>浮点型</strong></td>
<td>64 bit</td>
<td><code>0.0d</code></td>
<td><code>[2^-1074, 2^1024 - 1]</code></td>
<td>Double</td>
<td>赋值时一般在数字后加 <code>d</code> 或 <code>D</code></td>
</tr>
</tbody></table>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-basic-datatypes.html">菜鸟教程 - Java 基本数据类型</a></p>
<p>:::</p>
<h3 id="【简单】什么是装箱、拆箱？"><a href="#【简单】什么是装箱、拆箱？" class="headerlink" title="【简单】什么是装箱、拆箱？"></a>【简单】什么是装箱、拆箱？</h3><p>::: info 什么是装箱、拆箱？<br>:::</p>
<p>Java 中为每一种基本数据类型提供了相应的包装类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Byte &lt;-&gt; <span class="type">byte</span></span><br><span class="line">Short &lt;-&gt; <span class="type">short</span></span><br><span class="line">Integer &lt;-&gt; <span class="type">int</span></span><br><span class="line">Long &lt;-&gt; <span class="type">long</span></span><br><span class="line">Float &lt;-&gt; <span class="type">float</span></span><br><span class="line">Double &lt;-&gt; <span class="type">double</span></span><br><span class="line">Character &lt;-&gt; <span class="type">char</span></span><br><span class="line">Boolean &lt;-&gt; <span class="type">boolean</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p>
<p>基本数据类型与包装类的转换被称为装箱和拆箱。</p>
<ul>
<li><strong>装箱（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul>
<li><strong>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的</strong>。</li>
</ul>
</li>
<li><strong>拆箱（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul>
<li><strong>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的</strong>。（xxx 代表对应的基本数据类型）。</li>
</ul>
</li>
</ul>
<p>::: info 什么是自动装箱与拆箱？<br>:::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>上面这两行代码对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>通过字节码代码，不难发现，装箱其实就是调用了 包装类的 <code>valueOf()</code> 方法；而拆箱其实就是调用了 <code>xxxValue()</code> 方法。再次印证前文的内容：</p>
<ul>
<li><strong>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的</strong>。</li>
<li><strong>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的</strong>。</li>
</ul>
<p>因此，</p>
<ul>
<li><code>Integer a = 10</code> 等价于 <code>Integer a = Integer.valueOf(10)</code></li>
<li><code>int b = a</code> 等价于 <code>int b = a.intValue()</code>;</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<p>:::</p>
<h3 id="【中等】包装类型的缓存机制了解么？"><a href="#【中等】包装类型的缓存机制了解么？" class="headerlink" title="【中等】包装类型的缓存机制了解么？"></a>【中等】包装类型的缓存机制了解么？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>::: tabs</p>
<p>@tab <strong><code>Integer</code> 缓存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <strong><code>Character</code> 缓存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <strong><code>Boolean</code> 缓存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <code>Float</code> 和 <code>Double</code> 无缓存</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。你答对了吗？</p>
<p>值得一提的是，包装类通过缓存一定范围的常用数值，避免重复创建对象，以减少内存使用的思想，正是采用了<strong>享元模式</strong>（设计模式之一）。</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h3 id="【简单】比较包装类型为什么不能用-？"><a href="#【简单】比较包装类型为什么不能用-？" class="headerlink" title="【简单】比较包装类型为什么不能用 &#x3D;&#x3D;？"></a>【简单】比较包装类型为什么不能用 &#x3D;&#x3D;？</h3><p>Java 值类型的包装类大部分都使用了缓存机制来提升性能：</p>
<ul>
<li><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类，默认都创建了数值在 <strong>[-128，127]</strong> 范围之间的相应类型缓存数据；</li>
<li><code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围之间的缓存数据；</li>
<li><code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>；</li>
</ul>
<p>试图装箱的数值，如果超出缓存范围，则会创建新的对象。</p>
<p>以 <code>Long.valueOf</code> 方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】为什么浮点数运算的时候会有精度丢失的风险？"><a href="#【中等】为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="【中等】为什么浮点数运算的时候会有精度丢失的风险？"></a>【中等】为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b); <span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="【简单】如何解决浮点数运算的精度丢失问题？"><a href="#【简单】如何解决浮点数运算的精度丢失问题？" class="headerlink" title="【简单】如何解决浮点数运算的精度丢失问题？"></a>【简单】如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 直接使用字符串初始化（如 <code>new BigDecimal(&quot;0.1&quot;)</code>）可完全避免二进制浮点误差。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）可以通过 <code>BigDecimal</code> 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<h3 id="【简单】超过-long-整型的数据应该如何表示？"><a href="#【简单】超过-long-整型的数据应该如何表示？" class="headerlink" title="【简单】超过 long 整型的数据应该如何表示？"></a>【简单】超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><h3 id="【简单】静态变量、成员变量、局部变量的区别？"><a href="#【简单】静态变量、成员变量、局部变量的区别？" class="headerlink" title="【简单】静态变量、成员变量、局部变量的区别？"></a>【简单】静态变量、成员变量、局部变量的区别？</h3><p><strong>静态变量、成员变量、局部变量的主要区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>静态变量（static）</strong></th>
<th><strong>成员变量（非 static）</strong></th>
<th><strong>局部变量</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属</strong></td>
<td>类（所有实例共享）</td>
<td>对象（每个实例独立）</td>
<td>方法&#x2F;代码块内</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>类加载时创建，程序结束时销毁</td>
<td>对象创建时存在，垃圾回收时销毁</td>
<td>方法调用时创建，执行完销毁</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>方法区（JDK8+在元空间&#x2F;堆）</td>
<td>堆（对象内部）</td>
<td>栈（方法栈帧）</td>
</tr>
<tr>
<td><strong>默认值</strong></td>
<td>有（如<code>int</code>默认为 0）</td>
<td>有（同静态变量）</td>
<td><strong>无</strong>（必须手动初始化）</td>
</tr>
<tr>
<td><strong>访问方式</strong></td>
<td><code>类名.变量名</code> 或 <code>对象.变量名</code></td>
<td><code>对象.变量名</code></td>
<td>只能在声明的方法&#x2F;块内使用</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>：</p>
<ul>
<li><strong>静态变量</strong>：全局唯一，类共享。</li>
<li><strong>成员变量</strong>：对象私有，每个实例独立。</li>
<li><strong>局部变量</strong>：临时使用，方法内有效。</li>
</ul>
<h3 id="【简单】为什么成员变量有默认值？"><a href="#【简单】为什么成员变量有默认值？" class="headerlink" title="【简单】为什么成员变量有默认值？"></a>【简单】为什么成员变量有默认值？</h3><p><strong>成员变量有默认值的核心原因是：防止随机值风险</strong>。</p>
<ul>
<li><strong>内存安全</strong>：未初始化的变量会指向内存中的随机值，可能导致程序行为异常或崩溃。</li>
<li><strong>稳定运行</strong>：自动赋默认值（如 <code>int</code>→<code>0</code>，<code>boolean</code>→<code>false</code>）确保程序逻辑可预测。</li>
</ul>
<p><strong>编译器设计的权衡</strong></p>
<ul>
<li><strong>成员变量</strong>：<strong>自动赋默认值是内存安全与灵活性的平衡</strong>。<ul>
<li>运行时可能通过反射、构造器等动态赋值，编译器无法完全静态检测。</li>
<li>为避免误报错误，统一自动赋默认值。</li>
</ul>
</li>
<li><strong>局部变量</strong>：<strong>严格编译检查确保代码可靠性</strong>。<ul>
<li>作用域限于方法内，编译器可严格检查是否赋值。</li>
<li>强制手动初始化以规避潜在风险。</li>
</ul>
</li>
</ul>
<h3 id="【简单】字符型常量和字符串常量的区别？"><a href="#【简单】字符型常量和字符串常量的区别？" class="headerlink" title="【简单】字符型常量和字符串常量的区别？"></a>【简单】字符型常量和字符串常量的区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>字符常量</strong></th>
<th align="left"><strong>字符串常量</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>表示形式</strong></td>
<td align="left">单引号括起的<strong>单个字符</strong>（<code>&#39;A&#39;</code>）</td>
<td align="left">双引号括起的<strong>字符序列</strong>（<code>&quot;ABC&quot;</code>）</td>
</tr>
<tr>
<td align="left"><strong>数据类型</strong></td>
<td align="left"><code>char</code>（基本类型）</td>
<td align="left"><code>String</code>（引用类型）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">2 字节（Unicode 字符，如 <code>&#39;中&#39;</code>、<code>&#39;\n&#39;</code>）</td>
<td align="left">对象开销+字符数据（可变长度）</td>
</tr>
<tr>
<td align="left"><strong>转义字符</strong></td>
<td align="left">支持（<code>&#39;\t&#39;</code>、<code>&#39;\\&#39;</code>）</td>
<td align="left">同样支持（<code>&quot;\t&quot;</code>、<code>&quot;\\&quot;</code>）</td>
</tr>
<tr>
<td align="left"><strong>空值表示</strong></td>
<td align="left">不可为空（至少 1 字符）</td>
<td align="left">可为空（<code>&quot;&quot;</code>）</td>
</tr>
<tr>
<td align="left"><strong>运算行为</strong></td>
<td align="left">按 Unicode 值运算</td>
<td align="left">重载<code>+</code>为拼接</td>
</tr>
</tbody></table>
<h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><h3 id="【简单】Java-方法有哪些类型？"><a href="#【简单】Java-方法有哪些类型？" class="headerlink" title="【简单】Java 方法有哪些类型？"></a>【简单】Java 方法有哪些类型？</h3><p>Java 方法的类型可以从不同维度分类。</p>
<p>::: tabs</p>
<p>@tab <strong>按从属划分</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>关键字</strong></th>
<th><strong>调用方式</strong></th>
<th><strong>特点</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实例方法</strong></td>
<td>无</td>
<td><code>对象名.方法名 ()</code></td>
<td>依赖对象实例，可访问实例成员</td>
<td><code>list.add(&quot;item&quot;)</code></td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td><code>static</code></td>
<td><code>类名.方法名 ()</code></td>
<td>不依赖实例，只能访问静态成员</td>
<td><code>Math.abs(-1)</code></td>
</tr>
<tr>
<td><strong>构造方法</strong></td>
<td>无</td>
<td><code>new 类名 ()</code></td>
<td>用于对象初始化，无返回值类型</td>
<td><code>new String(&quot;hello&quot;)</code></td>
</tr>
</tbody></table>
<p>@tab <strong>按能否 <code>override</code> 划分</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>关键字</strong></th>
<th><strong>特点</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>普通方法</strong></td>
<td>无</td>
<td>可被重写（除非<code>final</code>修饰）</td>
<td><code>public void show()</code></td>
</tr>
<tr>
<td><strong>final 方法</strong></td>
<td><code>final</code></td>
<td>禁止子类重写</td>
<td><code>public final void lock()</code></td>
</tr>
<tr>
<td><strong>抽象方法</strong></td>
<td><code>abstract</code></td>
<td>无实现，需子类重写</td>
<td><code>abstract void draw();</code></td>
</tr>
<tr>
<td><strong>默认方法</strong></td>
<td><code>default</code></td>
<td>Java 8 接口中的默认实现</td>
<td><code>default void log()</code></td>
</tr>
</tbody></table>
<p>@tab <strong>按参数与返回值划分</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>无参方法</strong></td>
<td>不需要参数</td>
<td><code>String getName()</code></td>
</tr>
<tr>
<td><strong>有参方法</strong></td>
<td>可接受基本类型&#x2F;对象参数</td>
<td><code>void setAge(int age)</code></td>
</tr>
<tr>
<td><strong>可变参方法</strong></td>
<td>参数数量可变（<code>...</code>语法）</td>
<td><code>void print(String... strs)</code></td>
</tr>
<tr>
<td><strong>无返回值方法</strong></td>
<td>返回类型为<code>void</code></td>
<td><code>void shutdown()</code></td>
</tr>
<tr>
<td><strong>有返回值方法</strong></td>
<td>必须返回指定类型值</td>
<td><code>int calculate()</code></td>
</tr>
</tbody></table>
<p>@tab <strong>特殊方法</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>native 方法</strong></td>
<td>用<code>native</code>声明，由本地代码实现</td>
<td><code>public native void start()</code></td>
</tr>
<tr>
<td><strong>synchronized 方法</strong></td>
<td>用<code>synchronized</code>修饰，线程安全</td>
<td><code>public synchronized void save()</code></td>
</tr>
<tr>
<td><strong>递归方法</strong></td>
<td>方法内部调用自身</td>
<td><code>int factorial(int n)</code></td>
</tr>
<tr>
<td><strong>泛型方法</strong></td>
<td>声明类型参数</td>
<td><code>&lt;T&gt; T getData()</code></td>
</tr>
</tbody></table>
<p>@tab <strong>接口中的方法</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>关键字</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象方法</strong></td>
<td>无</td>
<td>默认<code>public abstract</code></td>
</tr>
<tr>
<td><strong>默认方法</strong></td>
<td><code>default</code></td>
<td>Java 8 引入，提供默认实现</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td><code>static</code></td>
<td>Java 8 引入，接口直接调用</td>
</tr>
<tr>
<td><strong>私有方法</strong></td>
<td><code>private</code></td>
<td>Java 9 引入，仅供接口内部使用</td>
</tr>
</tbody></table>
<p>:::</p>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例方法 vs 静态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">staticAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; <span class="comment">// 必须由子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123; System.out.println(msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">wrap</span><span class="params">(T item)</span> &#123; <span class="keyword">return</span> item; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::: info 如何选择方法类型？<br>:::</p>
<ul>
<li><strong>需要操作对象状态</strong> → 实例方法（如<code>user.getName()</code>）</li>
<li><strong>工具类操作</strong> → 静态方法（如<code>Collections.sort()</code>）</li>
<li><strong>强制子类实现</strong> → 抽象方法（如<code>Animal.eat()</code>）</li>
<li><strong>接口功能扩展</strong> → 默认方法（Java 8+）</li>
<li><strong>线程安全控制</strong> → <code>synchronized</code>方法</li>
</ul>
<h3 id="【简单】静态方法和实例方法有何不同？"><a href="#【简单】静态方法和实例方法有何不同？" class="headerlink" title="【简单】静态方法和实例方法有何不同？"></a>【简单】静态方法和实例方法有何不同？</h3><p><strong>静态方法和实例方法主要区别</strong>：</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>静态方法 (Static Method)</strong></th>
<th><strong>实例方法 (Instance Method)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>归属</strong></td>
<td>属于类</td>
<td>属于对象实例</td>
</tr>
<tr>
<td><strong>关键字</strong></td>
<td>使用 <code>static</code> 修饰</td>
<td>无 <code>static</code> 修饰</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><code>类名.方法名 ()</code></td>
<td><code>对象名.方法名 ()</code></td>
</tr>
<tr>
<td><strong>内存分配</strong></td>
<td>类加载时分配，永久代（JDK8 前）&#x2F;元空间（JDK8+）</td>
<td>对象实例化时分配，堆内存</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>与类相同（从类加载到 JVM 退出）</td>
<td>与对象相同（从对象创建到被 GC 回收）</td>
</tr>
</tbody></table>
<p><strong>访问权限对比</strong>：</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>静态方法</strong></th>
<th><strong>实例方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>访问静态成员</strong></td>
<td>✅ 可直接访问</td>
<td>✅ 可直接访问</td>
</tr>
<tr>
<td><strong>访问实例成员</strong></td>
<td>❌ 不能直接访问（需先创建对象）</td>
<td>✅ 可直接访问</td>
</tr>
<tr>
<td><strong>this&#x2F;super</strong></td>
<td>❌ 不可使用</td>
<td>✅ 可使用</td>
</tr>
</tbody></table>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;  <span class="comment">// 不依赖对象状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBase</span><span class="params">(<span class="type">int</span> base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;  <span class="comment">// 依赖对象状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> base + x;  <span class="comment">// 访问实例变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Calculator.add(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// 无需创建对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例方法调用</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        calc.setBase(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calc.calculate(<span class="number">5</span>);  <span class="comment">// 需要对象实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【简单】重载和重写有什么区别？"><a href="#【简单】重载和重写有什么区别？" class="headerlink" title="【简单】重载和重写有什么区别？"></a>【简单】重载和重写有什么区别？</h3><p><strong>Java 重载（Overload）与重写（Override）的核心区别</strong>：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>重载（Overload）</strong></th>
<th><strong>重写（Override）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>同一类中方法名相同但参数不同</td>
<td>子类重新实现父类的方法</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>处理不同类型&#x2F;数量的参数</td>
<td>修改或扩展父类方法的行为</td>
</tr>
<tr>
<td><strong>多态类型</strong></td>
<td>编译时多态（静态绑定）</td>
<td>运行时多态（动态绑定）</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>同一类中（或父子类间）</td>
<td>子类与父类之间</td>
</tr>
<tr>
<td><strong>方法签名</strong></td>
<td><strong>必须不同参数</strong>（类型&#x2F;数量&#x2F;顺序）</td>
<td><strong>必须完全相同</strong>（方法名+参数）</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>可自由修改</td>
<td>基本类型&#x2F;void：必须相同；引用类型：可协变（子类更具体）</td>
</tr>
<tr>
<td><strong>异常</strong></td>
<td>可自由声明</td>
<td>子类异常 ≤ 父类异常范围</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>可自由修改</td>
<td>子类权限 ≥ 父类（不能更严格）</td>
</tr>
<tr>
<td><strong>限制方法</strong></td>
<td>无</td>
<td>不能重写 <code>private</code>&#x2F;<code>final</code>&#x2F;<code>static</code> 方法</td>
</tr>
</tbody></table>
<p>::: code-tabs#重载和重写的示例</p>
<p>@tab 重载示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 参数类型不同</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量不同</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> a + b + c; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab 重写示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">sound</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Unknown sound&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sound</span><span class="params">()</span> &#123;  <span class="comment">// 访问权限扩大，返回值相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<p>::: note 关键区别总结</p>
<ul>
<li><strong>绑定时机</strong><ul>
<li>重载：编译时根据参数决定调用的方法（<code>Calculator.add(int)</code> vs <code>Calculator.add(double)</code>）</li>
<li>重写：运行时根据对象实际类型决定方法（<code>Animal.sound()</code> 实际调用 <code>Cat.sound()</code>）</li>
</ul>
</li>
<li><strong>设计目的</strong><ul>
<li>重载：<strong>横向扩展</strong>（同一功能的不同参数版本）</li>
<li>重写：<strong>纵向覆盖</strong>（子类定制父类行为）</li>
</ul>
</li>
<li><strong>验证阶段</strong><ul>
<li>重载：编译器检查参数差异</li>
<li>重写：编译器检查方法签名 + JVM 运行时验证</li>
</ul>
</li>
</ul>
<p>:::</p>
<h3 id="【简单】什么是可变长参数？"><a href="#【简单】什么是可变长参数？" class="headerlink" title="【简单】什么是可变长参数？"></a>【简单】什么是可变长参数？</h3><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(arg1 + arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<p>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> args.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> var1[var3];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-异常"><a href="#Java-异常" class="headerlink" title="Java 异常"></a>Java 异常</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504030805467.webp"></p>
<h3 id="【简单】Exception-和-Error-有什么区别？"><a href="#【简单】Exception-和-Error-有什么区别？" class="headerlink" title="【简单】Exception 和 Error 有什么区别？"></a>【简单】Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类：</p>
<ul>
<li><strong><code>Exception</code></strong> - 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又分为<strong>检查</strong>（checked）异常和<strong>非检查</strong>（unchecked）异常，检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</li>
<li><strong><code>Error</code></strong> - <code>Error</code> 属于程序无法处理的错误。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误（<code>OutOfMemoryError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="【简单】Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#【简单】Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="【简单】Checked Exception 和 Unchecked Exception 有什么区别？"></a>【简单】Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>差异对比</strong>：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Checked Exception</strong></th>
<th><strong>Unchecked Exception</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>编译检查</strong></td>
<td>必须显式处理（<code>catch</code>&#x2F;<code>throws</code>），否则编译失败</td>
<td>不强制处理，编译可通过</td>
</tr>
<tr>
<td><strong>继承体系</strong></td>
<td>继承自 <code>Exception</code>（非 <code>RuntimeException</code> 分支）</td>
<td>继承自 <code>RuntimeException</code></td>
</tr>
<tr>
<td><strong>设计目的</strong></td>
<td>处理<strong>可预见的、可恢复的</strong>异常情况（如文件不存在）</td>
<td>处理<strong>程序逻辑错误</strong>（如空指针）</td>
</tr>
</tbody></table>
<p>::: tabs#Checked Exception 和 Unchecked Exception 示例对比</p>
<p>@tab <strong>Checked Exception 示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理 IOException（受检异常）</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.readAllBytes(Paths.get(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  <span class="comment">// 或声明 throws IOException</span></span><br><span class="line">    System.err.println(<span class="string">&quot;文件读取失败：&quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <strong>Unchecked Exception 示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可不处理 NullPointerException（非受检异常）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.length());  <span class="comment">// 运行时抛出 NullPointerException</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<p><strong>常见异常类型</strong></p>
<table>
<thead>
<tr>
<th><strong>Checked Exception</strong></th>
<th><strong>Unchecked Exception</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>IOException</code></td>
<td><code>NullPointerException</code></td>
</tr>
<tr>
<td><code>SQLException</code></td>
<td><code>IllegalArgumentException</code></td>
</tr>
<tr>
<td><code>ClassNotFoundException</code></td>
<td><code>ArrayIndexOutOfBoundsException</code></td>
</tr>
<tr>
<td><code>InterruptedException</code></td>
<td><code>ClassCastException</code></td>
</tr>
</tbody></table>
<p><strong>选择原则</strong></p>
<ul>
<li><p><strong>用 Checked Exception</strong>：</p>
<ul>
<li>调用方<strong>必须处理</strong>该异常（如文件不存在、网络断开）</li>
<li>异常是业务逻辑的<strong>合法流程</strong>（如用户输入校验）</li>
</ul>
</li>
<li><p><strong>用 Unchecked Exception</strong>：</p>
<ul>
<li>表示<strong>程序错误</strong>（如参数为 null、数组越界）</li>
<li>调用方<strong>无法合理恢复</strong>（如内存溢出）</li>
</ul>
</li>
</ul>
<h3 id="【简单】Throwable-类常用方法有哪些？"><a href="#【简单】Throwable-类常用方法有哪些？" class="headerlink" title="【简单】Throwable 类常用方法有哪些？"></a>【简单】Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="【简单】try-catch-finally-如何使用？"><a href="#【简单】try-catch-finally-如何使用？" class="headerlink" title="【简单】try-catch-finally 如何使用？"></a>【简单】try-catch-finally 如何使用？</h3><ul>
<li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块：用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to <span class="keyword">do</span> something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5">jvm 官方文档</a> 中有明确提到：</p>
<blockquote>
<p>If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p>
<ol>
<li>Saves the return value (if any) in a local variable.</li>
<li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li>
<li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li>
</ol>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="【简单】finally-中的代码一定会执行吗？"><a href="#【简单】finally-中的代码一定会执行吗？" class="headerlink" title="【简单】finally 中的代码一定会执行吗？"></a>【简单】finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的 Java 虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Try</span> <span class="keyword">to</span> <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">Catch</span> Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure>

<p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h3 id="【简单】如何使用-try-with-resources-代替try-catch-finally？"><a href="#【简单】如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="【简单】如何使用 try-with-resources 代替try-catch-finally？"></a>【简单】如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3><ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effective Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【简单】NoClassDefFoundError-和-ClassNotFoundException-有什么区别"><a href="#【简单】NoClassDefFoundError-和-ClassNotFoundException-有什么区别" class="headerlink" title="【简单】NoClassDefFoundError 和 ClassNotFoundException 有什么区别"></a>【简单】NoClassDefFoundError 和 ClassNotFoundException 有什么区别</h3><p><code>NoClassDefFoundError</code>是一个 Error，而 <code>ClassNotFoundException</code> 是一个 Exception。</p>
<p><code>ClassNotFoundException</code> 产生的原因：</p>
<ul>
<li>使用 <code>Class.forName</code>、<code>ClassLoader.loadClass</code>、<code>ClassLOader.findSystemClass</code> 方法动态加载类，如果这个类没有被找到，那么就会在运行时抛出 <code>ClassNotFoundException</code> 异常；</li>
<li>当一个类已经被某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
</ul>
<p><code>NoClassDefFoundError</code> 产生的原因：当 JVM 或 <code>ClassLoader</code> 试图加载类，却找不到类的定义时（编译时存在，运行时找不到），抛出异常。</p>
<h3 id="【简单】异常使用有哪些需要注意的地方？"><a href="#【简单】异常使用有哪些需要注意的地方？" class="headerlink" title="【简单】异常使用有哪些需要注意的地方？"></a>【简单】异常使用有哪些需要注意的地方？</h3><ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li>
<li>……</li>
</ul>
<h3 id="【中等】Java-中-final、finally-和-finalize-有什么区别？"><a href="#【中等】Java-中-final、finally-和-finalize-有什么区别？" class="headerlink" title="【中等】Java 中 final、finally 和 finalize 有什么区别？"></a>【中等】Java 中 final、finally 和 finalize 有什么区别？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">final</th>
<th align="left">finally</th>
<th align="left">finalize</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">关键字</td>
<td align="left">代码块</td>
<td align="left">方法</td>
</tr>
<tr>
<td align="left"><strong>作用域</strong></td>
<td align="left">变量&#x2F;方法&#x2F;类</td>
<td align="left">异常处理块</td>
<td align="left">Object 类方法</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">声明不可变性</td>
<td align="left">即使有异常也必然执行，确保资源释放</td>
<td align="left">对象回收前的清理（已废弃）</td>
</tr>
<tr>
<td align="left"><strong>特点</strong></td>
<td align="left">可修饰变量（常量）、方法（不可重写）、类（不可继承）</td>
<td align="left">与<code>try-catch</code>搭配，<strong>必然执行</strong>（除非 JVM 退出）</td>
<td align="left">不推荐用，执行时机不可控</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">定义常量&#x2F;限制继承</td>
<td align="left">资源清理</td>
<td align="left">历史遗留的清理逻辑</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>：<code>final</code>管<strong>不变性</strong>，<code>finally</code>管<strong>必执行</strong>，<code>finalize</code>是<strong>过时的清理机制</strong>。</p>
<p>（注：现代 Java 开发用<code>try-with-resources</code>替代<code>finalize</code>）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/blog/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"11d050d74382da19a3385d9f8027eb99"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
