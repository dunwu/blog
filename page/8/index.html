<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/8/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1625eb55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1625eb55/" class="post-title-link" itemprop="url">Redis 过期删除和内存淘汰</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 15:14:13" itemprop="dateCreated datePublished" datetime="2023-08-23T15:14:13+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h1><blockquote>
<p>关键词：<code>定时删除</code>、<code>惰性删除</code>、<code>定期删除</code>、<code>LRU</code>、<code>LFU</code></p>
</blockquote>
<h2 id="Redis-过期删除"><a href="#Redis-过期删除" class="headerlink" title="Redis 过期删除"></a>Redis 过期删除</h2><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>Redis 中，和键的生存时间相关的命令如下所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/expire/"><code>EXPIRE</code></a></td>
<td>设置 key 的过期时间，单位为秒</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/pexpire/"><code>PEXPIRE</code></a></td>
<td>设置 key 的过期时间，单位为毫秒</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/expireat/"><code>EXPIREAT</code></a></td>
<td>设置 key 的过期时间为指定的秒级时间戳</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/pexpireat/"><code>PEXPIREAT</code></a></td>
<td>设置 key 的过期时间为指定的毫秒级时间戳</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/ttl/"><code>TTL</code></a></td>
<td>返回 key 的剩余生存时间，单位为秒</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/pttl/"><code>PTTL</code></a></td>
<td>返回 key 的剩余生存时间，单位为毫秒</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://redis.io/commands/persist/"><code>PERSIST</code></a></td>
<td>移除 key 的过期时间，key 将持久保持</td>
</tr>
</tbody></table>
<p>【示例】EXPIRE、TTL 操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> key value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key 的生存时间为 60s</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expire key 60</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key 的剩余生存时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key</span></span><br><span class="line">(integer) 58</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">60s 之内</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get key</span></span><br><span class="line">&quot;value&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">60s 之外</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get key</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>【示例】EXPIREAT、TTL 操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> key value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key 的生存时间为 1692419299</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expireat key 1692419299</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key 的剩余生存时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key</span></span><br><span class="line">(integer) 9948</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1692419299 之前</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get key</span></span><br><span class="line">&quot;value&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1692419299 之后</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get key</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="如何保存过期时间"><a href="#如何保存过期时间" class="headerlink" title="如何保存过期时间"></a>如何保存过期时间</h4><p>在 Redis 中，redisDb 结构的 <code>expires</code> 字典保存了数据库中所有键的过期时间，这个字典称为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向某个键对象</li>
<li>过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了键的过期时间——一个毫秒精度的 UNIX 时间戳。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>下图是一个带有过期字典的示例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309171537744.png"></p>
<p>当执行 <code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIREAT</code> 命令，Redis 都会将其转为 <code>PEXPIREAT</code> 形式的时间戳，然后维护在 <code>expires</code> 字典中。</p>
<h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>过期键的判定流程如下：</p>
<ul>
<li>检查指定 key 是否存在于过期字典；如果存在，则取得 key 的过期时间。</li>
<li>检查当前时间戳是否大于 key 的过期时间：如果是，key 已过期；反之，key 未过期。</li>
</ul>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><ul>
<li><strong>定时删除</strong> - 在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行对 key 的删除操作。<ul>
<li>优点 - 保证过期 key 被尽可能快的删除，释放内存。</li>
<li>缺点 - <strong>如果过期 key 较多，可能会占用相当一部分的 CPU，从而影响服务器的吞吐量和响应时延</strong>。</li>
</ul>
</li>
<li><strong>惰性删除</strong> - 放任 key 过期不管，但是每次访问 key 时，都检查 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。<ul>
<li>优点 - 占用 CPU 最少。程序只会在读写键时，对当前键进行过期检查，因此不会有额外的 CPU 开销。</li>
<li>缺点 - <strong>过期的 key 可能因为没有被访问，而一直无法释放，造成内存的浪费，有内存泄漏的风险</strong>。</li>
</ul>
</li>
<li><strong>定期删除</strong> - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key 。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。定期删除策略的难点是删除操作执行的时长和频率。<ul>
<li>执行太频或执行时间过长，就会出现和定时删除相同的问题；</li>
<li>执行太少或执行时间过短，就会出现和惰性删除相同的问题；</li>
</ul>
</li>
</ul>
<h3 id="Redis-的过期删除策略"><a href="#Redis-的过期删除策略" class="headerlink" title="Redis 的过期删除策略"></a>Redis 的过期删除策略</h3><p>Redis 同时采用了惰性删除和定期删除策略，以此在合理使用 CPU 和内存之间取得平衡。</p>
<p><strong>Redis 定期删除策略的实现</strong> - 由 <code>redis.c/activeExpireCycle</code> 函数实现，每当 Redis 周期性执行 <code>redis.c/serverCron</code> 函数时，<code>activeExpireCycle</code> 函数就会被调用。<code>activeExpireCycle</code> 函数会在规定时间内，遍历各个数据库，从 <code>expires</code> 字典中随机检查一部分键的过期时间，并删除过期的键。</p>
<p><strong>Redis 惰性删除策略的实现</strong> - 由 <code>db.c/expireIfNeeded</code> 函数实现，所有读写命令在执行之前都会调用 <code>expireIfNeeded</code> 函数对输入键进行检查：如果输入键已过期，将输入键从数据库中删除；否则，什么也不做。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309171604805.png"></p>
<h3 id="AOF、RDB-和复制对过期键的处理"><a href="#AOF、RDB-和复制对过期键的处理" class="headerlink" title="AOF、RDB 和复制对过期键的处理"></a>AOF、RDB 和复制对过期键的处理</h3><ul>
<li>生成 RDB 文件 - <strong>执行 <code>SAVE</code> 命令或者 <code>BGSAVE</code> 命令，所产生的新 RDB 文件“不会包含已经过期的键”</strong>。</li>
<li>载入 RDB 文件 - <strong>主服务器“不会载入已过期的键”</strong>；<strong>从服务器会载入“会载入已过期的键”</strong>。</li>
<li>生成 AOF 文件 - 当一个过期键未被删除时，不会影响 AOF 文件；当一个过期键被删除之后， 服务器会追加一条 <code>DEL</code> 命令到现有 AOF 文件的末尾， 显式地删除过期键。</li>
<li>重写 AOF 文件 - <strong>执行 <code>BGREWRITEAOF</code> 命令所产生的重写 AOF 文件“不会包含已经过期的键”</strong>。</li>
<li>复制 - 当主服务器删除一个过期键之后， 它会向所有从服务器发送一条 <code>DEL</code> 命令， 显式地删除过期键。从服务器即使发现过期键， 也不会自作主张地删除它， 而是等待主节点发来 DEL 命令， 这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当 Redis 命令对数据库进行修改之后， 服务器会根据配置， 向客户端发送数据库通知。</li>
</ul>
<h2 id="Redis-内存淘汰"><a href="#Redis-内存淘汰" class="headerlink" title="Redis 内存淘汰"></a>Redis 内存淘汰</h2><h3 id="Redis-内存淘汰要点"><a href="#Redis-内存淘汰要点" class="headerlink" title="Redis 内存淘汰要点"></a>Redis 内存淘汰要点</h3><ul>
<li><strong>失效时间</strong> - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，<code>EXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIRE</code>、<code>PEXPIREAT</code> 以及 <code>SETEX</code> 和 <code>PSETEX</code> 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。</li>
<li><strong>最大缓存</strong> - Redis 允许通过 <code>maxmemory</code> 参数来设置内存最大值。当内存达设定的阀值，就会触发<strong>内存淘汰</strong>。</li>
<li><strong>内存淘汰</strong> - 内存淘汰是为了更好的利用内存——清理部分缓存，以此换取内存的利用率，即尽量保证 Redis 缓存中存储的是热点数据。</li>
<li><strong>非精准的 LRU</strong> - 实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。</li>
</ul>
<h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p>
<p>Redis 提供了下面几种内存淘汰策略供用户选：</p>
<ul>
<li><strong>不淘汰</strong><ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
</ul>
</li>
<li><strong>在过期键中进行淘汰</strong><ul>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-lfu</code></strong> （Redis 4.0 新增）- 淘汰所有设置了过期时间的键值中，最少使用的键值。</li>
</ul>
</li>
<li><strong>在所有键中进行淘汰</strong><ul>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>allkeys-lfu</code></strong> (Redis 4.0 新增) - 淘汰整个键值中最少使用的键值。</li>
</ul>
</li>
</ul>
<h3 id="如何选择淘汰策略"><a href="#如何选择淘汰策略" class="headerlink" title="如何选择淘汰策略"></a>如何选择淘汰策略</h3><ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>。</li>
<li>如果数据呈现平均分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li>若 Redis 既用于缓存，也用于持久化存储时，适用 <code>volatile-lru</code> 、<code>volatile-lfu</code>、<code>volatile-random</code>。但是，这种情况下，也可以部署两个 Redis 集群来达到同样目的。</li>
<li>为 key 设置过期时间实际上会消耗更多的内存。因此，如果条件允许，建议使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>，从而更高效的使用内存。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c13783ff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c13783ff/" class="post-title-link" itemprop="url">Redis 数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 15:14:13" itemprop="dateCreated datePublished" datetime="2023-08-23T15:14:13+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><blockquote>
<p>关键词：<code>对象</code>、<code>SDS</code>、<code>链表</code>、<code>字典</code>、<code>跳表</code>、<code>整数集合</code>、<code>压缩列表</code></p>
</blockquote>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><h3 id="SDS-简介"><a href="#SDS-简介" class="headerlink" title="SDS 简介"></a>SDS 简介</h3><p>SDS 是 Simple Dynamic String 的缩写，即<strong>简单动态字符串</strong>。Redis 为 SDS 做了一些优化，以替代 C 字符串来表示字符串内容。此外，SDS 还被 Redis 用作缓冲区（buffer），如：AOF 模块中的 AOF 缓冲区；客户端状态中的输入缓冲区。</p>
<p>SDS 相比 C 字符串，具有以下优势：</p>
<table>
<thead>
<tr>
<th align="left">C 字符串</th>
<th align="left">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取字符串长度的复杂度为 O(N) 。</td>
<td align="left">获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td align="left">API 是不安全的，可能会造成缓冲区溢出。</td>
<td align="left">API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td align="left">修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td>
<td align="left">修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。</td>
</tr>
<tr>
<td align="left">只能保存文本数据。</td>
<td align="left">可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td align="left">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数。</td>
<td align="left">可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。</td>
</tr>
</tbody></table>
<h3 id="SDS-实现"><a href="#SDS-实现" class="headerlink" title="SDS 实现"></a>SDS 实现</h3><p>每个 <code>sds.h/sdshdr</code> 结构表示一个 SDS 值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410100815385.svg"></p>
<h3 id="SDS-特性"><a href="#SDS-特性" class="headerlink" title="SDS 特性"></a>SDS 特性</h3><p>SDS 与 C 字符串相比，做了一些优化，具有以下优势：</p>
<h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><ul>
<li>C 字符串 - 因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 <code>O(N)</code> 。</li>
<li>SDS - 因为 SDS 在 <code>len</code> 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 <code>O(1)</code> 。设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。</li>
</ul>
<h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><ul>
<li>C 字符串 - C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</li>
<li>SDS - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</li>
</ul>
<h4 id="减少修改字符串长度时所需的内存重分配次数"><a href="#减少修改字符串长度时所需的内存重分配次数" class="headerlink" title="减少修改字符串长度时所需的内存重分配次数"></a>减少修改字符串长度时所需的内存重分配次数</h4><ul>
<li>C 字符串 - 对于一个包含了 <code>N</code> 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 <code>N+1</code> 个字符长的数组（额外的一个字符空间用于保存空字符）。因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作。<ul>
<li>增长字符串时，如果没有内存重分配，就会产生缓冲区溢出。</li>
<li>缩减字符串是，如果没有内存重分配，就会产生内存泄露。</li>
</ul>
</li>
<li>SDS - 因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作。SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， <code>buf</code> 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 <code>free</code> 属性记录。通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。<ul>
<li><strong>空间预分配</strong> - <strong>空间预分配用于优化 SDS 的字符串增长操作</strong>。 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。通过空间预分配， SDS 将连续增长 <code>N</code> 次字符串所需的内存重分配次数从必定 <code>N</code> 次降低为最多 <code>N</code> 次。</li>
<li><strong>惰性空间</strong> - <strong>惰性空间释放用于优化 SDS 的字符串缩短操作</strong>。当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 <code>free</code> 属性将这些字节的数量记录起来， 并等待将来使用。通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。</li>
</ul>
</li>
</ul>
<h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><ul>
<li>C 字符串 - C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 <strong>C 字符串只能保存文本数据</strong>， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>SDS - SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf</code> 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。<strong>通过使用二进制安全的 SDS ， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据</strong>。</li>
</ul>
<h4 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的， 但也会遵循 C 字符串惯例，将保存的数据的末尾设置为空字符， 并且总会在为 <code>buf</code> 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code> 库定义的函数。因此，SDS 可以兼容部分 C 字符串函数。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h3><p><strong>链表被广泛用于实现 Redis 的各种功能，比如 List 键，订阅与发布，慢查询，监视器等</strong>。此外，Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区（output buffer）。</p>
<p>由于 C 语言没有内置的链表，因此 Redis 自实现了一个链表：<strong>Redis 的链表实现其实就是一个双链表</strong>。</p>
<ul>
<li>每个链表使用一个 list 结构来表示，这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL，所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数，Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>每个链表节点由一个 <code>adlist.h/listNode</code> 结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以 Redis 的链表实现是双链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双链表。</p>
<p>虽然仅仅使用多个 <code>listNode</code> 结构就可以组成链表， 但使用 <code>adlist.h/list</code> 来持有链表的话， 操作起来会更方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><code>list</code> 结构为链表提供了表头指针 <code>head</code> 、表尾指针 <code>tail</code> ， 以及链表长度计数器 <code>len</code> ， 而 <code>dup</code> 、 <code>free</code> 和 <code>match</code> 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li><code>dup</code> 函数 - 用于复制链表节点所保存的值；</li>
<li><code>free</code> 函数 - 用于释放链表节点所保存的值；</li>
<li><code>match</code> 函数 - 用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410100817994.svg"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典简介"><a href="#字典简介" class="headerlink" title="字典简介"></a>字典简介</h3><p>字典是一种用于保存键值对（key-value pair）的抽象数据结构。字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p>
<p>由于 C 语言没有内置的链表，因此 Redis 自实现了一个字典。</p>
<p>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和 Hash 键。</p>
<h3 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h3><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
<p>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code> 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个键值对。</li>
<li><code>size</code> 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（键值对）的数量。</li>
<li><code>sizemask</code> 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面。</li>
</ul>
<p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</li>
<li><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li>
</ul>
<p>Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
<li><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</li>
<li><code>rehashidx</code> 属性记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410100819328.svg"></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， <strong>Redis 使用 <a target="_blank" rel="noopener" href="http://code.google.com/p/smhasher/">MurmurHash2</a> 算法来计算键的哈希值</strong>。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[<span class="number">0</span>] 或者 ht[<span class="number">1</span>]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p><strong>Redis 使用链地址法（separate chaining）来解决哈希冲突</strong>： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410100822993.svg"></p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><h4 id="rehash-的步骤"><a href="#rehash-的步骤" class="headerlink" title="rehash 的步骤"></a>rehash 的步骤</h4><ol>
<li>为字典的 <code>ht[1]</code> 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 <code>ht[0]</code> 当前包含的键值对数量 （也即是 ht[0].used 属性的值）。</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p><img src="http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png"></p>
<p><img src="http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png"></p>
<p><img src="http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png"></p>
<p><img src="http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png"></p>
<h4 id="rehash-的条件"><a href="#rehash-的条件" class="headerlink" title="rehash 的条件"></a>rehash 的条件</h4><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式计算得出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line"><span class="attribute">load_factor</span> = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>

<h4 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h4><p>渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><h3 id="跳表简介"><a href="#跳表简介" class="headerlink" title="跳表简介"></a>跳表简介</h3><p>跳表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳表的效率可以和平衡树相媲美， 并且因为跳表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳表来代替平衡树。</p>
<p>Redis 使用跳表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳表来作为有序集合键的底层实现。</p>
<p>此外，Redis 还在集群节点中用跳表作为内部数据结构。</p>
<h3 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h3><p>Redis 的跳表实现由 <code>zskiplist</code> 和 <code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code> 用于保存跳表信息（比如表头节点、表尾节点、长度）， 而 <code>zskiplistNode</code> 则用于表示跳表节点。</p>
<p><img src="http://redisbook.com/_images/graphviz-59432127803598137980d030e8e529c5b068bebb.png"></p>
<p><code>zskiplist</code> 结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>header</code> 和 <code>tail</code> 指针分别指向跳表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>通过使用 <code>length</code> 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳表的长度。</li>
<li><code>level</code> 属性则用于在 O(1) 复杂度内获取跳表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。<strong>每个跳表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数</strong>。</li>
</ul>
<p>跳表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<ul>
<li>层（level）：每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：在跳表中，节点按各自所保存的分值从小到大排列。<strong>在同一个跳表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的</strong>。跳表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
<li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h3 id="整数集合简介"><a href="#整数集合简介" class="headerlink" title="整数集合简介"></a>整数集合简介</h3><p><strong>整数集合（intset）是集合键的底层实现之一</strong>。当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p><strong>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型</strong>。</p>
<p><strong>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存</strong>。</p>
<p><strong>整数集合只支持升级操作， 不支持降级操作</strong>。</p>
<h3 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h3><p>整数集合是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</li>
<li><code>length</code> 属性记录了整数集合包含的元素数量， 也即是 <code>contents</code> 数组的长度。</li>
<li>虽然 <code>intset</code> 结构将 <code>contents</code> 属性声明为 <code>int8_t</code> 类型的数组， 但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值：<ul>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li>
</ul>
</li>
</ul>
<p><img src="http://redisbook.com/_images/graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f.png"></p>
<p><img src="http://redisbook.com/_images/graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png"></p>
<h3 id="整数集合升级"><a href="#整数集合升级" class="headerlink" title="整数集合升级"></a>整数集合升级</h3><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="压缩列表简介"><a href="#压缩列表简介" class="headerlink" title="压缩列表简介"></a>压缩列表简介</h3><p><strong>压缩列表是一种为节约内存而开发的顺序型数据结构</strong>。</p>
<p><strong>压缩列表（ziplist）被用作列表键和哈希键的底层实现之一</strong>。</p>
<ul>
<li>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</li>
<li>当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</li>
</ul>
<p><strong>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</strong>。</p>
<p>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</p>
<h3 id="压缩列表实现"><a href="#压缩列表实现" class="headerlink" title="压缩列表实现"></a>压缩列表实现</h3><p>压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">长度</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code> 的位置时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left"><code>2</code> 字节</td>
<td align="left">记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left">列表节点</td>
<td align="left">不定</td>
<td align="left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>1</code> 字节</td>
<td align="left">特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>Redis 数据库中的每个键值对的键和值都是一个对象。</p>
<p>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</p>
<p>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</p>
<p><strong>基于引用计数技术的内存回收机制</strong> - Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</p>
<p><strong>基于引用计数技术的对象共享机制</strong> - Redis 会共享值为 <code>0</code> 到 <code>9999</code> 的字符串对象。</p>
<p><strong>计算数据库键的空转时长</strong> - 对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</p>
<h3 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h3><p><strong>Redis 使用对象来表示数据库中的键和值</strong>。每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>Redis 中的每个对象都由一个 <code>redisObject</code> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的 <code>type</code> 属性记录了对象的类型，有以下类型：</p>
<table>
<thead>
<tr>
<th align="left">对象</th>
<th align="left">对象 <code>type</code> 属性的值</th>
<th align="left">TYPE 命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串对象</td>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td align="left">列表对象</td>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>&quot;list&quot;</code></td>
</tr>
<tr>
<td align="left">哈希对象</td>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>&quot;hash&quot;</code></td>
</tr>
<tr>
<td align="left">集合对象</td>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>&quot;set&quot;</code></td>
</tr>
<tr>
<td align="left">有序集合对象</td>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>&quot;zset&quot;</code></td>
</tr>
</tbody></table>
<p>Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<p>【示例】通过 <code>TYPE</code> 命令查看数据库键的值对象的类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为字符串对象</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TYPE msg</span></span><br><span class="line">string</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为列表对象</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPUSH numbers 1 3 5</span></span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TYPE numbers</span></span><br><span class="line">list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为哈希对象</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMSET profile name Tome age 25 career Programmer</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TYPE profile</span></span><br><span class="line">hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为集合对象</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD fruits apple banana cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TYPE fruits</span></span><br><span class="line">set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为有序集合对象</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TYPE price</span></span><br><span class="line">zset</span><br></pre></td></tr></table></figure>

<h3 id="对象的编码"><a href="#对象的编码" class="headerlink" title="对象的编码"></a>对象的编码</h3><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现。</p>
<p>Redis 中每种类型的对象都至少使用了两种不同的编码，<strong>不同的编码可以在不同的使用场景上优化对象的使用效率</strong>。</p>
<p>Redis 支持的编码如下所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码</th>
<th align="left">对象</th>
<th><strong>OBJECT ENCODING</strong> <strong>命令输出</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_INT</code></td>
<td align="left">使用整数值实现的字符串对象。</td>
<td>“int”</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td align="left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
<td>“embstr”</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_RAW</code></td>
<td align="left">使用简单动态字符串实现的字符串对象。</td>
<td>“raw”</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的列表对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td align="left">使用双端链表实现的列表对象。</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的哈希对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的哈希对象。</td>
<td>“hashtable”</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_INTSET</code></td>
<td align="left">使用整数集合实现的集合对象。</td>
<td>“intset”</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的集合对象。</td>
<td>“hashtable”</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的有序集合对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td align="left">使用跳表和字典实现的有序集合对象。</td>
<td>“skiplist”</td>
</tr>
</tbody></table>
<p>【示例】使用 <code>OBJECT ENCODING</code> 命令可以查看数据库键的值对象的编码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello wrold&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT ENCODING msg</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET story <span class="string">&quot;long long long long long long ago ...&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT ENCODING story</span></span><br><span class="line">&quot;raw&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis 中用于操作键的命令基本上可以分为两种类型。</p>
<ul>
<li><strong>多态命令</strong> - 可以对任何类型的键执行。如 DEL、 EXPIRE 、 RENAME 、 TYPE 、 OBJECT 等命令。</li>
<li><strong>特定类型命令</strong><ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</li>
</ul>
</li>
</ul>
<p>为了确保只有指定类型的键可以执行某些特定的命令，Redis 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>由于 C 语言不支持内存回收，Redis 内部实现了一套基于引用计数的内存回收机制。</p>
<p>每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>
</ul>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>Redis 会在初始化服务器时， 共享值为 <code>0</code> 到 <code>9999</code> 的字符串对象。</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p><code>redisObject</code> 的 <code>lru</code> 属性记录了对象最后一次被命令程序访问的时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><code>OBJECT IDLETIME</code> 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待一小段时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待一阵子</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 180</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问 msg 键的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET msg</span></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键处于活跃状态，空转时长为 0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p><code>OBJECT IDLETIME</code> 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>
</blockquote>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ede171bb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ede171bb/" class="post-title-link" itemprop="url">《极客时间教程 - 玩转 Spring 全家桶》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-29 15:25:09" itemprop="dateCreated datePublished" datetime="2023-07-29T15:25:09+08:00">2023-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>32k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-玩转-Spring-全家桶》笔记"><a href="#《极客时间教程-玩转-Spring-全家桶》笔记" class="headerlink" title="《极客时间教程 - 玩转 Spring 全家桶》笔记"></a>《极客时间教程 - 玩转 Spring 全家桶》笔记</h1><h2 id="第一章：初识-Spring-4-讲"><a href="#第一章：初识-Spring-4-讲" class="headerlink" title="第一章：初识 Spring (4 讲)"></a>第一章：初识 Spring (4 讲)</h2><h3 id="01-Spring-课程介绍"><a href="#01-Spring-课程介绍" class="headerlink" title="01 | Spring 课程介绍"></a>01 | Spring 课程介绍</h3><h3 id="02-一起认识-Spring-家族的主要成员"><a href="#02-一起认识-Spring-家族的主要成员" class="headerlink" title="02 | 一起认识 Spring 家族的主要成员"></a>02 | 一起认识 Spring 家族的主要成员</h3><p>Spring Framework - 用于构建企业级应用的轻量级一站式解决方案</p>
<p>Spring Boot - 快速构建基于 Spring 的应用程序</p>
<p>Spring Cloud - 简化分布式系统的开发</p>
<h3 id="03-跟着-Spring-了解技术趋势"><a href="#03-跟着-Spring-了解技术趋势" class="headerlink" title="03 | 跟着 Spring 了解技术趋势"></a>03 | 跟着 Spring 了解技术趋势</h3><p>略</p>
<h3 id="04-编写你的第一个-Spring-程序"><a href="#04-编写你的第一个-Spring-程序" class="headerlink" title="04 | 编写你的第一个 Spring 程序"></a>04 | 编写你的第一个 Spring 程序</h3><p>略</p>
<h2 id="第二章：JDBC-必知必会-10-讲"><a href="#第二章：JDBC-必知必会-10-讲" class="headerlink" title="第二章：JDBC 必知必会 (10 讲)"></a>第二章：JDBC 必知必会 (10 讲)</h2><h3 id="05-如何配置单数据源"><a href="#05-如何配置单数据源" class="headerlink" title="05 | 如何配置单数据源"></a>05 | 如何配置单数据源</h3><h4 id="直接配置所需的-Bean"><a href="#直接配置所需的-Bean" class="headerlink" title="直接配置所需的 Bean"></a>直接配置所需的 Bean</h4><p>数据源相关</p>
<ul>
<li>DataSource（根据选择的连接池实现决定）</li>
</ul>
<p>事务相关（可选）</p>
<ul>
<li>PlatformTransactionManager（DataSourceTransactionManager）</li>
<li>TransactionTemplate</li>
</ul>
<p>操作相关（可选）</p>
<ul>
<li>JdbcTemplate</li>
</ul>
<h4 id="Spring-Boot-做了哪些配置"><a href="#Spring-Boot-做了哪些配置" class="headerlink" title="Spring Boot 做了哪些配置"></a>Spring Boot 做了哪些配置</h4><p>DataSourceAutoConfiguration</p>
<ul>
<li>配置 DataSource</li>
</ul>
<p>DataSourceTransactionManagerAutoConfiguration</p>
<ul>
<li>配置 DataSourceTransactionManager</li>
</ul>
<p>JdbcTemplateAutoConfiguration</p>
<ul>
<li>配置 JdbcTemplate</li>
</ul>
<p>符合条件时才进行配置</p>
<h4 id="数据源相关配置属性"><a href="#数据源相关配置属性" class="headerlink" title="数据源相关配置属性"></a>数据源相关配置属性</h4><p>通用</p>
<ul>
<li><code>spring.datasource.url=jdbc:mysql://localhost/test</code></li>
<li><code>spring.datasource.username=dbuser</code></li>
<li><code>spring.datasource.password=dbpass</code></li>
<li><code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>（可选）</li>
</ul>
<p>初始化内嵌数据库</p>
<ul>
<li><code>spring.datasource.initialization-mode=embedded|always|never</code></li>
<li>spring.datasource.schema 与 spring.datasource.data 确定初始化 SQL ⽂文件</li>
<li><code>spring.datasource.platform=hsqldb | h2 | oracle | mysql | postgresql</code>（与前者对应）</li>
</ul>
<h3 id="06-如何配置多数据源"><a href="#06-如何配置多数据源" class="headerlink" title="06 | 如何配置多数据源"></a>06 | 如何配置多数据源</h3><h4 id="配置多数据源的注意事项"><a href="#配置多数据源的注意事项" class="headerlink" title="配置多数据源的注意事项"></a>配置多数据源的注意事项</h4><p>不同数据源的配置要分开</p>
<p>关注每次使用的数据源</p>
<ul>
<li>有多个 DataSource 时系统如何判断</li>
<li>对应的设施（事务、ORM 等）如何选择 DataSource</li>
</ul>
<h4 id="Spring-Boot-中的多数据源配置"><a href="#Spring-Boot-中的多数据源配置" class="headerlink" title="Spring Boot 中的多数据源配置"></a>Spring Boot 中的多数据源配置</h4><p>手工配置两组 DataSource 及相关内容</p>
<p>与 Spring Boot 协同工作（二选一）</p>
<ul>
<li>配置@Primary 类型的 Bean</li>
<li>排除 Spring Boot 的自动配置</li>
<li>DataSourceAutoConfiguration</li>
<li>DataSourceTransactionManagerAutoConfiguration</li>
<li>JdbcTemplateAutoConfiguration</li>
</ul>
<h3 id="07-那些好用的连接池们：HikariCP"><a href="#07-那些好用的连接池们：HikariCP" class="headerlink" title="07 | 那些好用的连接池们：HikariCP"></a>07 | 那些好用的连接池们：HikariCP</h3><h4 id="在-Spring-Boot-中的配置"><a href="#在-Spring-Boot-中的配置" class="headerlink" title="在 Spring Boot 中的配置"></a>在 Spring Boot 中的配置</h4><p>Spring Boot 2.x</p>
<ul>
<li>默认使用 HikariCP</li>
<li>配置 spring.datasource.hikari.* 配置</li>
</ul>
<p>Spring Boot 1.x</p>
<ul>
<li>默认使用 Tomcat 连接池，需要移除 tomcat-jdbc 依赖</li>
<li>spring.datasource.type&#x3D;com.zaxxer.hikari.HikariDataSource</li>
</ul>
<h4 id="常用-HikariCP-配置参数"><a href="#常用-HikariCP-配置参数" class="headerlink" title="常用 HikariCP 配置参数"></a>常用 HikariCP 配置参数</h4><p>常用配置</p>
<ul>
<li>spring.datasource.hikari.maximumPoolSize&#x3D;10</li>
<li>spring.datasource.hikari.minimumIdle&#x3D;10</li>
<li>spring.datasource.hikari.idleTimeout&#x3D;600000</li>
<li>spring.datasource.hikari.connectionTimeout&#x3D;30000</li>
<li>spring.datasource.hikari.maxLifetime&#x3D;1800000</li>
</ul>
<p>其他配置详见 HikariCP 官网</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a></li>
</ul>
<h3 id="08-那些好用的连接池们：Alibaba-Druid"><a href="#08-那些好用的连接池们：Alibaba-Druid" class="headerlink" title="08 | 那些好用的连接池们：Alibaba Druid"></a>08 | 那些好用的连接池们：Alibaba Druid</h3><h4 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h4><p>直接配置 DruidDataSource</p>
<p>通过 druid-spring-boot-starter</p>
<ul>
<li><code>spring.datasource.druid.*</code></li>
</ul>
<p>Filter 配置</p>
<ul>
<li>spring.datasource.druid.filters&#x3D;stat,config,wall,log4j （全部使用默认值）</li>
</ul>
<p>密码加密</p>
<ul>
<li><code>spring.datasource.password=&lt;加密密码&gt;</code></li>
<li><code>spring.datasource.druid.filter.config.enabled=true</code></li>
<li><code>spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=&lt;public-key&gt;</code></li>
</ul>
<p>SQL 防注入</p>
<ul>
<li><code>spring.datasource.druid.filter.wall.enabled=true</code></li>
<li><code>spring.datasource.druid.filter.wall.db-type=h2</code></li>
<li><code>spring.datasource.druid.filter.wall.config.delete-allow=false</code></li>
<li><code>spring.datasource.druid.filter.wall.config.drop-table-allow=false</code></li>
</ul>
<h4 id="Druid-Filter"><a href="#Druid-Filter" class="headerlink" title="Druid Filter"></a>Druid Filter</h4><ul>
<li>用于定制连接池操作的各种环节</li>
<li>可以继承 FilterEventAdapter 以便方便地实现 Filter</li>
<li>修改 META-INF&#x2F;druid-filter.properties 增加 Filter 配置</li>
</ul>
<h3 id="09-如何通过-Spring-JDBC-访问数据库"><a href="#09-如何通过-Spring-JDBC-访问数据库" class="headerlink" title="09 | 如何通过 Spring JDBC 访问数据库"></a>09 | 如何通过 Spring JDBC 访问数据库</h3><h4 id="Spring-的-JDBC-操作类"><a href="#Spring-的-JDBC-操作类" class="headerlink" title="Spring 的 JDBC 操作类"></a>Spring 的 JDBC 操作类</h4><p>spring-jdbc</p>
<ul>
<li>core，JdbcTemplate 等相关核心接口和类</li>
<li>datasource，数据源相关的辅助类</li>
<li>object，将基本的 JDBC 操作封装成对象</li>
<li>support，错误码等其他辅助工具</li>
</ul>
<h4 id="常用的-Bean-注解"><a href="#常用的-Bean-注解" class="headerlink" title="常用的 Bean 注解"></a>常用的 Bean 注解</h4><p>通过注解定义 Bean</p>
<ul>
<li><code>@Component</code></li>
<li><code>@Repository</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
<li><code>@RestController</code></li>
</ul>
<h4 id="简单的-JDBC-操作"><a href="#简单的-JDBC-操作" class="headerlink" title="简单的 JDBC 操作"></a>简单的 JDBC 操作</h4><p><code>JdbcTemplate</code></p>
<ul>
<li><code>query</code></li>
<li><code>queryForObject</code></li>
<li><code>queryForList</code></li>
<li><code>update</code></li>
<li><code>execute</code></li>
</ul>
<h4 id="SQL-批处理"><a href="#SQL-批处理" class="headerlink" title="SQL 批处理"></a>SQL 批处理</h4><p><code>JdbcTemplate</code></p>
<ul>
<li><code>batchUpdate</code></li>
<li><code>BatchPreparedStatementSetter</code></li>
</ul>
<p><code>NamedParameterJdbcTemplate</code></p>
<ul>
<li><code>batchUpdate</code></li>
<li><code>SqlParameterSourceUtils.createBatch</code></li>
</ul>
<h3 id="10-什么是-Spring-的事务抽象（上）"><a href="#10-什么是-Spring-的事务抽象（上）" class="headerlink" title="10 | 什么是 Spring 的事务抽象（上）"></a>10 | 什么是 Spring 的事务抽象（上）</h3><h3 id="11-什么是-Spring-的事务抽象（下）"><a href="#11-什么是-Spring-的事务抽象（下）" class="headerlink" title="11 | 什么是 Spring 的事务抽象（下）"></a>11 | 什么是 Spring 的事务抽象（下）</h3><h4 id="Spring-的事务抽象"><a href="#Spring-的事务抽象" class="headerlink" title="Spring 的事务抽象"></a>Spring 的事务抽象</h4><p>一致的事务模型</p>
<ul>
<li>JDBC&#x2F;Hibernate&#x2F;myBatis</li>
<li>DataSource&#x2F;JTA</li>
</ul>
<h4 id="事务抽象的核心接口"><a href="#事务抽象的核心接口" class="headerlink" title="事务抽象的核心接口"></a>事务抽象的核心接口</h4><p>PlatformTransactionManager</p>
<ul>
<li>DataSourceTransactionManager</li>
<li>HibernateTransactionManager</li>
<li>JtaTransactionManager</li>
</ul>
<p>TransactionDefinition</p>
<ul>
<li>Propagation</li>
<li>Isolation</li>
<li>Timeout</li>
<li>Read-only status</li>
</ul>
<h4 id="事务传播特性"><a href="#事务传播特性" class="headerlink" title="事务传播特性"></a>事务传播特性</h4><table>
<thead>
<tr>
<th>传播性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>0</td>
<td>当前有事务就用当前的，没有就用新的</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>1</td>
<td>事务可有可无，不是必须的</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>2</td>
<td>当前一定要有事务，不然就抛异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>3</td>
<td>无论是否有事务，都起个新的事务</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>4</td>
<td>不支持事务，按非事务方式运行</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>5</td>
<td>不支持事务，如果有事务则抛异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>6</td>
<td>当前有事务就在当前事务里再起一个事务</td>
</tr>
</tbody></table>
<h4 id="事务隔离特性"><a href="#事务隔离特性" class="headerlink" title="事务隔离特性"></a>事务隔离特性</h4><table>
<thead>
<tr>
<th>隔离性</th>
<th>值</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>1</td>
<td>✔️️️</td>
<td>✔️️️</td>
<td>✔️️️</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>2</td>
<td>❌</td>
<td>✔️️️</td>
<td>✔️️️</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>3</td>
<td>❌</td>
<td>❌</td>
<td>✔️️️</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>4</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><p>TransactionTemplate</p>
<ul>
<li>TransactionCallback</li>
<li>TransactionCallbackWithoutResult</li>
</ul>
<p>PlatformTransactionManager</p>
<ul>
<li>可以传入 TransactionDefinition 进行定义</li>
</ul>
<h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>开启事务注解的方式</p>
<ul>
<li><code>@EnableTransactionManagement</code></li>
<li><code>&lt;tx:annotation-driven/&gt;</code></li>
</ul>
<p>一些配置</p>
<ul>
<li><code>proxyTargetClass</code></li>
<li><code>mode</code></li>
<li><code>order</code></li>
</ul>
<p><code>@Transactional</code></p>
<ul>
<li><code>transactionManager</code></li>
<li><code>propagation</code></li>
<li><code>isolation</code></li>
<li><code>timeout</code></li>
<li><code>readOnly</code></li>
<li>怎么判断回滚</li>
</ul>
<h3 id="12-了解-Spring-的-JDBC-异常抽象"><a href="#12-了解-Spring-的-JDBC-异常抽象" class="headerlink" title="12 | 了解 Spring 的 JDBC 异常抽象"></a>12 | 了解 Spring 的 JDBC 异常抽象</h3><h4 id="Spring-的-JDBC-异常抽象"><a href="#Spring-的-JDBC-异常抽象" class="headerlink" title="Spring 的 JDBC 异常抽象"></a>Spring 的 JDBC 异常抽象</h4><p>Spring 会将数据操作的异常转换为 DataAccessException</p>
<p>无论使用何种数据访问方式，都能使用一样的异常</p>
<h4 id="Spring-是怎么认识那些错误码的"><a href="#Spring-是怎么认识那些错误码的" class="headerlink" title="Spring 是怎么认识那些错误码的"></a>Spring 是怎么认识那些错误码的</h4><p>通过 SQLErrorCodeSQLExceptionTranslator 解析错误码</p>
<p>ErrorCode 定义</p>
<ul>
<li>org&#x2F;springframework&#x2F;jdbc&#x2F;support&#x2F;sql-error-codes.xml</li>
<li>Classpath 下的 sql-error-codes.xml</li>
</ul>
<h3 id="13-课程答疑（上）"><a href="#13-课程答疑（上）" class="headerlink" title="13 | 课程答疑（上）"></a>13 | 课程答疑（上）</h3><p>略</p>
<h3 id="14-课程答疑（下）"><a href="#14-课程答疑（下）" class="headerlink" title="14 | 课程答疑（下）"></a>14 | 课程答疑（下）</h3><p>略</p>
<h2 id="第三章：O-R-Mapping-实践-9-讲"><a href="#第三章：O-R-Mapping-实践-9-讲" class="headerlink" title="第三章：O&#x2F;R Mapping 实践 (9 讲)"></a>第三章：O&#x2F;R Mapping 实践 (9 讲)</h2><h3 id="15-认识-Spring-Data-JPA"><a href="#15-认识-Spring-Data-JPA" class="headerlink" title="15 | 认识 Spring Data JPA"></a>15 | 认识 Spring Data JPA</h3><h4 id="Java-Persistence-API"><a href="#Java-Persistence-API" class="headerlink" title="Java Persistence API"></a>Java Persistence API</h4><p>JPA 为对象关系映射提供了一种基于 POJO 的持久化模型</p>
<ul>
<li>简化数据持久化代码的开发工作</li>
<li>为 Java 社区屏蔽不同持久化 API 的差异</li>
</ul>
<h4 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h4><p>在保留底层存储特性的同时，提供相对一致的、基于 Spring 的编程模型</p>
<p>主要模块</p>
<ul>
<li>Spring Data Commons</li>
<li>Spring Data JDBC</li>
<li>Spring Data JPA</li>
<li>Spring Data Redis</li>
<li>……</li>
</ul>
<h3 id="16-定义-JPA-的实体对象"><a href="#16-定义-JPA-的实体对象" class="headerlink" title="16 | 定义 JPA 的实体对象"></a>16 | 定义 JPA 的实体对象</h3><h4 id="常用-JPA-注解"><a href="#常用-JPA-注解" class="headerlink" title="常用 JPA 注解"></a>常用 JPA 注解</h4><p>实体</p>
<ul>
<li>@Entity、@MappedSuperclass</li>
<li>@Table(name)</li>
</ul>
<p>主键</p>
<ul>
<li>@Id</li>
<li>@GeneratedValue(strategy, generator)</li>
<li>@SequenceGenerator(name, sequenceName)</li>
</ul>
<p>映射</p>
<ul>
<li>@Column(name, nullable, length, insertable, updatable)</li>
<li>@JoinTable(name)、@JoinColumn(name)</li>
</ul>
<p>关系</p>
<ul>
<li>@OneToOne、@OneToMany、@ManyToOne、@ManyToMany</li>
<li>@OrderBy</li>
</ul>
<h4 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h4><p>Project Lombok 能够自动嵌入 IDE 和构建工具，提升开发效率</p>
<p>常用功能</p>
<ul>
<li>@Getter &#x2F; @Setter</li>
<li>@ToString</li>
<li>@NoArgsConstructor &#x2F; @RequiredArgsConstructor &#x2F; @AllArgsConstructor</li>
<li>@Data</li>
<li>@Builder</li>
<li>@Slf4j &#x2F; @CommonsLog &#x2F; @Log4j2</li>
</ul>
<h3 id="17-开始我们的线上咖啡馆实战项目：SpringBucks"><a href="#17-开始我们的线上咖啡馆实战项目：SpringBucks" class="headerlink" title="17 | 开始我们的线上咖啡馆实战项目：SpringBucks"></a>17 | 开始我们的线上咖啡馆实战项目：SpringBucks</h3><p>略</p>
<h3 id="18-通过-Spring-Data-JPA-操作数据库"><a href="#18-通过-Spring-Data-JPA-操作数据库" class="headerlink" title="18 | 通过 Spring Data JPA 操作数据库"></a>18 | 通过 Spring Data JPA 操作数据库</h3><h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><p>@EnableJpaRepositories</p>
<p>Repository&lt;T, ID&gt; 接口</p>
<ul>
<li>CrudRepository&lt;T, ID&gt;</li>
<li>PagingAndSortingRepository&lt;T, ID&gt;</li>
<li>JpaRepository&lt;T, ID&gt;</li>
</ul>
<h4 id="定义查询"><a href="#定义查询" class="headerlink" title="定义查询"></a>定义查询</h4><p>根据方法名定义查询</p>
<ul>
<li><code>find…By… / read…By… / query…By… / get…By…</code></li>
<li><code>count…By…</code></li>
<li><code>…OrderBy…[Asc / Desc]</code></li>
<li><code>And / Or / IgnoreCase</code></li>
<li><code>Top / First / Distinct</code></li>
</ul>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul>
<li><code>PagingAndSortingRepository&lt;T, ID&gt;</code></li>
<li><code>Pageable / Sort</code></li>
<li><code>Slice&lt;T&gt; / Page&lt;T&gt;</code></li>
</ul>
<h3 id="19-Spring-Data-JPA-的-Repository-是怎么从接口变成-Bean-的"><a href="#19-Spring-Data-JPA-的-Repository-是怎么从接口变成-Bean-的" class="headerlink" title="19 | Spring Data JPA 的 Repository 是怎么从接口变成 Bean 的"></a>19 | Spring Data JPA 的 Repository 是怎么从接口变成 Bean 的</h3><h4 id="Repository-Bean-是如何创建的"><a href="#Repository-Bean-是如何创建的" class="headerlink" title="Repository Bean 是如何创建的"></a>Repository Bean 是如何创建的</h4><p>JpaRepositoriesRegistrar</p>
<ul>
<li>激活了 @EnableJpaRepositories</li>
<li>返回了 JpaRepositoryConfigExtension</li>
</ul>
<p>RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions</p>
<ul>
<li>注册 Repository Bean（类型是 JpaRepositoryFactoryBean）</li>
</ul>
<p>RepositoryConfigurationExtensionSupport.getRepositoryConfigurations</p>
<ul>
<li>取得 Repository 配置</li>
</ul>
<p>JpaRepositoryFactory.getTargetRepository</p>
<ul>
<li>创建了 Repository</li>
</ul>
<h4 id="接口中的方法是如何被解释的"><a href="#接口中的方法是如何被解释的" class="headerlink" title="接口中的方法是如何被解释的"></a>接口中的方法是如何被解释的</h4><p>RepositoryFactorySupport.getRepository 添加了 Advice</p>
<ul>
<li>DefaultMethodInvokingMethodInterceptor</li>
<li>QueryExecutorMethodInterceptor</li>
</ul>
<p>AbstractJpaQuery.execute 执行具体的查询</p>
<p>语法解析在 Part 中</p>
<h3 id="20-通过-MyBatis-操作数据库"><a href="#20-通过-MyBatis-操作数据库" class="headerlink" title="20 | 通过 MyBatis 操作数据库"></a>20 | 通过 MyBatis 操作数据库</h3><p>在 Spring 中使用 MyBatis</p>
<ul>
<li>MyBatis Spring Adapter（<a target="_blank" rel="noopener" href="https://github.com/mybatis/spring%EF%BC%89">https://github.com/mybatis/spring）</a></li>
<li>MyBatis Spring-Boot-Starter（<a target="_blank" rel="noopener" href="https://github.com/mybatis/spring-boot-starter%EF%BC%89">https://github.com/mybatis/spring-boot-starter）</a></li>
</ul>
<p>简单配置</p>
<ul>
<li>mybatis.mapper-locations &#x3D; classpath*:mapper&#x2F;**&#x2F;*.xml</li>
<li>mybatis.type-aliases-package &#x3D; 类型别名的包名</li>
<li>mybatis.type-handlers-package &#x3D; TypeHandler 扫描包名</li>
<li>mybatis.configuration.map-underscore-to-camel-case &#x3D; true</li>
</ul>
<p>Mapper 的定义与扫描</p>
<ul>
<li>@MapperScan 配置扫描位置</li>
<li>@Mapper 定义接口</li>
<li>映射的定义—— XML 与注解</li>
</ul>
<h3 id="21-让-MyBatis-更好用的那些工具：MyBatis-Generator"><a href="#21-让-MyBatis-更好用的那些工具：MyBatis-Generator" class="headerlink" title="21 | 让 MyBatis 更好用的那些工具：MyBatis Generator"></a>21 | 让 MyBatis 更好用的那些工具：MyBatis Generator</h3><p>MyBatis Generator（<a target="_blank" rel="noopener" href="http://www.mybatis.org/generator/%EF%BC%89">http://www.mybatis.org/generator/）</a></p>
<h3 id="22-让-MyBatis-更好用的那些工具：MyBatis-PageHelper"><a href="#22-让-MyBatis-更好用的那些工具：MyBatis-PageHelper" class="headerlink" title="22 | 让 MyBatis 更好用的那些工具：MyBatis PageHelper"></a>22 | 让 MyBatis 更好用的那些工具：MyBatis PageHelper</h3><p>MyBatis PageHepler（<a target="_blank" rel="noopener" href="https://pagehelper.github.io)/">https://pagehelper.github.io）</a></p>
<h3 id="23-SpringBucks-实战项目进度小结"><a href="#23-SpringBucks-实战项目进度小结" class="headerlink" title="23 | SpringBucks 实战项目进度小结"></a>23 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第四章：NoSQL-实践-7-讲"><a href="#第四章：NoSQL-实践-7-讲" class="headerlink" title="第四章：NoSQL 实践 (7 讲)"></a>第四章：NoSQL 实践 (7 讲)</h2><h3 id="24-通过-Docker-辅助开发"><a href="#24-通过-Docker-辅助开发" class="headerlink" title="24 | 通过 Docker 辅助开发"></a>24 | 通过 Docker 辅助开发</h3><h4 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h4><p>镜像相关</p>
<ul>
<li><code>docker pull &lt;image&gt;</code></li>
<li><code>docker search &lt;image&gt;</code></li>
</ul>
<p>容器相关</p>
<ul>
<li><code>docker run</code></li>
<li><code>docker start/stop &lt;容器名&gt;</code></li>
<li><code>docker ps &lt;容器名&gt;</code></li>
<li><code>docker logs &lt;容器名&gt;</code></li>
</ul>
<h4 id="docker-run-的常用选项"><a href="#docker-run-的常用选项" class="headerlink" title="docker run 的常用选项"></a>docker run 的常用选项</h4><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</code></p>
<p>选项说明</p>
<ul>
<li>-d，后台运行容器</li>
<li>-e，设置环境变量</li>
<li>–expose &#x2F; -p 宿主端口:容器端口</li>
<li>–name，指定容器名称</li>
<li>–link，链接不同容器</li>
<li>-v 宿主目录:容器目录，挂载磁盘卷</li>
</ul>
<h4 id="国内-Docker-镜像配置"><a href="#国内-Docker-镜像配置" class="headerlink" title="国内 Docker 镜像配置"></a>国内 Docker 镜像配置</h4><p>官方 Docker Hub</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a></li>
</ul>
<p>官方镜像</p>
<ul>
<li>镜像 <a target="_blank" rel="noopener" href="https://www.docker-cn.com/registry-mirror">https://www.docker-cn.com/registry-mirror</a></li>
<li>下载 <a target="_blank" rel="noopener" href="https://www.docker-cn.com/get-docker">https://www.docker-cn.com/get-docker</a></li>
</ul>
<p>阿里云镜像</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.aliyun.com/">https://dev.aliyun.com</a></li>
</ul>
<h3 id="25-在-Spring-中访问-MongoDB"><a href="#25-在-Spring-中访问-MongoDB" class="headerlink" title="25 | 在 Spring 中访问 MongoDB"></a>25 | 在 Spring 中访问 MongoDB</h3><h4 id="Spring-对-MongoDB-的支持"><a href="#Spring-对-MongoDB-的支持" class="headerlink" title="Spring 对 MongoDB 的支持"></a>Spring 对 MongoDB 的支持</h4><ul>
<li>Spring Data MongoDB<ul>
<li>MongoTemplate</li>
<li>Repository 支持</li>
</ul>
</li>
</ul>
<h4 id="Spring-Data-MongoDB-的基本用法"><a href="#Spring-Data-MongoDB-的基本用法" class="headerlink" title="Spring Data MongoDB 的基本用法"></a>Spring Data MongoDB 的基本用法</h4><p>注解</p>
<ul>
<li>@Document</li>
<li>@Id</li>
</ul>
<p>MongoTemplate</p>
<ul>
<li>save &#x2F; remove</li>
<li>Criteria &#x2F; Query &#x2F; Update</li>
</ul>
<h4 id="Spring-Data-MongoDB-的-Repository"><a href="#Spring-Data-MongoDB-的-Repository" class="headerlink" title="Spring Data MongoDB 的 Repository"></a>Spring Data MongoDB 的 Repository</h4><p><code>@EnableMongoRepositories</code></p>
<p>对应接口</p>
<ul>
<li><code>MongoRepository&lt;T, ID&gt;</code></li>
<li><code>PagingAndSortingRepository&lt;T, ID&gt;</code></li>
<li><code>CrudRepository&lt;T, ID&gt;</code></li>
</ul>
<h3 id="26-在-Spring-中访问-Redis"><a href="#26-在-Spring-中访问-Redis" class="headerlink" title="26 | 在 Spring 中访问 Redis"></a>26 | 在 Spring 中访问 Redis</h3><h4 id="Spring-对-Redis-的支持"><a href="#Spring-对-Redis-的支持" class="headerlink" title="Spring 对 Redis 的支持"></a>Spring 对 Redis 的支持</h4><ul>
<li>Spring Data Redis<ul>
<li>支持的客户端 Jedis &#x2F; Lettuce</li>
<li>RedisTemplate</li>
<li>Repository 支持</li>
</ul>
</li>
</ul>
<h4 id="Jedis-客户端的简单使用"><a href="#Jedis-客户端的简单使用" class="headerlink" title="Jedis 客户端的简单使用"></a>Jedis 客户端的简单使用</h4><ul>
<li>Jedis 不是线程安全的</li>
<li>通过 JedisPool 获得 Jedis 实例</li>
<li>直接使用 Jedis 中的方法</li>
</ul>
<h3 id="27-Redis-的哨兵与集群模式"><a href="#27-Redis-的哨兵与集群模式" class="headerlink" title="27 | Redis 的哨兵与集群模式"></a>27 | Redis 的哨兵与集群模式</h3><ul>
<li>JedisSentinelPool</li>
<li>JedisCluster</li>
</ul>
<h3 id="28-了解-Spring-的缓存抽象"><a href="#28-了解-Spring-的缓存抽象" class="headerlink" title="28 | 了解 Spring 的缓存抽象"></a>28 | 了解 Spring 的缓存抽象</h3><h4 id="Spring-的缓存抽象"><a href="#Spring-的缓存抽象" class="headerlink" title="Spring 的缓存抽象"></a>Spring 的缓存抽象</h4><p>为不同的缓存提供一层抽象</p>
<ul>
<li>为 Java 方法增加缓存，缓存执行结果</li>
<li>支持 ConcurrentMap、EhCache、Caffeine、JCache（JSR-107）</li>
<li>接口<ul>
<li><code>org.springframework.cache.Cache</code></li>
<li><code>org.springframework.cache.CacheManager</code></li>
</ul>
</li>
</ul>
<h4 id="基于注解的缓存"><a href="#基于注解的缓存" class="headerlink" title="基于注解的缓存"></a>基于注解的缓存</h4><p>@EnableCaching</p>
<ul>
<li>@Cacheable</li>
<li>@CacheEvict</li>
<li>@CachePut</li>
<li>@Caching</li>
<li>@CacheConfig</li>
</ul>
<h3 id="29-Redis-在-Spring-中的其他用法"><a href="#29-Redis-在-Spring-中的其他用法" class="headerlink" title="29 | Redis 在 Spring 中的其他用法"></a>29 | Redis 在 Spring 中的其他用法</h3><h4 id="与-Redis-建立连接"><a href="#与-Redis-建立连接" class="headerlink" title="与 Redis 建立连接"></a>与 Redis 建立连接</h4><p>配置连接工厂</p>
<ul>
<li>LettuceConnectionFactory 与 JedisConnectionFactory<ul>
<li>RedisStandaloneConfiguration</li>
<li>RedisSentinelConfiguration</li>
<li>RedisClusterConfiguration</li>
</ul>
</li>
</ul>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>Lettuce 内置支持读写分离</p>
<ul>
<li>只读主、只读从</li>
<li>优先读主、优先读从</li>
</ul>
<p>LettuceClientConfiguration</p>
<p>LettucePoolingClientConfiguration</p>
<p>LettuceClientConfigurationBuilderCustomizer</p>
<h4 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h4><p>RedisTemplate&lt;K, V&gt;</p>
<ul>
<li>opsForXxx()</li>
</ul>
<p>StringRedisTemplate</p>
<h4 id="Redis-Repository"><a href="#Redis-Repository" class="headerlink" title="Redis Repository"></a>Redis Repository</h4><p>实体注解</p>
<ul>
<li>@RedisHash</li>
<li>@Id</li>
<li>@Indexed</li>
</ul>
<h4 id="处理不同类型数据源的-Repository"><a href="#处理不同类型数据源的-Repository" class="headerlink" title="处理不同类型数据源的 Repository"></a>处理不同类型数据源的 Repository</h4><p>如何区分这些 Repository</p>
<ul>
<li>根据实体的注解</li>
<li>根据继承的接口类型</li>
<li>扫描不同的包</li>
</ul>
<h3 id="30-SpringBucks-实战项目进度小结"><a href="#30-SpringBucks-实战项目进度小结" class="headerlink" title="30 | SpringBucks 实战项目进度小结"></a>30 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第五章：数据访问进阶-8-讲"><a href="#第五章：数据访问进阶-8-讲" class="headerlink" title="第五章：数据访问进阶 (8 讲)"></a>第五章：数据访问进阶 (8 讲)</h2><h3 id="31-Project-Reactor-介绍（上）"><a href="#31-Project-Reactor-介绍（上）" class="headerlink" title="31 | Project Reactor 介绍（上）"></a>31 | Project Reactor 介绍（上）</h3><h3 id="32-Project-Reactor-介绍（下）"><a href="#32-Project-Reactor-介绍（下）" class="headerlink" title="32 | Project Reactor 介绍（下）"></a>32 | Project Reactor 介绍（下）</h3><p>一些核心的概念</p>
<p>Operators - Publisher &#x2F; Subscriber</p>
<ul>
<li>Nothing Happens Until You subscribe()</li>
<li>Flux [ 0..N ] - onNext()、onComplete()、onError()</li>
<li>Mono [ 0..1 ] - onNext()、onComplete()、onError()</li>
</ul>
<p>Backpressure</p>
<ul>
<li>Subscription</li>
<li>onRequest()、onCancel()、onDispose()</li>
</ul>
<p>线程调度 Schedulers</p>
<ul>
<li>immediate() &#x2F; single() &#x2F; newSingle()</li>
<li>elastic() &#x2F; parallel() &#x2F; newParallel()</li>
</ul>
<p>错误处理</p>
<ul>
<li>onError &#x2F; onErrorReturn &#x2F; onErrorResume</li>
<li>doOnError &#x2F; doFinally</li>
</ul>
<h3 id="33-通过-Reactive-的方式访问-Redis"><a href="#33-通过-Reactive-的方式访问-Redis" class="headerlink" title="33 | 通过 Reactive 的方式访问 Redis"></a>33 | 通过 Reactive 的方式访问 Redis</h3><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>Lettuce 能够支持 Reactive 方式</p>
<p>Spring Data Redis 中主要的支持</p>
<ul>
<li>ReactiveRedisConnection</li>
<li>ReactiveRedisConnectionFactory</li>
<li>ReactiveRedisTemplate</li>
<li>opsForXxx()</li>
</ul>
<h3 id="34-通过-Reactive-的方式访问-MongoDB"><a href="#34-通过-Reactive-的方式访问-MongoDB" class="headerlink" title="34 | 通过 Reactive 的方式访问 MongoDB"></a>34 | 通过 Reactive 的方式访问 MongoDB</h3><h4 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h4><p>MongoDB 官方提供了支持 Reactive 的驱动</p>
<ul>
<li>mongodb-driver-reactivestreams</li>
</ul>
<p>Spring Data MongoDB 中主要的支持</p>
<ul>
<li>ReactiveMongoClientFactoryBean</li>
<li>ReactiveMongoDatabaseFactory</li>
<li>ReactiveMongoTemplate</li>
</ul>
<h3 id="35-通过-Reactive-的方式访问-RDBMS"><a href="#35-通过-Reactive-的方式访问-RDBMS" class="headerlink" title="35 | 通过 Reactive 的方式访问 RDBMS"></a>35 | 通过 Reactive 的方式访问 RDBMS</h3><h4 id="Spring-Data-R2DBC"><a href="#Spring-Data-R2DBC" class="headerlink" title="Spring Data R2DBC"></a>Spring Data R2DBC</h4><p>R2DBC （<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-r2dbc%EF%BC%89">https://spring.io/projects/spring-data-r2dbc）</a></p>
<ul>
<li>Reactive Relational Database Connectivity</li>
</ul>
<p>支持的数据库</p>
<ul>
<li>Postgres（io.r2dbc:r2dbc-postgresql）</li>
<li>H2（io.r2dbc:r2dbc-h2）</li>
<li>Microsoft SQL Server（io.r2dbc:r2dbc-mssql）</li>
</ul>
<p>一些主要的类</p>
<ul>
<li>ConnectionFactory</li>
<li>DatabaseClient<ul>
<li>execute().sql(SQL)</li>
<li>inTransaction(db -&gt; {})</li>
</ul>
</li>
<li>R2dbcExceptionTranslator<ul>
<li>SqlErrorCodeR2dbcExceptionTranslator</li>
</ul>
</li>
</ul>
<p>R2DBC Repository 支持</p>
<p>一些主要的类</p>
<ul>
<li>@EnableR2dbcRepositories</li>
<li>ReactiveCrudRepository&lt;T, ID&gt;</li>
<li>@Table &#x2F; @Id</li>
<li>其中的方法返回都是 Mono 或者 Flux</li>
<li>自定义查询需要自己写 @Query</li>
</ul>
<h3 id="36-通过-AOP-打印数据访问层的摘要（上）"><a href="#36-通过-AOP-打印数据访问层的摘要（上）" class="headerlink" title="36 | 通过 AOP 打印数据访问层的摘要（上）"></a>36 | 通过 AOP 打印数据访问层的摘要（上）</h3><h3 id="37-通过-AOP-打印数据访问层的摘要（下）"><a href="#37-通过-AOP-打印数据访问层的摘要（下）" class="headerlink" title="37 | 通过 AOP 打印数据访问层的摘要（下）"></a>37 | 通过 AOP 打印数据访问层的摘要（下）</h3><h4 id="Spring-AOP-的一些核心概念"><a href="#Spring-AOP-的一些核心概念" class="headerlink" title="Spring AOP 的一些核心概念"></a>Spring AOP 的一些核心概念</h4><table>
<thead>
<tr>
<th>概念</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面</td>
</tr>
<tr>
<td>Join</td>
<td>Point 连接点，Spring AOP 里总是代表一次方法执行</td>
</tr>
<tr>
<td>Advice</td>
<td>通知，在连接点执行的动作</td>
</tr>
<tr>
<td>Pointcut</td>
<td>切入点，说明如何匹配连接点</td>
</tr>
<tr>
<td>Introduction</td>
<td>引入，为现有类型声明额外的方法和属性</td>
</tr>
<tr>
<td>Target</td>
<td>object 目标对象</td>
</tr>
<tr>
<td>AOP proxy</td>
<td>AOP 代理对象，可以是 JDK 动态代理，也可以是 CGLIB 代理</td>
</tr>
<tr>
<td>Weaving</td>
<td>织入，连接切面与目标对象或类型创建代理的过程</td>
</tr>
</tbody></table>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ul>
<li>@EnableAspectJAutoProxy</li>
<li>@Aspect</li>
<li>@Pointcut</li>
<li>@Before</li>
<li>@After &#x2F; @AfterReturning &#x2F; @AfterThrowing</li>
<li>@Around</li>
<li>@Order</li>
</ul>
<h4 id="如何打印-SQL"><a href="#如何打印-SQL" class="headerlink" title="如何打印 SQL"></a>如何打印 SQL</h4><p>HikariCP</p>
<ul>
<li>P6SQL，<a target="_blank" rel="noopener" href="https://github.com/p6spy/p6spy">https://github.com/p6spy/p6spy</a></li>
</ul>
<p>Alibaba Druid</p>
<ul>
<li>内置 SQL 输出</li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/Druid%E4%B8%AD%E4%BD%BF%E2%BD%A4%E7%94%A8log4j2%E8%BF%9B%E2%BE%8F%E8%A1%8C%EF%A8%88%E2%BD%87%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA">https://github.com/alibaba/druid/wiki/Druid中使⽤用log4j2进⾏行行⽇日志输出</a></li>
</ul>
<h3 id="38-SpringBucks-实战项目进度小结"><a href="#38-SpringBucks-实战项目进度小结" class="headerlink" title="38 | SpringBucks 实战项目进度小结"></a>38 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第六章：Spring-MVC-实践-14-讲"><a href="#第六章：Spring-MVC-实践-14-讲" class="headerlink" title="第六章：Spring MVC 实践 (14 讲)"></a>第六章：Spring MVC 实践 (14 讲)</h2><h3 id="39-编写第一个-Spring-MVC-Controller"><a href="#39-编写第一个-Spring-MVC-Controller" class="headerlink" title="39 | 编写第一个 Spring MVC Controller"></a>39 | 编写第一个 Spring MVC Controller</h3><h3 id="认识-Spring-MVC"><a href="#认识-Spring-MVC" class="headerlink" title="认识 Spring MVC"></a>认识 Spring MVC</h3><p>DispatcherServlet</p>
<ul>
<li>Controller</li>
<li>xxxResolver</li>
<li>ViewResolver</li>
<li>HandlerExceptionResolver</li>
<li>MultipartResolver</li>
<li>HandlerMapping</li>
</ul>
<h3 id="Spring-MVC-中的常⽤用注解"><a href="#Spring-MVC-中的常⽤用注解" class="headerlink" title="Spring MVC 中的常⽤用注解"></a>Spring MVC 中的常⽤用注解</h3><ul>
<li>@Controller</li>
<li>@RestController</li>
<li>@RequestMapping</li>
<li>@GetMapping &#x2F; @PostMapping</li>
<li>@PutMapping &#x2F; @DeleteMapping</li>
<li>@RequestBody &#x2F; @ResponseBody &#x2F; @ResponseStatus</li>
</ul>
<h3 id="40-理解-Spring-的应用上下文"><a href="#40-理解-Spring-的应用上下文" class="headerlink" title="40 | 理解 Spring 的应用上下文"></a>40 | 理解 Spring 的应用上下文</h3><h3 id="Spring-的应用程序上下文"><a href="#Spring-的应用程序上下文" class="headerlink" title="Spring 的应用程序上下文"></a>Spring 的应用程序上下文</h3><p><strong>关于上下文常用的接口</strong></p>
<ul>
<li>BeanFactory</li>
<li>DefaultListableBeanFactory</li>
<li>ApplicationContext</li>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>AnnotationConfigApplicationContext</li>
<li>WebApplicationContext</li>
</ul>
<h3 id="41-理解请求的处理机制"><a href="#41-理解请求的处理机制" class="headerlink" title="41 | 理解请求的处理机制"></a>41 | 理解请求的处理机制</h3><p>一个请求的大致处理流程</p>
<p>绑定一些 Attribute</p>
<ul>
<li>WebApplicationContext &#x2F; LocaleResolver &#x2F; ThemeResolver</li>
</ul>
<p>处理 Multipart</p>
<ul>
<li>如果是，则将请求转为 MultipartHttpServletRequest</li>
</ul>
<p>Handler 处理</p>
<ul>
<li>如果找到对应 Handler，执行 Controller 及前后置处理器逻辑处理返回的 Model ，呈现视图</li>
</ul>
<h3 id="42-如何定义处理方法（上）"><a href="#42-如何定义处理方法（上）" class="headerlink" title="42 | 如何定义处理方法（上）"></a>42 | 如何定义处理方法（上）</h3><h3 id="定义映射关系"><a href="#定义映射关系" class="headerlink" title="定义映射关系"></a>定义映射关系</h3><p>@Controller</p>
<p>@RequestMapping</p>
<ul>
<li>path &#x2F; method 指定映射路路径与⽅方法</li>
<li>params &#x2F; headers 限定映射范围</li>
<li>consumes &#x2F; produces 限定请求与响应格式</li>
</ul>
<p>一些快捷方式</p>
<ul>
<li>@RestController</li>
<li>@GetMapping &#x2F; @PostMapping &#x2F; @PutMapping &#x2F; @DeleteMapping &#x2F; @PatchMapping</li>
</ul>
<h3 id="定义处理方法"><a href="#定义处理方法" class="headerlink" title="定义处理方法"></a>定义处理方法</h3><ul>
<li>@RequestBody &#x2F; @ResponseBody &#x2F; @ResponseStatus</li>
<li>@PathVariable &#x2F; @RequestParam &#x2F; @RequestHeader</li>
<li>HttpEntity &#x2F; ResponseEntity</li>
</ul>
<h3 id="定义类型转换"><a href="#定义类型转换" class="headerlink" title="定义类型转换"></a>定义类型转换</h3><p>自己实现 WebMvcConfigurer</p>
<ul>
<li>Spring Boot 在 WebMvcAutoConfiguration 中实现了一个</li>
<li>添加自定义的 Converter</li>
<li>添加自定义的 Formatter</li>
</ul>
<h3 id="定义校验"><a href="#定义校验" class="headerlink" title="定义校验"></a>定义校验</h3><ul>
<li>通过 Validator 对绑定结果进行校验<ul>
<li>Hibernate Validator</li>
</ul>
</li>
<li>@Valid 注解</li>
<li>BindingResult</li>
</ul>
<h3 id="Multipart-上传"><a href="#Multipart-上传" class="headerlink" title="Multipart 上传"></a>Multipart 上传</h3><ul>
<li>配置 MultipartResolver</li>
<li>Spring Boot 自动配置 MultipartAutoConfiguration</li>
<li>支持类型 multipart&#x2F;form-data</li>
<li>MultipartFile 类型</li>
</ul>
<h3 id="43-如何定义处理方法（下）"><a href="#43-如何定义处理方法（下）" class="headerlink" title="43 | 如何定义处理方法（下）"></a>43 | 如何定义处理方法（下）</h3><h3 id="44-Spring-MVC-中的视图解析机制（上）"><a href="#44-Spring-MVC-中的视图解析机制（上）" class="headerlink" title="44 | Spring MVC 中的视图解析机制（上）"></a>44 | Spring MVC 中的视图解析机制（上）</h3><h3 id="45-Spring-MVC-中的视图解析机制（下）"><a href="#45-Spring-MVC-中的视图解析机制（下）" class="headerlink" title="45 | Spring MVC 中的视图解析机制（下）"></a>45 | Spring MVC 中的视图解析机制（下）</h3><h4 id="视图解析的实现基础"><a href="#视图解析的实现基础" class="headerlink" title="视图解析的实现基础"></a>视图解析的实现基础</h4><p>ViewResolver 与 View 接口</p>
<ul>
<li>AbstractCachingViewResolver</li>
<li>UrlBasedViewResolver</li>
<li>FreeMarkerViewResolver</li>
<li>ContentNegotiatingViewResolver</li>
<li>InternalResourceViewResolver</li>
</ul>
<h4 id="DispatcherServlet-中的视图解析逻辑"><a href="#DispatcherServlet-中的视图解析逻辑" class="headerlink" title="DispatcherServlet 中的视图解析逻辑"></a>DispatcherServlet 中的视图解析逻辑</h4><ul>
<li>initStrategies()<ul>
<li>initViewResolvers() 初始化了了对应 ViewResolver</li>
</ul>
</li>
<li>doDispatch()<ul>
<li>processDispatchResult()<ul>
<li>没有返回视图的话，尝试 RequestToViewNameTranslator</li>
<li>resolveViewName() 解析 View 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用 @ResponseBody 的情况</p>
<ul>
<li>在 HandlerAdapter.handle() 的中完成了 Response 输出<ul>
<li><code>RequestMappingHandlerAdapter.invokeHandlerMethod()</code><ul>
<li><code>HandlerMethodReturnValueHandlerComposite.handleReturnValue()</code><ul>
<li><code>RequestResponseBodyMethodProcessor.handleReturnValue()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>两种不同的重定向前缀</p>
<ul>
<li><code>redirect:</code></li>
<li><code>forward:</code></li>
</ul>
<h3 id="46-Spring-MVC-中的常用视图（上）"><a href="#46-Spring-MVC-中的常用视图（上）" class="headerlink" title="46 | Spring MVC 中的常用视图（上）"></a>46 | Spring MVC 中的常用视图（上）</h3><h4 id="Spring-MVC-支持的视图"><a href="#Spring-MVC-支持的视图" class="headerlink" title="Spring MVC 支持的视图"></a>Spring MVC 支持的视图</h4><p>支持的视图列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-frameworkreference/web.html#mvc-view">https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-frameworkreference/web.html#mvc-view</a></li>
<li>Jackson-based JSON &#x2F; XML</li>
<li>Thymeleaf &amp; FreeMarker</li>
</ul>
<h4 id="配置-MessageConverter"><a href="#配置-MessageConverter" class="headerlink" title="配置 MessageConverter"></a>配置 MessageConverter</h4><ul>
<li>通过 WebMvcConfigurer 的 configureMessageConverters()</li>
<li>Spring Boot 自动查找 HttpMessageConverters 进行注册</li>
</ul>
<h4 id="Spring-Boot-对-Jackson-的支持"><a href="#Spring-Boot-对-Jackson-的支持" class="headerlink" title="Spring Boot 对 Jackson 的支持"></a>Spring Boot 对 Jackson 的支持</h4><ul>
<li>JacksonAutoConfiguration<ul>
<li>Spring Boot 通过 @JsonComponent 注册 JSON 序列化组件</li>
<li>Jackson2ObjectMapperBuilderCustomizer</li>
</ul>
</li>
<li>JacksonHttpMessageConvertersConfiguration<ul>
<li>增加 jackson-dataformat-xml 以支持 XML 序列化</li>
</ul>
</li>
</ul>
<h3 id="47-Spring-MVC-中的常用视图（下）"><a href="#47-Spring-MVC-中的常用视图（下）" class="headerlink" title="47 | Spring MVC 中的常用视图（下）"></a>47 | Spring MVC 中的常用视图（下）</h3><h4 id="使用-Thymeleaf"><a href="#使用-Thymeleaf" class="headerlink" title="使用 Thymeleaf"></a>使用 Thymeleaf</h4><p>添加 Thymeleaf 依赖</p>
<ul>
<li>org.springframework.boot:spring-boot-starter-thymeleaf</li>
</ul>
<p>Spring Boot 的自动配置</p>
<ul>
<li><code>ThymeleafAutoConfiguration</code><ul>
<li><code>ThymeleafViewResolver</code></li>
</ul>
</li>
</ul>
<h5 id="Thymeleaf-的一些默认配置"><a href="#Thymeleaf-的一些默认配置" class="headerlink" title="Thymeleaf 的一些默认配置"></a>Thymeleaf 的一些默认配置</h5><ul>
<li><code>spring.thymeleaf.cache=true</code></li>
<li><code>spring.thymeleaf.check-template=true</code></li>
<li><code>spring.thymeleaf.check-template-location=true</code></li>
<li><code>spring.thymeleaf.enabled=true</code></li>
<li><code>spring.thymeleaf.encoding=UTF-8</code></li>
<li><code>spring.thymeleaf.mode=HTML</code></li>
<li><code>spring.thymeleaf.servlet.content-type=text/html</code></li>
<li><code>spring.thymeleaf.prefix=classpath:/templates/</code></li>
<li><code>spring.thymeleaf.suffix=.html</code></li>
</ul>
<h3 id="48-静态资源与缓存"><a href="#48-静态资源与缓存" class="headerlink" title="48 | 静态资源与缓存"></a>48 | 静态资源与缓存</h3><h4 id="Spring-Boot-中的静态资源配置"><a href="#Spring-Boot-中的静态资源配置" class="headerlink" title="Spring Boot 中的静态资源配置"></a>Spring Boot 中的静态资源配置</h4><p>核心逻辑</p>
<ul>
<li>WebMvcConfigurer.addResourceHandlers()</li>
</ul>
<p>常用配置</p>
<ul>
<li>spring.mvc.static-path-pattern&#x3D;&#x2F;**</li>
<li>spring.resources.static-locations&#x3D;classpath:&#x2F;META-INF&#x2F;<br>resources&#x2F;,classpath:&#x2F;resources&#x2F;,classpath:&#x2F;static&#x2F;,classpath:&#x2F;public&#x2F;</li>
</ul>
<h4 id="Spring-Boot-中的缓存配置"><a href="#Spring-Boot-中的缓存配置" class="headerlink" title="Spring Boot 中的缓存配置"></a>Spring Boot 中的缓存配置</h4><p>常用配置（默认时间单位都是秒）</p>
<ul>
<li>ResourceProperties.Cache</li>
<li>spring.resources.cache.cachecontrol.max-age&#x3D;时间</li>
<li>spring.resources.cache.cachecontrol.no-cache&#x3D;true&#x2F;false</li>
<li>spring.resources.cache.cachecontrol.s-max-age&#x3D;时间</li>
</ul>
<h3 id="49-Spring-MVC-中的异常处理机制"><a href="#49-Spring-MVC-中的异常处理机制" class="headerlink" title="49 | Spring MVC 中的异常处理机制"></a>49 | Spring MVC 中的异常处理机制</h3><h4 id="Spring-MVC-的异常解析"><a href="#Spring-MVC-的异常解析" class="headerlink" title="Spring MVC 的异常解析"></a>Spring MVC 的异常解析</h4><p>核心接口</p>
<ul>
<li>HandlerExceptionResolver</li>
</ul>
<p>实现类</p>
<ul>
<li>SimpleMappingExceptionResolver</li>
<li>DefaultHandlerExceptionResolver</li>
<li>ResponseStatusExceptionResolver</li>
<li>ExceptionHandlerExceptionResolver</li>
</ul>
<h4 id="异常处理方法"><a href="#异常处理方法" class="headerlink" title="异常处理方法"></a>异常处理方法</h4><p>处理方法</p>
<ul>
<li>@ExceptionHandler</li>
</ul>
<p>添加位置</p>
<ul>
<li>@Controller &#x2F; @RestController</li>
<li>@ControllerAdvice &#x2F; @RestControllerAdvice</li>
</ul>
<h3 id="50-了解-Spring-MVC-的切入点"><a href="#50-了解-Spring-MVC-的切入点" class="headerlink" title="50 | 了解 Spring MVC 的切入点"></a>50 | 了解 Spring MVC 的切入点</h3><h4 id="Spring-MVC-的拦截器"><a href="#Spring-MVC-的拦截器" class="headerlink" title="Spring MVC 的拦截器"></a>Spring MVC 的拦截器</h4><p>核心接口</p>
<ul>
<li>HandlerInteceptor<ul>
<li>boolean preHandle()</li>
<li>void postHandle()</li>
<li>void afterCompletion()</li>
</ul>
</li>
</ul>
<p>针对 @ResponseBody 和 ResponseEntity 的情况</p>
<ul>
<li>ResponseBodyAdvice</li>
</ul>
<p>针对异步请求的接口</p>
<ul>
<li>AsyncHandlerInterceptor</li>
</ul>
<h4 id="拦截器的配置方式"><a href="#拦截器的配置方式" class="headerlink" title="拦截器的配置方式"></a>拦截器的配置方式</h4><p>常规方法</p>
<ul>
<li>WebMvcConfigurer.addInterceptors()</li>
</ul>
<p>Spring Boot 中的配置</p>
<ul>
<li>创建一个带 @Configuration 的 WebMvcConfigurer 配置类</li>
<li>不能带 @EnableWebMvc（想彻底自己控制 MVC 配置除外）</li>
</ul>
<h3 id="51-SpringBucks-实战项目进度小结"><a href="#51-SpringBucks-实战项目进度小结" class="headerlink" title="51 | SpringBucks 实战项目进度小结"></a>51 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h3 id="52-课程答疑"><a href="#52-课程答疑" class="headerlink" title="52 | 课程答疑"></a>52 | 课程答疑</h3><p>略</p>
<h2 id="第七章：访问-Web-资源-5-讲"><a href="#第七章：访问-Web-资源-5-讲" class="headerlink" title="第七章：访问 Web 资源 (5 讲)"></a>第七章：访问 Web 资源 (5 讲)</h2><h3 id="53-通过-RestTemplate-访问-Web-资源"><a href="#53-通过-RestTemplate-访问-Web-资源" class="headerlink" title="53 | 通过 RestTemplate 访问 Web 资源"></a>53 | 通过 RestTemplate 访问 Web 资源</h3><h4 id="Spring-Boot-中的-RestTemplate"><a href="#Spring-Boot-中的-RestTemplate" class="headerlink" title="Spring Boot 中的 RestTemplate"></a>Spring Boot 中的 RestTemplate</h4><ul>
<li>Spring Boot 中没有自动配置 RestTemplate</li>
<li>Spring Boot 提供了 RestTemplateBuilder</li>
<li>RestTemplateBuilder.build()</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>GET 请求</p>
<ul>
<li>getForObject() &#x2F; getForEntity()</li>
</ul>
<p>POST 请求</p>
<ul>
<li>postForObject() &#x2F; postForEntity()</li>
</ul>
<p>PUT 请求</p>
<ul>
<li>put()</li>
</ul>
<p>DELETE 请求</p>
<ul>
<li>delete()</li>
</ul>
<h4 id="构造-URI"><a href="#构造-URI" class="headerlink" title="构造 URI"></a>构造 URI</h4><p>构造 URI</p>
<ul>
<li>UriComponentsBuilder</li>
</ul>
<p>构造相对于当前请求的 URI</p>
<ul>
<li>ServletUriComponentsBuilder</li>
</ul>
<p>构造指向 Controller 的 URI</p>
<ul>
<li>MvcUriComponentsBuilder</li>
</ul>
<h3 id="54-RestTemplate-的高阶用法"><a href="#54-RestTemplate-的高阶用法" class="headerlink" title="54 | RestTemplate 的高阶用法"></a>54 | RestTemplate 的高阶用法</h3><p>传递 HTTP Header</p>
<ul>
<li><code>RestTemplate.exchange()</code></li>
<li><code>RequestEntity&lt;T&gt; / ResponseEntity&lt;T&gt;</code></li>
</ul>
<p>类型转换</p>
<ul>
<li><code>JsonSerializer / JsonDeserializer</code></li>
<li><code>@JsonComponent</code></li>
</ul>
<p>解析泛型对象</p>
<ul>
<li><code>RestTemplate.exchange()</code></li>
<li><code>ParameterizedTypeReference&lt;T&gt;</code></li>
</ul>
<h3 id="55-简单定制-RestTemplate"><a href="#55-简单定制-RestTemplate" class="headerlink" title="55 | 简单定制 RestTemplate"></a>55 | 简单定制 RestTemplate</h3><h4 id="RestTemplate-⽀支持的-HTTP-库"><a href="#RestTemplate-⽀支持的-HTTP-库" class="headerlink" title="RestTemplate ⽀支持的 HTTP 库"></a>RestTemplate ⽀支持的 HTTP 库</h4><p>通用接口</p>
<ul>
<li>ClientHttpRequestFactory</li>
</ul>
<p>默认实现</p>
<ul>
<li>SimpleClientHttpRequestFactory</li>
</ul>
<p>Apache HttpComponents</p>
<ul>
<li>HttpComponentsClientHttpRequestFactory</li>
</ul>
<p>Netty</p>
<ul>
<li>Netty4ClientHttpRequestFactory</li>
</ul>
<p>OkHttp</p>
<ul>
<li>OkHttp3ClientHttpRequestFactory</li>
</ul>
<h4 id="优化底层请求策略"><a href="#优化底层请求策略" class="headerlink" title="优化底层请求策略"></a>优化底层请求策略</h4><p>连接管理</p>
<ul>
<li>PoolingHttpClientConnectionManager</li>
<li>KeepAlive 策略</li>
</ul>
<p>超时设置</p>
<ul>
<li>connectTimeout &#x2F; readTimeout</li>
</ul>
<p>SSL 校验</p>
<ul>
<li>证书检查策略</li>
</ul>
<h3 id="56-通过-WebClient-访问-Web-资源"><a href="#56-通过-WebClient-访问-Web-资源" class="headerlink" title="56 | 通过 WebClient 访问 Web 资源"></a>56 | 通过 WebClient 访问 Web 资源</h3><h4 id="了解-WebClient"><a href="#了解-WebClient" class="headerlink" title="了解 WebClient"></a>了解 WebClient</h4><p>WebClient</p>
<ul>
<li>一个以 Reactive 方式处理 HTTP 请求的非阻塞式的客户端</li>
</ul>
<p>支持的底层 HTTP 库</p>
<ul>
<li>Reactor Netty - ReactorClientHttpConnector</li>
<li>Jetty ReactiveStream HttpClient - JettyClientHttpConnector</li>
</ul>
<h4 id="WebClient-的基本用法"><a href="#WebClient-的基本用法" class="headerlink" title="WebClient 的基本用法"></a>WebClient 的基本用法</h4><p>创建 WebClient</p>
<ul>
<li>WebClient.create()</li>
<li>WebClient.builder()</li>
</ul>
<p>发起请求</p>
<ul>
<li>get() &#x2F; post() &#x2F; put() &#x2F; delete() &#x2F; patch()</li>
</ul>
<p>获得结果</p>
<ul>
<li>retrieve() &#x2F; exchange()</li>
</ul>
<p>处理 HTTP Status</p>
<ul>
<li>onStatus()</li>
</ul>
<p>应答正文</p>
<ul>
<li>bodyToMono() &#x2F; bodyToFlux()</li>
</ul>
<h3 id="57-SpringBucks-实战项目进度小结"><a href="#57-SpringBucks-实战项目进度小结" class="headerlink" title="57 | SpringBucks 实战项目进度小结"></a>57 | SpringBucks 实战项目进度小结</h3><h2 id="第八章：-Web-开发进阶-9-讲"><a href="#第八章：-Web-开发进阶-9-讲" class="headerlink" title="第八章： Web 开发进阶 (9 讲)"></a>第八章： Web 开发进阶 (9 讲)</h2><h3 id="58-设计好的-RESTful-Web-Service（上）"><a href="#58-设计好的-RESTful-Web-Service（上）" class="headerlink" title="58 | 设计好的 RESTful Web Service（上）"></a>58 | 设计好的 RESTful Web Service（上）</h3><h3 id="59-设计好的-RESTful-Web-Service（下）"><a href="#59-设计好的-RESTful-Web-Service（下）" class="headerlink" title="59 | 设计好的 RESTful Web Service（下）"></a>59 | 设计好的 RESTful Web Service（下）</h3><p>如何实现 Restful Web Service</p>
<ul>
<li>识别资源</li>
<li>选择合适的资源粒度</li>
<li>设计 URI</li>
<li>选择合适的 HTTP 方法和返回码</li>
<li>设计资源的表述</li>
</ul>
<p>识别资源</p>
<ul>
<li>找到领域名词</li>
<li>能用 CRUD 操作的名词</li>
<li>将资源组织为集合（即集合资源）</li>
<li>将资源合并为复合资源</li>
<li>计算或处理函数</li>
</ul>
<h3 id="资源的粒度"><a href="#资源的粒度" class="headerlink" title="资源的粒度"></a>资源的粒度</h3><p>站在客户端的角度，要考虑</p>
<ul>
<li>可缓存性</li>
<li>修改频率</li>
<li>可变性</li>
</ul>
<p>站在服务端的角度，要考虑</p>
<ul>
<li>网络效率</li>
<li>表述的多少</li>
<li>客户端的易用程度</li>
</ul>
<p>构建更好的 URI</p>
<ul>
<li>使用域及子域对资源进行合理的分组或划分</li>
<li>在 URI 的路径部分使用斜杠分隔符 ( &#x2F; ) 来表示资源之间的层次关系</li>
<li>在 URI 的路径部分使用逗号 ( , ) 和分号 ( ; ) 来表示非层次元素</li>
<li>使用连字符 ( - ) 和下划线 ( _ ) 来改善长路径中名称的可读性</li>
<li>在 URI 的查询部分使用“与”符号 ( &amp; ) 来分隔参数</li>
<li>在 URI 中避免出现文件扩展名 ( 例例如 .php，.aspx 和 .jsp )</li>
</ul>
<h3 id="60-什么是-HATEOAS"><a href="#60-什么是-HATEOAS" class="headerlink" title="60 | 什么是 HATEOAS"></a>60 | 什么是 HATEOAS</h3><h3 id="61-使用-Spring-Data-REST-实现简单的超媒体服务（上）"><a href="#61-使用-Spring-Data-REST-实现简单的超媒体服务（上）" class="headerlink" title="61 | 使用 Spring Data REST 实现简单的超媒体服务（上）"></a>61 | 使用 Spring Data REST 实现简单的超媒体服务（上）</h3><h3 id="62-使用-Spring-Data-REST-实现简单的超媒体服务-下"><a href="#62-使用-Spring-Data-REST-实现简单的超媒体服务-下" class="headerlink" title="62 | 使用 Spring Data REST 实现简单的超媒体服务(下)"></a>62 | 使用 Spring Data REST 实现简单的超媒体服务(下)</h3><h4 id="认识-HAL"><a href="#认识-HAL" class="headerlink" title="认识 HAL"></a>认识 HAL</h4><p>HAL</p>
<ul>
<li>Hypertext Application Language</li>
<li>HAL 是一种简单的格式，为 API 中的资源提供简单一致的链接</li>
</ul>
<p>HAL 模型</p>
<ul>
<li>链接</li>
<li>内嵌资源</li>
<li>状态</li>
</ul>
<h4 id="Spring-Data-REST"><a href="#Spring-Data-REST" class="headerlink" title="Spring Data REST"></a>Spring Data REST</h4><p>Spring Boot 依赖</p>
<ul>
<li>spring-boot-starter-data-rest</li>
</ul>
<p>常用注解与类</p>
<ul>
<li><code>@RepositoryRestResource</code></li>
<li><code>Resource&lt;T&gt;</code></li>
<li><code>PagedResource&lt;T&gt;</code></li>
</ul>
<h4 id="如何访问-HATEOAS-服务"><a href="#如何访问-HATEOAS-服务" class="headerlink" title="如何访问 HATEOAS 服务"></a>如何访问 HATEOAS 服务</h4><p>配置 Jackson JSON</p>
<ul>
<li>注册 HAL 支持</li>
</ul>
<p>操作超链接</p>
<ul>
<li>找到需要的 Link</li>
<li>访问超链接</li>
</ul>
<h3 id="63-分布式环境中如何解决-Session-的问题"><a href="#63-分布式环境中如何解决-Session-的问题" class="headerlink" title="63 | 分布式环境中如何解决 Session 的问题"></a>63 | 分布式环境中如何解决 Session 的问题</h3><h4 id="常见的会话解决方案"><a href="#常见的会话解决方案" class="headerlink" title="常见的会话解决方案"></a>常见的会话解决方案</h4><ul>
<li>粘性会话 Sticky Session</li>
<li>会话复制 Session Replication</li>
<li>集中会话 Centralized Session</li>
</ul>
<h4 id="认识-Spring-Session"><a href="#认识-Spring-Session" class="headerlink" title="认识 Spring Session"></a>认识 Spring Session</h4><p>Spring Session</p>
<ul>
<li>简化集群中的用户会话管理</li>
<li>无需绑定容器特定解决方案</li>
</ul>
<p>支持的存储</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
<li>JDBC</li>
<li>Hazelcast</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>定制 HttpSession</p>
<ul>
<li>通过定制的 HttpServletRequest 返回定制的 HttpSession</li>
<li><code>SessionRepositoryRequestWrapper</code></li>
<li><code>SessionRepositoryFilter</code></li>
<li><code>DelegatingFilterProxy</code></li>
</ul>
<h4 id="基于-Redis-的-HttpSession"><a href="#基于-Redis-的-HttpSession" class="headerlink" title="基于 Redis 的 HttpSession"></a>基于 Redis 的 HttpSession</h4><p>引入依赖</p>
<ul>
<li>spring-session-data-redis</li>
</ul>
<p>基本配置</p>
<ul>
<li>@EnableRedisHttpSession</li>
<li>提供 RedisConnectionFactory</li>
<li>实现 AbstractHttpSessionApplicationInitializer</li>
<li>配置 DelegatingFilterProxy</li>
</ul>
<h3 id="64-使用-WebFlux-代替-Spring-MVC（上）"><a href="#64-使用-WebFlux-代替-Spring-MVC（上）" class="headerlink" title="64 | 使用 WebFlux 代替 Spring MVC（上）"></a>64 | 使用 WebFlux 代替 Spring MVC（上）</h3><h3 id="65-使用-WebFlux-代替-Spring-MVC（下）"><a href="#65-使用-WebFlux-代替-Spring-MVC（下）" class="headerlink" title="65 | 使用 WebFlux 代替 Spring MVC（下）"></a>65 | 使用 WebFlux 代替 Spring MVC（下）</h3><h4 id="认识-WebFlux"><a href="#认识-WebFlux" class="headerlink" title="认识 WebFlux"></a>认识 WebFlux</h4><p>什么是 WebFlux</p>
<ul>
<li>用于构建基于 Reactive 技术栈之上的 Web 应用程序</li>
<li>基于 Reactive Streams API ，运行在非阻塞服务器上</li>
</ul>
<p>为什么会有 WebFlux</p>
<ul>
<li>对于非阻塞 Web 应用的需要</li>
<li>函数式编程</li>
</ul>
<p>关于 WebFlux 的性能</p>
<ul>
<li>请求的耗时并不会有很大的改善</li>
<li>仅需少量固定数量的线程和较少的内存即可实现扩展</li>
</ul>
<h4 id="WebMVC-v-s-WebFlux"><a href="#WebMVC-v-s-WebFlux" class="headerlink" title="WebMVC v.s. WebFlux"></a>WebMVC v.s. WebFlux</h4><ul>
<li>已有 Spring MVC 应⽤用，运行正常，就别改了</li>
<li>依赖了大量阻塞式持久化 API 和网络 API，建议使用 Spring MVC</li>
<li>已经使用了非阻塞技术栈，可以考虑使用 WebFlux</li>
<li>想要使用 Java 8 Lambda 结合轻量级函数式框架，可以考虑 WebFlux</li>
</ul>
<h4 id="WebFlux-中的编程模型"><a href="#WebFlux-中的编程模型" class="headerlink" title="WebFlux 中的编程模型"></a>WebFlux 中的编程模型</h4><p>两种编程模型</p>
<ul>
<li>基于注解的控制器</li>
<li>函数式 Endpoints</li>
</ul>
<h4 id="基于注解的控制器"><a href="#基于注解的控制器" class="headerlink" title="基于注解的控制器"></a>基于注解的控制器</h4><p>常用注解</p>
<ul>
<li>@Controller</li>
<li>@RequestMapping 及其等价注解</li>
<li>@RequestBody &#x2F; @ResponseBody</li>
</ul>
<p>返回值</p>
<ul>
<li><code>Mono&lt;T&gt; / Flux&lt;T&gt;</code></li>
</ul>
<h3 id="66-SpringBucks-实战项目进度小结"><a href="#66-SpringBucks-实战项目进度小结" class="headerlink" title="66 | SpringBucks 实战项目进度小结"></a>66 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第九章：重新认识-Spring-Boot-8-讲"><a href="#第九章：重新认识-Spring-Boot-8-讲" class="headerlink" title="第九章：重新认识 Spring Boot (8 讲)"></a>第九章：重新认识 Spring Boot (8 讲)</h2><h3 id="67-认识-Spring-Boot-的组成部分"><a href="#67-认识-Spring-Boot-的组成部分" class="headerlink" title="67 | 认识 Spring Boot 的组成部分"></a>67 | 认识 Spring Boot 的组成部分</h3><h3 id="Spring-Boot-的特性"><a href="#Spring-Boot-的特性" class="headerlink" title="Spring Boot 的特性"></a>Spring Boot 的特性</h3><ul>
<li>方便地创建可独立运行的 Spring 应用程序</li>
<li>直接内嵌 Tomcat、Jetty 或 Undertow</li>
<li>简化了项目的构建配置</li>
<li>为 Spring 及第三方库提供自动配置</li>
<li>提供生产级特性</li>
<li>无需生成代码或进行 XML 配置</li>
</ul>
<h3 id="Spring-Boot-的四大核心"><a href="#Spring-Boot-的四大核心" class="headerlink" title="Spring Boot 的四大核心"></a>Spring Boot 的四大核心</h3><ul>
<li>自动配置 - Auto Configuration</li>
<li>起步依赖 - Starter Dependency</li>
<li>命令行界面 - Spring Boot CLI</li>
<li>Actuator</li>
</ul>
<h3 id="68-了解自动配置的实现原理"><a href="#68-了解自动配置的实现原理" class="headerlink" title="68 | 了解自动配置的实现原理"></a>68 | 了解自动配置的实现原理</h3><h3 id="了解自动配置"><a href="#了解自动配置" class="headerlink" title="了解自动配置"></a>了解自动配置</h3><p><strong>自动配置</strong></p>
<ul>
<li>基于添加的 JAR 依赖自动对 Spring Boot 应⽤用程序进行配置</li>
<li>spring-boot-autoconfiguration</li>
</ul>
<p><strong>开启自动配置</strong></p>
<ul>
<li><code>@EnableAutoConfiguration</code><ul>
<li><code>exclude = Class&lt;?&gt;[]</code></li>
</ul>
</li>
<li><code>@SpringBootApplication</code></li>
</ul>
<h3 id="自动配置的实现原理"><a href="#自动配置的实现原理" class="headerlink" title="自动配置的实现原理"></a>自动配置的实现原理</h3><p><strong><code>@EnableAutoConfiguration</code></strong></p>
<ul>
<li><code>AutoConfigurationImportSelector</code></li>
<li><code>META-INF/spring.factories</code><ul>
<li><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code></li>
</ul>
</li>
</ul>
<p><strong>条件注解</strong></p>
<ul>
<li><code>@Conditional</code></li>
<li><code>@ConditionalOnClass</code></li>
<li><code>@ConditionalOnBean</code></li>
<li><code>@ConditionalOnMissingBean</code></li>
<li><code>@ConditionalOnProperty</code></li>
<li>……</li>
</ul>
<h3 id="了解自动配置的情况"><a href="#了解自动配置的情况" class="headerlink" title="了解自动配置的情况"></a>了解自动配置的情况</h3><p><strong>观察自动配置的判断结果</strong></p>
<ul>
<li>–debug</li>
</ul>
<p><strong><code>ConditionEvaluationReportLoggingListener</code></strong></p>
<ul>
<li>Positive matches</li>
<li>Negative matches</li>
<li>Exclusions</li>
<li>Unconditional classes</li>
</ul>
<h3 id="69-动手实现自己的自动配置"><a href="#69-动手实现自己的自动配置" class="headerlink" title="69 | 动手实现自己的自动配置"></a>69 | 动手实现自己的自动配置</h3><h3 id="主要工作内容"><a href="#主要工作内容" class="headerlink" title="主要工作内容"></a>主要工作内容</h3><ul>
<li>编写 Java Config<ul>
<li><code>@Configuration</code></li>
</ul>
</li>
<li>添加条件<ul>
<li><code>@Conditional</code></li>
</ul>
</li>
<li>定位自动配置<ul>
<li><code>META-INF/spring.factories</code></li>
</ul>
</li>
</ul>
<h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3><p><strong>条件注解</strong></p>
<ul>
<li><code>@Conditional</code></li>
</ul>
<p><strong>类条件</strong></p>
<ul>
<li><code>@ConditionalOnClass</code></li>
<li><code>@ConditionalOnMissingClass</code></li>
</ul>
<p><strong>属性条件</strong></p>
<ul>
<li><code>@ConditionalOnProperty</code></li>
</ul>
<p><strong>Bean 条件</strong></p>
<ul>
<li><code>@ConditionalOnBean</code></li>
<li><code>@ConditionalOnMissingBean</code></li>
<li><code>**@ConditionalOnSingleCandidate</code>**</li>
</ul>
<p><strong>资源条件</strong></p>
<ul>
<li><code>@ConditionalOnResource</code></li>
</ul>
<p><strong>Web 应用条件</strong></p>
<ul>
<li><code>@ConditionalOnWebApplication</code></li>
<li><code>@ConditionalOnNotWebApplication</code></li>
</ul>
<p><strong>其他条件</strong></p>
<ul>
<li><code>@ConditionalOnExpression</code></li>
<li><code>@ConditionalOnJava</code></li>
<li><code>@ConditionalOnJndi</code></li>
</ul>
<h3 id="自动配置的执行顺序"><a href="#自动配置的执行顺序" class="headerlink" title="自动配置的执行顺序"></a>自动配置的执行顺序</h3><p><strong>执行顺序</strong></p>
<ul>
<li><code>@AutoConfigureBefore</code></li>
<li><code>@AutoConfigureAfter</code></li>
<li><code>@AutoConfigureOrder</code></li>
</ul>
<h3 id="70-如何在低版本-Spring-中快速实现类似自动配置的功能"><a href="#70-如何在低版本-Spring-中快速实现类似自动配置的功能" class="headerlink" title="70 | 如何在低版本 Spring 中快速实现类似自动配置的功能"></a>70 | 如何在低版本 Spring 中快速实现类似自动配置的功能</h3><h3 id="需求与问题"><a href="#需求与问题" class="headerlink" title="需求与问题"></a>需求与问题</h3><p><strong>核心的诉求</strong></p>
<ul>
<li>现存系统，不打算重构</li>
<li>Spring 版本 3.x，不打算升级版本和引入 Spring Boot</li>
<li>期望能够在少改代码的前提下实现一些功能增强</li>
</ul>
<p><strong>面临的问题</strong></p>
<ul>
<li>3.x 的 Spring 没有条件注解</li>
<li>无法自动定位需要加载的自动配置</li>
</ul>
<h3 id="核心解决思路"><a href="#核心解决思路" class="headerlink" title="核心解决思路"></a>核心解决思路</h3><p><strong>条件判断</strong></p>
<ul>
<li>通过 <code>BeanFactoryPostProcessor</code> 进行判断</li>
</ul>
<p><strong>配置加载</strong></p>
<ul>
<li>编写 Java Config 类</li>
<li>引入配置类</li>
<li>通过 component-scan</li>
<li>通过 xml 文件 import</li>
</ul>
<h3 id="Spring-的扩展点"><a href="#Spring-的扩展点" class="headerlink" title="Spring 的扩展点"></a>Spring 的扩展点</h3><p><strong>BeanPostProcessor</strong></p>
<ul>
<li><p>针对 Bean 实例</p>
</li>
<li><p>在 Bean 创建后提供定制逻辑回调</p>
</li>
</ul>
<p><strong>BeanFactoryPostProcessor</strong></p>
<ul>
<li><p>针对 Bean 定义</p>
</li>
<li><p>在容器创建 Bean 前获取配置元数据</p>
</li>
<li><p>Java Config 中需要定义为 static 方法</p>
</li>
</ul>
<h3 id="关于-Bean-的一些定制"><a href="#关于-Bean-的一些定制" class="headerlink" title="关于 Bean 的一些定制"></a>关于 Bean 的一些定制</h3><h4 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h4><ul>
<li>InitializingBean &#x2F; @PostConstruct &#x2F; init-method</li>
<li>DisposableBean &#x2F; @PostDestory &#x2F; destroy-method</li>
</ul>
<h4 id="XXXAware"><a href="#XXXAware" class="headerlink" title="XXXAware"></a>XXXAware</h4><ul>
<li><code>ApplicationContextAware</code></li>
<li><code>BeanFactoryAware</code></li>
<li><code>BeanNameAware</code></li>
</ul>
<h3 id="一些常用操作"><a href="#一些常用操作" class="headerlink" title="一些常用操作"></a>一些常用操作</h3><p><strong>判断类是否存在</strong></p>
<ul>
<li><code>ClassUtils.isPresent()</code></li>
</ul>
<p><strong>判断 Bean 是否已定义</strong></p>
<ul>
<li><code>ListableBeanFactory.containsBeanDefinition()</code></li>
<li><code>ListableBeanFactory.getBeanNamesForType()</code></li>
</ul>
<p><strong>注册 Bean 定义</strong></p>
<ul>
<li><p><code>BeanDefinitionRegistry.registerBeanDefinition()</code></p>
<ul>
<li><code>GenericBeanDefinition</code></li>
</ul>
</li>
<li><p><code>BeanFactory.registerSingleton()</code></p>
</li>
</ul>
<h3 id="71-了解起步依赖及其实现原理"><a href="#71-了解起步依赖及其实现原理" class="headerlink" title="71 | 了解起步依赖及其实现原理"></a>71 | 了解起步依赖及其实现原理</h3><h3 id="Maven-依赖管理技巧"><a href="#Maven-依赖管理技巧" class="headerlink" title="Maven 依赖管理技巧"></a>Maven 依赖管理技巧</h3><p>了解你的依赖</p>
<ul>
<li>mvn dependency:tree</li>
<li>IDEA Maven Helper 插件</li>
</ul>
<p>排除特定依赖</p>
<ul>
<li>exclusion</li>
</ul>
<p>统一管理依赖</p>
<ul>
<li>dependencyManagement</li>
<li>Bill of Materials - bom</li>
</ul>
<h3 id="Spring-Boot-的-starter-依赖"><a href="#Spring-Boot-的-starter-依赖" class="headerlink" title="Spring Boot 的 starter 依赖"></a>Spring Boot 的 starter 依赖</h3><p><strong>Starter Dependencies</strong></p>
<ul>
<li>直接面向功能</li>
<li>一站获得所有相关依赖，不再复制粘贴</li>
</ul>
<p><strong>官方的 Starters</strong></p>
<ul>
<li>spring-boot-starter-*</li>
</ul>
<h3 id="72-定制自己的起步依赖"><a href="#72-定制自己的起步依赖" class="headerlink" title="72 | 定制自己的起步依赖"></a>72 | 定制自己的起步依赖</h3><p><strong>主要内容</strong></p>
<ul>
<li>autoconfigure 模块，包含自动配置代码</li>
<li>starter 模块，包含指向自动配置模块的依赖及其他相关依赖</li>
</ul>
<p><strong>命名方式</strong></p>
<ul>
<li>xxx-spring-boot-autoconfigure</li>
<li>xxx-spring-boot-starter</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>不要使用 spring-boot 作为依赖的前缀</li>
<li>不要使用 spring-boot 的配置命名空间</li>
<li>starter 中仅添加必要的依赖</li>
<li>声明对 spring-boot-starter 的依赖</li>
</ul>
<h3 id="73-深挖-Spring-Boot-的配置加载机制"><a href="#73-深挖-Spring-Boot-的配置加载机制" class="headerlink" title="73 | 深挖 Spring Boot 的配置加载机制"></a>73 | 深挖 Spring Boot 的配置加载机制</h3><h3 id="外化配置加载顺序"><a href="#外化配置加载顺序" class="headerlink" title="外化配置加载顺序"></a>外化配置加载顺序</h3><ul>
<li>开启 DevTools 时，<code>~/.spring-boot-devtools.properties</code></li>
<li>测试类上的 <code>@TestPropertySource</code> 注解</li>
<li><code>@SpringBootTest#properties</code> 属性</li>
<li>命令行参数（ <code>--server.port=9000</code> ）</li>
<li>SPRING_APPLICATION_JSON 中的属性</li>
<li><code>ServletConfig</code> 初始化参数</li>
<li><code>ServletContext</code> 初始化参数</li>
<li><code>java:comp/env</code> 中的 JNDI 属性</li>
<li><code>System.getProperties()</code></li>
<li>操作系统环境变量</li>
<li><code>random.*</code> 涉及到的 <code>RandomValuePropertySource</code></li>
<li>jar 包外部的 application-{profile}.properties 或 .yml</li>
<li>jar 包内部的 application-{profile}.properties 或 .yml</li>
<li>jar 包外部的 application.properties 或 .yml</li>
<li>jar 包内部的 application.properties 或 .yml</li>
<li>@Configuration 类上的 @PropertySource</li>
<li>SpringApplication.setDefaultProperties() 设置的默认属性</li>
</ul>
<h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><p>默认位置</p>
<ul>
<li><code>./config</code></li>
<li><code>./</code></li>
<li>CLASSPATH 中的 <code>/config</code></li>
<li>CLASSPATH 中的 <code>/</code></li>
</ul>
<p>修改名字或路路径</p>
<ul>
<li><code>spring.config.name</code></li>
<li><code>spring.config.location</code></li>
<li><code>spring.config.additional-location</code></li>
</ul>
<h3 id="Relaxed-Binding"><a href="#Relaxed-Binding" class="headerlink" title="Relaxed Binding"></a>Relaxed Binding</h3><table>
<thead>
<tr>
<th>命名风格</th>
<th>使用范围</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>短划线分隔</td>
<td>Properties 文件<br/>YAML 文件<br/>系统属性</td>
<td>geektime.spring-boot.first-demo</td>
</tr>
<tr>
<td>驼峰式</td>
<td>Properties 文件<br/>YAML 文件<br/>系统属性</td>
<td>geektime.springBoot.firstDemo</td>
</tr>
<tr>
<td>下划线分割</td>
<td>Properties 文件<br/>YAML 文件<br/>系统属性</td>
<td>geektime.spring_boot.first_demo</td>
</tr>
<tr>
<td>全⼤大写，下划线分隔</td>
<td>环境变量</td>
<td>GEEKTIME_SPRINGBOOT_FIRSTDEMO</td>
</tr>
</tbody></table>
<h3 id="74-理解配置背后的-PropertySource-抽象"><a href="#74-理解配置背后的-PropertySource-抽象" class="headerlink" title="74 | 理解配置背后的 PropertySource 抽象"></a>74 | 理解配置背后的 PropertySource 抽象</h3><h3 id="添加-PropertySource"><a href="#添加-PropertySource" class="headerlink" title="添加 PropertySource"></a>添加 PropertySource</h3><ul>
<li><code>&lt;context:property-placeholder&gt;</code></li>
<li><code>PropertySourcesPlaceholderConfigurer</code></li>
<li><code>PropertyPlaceholderConfigurer</code></li>
<li><code>@PropertySource</code></li>
<li><code>@PropertySources</code></li>
</ul>
<h3 id="Spring-Boot-中的-ConfigurationProperties"><a href="#Spring-Boot-中的-ConfigurationProperties" class="headerlink" title="Spring Boot 中的 @ConfigurationProperties"></a>Spring Boot 中的 @ConfigurationProperties</h3><ul>
<li>可以将属性绑定到结构化对象上</li>
<li>支持 Relaxed Binding</li>
<li>支持安全的类型转换</li>
<li><code>@EnableConfigurationProperties</code></li>
</ul>
<h3 id="定制-PropertySource"><a href="#定制-PropertySource" class="headerlink" title="定制 PropertySource"></a>定制 PropertySource</h3><p><strong>主要步骤</strong></p>
<ul>
<li>实现 <code>PropertySource&lt;T&gt;</code></li>
<li>从 <code>Environment</code> 取得 <code>PropertySources</code></li>
<li>将自己的 <code>PropertySource</code> 添加到合适的位置</li>
</ul>
<p><strong>切入位置</strong></p>
<ul>
<li><code>EnvironmentPostProcessor</code></li>
<li><code>BeanFactoryPostProcessor</code></li>
</ul>
<h2 id="第十章：运行中的-Spring-Boot-11-讲"><a href="#第十章：运行中的-Spring-Boot-11-讲" class="headerlink" title="第十章：运行中的 Spring Boot (11 讲)"></a>第十章：运行中的 Spring Boot (11 讲)</h2><h3 id="75-认识-Spring-Boot-的各类-Actuator-Endpoint"><a href="#75-认识-Spring-Boot-的各类-Actuator-Endpoint" class="headerlink" title="75 | 认识 Spring Boot 的各类 Actuator Endpoint"></a>75 | 认识 Spring Boot 的各类 Actuator Endpoint</h3><h3 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h3><p><strong>目的</strong></p>
<ul>
<li>监控并管理应用程序</li>
</ul>
<p><strong>访问方式</strong></p>
<ul>
<li>HTTP</li>
<li>JMX</li>
</ul>
<p><strong>依赖</strong></p>
<ul>
<li>spring-boot-starter-actuator</li>
</ul>
<h3 id="一些常用-Endpoint"><a href="#一些常用-Endpoint" class="headerlink" title="一些常用 Endpoint"></a>一些常用 Endpoint</h3><table>
<thead>
<tr>
<th>ID</th>
<th>说明</th>
<th>默认开启</th>
<th>默认 HTTP</th>
<th>默认 JMX</th>
</tr>
</thead>
<tbody><tr>
<td>beans</td>
<td>显示容器中的 Bean 列表</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>caches</td>
<td>显示应用中的缓存</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>conditions</td>
<td>显示配置条件的计算情况</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>configprops</td>
<td>显示 @ConfigurationProperties 的信息</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>env</td>
<td>显示 ConfigurableEnvironment 中的属性</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>health</td>
<td>显示健康检查信息</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>httptrace</td>
<td>显示 HTTP Trace 信息</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>info</td>
<td>显示设置好的应用信息</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>loggers</td>
<td>显示并更新日志配置</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>metrics</td>
<td>显示应用的度量信息</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>mappings</td>
<td>显示所有的 @RequestMapping 信息</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>scheduledtasks</td>
<td>显示应用的调度任务信息</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>shutdown</td>
<td>优雅地关闭应用程序</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>threaddump</td>
<td>执行 Thread Dump</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>heapdump</td>
<td>返回 Heap Dump 文件，格式为 HPROF</td>
<td>Y</td>
<td>N</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>prometheus</td>
<td>返回可供 Prometheus 抓取的信息</td>
<td>Y</td>
<td>N</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<h3 id="如何访问-Actuator-Endpoint"><a href="#如何访问-Actuator-Endpoint" class="headerlink" title="如何访问 Actuator Endpoint"></a>如何访问 Actuator Endpoint</h3><p><strong>HTTP 访问</strong></p>
<ul>
<li><code>/actuator/&lt;id&gt;</code></li>
</ul>
<p><strong>端口与路径</strong></p>
<ul>
<li><code>management.server.address=</code></li>
<li><code>management.server.port=</code></li>
<li><code>management.endpoints.web.base-path=/actuator</code></li>
<li><code>management.endpoints.web.path-mapping.&lt;id&gt;=路径</code></li>
</ul>
<p><strong>开启 Endpoint</strong></p>
<ul>
<li><code>management.endpoint.&lt;id&gt;.enabled=true</code></li>
<li><code>management.endpoints.enabled-by-default=false</code></li>
</ul>
<p><strong>暴露 Endpoint</strong></p>
<ul>
<li><code>management.endpoints.jmx.exposure.exclude=</code></li>
<li><code>management.endpoints.jmx.exposure.include=*</code></li>
<li><code>management.endpoints.web.exposure.exclude=</code></li>
<li><code>management.endpoints.web.exposure.include=info, health</code></li>
</ul>
<h3 id="76-动手定制自己的-Health-Indicator"><a href="#76-动手定制自己的-Health-Indicator" class="headerlink" title="76 | 动手定制自己的 Health Indicator"></a>76 | 动手定制自己的 Health Indicator</h3><h3 id="Spring-Boot-自带的-Health-Indicator"><a href="#Spring-Boot-自带的-Health-Indicator" class="headerlink" title="Spring Boot 自带的 Health Indicator"></a>Spring Boot 自带的 Health Indicator</h3><p>目的</p>
<ul>
<li>检查应用程序的运行状态</li>
</ul>
<p>状态</p>
<ul>
<li>DOWN - 503</li>
<li>OUT_OF_SERVICE - 503</li>
<li>UP - 200</li>
<li>UNKNOWN - 200</li>
</ul>
<p>机制</p>
<ul>
<li>通过 <code>HealthIndicatorRegistry</code> 收集信息</li>
<li><code>HealthIndicator</code> 实现具体检查逻辑</li>
</ul>
<p>配置项</p>
<ul>
<li><code>management.health.defaults.enabled=true|false</code></li>
<li><code>management.health.&lt;id&gt;.enabled=true</code></li>
<li><code>management.endpoint.health.show-details=never|whenauthorized|always</code></li>
</ul>
<p><strong>内置 HealthIndicator 清单</strong></p>
<ul>
<li><p><code>CassandraHealthIndicator</code></p>
</li>
<li><p><code>ElasticsearchHealthIndicator</code></p>
</li>
<li><p><code>MongoHealthIndicator</code></p>
</li>
<li><p><code>SolrHealthIndicator</code></p>
</li>
<li><p><code>CouchbaseHealthIndicator</code></p>
</li>
<li><p><code>InfluxDbHealthIndicator</code></p>
</li>
<li><p><code>Neo4jHealthIndicator</code></p>
</li>
<li><p><code>DiskSpaceHealthIndicator</code></p>
</li>
<li><p><code>JmsHealthIndicator</code></p>
</li>
<li><p><code>RabbitHealthIndicator</code></p>
</li>
<li><p><code>DataSourceHealthIndicator</code></p>
</li>
<li><p><code>MailHealthIndicator</code></p>
</li>
<li><p><code>RedisHealthIndicator</code></p>
</li>
</ul>
<h3 id="自定义-Health-Indicator"><a href="#自定义-Health-Indicator" class="headerlink" title="自定义 Health Indicator"></a>自定义 Health Indicator</h3><p><strong>方法</strong></p>
<ul>
<li>实现 HealthIndicator 接口</li>
<li>根据自定义检查逻辑返回对应 Health 状态</li>
<li>Health 中包含状态和详细描述信息</li>
</ul>
<h3 id="77-通过-Micrometer-获取运行数据"><a href="#77-通过-Micrometer-获取运行数据" class="headerlink" title="77 | 通过 Micrometer 获取运行数据"></a>77 | 通过 Micrometer 获取运行数据</h3><h3 id="认识-Micrometer"><a href="#认识-Micrometer" class="headerlink" title="认识 Micrometer"></a>认识 Micrometer</h3><p><strong>特性</strong></p>
<ul>
<li>多维度度量量</li>
<li>支持 Tag</li>
<li>预置大量探针</li>
<li>缓存、类加载器器、GC、CPU 利利⽤用率、线程池……</li>
<li>与 Spring 深度整合</li>
</ul>
<p><strong>支持多种监控系统</strong></p>
<ul>
<li><p>Dimensional</p>
<ul>
<li>AppOptics, Atlas, Azure Monitor, Cloudwatch, Datadog, Datadog StatsD, Dynatrace, Elastic, Humio, Influx, KairosDB, New Relic, Prometheus, SignalFx, Sysdig StatsD, Telegraf<br>StatsD, Wavefront</li>
</ul>
</li>
<li><p>Hierarchical</p>
<ul>
<li>Graphite, Ganglia, JMX, Etsy StatsD</li>
</ul>
</li>
</ul>
<h3 id="一些核心度量指标"><a href="#一些核心度量指标" class="headerlink" title="一些核心度量指标"></a>一些核心度量指标</h3><p><strong>核心接口</strong></p>
<ul>
<li>Meter</li>
</ul>
<p><strong>内置实现</strong></p>
<ul>
<li>Gauge, TimeGauge</li>
<li>Timer, LongTaskTimer, FunctionTimer</li>
<li>Counter, FunctionCounter</li>
<li>DistributionSummary</li>
</ul>
<h3 id="Micrometer-in-Spring-Boot-2-x"><a href="#Micrometer-in-Spring-Boot-2-x" class="headerlink" title="Micrometer in Spring Boot 2.x"></a>Micrometer in Spring Boot 2.x</h3><p><strong>一些 URL</strong></p>
<ul>
<li><code>/actuator/metrics</code></li>
<li><code>/actuator/prometheus</code></li>
</ul>
<p><strong>一些配置项</strong></p>
<ul>
<li><code>management.metrics.export.*</code></li>
<li><code>management.metrics.tags.*</code></li>
<li><code>management.metrics.enable.*</code></li>
<li><code>management.metrics.distribution.*</code></li>
<li><code>management.metrics.web.server.auto-time-requests</code></li>
</ul>
<p>核心度量项</p>
<ul>
<li>JVM、CPU、文件句柄数、日志、启动时间</li>
</ul>
<p>其他度量项</p>
<ul>
<li>Spring MVC、Spring WebFlux</li>
<li>Tomcat、Jersey JAX-RS</li>
<li>RestTemplate、WebClient</li>
<li>缓存、数据源、Hibernate</li>
<li>Kafka、RabbitMQ</li>
</ul>
<p>自定义度量指标</p>
<ul>
<li>通过 MeterRegistry 注册 Meter</li>
<li>提供 MeterBinder Bean 让 Spring Boot ⾃自动绑定</li>
<li>通过 MeterFilter 进⾏行行定制</li>
</ul>
<h3 id="78-通过-Spring-Boot-Admin-了解程序的运行状态"><a href="#78-通过-Spring-Boot-Admin-了解程序的运行状态" class="headerlink" title="78 | 通过 Spring Boot Admin 了解程序的运行状态"></a>78 | 通过 Spring Boot Admin 了解程序的运行状态</h3><h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p><strong>目的</strong></p>
<ul>
<li>为 Spring Boot 应用程序提供一套管理界面</li>
</ul>
<p><strong>主要功能</strong></p>
<ul>
<li>集中展示应用程序 Actuator 相关的内容</li>
<li>变更通知</li>
</ul>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><strong>服务端</strong></p>
<ul>
<li><code>de.codecentric:spring-boot-admin-starter-server:2.1.3</code></li>
<li><code>@EnableAdminServer</code></li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li><code>de.codecentric:spring-boot-admin-starter-client:2.1.3</code></li>
<li>配置服务端及 Endpoint</li>
<li><code>spring.boot.admin.client.url=http://localhost:8080</code></li>
<li><code>management.endpoints.web.exposure.include=*</code></li>
</ul>
<h3 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h3><p>安全相关依赖</p>
<ul>
<li>spring-boot-starter-security</li>
</ul>
<p>服务端配置</p>
<ul>
<li>spring.security.user.name</li>
<li>spring.security.user.password</li>
</ul>
<h3 id="79-如何定制-Web-容器的运行参数"><a href="#79-如何定制-Web-容器的运行参数" class="headerlink" title="79 | 如何定制 Web 容器的运行参数"></a>79 | 如何定制 Web 容器的运行参数</h3><h3 id="内嵌-Web-容器"><a href="#内嵌-Web-容器" class="headerlink" title="内嵌 Web 容器"></a>内嵌 Web 容器</h3><p>可选容器列表</p>
<ul>
<li><code>spring-boot-starter-tomcat</code></li>
<li><code>spring-boot-starter-jetty</code></li>
<li><code>spring-boot-starter-undertow</code></li>
<li><code>spring-boot-starter-reactor-netty</code></li>
</ul>
<h3 id="修改容器器配置"><a href="#修改容器器配置" class="headerlink" title="修改容器器配置"></a>修改容器器配置</h3><p><strong>端口</strong></p>
<ul>
<li><code>server.port</code></li>
<li><code>server.address</code></li>
</ul>
<p><strong>压缩</strong></p>
<ul>
<li><code>server.compression.enabled</code></li>
<li><code>server.compression.min-response-size</code></li>
<li><code>server.compression.mime-types</code></li>
</ul>
<p><strong>Tomcat 特定配置</strong></p>
<ul>
<li><code>server.tomcat.max-connections=10000</code></li>
<li><code>server.tomcat.max-http-post-size=2MB</code></li>
<li><code>server.tomcat.max-swallow-size=2MB</code></li>
<li><code>server.tomcat.max-threads=200</code></li>
<li><code>server.tomcat.min-spare-threads=10</code></li>
</ul>
<p>错误处理</p>
<ul>
<li><code>server.error.path=/error</code></li>
<li><code>server.error.include-exception=false</code></li>
<li><code>server.error.include-stacktrace=never</code></li>
<li><code>server.error.whitelabel.enabled=true</code></li>
</ul>
<p>其他</p>
<ul>
<li><code>server.use-forward-headers</code></li>
<li><code>server.servlet.session.timeout</code></li>
</ul>
<p>编程方式</p>
<ul>
<li><code>WebServerFactoryCustomizer&lt;T&gt;</code></li>
<li><code>TomcatServletWebServerFactory</code></li>
<li><code>JettyServletWebServerFactory</code></li>
<li><code>UndertowServletWebServerFactory</code></li>
</ul>
<h3 id="80-如何配置容器支持-HTTP-2（上）"><a href="#80-如何配置容器支持-HTTP-2（上）" class="headerlink" title="80 | 如何配置容器支持 HTTP&#x2F;2（上）"></a>80 | 如何配置容器支持 HTTP&#x2F;2（上）</h3><h3 id="配置-HTTPS-支持"><a href="#配置-HTTPS-支持" class="headerlink" title="配置 HTTPS 支持"></a>配置 HTTPS 支持</h3><p><strong>通过参数进行配置</strong></p>
<ul>
<li><code>server.port=8443</code></li>
<li><code>server.ssl.*</code><ul>
<li><code>server.ssl.key-store</code></li>
<li>server.ssl.key-store-type，JKS 或者 PKCS12</li>
<li><code>server.ssl.key-store-password=secret</code></li>
</ul>
</li>
</ul>
<h3 id="生成证书文件"><a href="#生成证书文件" class="headerlink" title="生成证书文件"></a>生成证书文件</h3><p><strong>命令</strong></p>
<ul>
<li>keytool -genkey -alias 别名<ul>
<li>-storetype 仓库类型 -keyalg 算法 -keysize 长度</li>
<li>-keystore 文件名 -validity 有效期</li>
</ul>
</li>
</ul>
<p>说明</p>
<ul>
<li>仓库类型，JKS、JCEKS、PKCS12 等</li>
<li>算法，RSA、DSA 等</li>
<li>长度，例如 2048</li>
</ul>
<h3 id="客户端-HTTPS-支持"><a href="#客户端-HTTPS-支持" class="headerlink" title="客户端 HTTPS 支持"></a>客户端 HTTPS 支持</h3><p>配置 HttpClient （ &gt;&#x3D; 4.4 ）</p>
<ul>
<li><code>SSLContextBuilder</code> 构造 <code>SSLContext</code></li>
<li><code>setSSLHostnameVerifier(new NoopHostnameVerifier())</code></li>
</ul>
<p>配置 <code>RequestFactory</code></p>
<ul>
<li><code>HttpComponentsClientHttpRequestFactory</code></li>
<li><code>setHttpClient()</code></li>
</ul>
<h3 id="81-如何配置容器支持-HTTP-2（下）"><a href="#81-如何配置容器支持-HTTP-2（下）" class="headerlink" title="81 | 如何配置容器支持 HTTP&#x2F;2（下）"></a>81 | 如何配置容器支持 HTTP&#x2F;2（下）</h3><h3 id="配置-HTTP-2-支持"><a href="#配置-HTTP-2-支持" class="headerlink" title="配置 HTTP&#x2F;2 支持"></a>配置 HTTP&#x2F;2 支持</h3><p>前提条件</p>
<ul>
<li>Java &gt;&#x3D; JDK 9</li>
<li>Tomcat &gt;&#x3D; 9.0.0</li>
<li>Spring Boot 不支持 h2c，需要先配置 SSL</li>
</ul>
<p>配置项</p>
<ul>
<li>server.http2.enabled</li>
</ul>
<h3 id="客户端-HTTP-2-支持"><a href="#客户端-HTTP-2-支持" class="headerlink" title="客户端 HTTP&#x2F;2 支持"></a>客户端 HTTP&#x2F;2 支持</h3><p>HTTP 库选择</p>
<ul>
<li><code>OkHttp（ com.squareup.okhttp3:okhttp:3.14.0 ）</code></li>
<li><code>OkHttpClient</code></li>
</ul>
<p>RestTemplate 配置</p>
<ul>
<li><code>OkHttp3ClientHttpRequestFactory</code></li>
</ul>
<h3 id="82-如何编写命令行运行的程序"><a href="#82-如何编写命令行运行的程序" class="headerlink" title="82 | 如何编写命令行运行的程序"></a>82 | 如何编写命令行运行的程序</h3><h3 id="关闭-Web-容器"><a href="#关闭-Web-容器" class="headerlink" title="关闭 Web 容器"></a>关闭 Web 容器</h3><p>控制依赖</p>
<ul>
<li>不添加 Web 相关依赖</li>
</ul>
<p>配置方式</p>
<ul>
<li><code>spring.main.web-application-type=none</code></li>
</ul>
<p>编程方式</p>
<ul>
<li><code>SpringApplication</code></li>
<li><code>setWebApplicationType()</code></li>
<li><code>SpringApplicationBuilder</code></li>
<li><code>web()</code></li>
<li>在调用 <code>SpringApplication</code> 的 <code>run()</code> 方法前设置 <code>WebApplicationType</code></li>
</ul>
<h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><p>不同的 Runner</p>
<ul>
<li>ApplicationRunner</li>
<li>参数是 ApplicationArguments</li>
<li>CommandLineRunner</li>
<li>参数是 String[]</li>
</ul>
<p>返回码</p>
<ul>
<li>ExitCodeGenerator</li>
</ul>
<h3 id="83-了解可执行-Jar-背后的秘密"><a href="#83-了解可执行-Jar-背后的秘密" class="headerlink" title="83 | 了解可执行 Jar 背后的秘密"></a>83 | 了解可执行 Jar 背后的秘密</h3><h3 id="认识可执行-Jar"><a href="#认识可执行-Jar" class="headerlink" title="认识可执行 Jar"></a>认识可执行 Jar</h3><p><strong>其中包含</strong></p>
<ul>
<li>Jar 描述，<code>META-INF/MANIFEST.MF</code></li>
<li>Spring Boot Loader，org&#x2F;springframework&#x2F;boot&#x2F;loader</li>
<li>项目内容，BOOT-INF&#x2F;classes</li>
<li>项目依赖，BOOT-INF&#x2F;lib</li>
</ul>
<p><strong>其中不包含</strong></p>
<ul>
<li>JDK &#x2F; JRE</li>
</ul>
<h3 id="如何找到程序的入口"><a href="#如何找到程序的入口" class="headerlink" title="如何找到程序的入口"></a>如何找到程序的入口</h3><p><strong>Jar 的启动类</strong></p>
<ul>
<li><code>MANIFEST.MF</code></li>
<li><code>Main-Class: org.springframework.boot.loader.JarLauncher</code></li>
</ul>
<p><strong>项目的主类</strong></p>
<ul>
<li><code>@SpringApplication</code></li>
<li><code>MANIFEST.MF</code></li>
<li><code>Start-Class: xxx.yyy.zzz</code></li>
</ul>
<h3 id="84-如何将-Spring-Boot-应用打包成-Docker-镜像文件"><a href="#84-如何将-Spring-Boot-应用打包成-Docker-镜像文件" class="headerlink" title="84 | 如何将 Spring Boot 应用打包成 Docker 镜像文件"></a>84 | 如何将 Spring Boot 应用打包成 Docker 镜像文件</h3><h3 id="什么是-Docker-镜像"><a href="#什么是-Docker-镜像" class="headerlink" title="什么是 Docker 镜像"></a>什么是 Docker 镜像</h3><ul>
<li>镜像是静态的只读模板</li>
<li>镜像中包含构建 Docker 容器器的指令</li>
<li>镜像是分层的</li>
<li>通过 Dockerfile 来创建镜像</li>
</ul>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230806142644.png"></p>
<h3 id="通过-Maven-构建-Docker-镜像"><a href="#通过-Maven-构建-Docker-镜像" class="headerlink" title="通过 Maven 构建 Docker 镜像"></a>通过 Maven 构建 Docker 镜像</h3><p>准备工作</p>
<ul>
<li>提供一个 Dockerfile</li>
<li>配置 dockerfile-maven-plugin 插件</li>
</ul>
<p>执行构建</p>
<ul>
<li><code>mvn package</code></li>
<li><code>mvn dockerfile:build</code></li>
</ul>
<p>检查结果</p>
<ul>
<li><code>docker images</code></li>
</ul>
<h3 id="85-SpringBucks-实战项目进度小结"><a href="#85-SpringBucks-实战项目进度小结" class="headerlink" title="85 | SpringBucks 实战项目进度小结"></a>85 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第十一章：Spring-Cloud-及-Cloud-Native-概述-5-讲"><a href="#第十一章：Spring-Cloud-及-Cloud-Native-概述-5-讲" class="headerlink" title="第十一章：Spring Cloud 及 Cloud Native 概述 (5 讲)"></a>第十一章：Spring Cloud 及 Cloud Native 概述 (5 讲)</h2><h3 id="86-简单理解微服务"><a href="#86-简单理解微服务" class="headerlink" title="86 | 简单理解微服务"></a>86 | 简单理解微服务</h3><p>微服务就是一些协同工作的小而自治的服务。</p>
<p>微服务的优点</p>
<ul>
<li>易于部署</li>
<li>与组织结构对齐</li>
<li>可组合性</li>
<li>可替代性</li>
</ul>
<p>微服务的代价</p>
<ul>
<li>架构复杂</li>
<li>运维复杂</li>
</ul>
<h3 id="87-如何理解云原生-Cloud-Native"><a href="#87-如何理解云原生-Cloud-Native" class="headerlink" title="87 | 如何理解云原生(Cloud Native)"></a>87 | 如何理解云原生(Cloud Native)</h3><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。</p>
<p>云原生应用要求</p>
<ul>
<li>DevOps</li>
<li>持续交付</li>
<li>微服务</li>
<li>容器</li>
</ul>
<p>Cloud Native Computing Foundation，缩写 CNCF</p>
<h3 id="88-12-Factor-App（上）"><a href="#88-12-Factor-App（上）" class="headerlink" title="88 | 12-Factor App（上）"></a>88 | 12-Factor App（上）</h3><h3 id="89-12-Factor-App（下）"><a href="#89-12-Factor-App（下）" class="headerlink" title="89 | 12-Factor App（下）"></a>89 | 12-Factor App（下）</h3><p>12-Factor 为构建 SaaS 应用提供了方法论。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://12factor.net/zh_cn/">https://12factor.net/zh_cn/</a></p>
<ul>
<li><p>基准代码 - 一份基准代码，多份部署。解决方案：git</p>
</li>
<li><p>依赖 - 显式声明依赖关系。解决方案：maven、gradle</p>
</li>
<li><p>配置 - 在环境中存储配置。解决方案：apollo</p>
</li>
<li><p>后端服务 - 把后端服务当作附加资源</p>
</li>
<li><p>构建，发布，运行 - 严格分离构建和运行。解决方案：CI&#x2F;CD（如：jenkins、sonar 等）</p>
</li>
<li><p>进程 - 以一个或多个无状态进程运行应用</p>
</li>
<li><p>端口绑定 - 通过端口绑定提供服务</p>
</li>
<li><p>并发 - 通过进程模型进行扩展</p>
</li>
<li><p>易处理 - 快速启动和优雅终止可最大化健壮性</p>
</li>
<li><p>开发环境与线上环境等价 - 尽可能的保持开发，预发布，线上环境相同</p>
</li>
<li><p>日志 - 把日志当作事件流</p>
</li>
<li><p>管理进程 - 后台管理任务当作一次性进程运行</p>
</li>
</ul>
<h3 id="90-认识-Spring-Cloud-的组成部分"><a href="#90-认识-Spring-Cloud-的组成部分" class="headerlink" title="90 | 认识 Spring Cloud 的组成部分"></a>90 | 认识 Spring Cloud 的组成部分</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230729155944.svg"></p>
<p>Spring Cloud 的主要功能</p>
<ul>
<li>服务发现</li>
<li>服务熔断</li>
<li>配置服务</li>
<li>服务安全</li>
<li>服务网关</li>
<li>分布式消息</li>
<li>分布式跟踪</li>
<li>各种云平台支持</li>
</ul>
<h2 id="第十二章：服务注册与发现-9-讲"><a href="#第十二章：服务注册与发现-9-讲" class="headerlink" title="第十二章：服务注册与发现 (9 讲)"></a>第十二章：服务注册与发现 (9 讲)</h2><h3 id="91-使用-Eureka-作为服务注册中心"><a href="#91-使用-Eureka-作为服务注册中心" class="headerlink" title="91 | 使用 Eureka 作为服务注册中心"></a>91 | 使用 Eureka 作为服务注册中心</h3><ul>
<li><strong>SpringCloud 启动包</strong><ul>
<li>服务端 - <code>spring-cloud-starter-netflix-eureka-server</code></li>
<li>客户端 - <code>spring-cloud-starter-netflix-eureka-client</code></li>
</ul>
</li>
<li><strong>注解</strong><ul>
<li>服务端启动注解 - <code>@EnableEurekaServer</code></li>
<li>客户端启动注解<ul>
<li>通用注解 - <code>@EnableDiscoveryClient</code></li>
<li>Eureka 特定注解 - <code>@EnableEurekaClient</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>要点</strong><ul>
<li>Eureka 默认端口 8761</li>
</ul>
</li>
<li><strong>配置</strong><ul>
<li><code>eureka.client.serviceUrl.defaultZone</code> - 注册地址，如 <a target="_blank" rel="noopener" href="http://localhost:10001/eureka/">http://localhost:10001/eureka/</a></li>
<li><code>eureka.client.register-with-eureka</code> - 是否将自己注册到 Eureka Server，默认为 true</li>
<li><code>eureka.client.fetch-registry</code> - 是否从 Eureka Server 获取注册信息，默认为 true</li>
</ul>
</li>
</ul>
<h3 id="92-使用-Spring-Cloud-Loadbalancer-访问服务"><a href="#92-使用-Spring-Cloud-Loadbalancer-访问服务" class="headerlink" title="92 | 使用 Spring Cloud Loadbalancer 访问服务"></a>92 | 使用 Spring Cloud Loadbalancer 访问服务</h3><ul>
<li>如何获得服务地址<ul>
<li><code>org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient</code></li>
<li><code>org.springframework.cloud.client.discovery.DiscoveryClient</code> - 通用接口，推荐方式</li>
</ul>
</li>
<li>负载均衡客户端<ul>
<li><code>@LoadBalanced</code></li>
<li>实际是通过 <code>ClientHttpRequestInterceptor</code> 实现的</li>
<li><code>LoadBalancerInterceptor</code></li>
<li><code>LoadBalancerClient</code></li>
<li><code>RibbonLoadBalancerClient</code></li>
</ul>
</li>
</ul>
<h3 id="93-使用-Feign-访问服务"><a href="#93-使用-Feign-访问服务" class="headerlink" title="93 | 使用 Feign 访问服务"></a>93 | 使用 Feign 访问服务</h3><p>声明式 REST Web 服务客户端</p>
<ul>
<li><strong>SpringCloud 启动包</strong><ul>
<li>spring-cloud-starter-openfeign</li>
</ul>
</li>
<li><strong>注解</strong><ul>
<li>启动注解 - <code>@EnableFeignClients</code></li>
<li>定义接口注解 - <code>@FeignClient</code></li>
</ul>
</li>
<li><strong>配置</strong> - <code>org.springframework.cloud.openfeign.FeignClientsConfiguration</code></li>
</ul>
<h3 id="94-深入理解服务发现背后的-DiscoveryClient"><a href="#94-深入理解服务发现背后的-DiscoveryClient" class="headerlink" title="94 | 深入理解服务发现背后的 DiscoveryClient"></a>94 | 深入理解服务发现背后的 DiscoveryClient</h3><ul>
<li><strong>服务端抽象接口</strong> - <code>org.springframework.cloud.client.serviceregistry.ServiceRegistry</code><ul>
<li><code>EurekaServiceRegistry</code></li>
<li><code>EurekaRegistration</code></li>
<li><code>EurekaAutoServiceRegistration</code></li>
<li><code>EurekaClientAutoConfiguration</code></li>
</ul>
</li>
<li><strong>客户端抽象接口</strong> - <code>org.springframework.cloud.client.discovery.DiscoveryClient</code><ul>
<li><code>@EnableDiscoveryClient</code></li>
</ul>
</li>
<li><strong>负载均衡抽象接口</strong> - <code>org.springframework.cloud.client.loadbalancer.LoadBalancerClient</code></li>
</ul>
<h3 id="95-使用-Zookeeper-作为服务注册中心"><a href="#95-使用-Zookeeper-作为服务注册中心" class="headerlink" title="95 | 使用 Zookeeper 作为服务注册中心"></a>95 | 使用 Zookeeper 作为服务注册中心</h3><ul>
<li><strong>SpringCloud 启动包</strong><ul>
<li><strong>spring-cloud-starter-zookeeper-discovery</strong></li>
</ul>
</li>
<li><strong>配置</strong><ul>
<li><code>ZookeeperAutoConfiguration</code></li>
<li><code>ZookeeperDiscoveryAutoConfiguration</code></li>
</ul>
</li>
</ul>
<h3 id="96-使用-Consul-作为服务注册中心"><a href="#96-使用-Consul-作为服务注册中心" class="headerlink" title="96 | 使用 Consul 作为服务注册中心"></a>96 | 使用 Consul 作为服务注册中心</h3><ul>
<li><strong>SpringCloud 启动包</strong><ul>
<li><strong>spring-cloud-starter-consul-discovery</strong></li>
</ul>
</li>
<li><strong>配置</strong><ul>
<li><code>ConsulAutoConfiguration</code></li>
</ul>
</li>
</ul>
<h3 id="97-使用-Nacos-作为服务注册中心"><a href="#97-使用-Nacos-作为服务注册中心" class="headerlink" title="97 | 使用 Nacos 作为服务注册中心"></a>97 | 使用 Nacos 作为服务注册中心</h3><ul>
<li><strong>SpringCloud 启动包</strong><ul>
<li><strong>spring-cloud-starter-alibaba-nacos-discovery</strong></li>
</ul>
</li>
<li><strong>配置</strong><ul>
<li><code>NacosDiscoveryAutoConfiguration</code></li>
</ul>
</li>
</ul>
<h3 id="98-如何定制自己的-DiscoveryClient"><a href="#98-如何定制自己的-DiscoveryClient" class="headerlink" title="98 | 如何定制自己的 DiscoveryClient"></a>98 | 如何定制自己的 DiscoveryClient</h3><p><strong><code>DiscoveryClient</code></strong></p>
<ul>
<li><code>EurekaDiscoveryClient</code></li>
<li><code>ZooKeeperDiscoveryClient</code></li>
<li><code>ConsulDiscoveryClient</code></li>
<li><code>NacosDiscoveryClient</code></li>
</ul>
<p><strong><code>LoadBalancerClient</code></strong></p>
<ul>
<li><code>RibbonLoadBalancerClient</code></li>
</ul>
<p><strong>自定义 DiscoveryClient 步骤</strong></p>
<ul>
<li>返回该 DiscoveryClient 能提供的服务名列表</li>
<li>返回指定服务对应的 ServiceInstance 列表</li>
<li>返回 DiscoveryClient 的顺序</li>
<li>返回 HealthIndicator 里显示的描述</li>
</ul>
<p>自定义 RibbonClient 支持</p>
<ul>
<li>实现 <code>ServerList&lt;T extends Server&gt;</code></li>
<li>Ribbon 提供了 AbstractServerList</li>
<li>提供一个配置类，声明 ServerList Bean 实例</li>
</ul>
<h3 id="99-SpringBucks-实战项目进度小结"><a href="#99-SpringBucks-实战项目进度小结" class="headerlink" title="99 | SpringBucks 实战项目进度小结"></a>99 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第十三章：服务熔断-7-讲"><a href="#第十三章：服务熔断-7-讲" class="headerlink" title="第十三章：服务熔断 (7 讲)"></a>第十三章：服务熔断 (7 讲)</h2><h3 id="100-使用-Hystrix-实现服务熔断（上）"><a href="#100-使用-Hystrix-实现服务熔断（上）" class="headerlink" title="100 | 使用 Hystrix 实现服务熔断（上）"></a>100 | 使用 Hystrix 实现服务熔断（上）</h3><p>断路器模式</p>
<p>在断路器对象中封装受保护的方法调用</p>
<p>该对象监控调用和断路情况</p>
<p>调用失败触发阈值后，后序调用直接由断路器返回错误，不再执行实际调用</p>
<h3 id="101-使用-Hystrix-实现服务熔断（下）"><a href="#101-使用-Hystrix-实现服务熔断（下）" class="headerlink" title="101 | 使用 Hystrix 实现服务熔断（下）"></a>101 | 使用 Hystrix 实现服务熔断（下）</h3><ul>
<li><p><strong>Hystrix 应用</strong></p>
<ul>
<li>注解</li>
<li>@HystrixCommand<ul>
<li>fallbackMethod</li>
<li>commandProperties<ul>
<li>@HystrixProperty</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SpringCloud 启动包</strong></p>
<ul>
<li><strong>spring-cloud-starter-netflix-hystrix</strong></li>
</ul>
</li>
<li><p><strong>注解</strong></p>
<ul>
<li><code>@EnableCircuitBreaker</code> - 断路器开启注解</li>
</ul>
</li>
<li><p><strong>Feign 支持</strong></p>
<ul>
<li><code>feign.hystrix.enabled=true</code></li>
<li><code>@FeignClient</code> 的 <code>fallback</code> &#x2F; <code>fallbackFactory</code></li>
</ul>
</li>
<li><p><strong>配置</strong></p>
<ul>
<li><code>HystrixCircuitBreakerAutoConfiguration</code></li>
</ul>
</li>
</ul>
<h3 id="102-如何观察服务熔断"><a href="#102-如何观察服务熔断" class="headerlink" title="102 | 如何观察服务熔断"></a>102 | 如何观察服务熔断</h3><p>Spring Cloud 对于熔断的监控支持</p>
<ul>
<li>Hystrix Metrics Stream<ul>
<li>spring-boot-starter-actuator</li>
<li><code>/actuator/hystrix.stream</code></li>
</ul>
</li>
<li>Hystrix Dashboard<ul>
<li>spring-cloud-starter-netflix-hystrix-dashboard</li>
<li><code>@EnableHystrixDashboard</code></li>
<li><code>/hystirx</code></li>
</ul>
</li>
</ul>
<p><strong>聚合集群熔断信息</strong></p>
<ul>
<li><strong>SpringCloud 启动包</strong> - spring-cloud-starter-netflix-turbines</li>
<li><strong>注解</strong> - <code>@EnableTurbine</code></li>
<li><code>/turbine/stream?cluster=集群名</code></li>
</ul>
<h3 id="103-使用-Resilience4j-实现服务熔断"><a href="#103-使用-Resilience4j-实现服务熔断" class="headerlink" title="103 | 使用 Resilience4j 实现服务熔断"></a>103 | 使用 Resilience4j 实现服务熔断</h3><p>Hystrix 官方已经停止维护，因此建议选择其他产品来替代。例如：<a target="_blank" rel="noopener" href="https://github.com/resilience4j/resilience4j">Resilience4J</a></p>
<ul>
<li><p>Resilience4J 实现</p>
<ul>
<li>基于 <code>ConcurrentHashMap</code> 的内存断路器</li>
<li><code>CircuitBreakerRegistry</code></li>
<li><code>CircuitBreakerConfig</code></li>
</ul>
</li>
<li><p>Resilience4J 依赖</p>
<ul>
<li>resilience4j-spring-boot2</li>
</ul>
</li>
<li><p>注解</p>
<ul>
<li>@CircuitBreaker</li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li>CircuitBreakerProperties</li>
</ul>
</li>
</ul>
<h3 id="104-使用-Resilience4j-实现服务限流（上）"><a href="#104-使用-Resilience4j-实现服务限流（上）" class="headerlink" title="104 | 使用 Resilience4j 实现服务限流（上）"></a>104 | 使用 Resilience4j 实现服务限流（上）</h3><p>Bulkhead</p>
<ul>
<li>目的<ul>
<li>防止下游依赖被并发请求冲击</li>
<li>防止发生雪崩</li>
</ul>
</li>
<li>用法<ul>
<li>BulkheadRegistry &#x2F; BulkheadConfig</li>
<li>@Bulkhead(name &#x3D; “xxx”)</li>
</ul>
</li>
</ul>
<h3 id="105-使用-Resilience4j-实现服务限流（下）"><a href="#105-使用-Resilience4j-实现服务限流（下）" class="headerlink" title="105 | 使用 Resilience4j 实现服务限流（下）"></a>105 | 使用 Resilience4j 实现服务限流（下）</h3><p>RateLimit</p>
<ul>
<li>目的<ul>
<li>限制特定时间内的执行次数</li>
</ul>
</li>
<li>用法<ul>
<li><code>RateLimiterRegistry</code> &#x2F; <code>RateLimiterConfig</code></li>
<li><code>@RateLimiter</code></li>
</ul>
</li>
<li>配置</li>
<li>RateLimiterPropertis</li>
</ul>
<h3 id="106-SpringBucks-实战项目进度小结"><a href="#106-SpringBucks-实战项目进度小结" class="headerlink" title="106 | SpringBucks 实战项目进度小结"></a>106 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第十四章：服务配置-7-讲"><a href="#第十四章：服务配置-7-讲" class="headerlink" title="第十四章：服务配置 (7 讲)"></a>第十四章：服务配置 (7 讲)</h2><h3 id="107-基于-Git-的配置中心（上）"><a href="#107-基于-Git-的配置中心（上）" class="headerlink" title="107 | 基于 Git 的配置中心（上）"></a>107 | 基于 Git 的配置中心（上）</h3><p>目的</p>
<p>提供针对外置配置的 HTTP API</p>
<ul>
<li><strong>SpringCloud 启动包</strong> - spring-cloud-config-server</li>
<li><strong>注解</strong> - <code>@EnableConfigServer</code></li>
</ul>
<h3 id="108-基于-Git-的配置中心（下）"><a href="#108-基于-Git-的配置中心（下）" class="headerlink" title="108 | 基于 Git 的配置中心（下）"></a>108 | 基于 Git 的配置中心（下）</h3><h3 id="109-基于-Zookeeper-的配置中心"><a href="#109-基于-Zookeeper-的配置中心" class="headerlink" title="109 | 基于 Zookeeper 的配置中心"></a>109 | 基于 Zookeeper 的配置中心</h3><h3 id="110-深入理解-Spring-Cloud-的配置抽象"><a href="#110-深入理解-Spring-Cloud-的配置抽象" class="headerlink" title="110 | 深入理解 Spring Cloud 的配置抽象"></a>110 | 深入理解 Spring Cloud 的配置抽象</h3><p>实现</p>
<ul>
<li>类似于 Spring 的 Environment 和 PropertySource</li>
<li>在上下文中增加 Spring Cloud Config 的 PropertySource</li>
</ul>
<p>PropertySource 子类</p>
<ul>
<li><code>ZooKeeperPropertySource</code></li>
<li><code>ConsulPropertySource</code></li>
<li><code>ConsulFilePropertySource</code></li>
</ul>
<p>PropertySourceLocator</p>
<p>EnvironmentRepositry</p>
<p>配置刷新</p>
<ul>
<li>&#x2F;actuator&#x2F;refresh</li>
<li>Spring Cloud Bus - RegfreshRemoteApplicationEvent</li>
</ul>
<p>ZooKeeperConfigBootstrapConfiguration</p>
<p>ZooKeeperConfigAutoConfiguration</p>
<h3 id="111-基于-Consul-的配置中心"><a href="#111-基于-Consul-的配置中心" class="headerlink" title="111 | 基于 Consul 的配置中心"></a>111 | 基于 Consul 的配置中心</h3><p><strong>SpringCloud 启动包</strong> - spring-cloud-starter-consual-config</p>
<p><strong>配置文件</strong> - bootstrap.propertis | yml</p>
<h3 id="112-基于-Nacos-的配置中心"><a href="#112-基于-Nacos-的配置中心" class="headerlink" title="112 | 基于 Nacos 的配置中心"></a>112 | 基于 Nacos 的配置中心</h3><p><strong>SpringCloud 启动包</strong> - spring-cloud-starter-alibaba-nacos-config</p>
<p><strong>配置文件</strong> - bootstrap.propertis | yml</p>
<h3 id="113-SpringBucks-实战项目进度小结"><a href="#113-SpringBucks-实战项目进度小结" class="headerlink" title="113 | SpringBucks 实战项目进度小结"></a>113 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第十五章：Spring-Cloud-Stream-4-讲"><a href="#第十五章：Spring-Cloud-Stream-4-讲" class="headerlink" title="第十五章：Spring Cloud Stream (4 讲)"></a>第十五章：Spring Cloud Stream (4 讲)</h2><h3 id="114-认识-Spring-Cloud-Stream"><a href="#114-认识-Spring-Cloud-Stream" class="headerlink" title="114 | 认识 Spring Cloud Stream"></a>114 | 认识 Spring Cloud Stream</h3><p>Spring Cloud Stream 是一款用于构建消息驱动的微服务应用程序的轻量级框架。</p>
<p>特性</p>
<ul>
<li>声明式编程模型</li>
<li>引入多种概念抽象：发布订阅、消费组、分区</li>
<li>支持多种消息中间件：RabbitMQ、Kafka</li>
</ul>
<p>概念</p>
<ul>
<li>Binding<ul>
<li>生产者、消费者与 MQ 之间的桥梁</li>
<li>@EnableBinding</li>
<li>@Input &#x2F;SubscribableChannel</li>
<li>@Output &#x2F; MessageChannel</li>
</ul>
</li>
<li>消费组</li>
<li>分区</li>
</ul>
<p>生产消息</p>
<ul>
<li>使用 MessageChannel 的 send()</li>
<li>@SendTo</li>
</ul>
<p>消费消息</p>
<ul>
<li>@StreamListener</li>
<li>@Payload &#x2F; @Headers &#x2F; @Header</li>
</ul>
<h3 id="115-通过-Spring-Cloud-Stream-访问-RabbitMQ"><a href="#115-通过-Spring-Cloud-Stream-访问-RabbitMQ" class="headerlink" title="115 | 通过 Spring Cloud Stream 访问 RabbitMQ"></a>115 | 通过 Spring Cloud Stream 访问 RabbitMQ</h3><p><strong>SpringCloud 启动包</strong> - spring-cloud-starter-stream-rabbit</p>
<p><strong>SpringBoot 启动包</strong> - spring-boot-starter-amqp</p>
<p><strong>配置</strong></p>
<p><code>org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration</code></p>
<h3 id="116-通过-Spring-Cloud-Stream-访问-Kafka"><a href="#116-通过-Spring-Cloud-Stream-访问-Kafka" class="headerlink" title="116 | 通过 Spring Cloud Stream 访问 Kafka"></a>116 | 通过 Spring Cloud Stream 访问 Kafka</h3><p><strong>SpringCloud 启动包</strong> - spring-cloud-starter-stream-kafka</p>
<p><strong>配置</strong> - <code>org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration</code></p>
<p>Spring 定时任务</p>
<ul>
<li>TaskScheduler &#x2F; Trigger &#x2F; TriggerContext</li>
<li>配置定时任务<ul>
<li><code>@EnableScheduling</code></li>
<li><code>&lt;task:scheduler /&gt;</code></li>
<li><code>@Scheduled</code></li>
</ul>
</li>
</ul>
<p>Spring 事件机制</p>
<ul>
<li><code>ApplicationEvent</code></li>
<li>发送事件<ul>
<li><code>ApplicationEventPublisher</code></li>
<li><code>ApplicationEventPublisherAware</code></li>
</ul>
</li>
<li>监听事件<ul>
<li><code>ApplicationListener&lt;T&gt;</code></li>
<li><code>@EventListener</code></li>
</ul>
</li>
</ul>
<h3 id="117-SpringBucks-实战项目进度小结"><a href="#117-SpringBucks-实战项目进度小结" class="headerlink" title="117 | SpringBucks 实战项目进度小结"></a>117 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="第十六章：服务链路追踪-6-讲"><a href="#第十六章：服务链路追踪-6-讲" class="headerlink" title="第十六章：服务链路追踪 (6 讲)"></a>第十六章：服务链路追踪 (6 讲)</h2><h3 id="118-通过-Dapper-理解链路治理"><a href="#118-通过-Dapper-理解链路治理" class="headerlink" title="118 | 通过 Dapper 理解链路治理"></a>118 | 通过 Dapper 理解链路治理</h3><p>略</p>
<h3 id="119-使用-Spring-Cloud-Sleuth-实现链路追踪"><a href="#119-使用-Spring-Cloud-Sleuth-实现链路追踪" class="headerlink" title="119 | 使用 Spring Cloud Sleuth 实现链路追踪"></a>119 | 使用 Spring Cloud Sleuth 实现链路追踪</h3><p><strong>SpringCloud 启动包</strong> - spring-cloud-starter-sleuth、spring-cloud-starter-zipkin</p>
<h3 id="120-如何追踪消息链路"><a href="#120-如何追踪消息链路" class="headerlink" title="120 | 如何追踪消息链路"></a>120 | 如何追踪消息链路</h3><p>略</p>
<h3 id="121-除了链路还要治理什么"><a href="#121-除了链路还要治理什么" class="headerlink" title="121 | 除了链路还要治理什么"></a>121 | 除了链路还要治理什么</h3><p>略</p>
<h3 id="122-SpringBucks-实战项目进度小结"><a href="#122-SpringBucks-实战项目进度小结" class="headerlink" title="122 | SpringBucks 实战项目进度小结"></a>122 | SpringBucks 实战项目进度小结</h3><p>略</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/156">玩转 Spring 全家桶</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/266510c3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/266510c3/" class="post-title-link" itemprop="url">《24 讲吃透分布式数据库》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-25 22:41:52" itemprop="dateCreated datePublished" datetime="2023-07-25T22:41:52+08:00">2023-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《24-讲吃透分布式数据库》笔记"><a href="#《24-讲吃透分布式数据库》笔记" class="headerlink" title="《24 讲吃透分布式数据库》笔记"></a>《24 讲吃透分布式数据库》笔记</h1><h2 id="开篇词-吃透分布式数据库，提升职场竞争力"><a href="#开篇词-吃透分布式数据库，提升职场竞争力" class="headerlink" title="开篇词 吃透分布式数据库，提升职场竞争力"></a>开篇词 吃透分布式数据库，提升职场竞争力</h2><p>略</p>
<h2 id="导论：什么是分布式数据库？聊聊它的前世今生"><a href="#导论：什么是分布式数据库？聊聊它的前世今生" class="headerlink" title="导论：什么是分布式数据库？聊聊它的前世今生"></a>导论：什么是分布式数据库？聊聊它的前世今生</h2><h3 id="分布式数据库的核心"><a href="#分布式数据库的核心" class="headerlink" title="分布式数据库的核心"></a>分布式数据库的核心</h3><p>数据分片</p>
<ul>
<li><p>水平分片：按行进行数据分割，数据被切割为一个个数据组，分散到不同节点上。</p>
</li>
<li><p>垂直分片：按列进行数据切割，一个数据表的模式（Schema）被切割为多个小的模式。</p>
</li>
</ul>
<p>数据同步</p>
<p>数据库同步用于帮助数据库恢复一致性。</p>
<p><strong>分布式数据库发展就是一个由合到分，再到合的过程</strong>：</p>
<ol>
<li>早期的关系型商业数据库的分布式能力可以满足大部分用户的场景，因此产生了如 Oracle 等几种巨无霸数据库产品；</li>
<li>OLAP 领域首先寻求突破，演化出了大数据技术与 MPP 类型数据库，提供功能更强的数据分析能力；</li>
<li>去 IOE 引入数据库中间件，并结合应用平台与开源单机数据库形成新一代解决方案，让商业关系型数据库走下神坛，NoSQL 数据库更进一步打破了关系型数据库唯我独尊的江湖地位；</li>
<li>新一代分布式 OLTP 数据库正式完成了分布式领域对数据库核心特性的完整支持，它代表了分布式数据库从此走向了成熟，也表明了 OLAP 与 OLTP 分布式场景下，分别在各自领域内取得了胜利；</li>
<li>HTAP 和多模式数据处理的引入，再一次将 OLAP 与 OLTP 融合，从而将分布式数据库推向如传统商业关系型数据库数十年前那般的盛况，而其产生的影响要比后者更为深远。</li>
</ol>
<h2 id="SQL-vs-NoSQL：一次搞清楚五花八门的“SQL”"><a href="#SQL-vs-NoSQL：一次搞清楚五花八门的“SQL”" class="headerlink" title="SQL vs NoSQL：一次搞清楚五花八门的“SQL”"></a>SQL vs NoSQL：一次搞清楚五花八门的“SQL”</h2><p>略</p>
<h2 id="数据分片：如何存储超大规模的数据？"><a href="#数据分片：如何存储超大规模的数据？" class="headerlink" title="数据分片：如何存储超大规模的数据？"></a>数据分片：如何存储超大规模的数据？</h2><h3 id="数据分片概论"><a href="#数据分片概论" class="headerlink" title="数据分片概论"></a>数据分片概论</h3><p>想提升系统对于数据的处理，有两种思路：</p>
<p>垂直扩展：提升硬件设备，获得更好的 CPU、更大的内存。但这种方式容易达到瓶颈。</p>
<p>水平扩展：采用分而治之的思想，将数据拆分成多个分区，分散到一组便宜的机器上。这种方式性价比更高，不过也会引入数据同步等复杂的问题。</p>
<h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><p>哈希分片</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230725224346.png"></p>
<p>范围分片</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230725224415.png"></p>
<h3 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h3><p>UUID：性能较差，且离散度不高</p>
<p>雪花算法</p>
<h2 id="数据复制：如何保证数据在分布式场景下的高可用？"><a href="#数据复制：如何保证数据在分布式场景下的高可用？" class="headerlink" title="数据复制：如何保证数据在分布式场景下的高可用？"></a>数据复制：如何保证数据在分布式场景下的高可用？</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul>
<li><strong>复制同步模式</strong><ul>
<li>同步复制：如果由于从库已崩溃，存在网络故障或其他原因而没有响应，则主库也无法写入该数据。</li>
<li>半同步复制：其中部分从库进行同步复制，而其他从库进行异步复制。也就是，如果其中一个从库同步确认，主库可以写入该数据。</li>
<li>异步复制：不管从库的复制情况如何，主库可以写入该数据。而此时，如果主库失效，那么还未同步到从库的数据就会丢失。</li>
</ul>
</li>
<li>复制延迟 - 提高系统的查询性能，可以通过添加从节点来实现。但是如果使用同步复制，每次写入都需要同步所有从节点，会造成一部分从节点已经有数据，但是主节点还没写入数据。而异步复制的问题是从节点的数据可能不是最新的。</li>
<li><strong>复制与高可用性</strong><ul>
<li><strong>从节点故障</strong>。由于每个节点都复制了从主库那里收到的数据更改日志，因此它知道在发生故障之前已处理的最后一个事务，由此可以凭借此信息从主节点或其他从节点那里恢复自己的数据。</li>
<li><strong>主节点故障</strong>。在这种情况下，需要在从节点中选择一个成为新的主节点，此过程称为故障转移，可以手动或自动触发。其典型过程为：第一步根据超时时间确定主节点离线；第二步选择新的主节点，这里注意<strong>新的主节点通常应该与旧的主节点数据最为接近</strong>；第三步是重置系统，让它成为新的主节点。</li>
</ul>
</li>
<li><strong>复制方式</strong><ul>
<li>基于语句的复制：主库记录它所执行的每个写请求（一般以 SQL 语句形式保存），每个从库解析并执行该语句，就像从客户端收到该语句一样。但这种复制会有一些潜在问题，如语句使用了获取当前时间的函数，复制后会在不同数据节点上产生不同的值。另外如自增列、触发器、存储过程和函数都可能在复制后产生意想不到的问题。但可以通过预处理规避这些问题。使用该复制方式的分布式数据库有 VoltDB、Calvin。</li>
<li>日志（WAL）同步：WAL 是一组字节序列，其中包含对数据库的所有写操作。它的内容是一组低级操作，如向磁盘的某个页面的某个数据块写入一段二进制数据，主库通过网络将这样的数据发送给从库。这种方法避免了上面提到的语句中部分操作复制后产生的一些副作用，但要求主从的数据库引擎完全一致，最好版本也要一致。如果要升级从库版本，那么就需要计划外停机。PostgreSQL 和 Oracle 中使用了此方法。</li>
<li>行复制：它由一系列记录组成，这些记录描述了以行的粒度对数据库表进行的写操作。它与特定存储引擎解耦，并且第三方应用可以很容易解析其数据格式。</li>
<li>ETL 工具：该功能一般是最灵活的方式。用户可以根据自己的业务来设计复制的范围和机制，同时在复制过程中还可以进行如过滤、转换和压缩等操作。但性能一般较低，故适合处理子数据集的场景。</li>
</ul>
</li>
</ul>
<h2 id="一致性与-CAP-模型：为什么需要分布式一致性？"><a href="#一致性与-CAP-模型：为什么需要分布式一致性？" class="headerlink" title="一致性与 CAP 模型：为什么需要分布式一致性？"></a>一致性与 CAP 模型：为什么需要分布式一致性？</h2><p>略</p>
<h2 id="实践：设计一个最简单的分布式数据库"><a href="#实践：设计一个最简单的分布式数据库" class="headerlink" title="实践：设计一个最简单的分布式数据库"></a>实践：设计一个最简单的分布式数据库</h2><p>略</p>
<h2 id="概要：什么是存储引擎，为什么需要了解它？"><a href="#概要：什么是存储引擎，为什么需要了解它？" class="headerlink" title="概要：什么是存储引擎，为什么需要了解它？"></a>概要：什么是存储引擎，为什么需要了解它？</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>数据库的一般架构</p>
<ol>
<li>传输层：它是接受客户端请求的一层。用来处理网络协议。同时，在分布式数据库中，它还承担着节点间互相通信的职责。</li>
<li>查询层：请求从传输层被发送到查询层。在查询层，协议被进行解析，如 SQL 解析；后进行验证与分析；最后结合访问控制来决定该请求是否要被执行。解析完成后，请求被发送到查询优化器，在这里根据预制的规则，数据分布并结合数据库内部的统计，会生成该请求的执行计划。执行计划一般是树状的，包含一系列相关的操作，用于从数据库中查询到请求希望获取的数据。</li>
<li>执行层：执行计划被发送到执行层去运行。执行层一般包含本地运行单元与远程运行单元。根据执行计划，调用不同的单元，而后将结果合并返回到传输层。执行层本地运行单元其实就是存储引擎。它一般包含如下一些功能<ol>
<li>事务管理器：用来调度事务并保证数据库的内部一致性（这与模块一中讨论的分布式一致性是不同的）；</li>
<li>锁管理：保证操作共享对象时候的一致性，包括事务、修改数据库参数都会使用到它；</li>
<li>存储结构：包含各种物理存储层，描述了数据与索引是如何组织在磁盘上的；</li>
<li>内存结构：主要包含缓存与缓冲管理，数据一般是批量输入磁盘的，写入之前会使用内存去缓存数据；</li>
<li>提交日志：当数据库崩溃后，可以使用提交日志恢复系统的一致性状态。</li>
</ol>
</li>
</ol>
<h3 id="内存与磁盘"><a href="#内存与磁盘" class="headerlink" title="内存与磁盘"></a>内存与磁盘</h3><p>内存特点：查询快、更昂贵、持久化比较复杂</p>
<h3 id="行式存储与列式存储"><a href="#行式存储与列式存储" class="headerlink" title="行式存储与列式存储"></a>行式存储与列式存储</h3><p><strong>列式存储非常适合处理分析聚合类型的任务</strong>，如计算数据趋势、平均值，等等。因为这些数据一般需要加载一列的所有行，而不关心的列数据不会被读取，从而获得了更高的性能。</p>
<h3 id="数据文件与索引文件"><a href="#数据文件与索引文件" class="headerlink" title="数据文件与索引文件"></a>数据文件与索引文件</h3><p>数据文件最传统的形式为堆组织表（Heap-Organized Table），数据的放置没有一个特别的顺序，一般是按照写入的先后顺序排布。这种数据文件需要一定额外的索引帮助来查找数据。</p>
<p>索引文件的分类模式一般为主键索引与二级索引两类。前者是建立在主键上的，它可能是一个字段或多个字段组成。而其他类型的索引都被称为二级索引。主键索引与数据是一对一关系，而二级索引很有可能是一对多的关系，即多个索引条目指向一条数据。</p>
<h3 id="面向分布式的存储引擎特点"><a href="#面向分布式的存储引擎特点" class="headerlink" title="面向分布式的存储引擎特点"></a>面向分布式的存储引擎特点</h3><p><strong>内存型数据库会倾向于选择分布式模式来进行构建</strong>。原因也是显而易见的，由于单机内存容量相比磁盘来说是很小的，故需要构建分布式数据库来满足业务所需要的容量。</p>
<p><strong>列式存储也与分布式数据库存在天然的联系</strong>。原因是针对 OLAP 的分析数据库，一个非常大的应用场景就是要分析所有数据。</p>
<h2 id="分布式索引：如何在集群中快速定位数据？"><a href="#分布式索引：如何在集群中快速定位数据？" class="headerlink" title="分布式索引：如何在集群中快速定位数据？"></a>分布式索引：如何在集群中快速定位数据？</h2><h3 id="读取路径"><a href="#读取路径" class="headerlink" title="读取路径"></a>读取路径</h3><p>存储引擎处理查询请求一般流程：</p>
<ol>
<li>寻找分片和目标节点；</li>
<li>检查数据是否在缓存与缓冲中；</li>
<li>检查数据是否在磁盘文件中；</li>
<li>合并结果。</li>
</ol>
<h3 id="索引数据表"><a href="#索引数据表" class="headerlink" title="索引数据表"></a>索引数据表</h3><p>SSTable 文件是一个排序的、不可变的、持久化的键值对结构，其中键值对可以是任意字节的字符串，支持使用指定键来查找值，或通过给定键范围遍历所有的键值对。每个 SSTable 文件包含一系列的块。SSTable 文件中的块索引（这些块索引通常保存在文件尾部区域）用于定位块，这些块索引在 SSTable 文件被打开时加载到内存。在查找时首先从内存中的索引二分查找找到块，然后一次磁盘寻道即可读取到相应的块。另一种方式是将 SSTable 文件完全加载到内存，从而在查找和扫描中就不需要读取磁盘。</p>
<h3 id="内存缓冲"><a href="#内存缓冲" class="headerlink" title="内存缓冲"></a>内存缓冲</h3><p>内存中常用的快速搜索数据结构是跳表。典型代表：Redis 使用跳表实现 zset。</p>
<h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><h2 id="日志型存储：为什么选择它作为底层存储？"><a href="#日志型存储：为什么选择它作为底层存储？" class="headerlink" title="日志型存储：为什么选择它作为底层存储？"></a>日志型存储：为什么选择它作为底层存储？</h2><h2 id="事务处理与恢复（上）：数据库崩溃后如何保证数据不丢失？"><a href="#事务处理与恢复（上）：数据库崩溃后如何保证数据不丢失？" class="headerlink" title="事务处理与恢复（上）：数据库崩溃后如何保证数据不丢失？"></a>事务处理与恢复（上）：数据库崩溃后如何保证数据不丢失？</h2><h2 id="事务处理与恢复（下）：如何控制并发事务？"><a href="#事务处理与恢复（下）：如何控制并发事务？" class="headerlink" title="事务处理与恢复（下）：如何控制并发事务？"></a>事务处理与恢复（下）：如何控制并发事务？</h2><h2 id="引擎拓展：解读当前流行的分布式存储引擎"><a href="#引擎拓展：解读当前流行的分布式存储引擎" class="headerlink" title="引擎拓展：解读当前流行的分布式存储引擎"></a>引擎拓展：解读当前流行的分布式存储引擎</h2><h2 id="概要：分布式系统都要解决哪些问题？"><a href="#概要：分布式系统都要解决哪些问题？" class="headerlink" title="概要：分布式系统都要解决哪些问题？"></a>概要：分布式系统都要解决哪些问题？</h2><h2 id="错误侦测：如何保证分布式系统稳定？"><a href="#错误侦测：如何保证分布式系统稳定？" class="headerlink" title="错误侦测：如何保证分布式系统稳定？"></a>错误侦测：如何保证分布式系统稳定？</h2><h2 id="领导选举：如何在分布式系统内安全地协调操作？"><a href="#领导选举：如何在分布式系统内安全地协调操作？" class="headerlink" title="领导选举：如何在分布式系统内安全地协调操作？"></a>领导选举：如何在分布式系统内安全地协调操作？</h2><h2 id="再谈一致性：除了-CAP-之外的一致性模型还有哪些？"><a href="#再谈一致性：除了-CAP-之外的一致性模型还有哪些？" class="headerlink" title="再谈一致性：除了 CAP 之外的一致性模型还有哪些？"></a>再谈一致性：除了 CAP 之外的一致性模型还有哪些？</h2><h2 id="数据可靠传播：反熵理论如何帮助数据库可靠工作？"><a href="#数据可靠传播：反熵理论如何帮助数据库可靠工作？" class="headerlink" title="数据可靠传播：反熵理论如何帮助数据库可靠工作？"></a>数据可靠传播：反熵理论如何帮助数据库可靠工作？</h2><h2 id="分布式事务（上）：除了-XA，还有哪些原子提交算法吗？"><a href="#分布式事务（上）：除了-XA，还有哪些原子提交算法吗？" class="headerlink" title="分布式事务（上）：除了 XA，还有哪些原子提交算法吗？"></a>分布式事务（上）：除了 XA，还有哪些原子提交算法吗？</h2><h2 id="分布式事务（下）：Spanner-与-Calvin"><a href="#分布式事务（下）：Spanner-与-Calvin" class="headerlink" title="分布式事务（下）：Spanner 与 Calvin"></a>分布式事务（下）：Spanner 与 Calvin</h2><h2 id="共识算法：一次性说清楚-Paxos、Raft-等算法的区别"><a href="#共识算法：一次性说清楚-Paxos、Raft-等算法的区别" class="headerlink" title="共识算法：一次性说清楚 Paxos、Raft 等算法的区别"></a>共识算法：一次性说清楚 Paxos、Raft 等算法的区别</h2><h2 id="知识串讲：如何取得性能和可扩展性的平衡？"><a href="#知识串讲：如何取得性能和可扩展性的平衡？" class="headerlink" title="知识串讲：如何取得性能和可扩展性的平衡？"></a>知识串讲：如何取得性能和可扩展性的平衡？</h2><h2 id="发展与局限：传统数据库在分布式领域的探索"><a href="#发展与局限：传统数据库在分布式领域的探索" class="headerlink" title="发展与局限：传统数据库在分布式领域的探索"></a>发展与局限：传统数据库在分布式领域的探索</h2><h2 id="数据库中间件：传统数据库向分布式数据库的过渡"><a href="#数据库中间件：传统数据库向分布式数据库的过渡" class="headerlink" title="数据库中间件：传统数据库向分布式数据库的过渡"></a>数据库中间件：传统数据库向分布式数据库的过渡</h2><h2 id="现状解读：分布式数据库的最新发展情况"><a href="#现状解读：分布式数据库的最新发展情况" class="headerlink" title="现状解读：分布式数据库的最新发展情况"></a>现状解读：分布式数据库的最新发展情况</h2><h2 id="加餐-1-概念解析：云原生、HTAP、图与内存数据库"><a href="#加餐-1-概念解析：云原生、HTAP、图与内存数据库" class="headerlink" title="加餐 1 概念解析：云原生、HTAP、图与内存数据库"></a>加餐 1 概念解析：云原生、HTAP、图与内存数据库</h2><h2 id="加餐-2-数据库选型：我们该用什么分布式数据库？"><a href="#加餐-2-数据库选型：我们该用什么分布式数据库？" class="headerlink" title="加餐 2 数据库选型：我们该用什么分布式数据库？"></a>加餐 2 数据库选型：我们该用什么分布式数据库？</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=605">《24 讲吃透分布式数据库》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/daa6b97a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/daa6b97a/" class="post-title-link" itemprop="url">《Dubbo 源码解读与实战》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-25 19:24:38" itemprop="dateCreated datePublished" datetime="2023-06-25T19:24:38+08:00">2023-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《Dubbo-源码解读与实战》笔记"><a href="#《Dubbo-源码解读与实战》笔记" class="headerlink" title="《Dubbo 源码解读与实战》笔记"></a>《Dubbo 源码解读与实战》笔记</h1><h2 id="开篇词-深入掌握-Dubbo-原理与实现，提升你的职场竞争力"><a href="#开篇词-深入掌握-Dubbo-原理与实现，提升你的职场竞争力" class="headerlink" title="开篇词 深入掌握 Dubbo 原理与实现，提升你的职场竞争力"></a>开篇词 深入掌握 Dubbo 原理与实现，提升你的职场竞争力</h2><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/">Apache Dubbo</a>是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：</p>
<ul>
<li>面向接口的远程方法调用；</li>
<li>可靠、智能的容错和负载均衡；</li>
<li>服务自动注册和发现能力。</li>
</ul>
<p><strong>Dubbo 是一个分布式服务框架，致力于提供高性能、透明化的 RPC 远程服务调用方案以及服务治理方案，以帮助我们解决微服务架构落地时的问题。</strong></p>
<h2 id="Dubbo-源码环境搭建：千里之行，始于足下"><a href="#Dubbo-源码环境搭建：千里之行，始于足下" class="headerlink" title="Dubbo 源码环境搭建：千里之行，始于足下"></a>Dubbo 源码环境搭建：千里之行，始于足下</h2><h3 id="Dubbo-核心组件"><a href="#Dubbo-核心组件" class="headerlink" title="Dubbo 核心组件"></a>Dubbo 核心组件</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png"></p>
<p>Registry - <strong>注册中心</strong>。负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册中心会立即推送相关事件通知 Consumer。</p>
<p>Provider - <strong>服务提供者</strong>。在它启动的时候，会向 Registry 进行注册操作，将自己服务的地址和相关配置信息封装成 URL 添加到 ZooKeeper 中。</p>
<p>Consumer - <strong>服务消费者</strong>。在它启动的时候，会向 Registry 进行订阅操作。订阅操作会从 ZooKeeper 中获取 Provider 注册的 URL，并在 ZooKeeper 中添加相应的监听器。获取到 Provider URL 之后，Consumer 会根据负载均衡算法从多个 Provider 中选择一个 Provider 并与其建立连接，最后发起对 Provider 的 RPC 调用。 如果 Provider URL 发生变更，Consumer 将会通过之前订阅过程中在注册中心添加的监听器，获取到最新的 Provider URL 信息，进行相应的调整，比如断开与宕机 Provider 的连接，并与新的 Provider 建立连接。Consumer 与 Provider 建立的是长连接，且 Consumer 会缓存 Provider 信息，所以一旦连接建立，即使注册中心宕机，也不会影响已运行的 Provider 和 Consumer。</p>
<p>Monitor - <strong>监控中心</strong>。用于统计服务的调用次数和调用时间。Provider 和 Consumer 在运行过程中，会在内存中统计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。监控中心在上面的架构图中并不是必要角色，监控中心宕机不会影响 Provider、Consumer 以及 Registry 的功能，只会丢失监控数据而已。</p>
<p>Container - 服务运行容器。</p>
<h3 id="Dubbo-核心模块"><a href="#Dubbo-核心模块" class="headerlink" title="Dubbo 核心模块"></a>Dubbo 核心模块</h3><ul>
<li><strong>dubbo-common 模块：</strong> Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，如 Dubbo SPI 实现、时间轮实现、动态编译器等。</li>
<li><strong>dubbo-remoting 模块：</strong> Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件进行实现，例如，dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。</li>
<li><strong>dubbo-rpc 模块：</strong> Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现，例如，dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。 dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。</li>
<li><strong>dubbo-cluster 模块：</strong> Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集群相关的功能，最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调用一个 Provider 那样调用 Provider 集群了。</li>
<li><strong>dubbo-registry 模块：</strong> Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能力。其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的具体实现，例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。</li>
<li><strong>dubbo-monitor 模块：</strong> Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。</li>
<li><strong>dubbo-config 模块：</strong> Dubbo 对外暴露的配置都是由该模块进行解析的。例如，dubbo-config-api 子模块负责处理 API 方式使用时的相关配置，dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。有了 dubbo-config 模块，用户只需要了解 Dubbo 配置的规则即可，无须了解 Dubbo 内部的细节。</li>
<li><strong>dubbo-metadata 模块：</strong> Dubbo 的元数据模块。dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。</li>
<li><strong>dubbo-configcenter 模块：</strong> Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。</li>
</ul>
<h2 id="Dubbo-的配置总线：抓住-URL，就理解了半个-Dubbo"><a href="#Dubbo-的配置总线：抓住-URL，就理解了半个-Dubbo" class="headerlink" title="Dubbo 的配置总线：抓住 URL，就理解了半个 Dubbo"></a>Dubbo 的配置总线：抓住 URL，就理解了半个 Dubbo</h2><p>Dubbo 中任意的一个实现都可以抽象为一个 URL，Dubbo 使用 URL 来统一描述了所有对象和配置信息，并贯穿在整个 Dubbo 框架之中。Dubbo URL 格式如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">protocol:</span>//<span class="symbol">username:</span>password<span class="variable">@host</span><span class="symbol">:port/path?key=value&amp;key=value</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>protocol</strong>：URL 的协议。我们常见的就是 HTTP 协议和 HTTPS 协议，当然，还有其他协议，如 FTP 协议、SMTP 协议等。</li>
<li><strong>username&#x2F;password</strong>：用户名&#x2F;密码。 HTTP Basic Authentication 中多会使用在 URL 的协议之后直接携带用户名和密码的方式。</li>
<li><strong>host&#x2F;port</strong>：主机&#x2F;端口。在实践中一般会使用域名，而不是使用具体的 host 和 port。</li>
<li><strong>path</strong>：请求的路径。</li>
<li><strong>parameters</strong>：参数键值对。一般在 GET 请求中会将参数放到 URL 中，POST 请求会将参数放到请求体中。</li>
</ul>
<p>Dubbo 中和 URL 相关的核心类：</p>
<ul>
<li><strong>URL</strong> - 定义了 URL 的结构；</li>
<li><strong>URLBuilder，</strong> 辅助构造 URL；</li>
<li><strong>URLStrParser，</strong> 将字符串解析成 URL 对象。</li>
</ul>
<h3 id="Dubbo-中的-URL-示例"><a href="#Dubbo-中的-URL-示例" class="headerlink" title="Dubbo 中的 URL 示例"></a>Dubbo 中的 URL 示例</h3><p>URL 在 SPI 中的应用：RegistryFactory.getRegistry() 方法。</p>
<p>URL 在服务暴露中的应用：ZookeeperRegistry.doRegister() 方法。</p>
<p>URL 在服务订阅中的应用：Registry.doSubscribe() 方法</p>
<h2 id="Dubbo-SPI-精析，接口实现两极反转（上）"><a href="#Dubbo-SPI-精析，接口实现两极反转（上）" class="headerlink" title="Dubbo SPI 精析，接口实现两极反转（上）"></a>Dubbo SPI 精析，接口实现两极反转（上）</h2><p>Dubbo 通过 SPI 机制来实现微内核架构，以达到 OCP 原则（即“对扩展开放，对修改封闭”的原则）。</p>
<p>JDK SPI 要点：</p>
<ul>
<li>在 Classpath 下的 META-INF&#x2F;services&#x2F; 目录里创建一个以服务接口命名的文件</li>
<li>此文件记录了该 jar 包提供的服务接口的具体实现类</li>
</ul>
<p>JDK SPI 源码分析</p>
<p>ServiceLoader.load() 方法，首先会尝试获取当前使用的 ClassLoader；查找失败后使用 SystemClassLoader；然后调用 reload() 方法。</p>
<p>在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象。</p>
<h2 id="Dubbo-SPI-精析，接口实现两极反转（下）"><a href="#Dubbo-SPI-精析，接口实现两极反转（下）" class="headerlink" title="Dubbo SPI 精析，接口实现两极反转（下）"></a>Dubbo SPI 精析，接口实现两极反转（下）</h2><p>Dubbo 按照 SPI 配置文件的用途，将其分成了三类目录。</p>
<ul>
<li>META-INF&#x2F;services&#x2F; 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。</li>
<li>META-INF&#x2F;dubbo&#x2F; 目录：该目录用于存放用户自定义 SPI 配置文件。</li>
<li>META-INF&#x2F;dubbo&#x2F;internal&#x2F; 目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。</li>
</ul>
<p>Dubbo 将 SPI 配置文件改成了 <strong>KV 格式</strong>，例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo</span>=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>

<h3 id="SPI-核心实现"><a href="#SPI-核心实现" class="headerlink" title="SPI 核心实现"></a>SPI 核心实现</h3><p>@SPI 注解</p>
<p>Dubbo SPI 的核心逻辑几乎都封装在 ExtensionLoader 之中。</p>
<p>ExtensionLoader 中三个核心的静态字段。</p>
<ul>
<li><strong>strategies（LoadingStrategy[]类型）:</strong> LoadingStrategy 接口有三个实现（通过 JDK SPI 方式加载的），分别对应前面介绍的三个 Dubbo SPI 配置文件所在的目录</li>
<li><strong>EXTENSION_LOADERS（ConcurrentMap&lt;Class, ExtensionLoader&gt;类型）</strong> ：Dubbo 中一个扩展接口对应一个 ExtensionLoader 实例，该集合缓存了全部 ExtensionLoader 实例，其中的 Key 为扩展接口，Value 为加载其扩展实现的 ExtensionLoader 实例。</li>
<li><strong>EXTENSION_INSTANCES（ConcurrentMap&lt;Class&lt;?&gt;, Object&gt;类型）</strong>：该集合缓存了扩展实现类与其实例对象的映射关系。在前文示例中，Key 为 Class，Value 为 DubboProtocol 对象。</li>
</ul>
<h2 id="海量定时任务，一个时间轮搞定"><a href="#海量定时任务，一个时间轮搞定" class="headerlink" title="海量定时任务，一个时间轮搞定"></a>海量定时任务，一个时间轮搞定</h2><p><strong>时间轮是一种高效的、批量管理定时任务的调度模型</strong>。时间轮一般会实现成一个环形结构，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；指针周期性地跳动，跳动到一个槽位，就执行该槽位的定时任务。</p>
<p>需要注意的是，单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，通常会使用<strong>多级时间轮</strong>以及<strong>持久化存储与时间轮结合</strong>的方案。</p>
<p>核心接口和类：</p>
<ul>
<li>TimerTask 接口</li>
<li>Timer 接口</li>
<li>Timeout 接口</li>
<li>HashedWheelTimeout 类</li>
<li>HashedWheelBucket 类</li>
<li>HashedWheelTimer 类</li>
</ul>
<h2 id="ZooKeeper-与-Curator，求你别用-ZkClient-了（上）"><a href="#ZooKeeper-与-Curator，求你别用-ZkClient-了（上）" class="headerlink" title="ZooKeeper 与 Curator，求你别用 ZkClient 了（上）"></a>ZooKeeper 与 Curator，求你别用 ZkClient 了（上）</h2><p>Dubbo 目前支持 Consul、etcd、Nacos、ZooKeeper、Redis 等多种开源组件作为注册中心，并且在 Dubbo 源码也有相应的接入模块。</p>
<p><strong>ZooKeeper 是一个针对分布式系统的、可靠的、可扩展的协调服务</strong>，它通常作为统一命名服务、统一配置管理、注册中心（分布式集群管理）、分布式锁服务、Leader 选举服务等角色出现。</p>
<p>ZooKeeper 集群中的角色</p>
<ul>
<li><strong>Client 节点</strong>：从业务角度来看，这是分布式应用中的一个节点，通过 ZkClient 或是其他 ZooKeeper 客户端与 ZooKeeper 集群中的一个 Server 实例维持长连接，并定时发送心跳。从 ZooKeeper 集群的角度来看，它是 ZooKeeper 集群的一个客户端，可以主动查询或操作 ZooKeeper 集群中的数据，也可以在某些 ZooKeeper 节点（ZNode）上添加监听。当被监听的 ZNode 节点发生变化时，例如，该 ZNode 节点被删除、新增子节点或是其中数据被修改等，ZooKeeper 集群都会立即通过长连接通知 Client。</li>
<li><strong>Leader 节点</strong>：ZooKeeper 集群的主节点，负责整个 ZooKeeper 集群的写操作，保证集群内事务处理的顺序性。同时，还要负责整个集群中所有 Follower 节点与 Observer 节点的数据同步。</li>
<li><strong>Follower 节点</strong>：ZooKeeper 集群中的从节点，可以接收 Client 读请求并向 Client 返回结果，并不处理写请求，而是转发到 Leader 节点完成写入操作。另外，Follower 节点还会参与 Leader 节点的选举。</li>
<li><strong>Observer 节点</strong>：ZooKeeper 集群中特殊的从节点，不会参与 Leader 节点的选举，其他功能与 Follower 节点相同。引入 Observer 角色的目的是增加 ZooKeeper 集群读操作的吞吐量，如果单纯依靠增加 Follower 节点来提高 ZooKeeper 的读吞吐量，那么有一个很严重的副作用，就是 ZooKeeper 集群的写能力会大大降低，因为 ZooKeeper 写数据时需要 Leader 将写操作同步给半数以上的 Follower 节点。引入 Observer 节点使得 ZooKeeper 集群在写能力不降低的情况下，大大提升了读操作的吞吐量。</li>
</ul>
<p>ZNode 节点类型有如下四种：</p>
<ul>
<li><strong>持久节点。</strong> 持久节点创建后，会一直存在，不会因创建该节点的 Client 会话失效而删除。</li>
<li><strong>持久顺序节点。</strong> 持久顺序节点的基本特性与持久节点一致，创建节点的过程中，ZooKeeper 会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名。</li>
<li><strong>临时节点。</strong> 创建临时节点的 ZooKeeper Client 会话失效之后，其创建的临时节点会被 ZooKeeper 集群自动删除。与持久节点的另一点区别是，临时节点下面不能再创建子节点。</li>
<li><strong>临时顺序节点。</strong> 基本特性与临时节点一致，创建节点的过程中，ZooKeeper 会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名。</li>
</ul>
<h2 id="ZooKeeper-与-Curator，求你别用-ZkClient-了（下）"><a href="#ZooKeeper-与-Curator，求你别用-ZkClient-了（下）" class="headerlink" title="ZooKeeper 与 Curator，求你别用 ZkClient 了（下）"></a>ZooKeeper 与 Curator，求你别用 ZkClient 了（下）</h2><h2 id="代理模式与常见实现"><a href="#代理模式与常见实现" class="headerlink" title="代理模式与常见实现"></a>代理模式与常见实现</h2><p>代理模式</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>JDK 动态代理的核心是 InvocationHandler 接口。</p>
<h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>CGLib（Code Generation Library）是一个基于 ASM 的字节码生成库。它允许我们在运行时对字节码进行修改和动态生成。CGLib 采用字节码技术实现动态代理功能，其底层原理是通过字节码技术为目标类生成一个子类，并在该子类中采用方法拦截的方式拦截所有父类方法的调用，从而实现代理的功能。</p>
<p>因为 CGLib 使用生成子类的方式实现动态代理，所以无法代理 final 关键字修饰的方法（因为 final 方法是不能够被重写的）。这样的话，<strong>CGLib 与 JDK 动态代理之间可以相互补充：在目标类实现接口时，使用 JDK 动态代理创建代理对象；当目标类没有实现接口时，使用 CGLib 实现动态代理的功能</strong>。在 Spring、MyBatis 等多种开源框架中，都可以看到 JDK 动态代理与 CGLib 结合使用的场景。</p>
<p>CGLib 的实现有两个重要的成员组成。</p>
<ul>
<li><strong>Enhancer</strong>：指定要代理的目标对象以及实际处理代理逻辑的对象，最终通过调用 create() 方法得到代理对象，对这个对象所有的非 final 方法的调用都会转发给 MethodInterceptor 进行处理。</li>
<li><strong>MethodInterceptor</strong>：动态代理对象的方法调用都会转发到 intercept 方法进行增强。</li>
</ul>
<h3 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h3><p><strong>Javassist 是一个开源的生成 Java 字节码的类库</strong>，其主要优点在于简单、快速，直接使用 Javassist 提供的 Java API 就能动态修改类的结构，或是动态生成类。</p>
<h2 id="Netty-入门，用它做网络编程都说好（上）"><a href="#Netty-入门，用它做网络编程都说好（上）" class="headerlink" title="Netty 入门，用它做网络编程都说好（上）"></a>Netty 入门，用它做网络编程都说好（上）</h2><h3 id="Netty-I-O-模型设计"><a href="#Netty-I-O-模型设计" class="headerlink" title="Netty I&#x2F;O 模型设计"></a>Netty I&#x2F;O 模型设计</h3><h4 id="传统阻塞-I-O-模型"><a href="#传统阻塞-I-O-模型" class="headerlink" title="传统阻塞 I&#x2F;O 模型"></a>传统阻塞 I&#x2F;O 模型</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626221005.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626221044.png"></p>
<h4 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I&#x2F;O 多路复用模型"></a>I&#x2F;O 多路复用模型</h4><p>针对传统的阻塞 I&#x2F;O 模型的缺点，I&#x2F;O 复用的模型在性能方面有不小的提升。I&#x2F;O 复用模型中的多个连接会共用一个 Selector 对象，由 Selector 感知连接的读写事件，而此时的线程数并不需要和连接数一致，只需要很少的线程定期从 Selector 上查询连接的读写状态即可，无须大量线程阻塞等待连接。当某个连接有新的数据可以处理时，操作系统会通知线程，线程从阻塞状态返回，开始进行读写操作以及后续的业务逻辑处理。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626221405.png"></p>
<p>Netty 就是采用了上述 I&#x2F;O 复用的模型。由于多路复用器 Selector 的存在，可以同时并发处理成百上千个网络连接，大大增加了服务器的处理能力。另外，Selector 并不会阻塞线程，也就是说当一个连接不可读或不可写的时候，线程可以去处理其他可读或可写的连接，这就充分提升了 I&#x2F;O 线程的运行效率，避免由于频繁 I&#x2F;O 阻塞导致的线程切换。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626221543.png"></p>
<h3 id="Netty-线程模型设计"><a href="#Netty-线程模型设计" class="headerlink" title="Netty 线程模型设计"></a>Netty 线程模型设计</h3><p><strong>Netty 采用了 Reactor 线程模型的设计。</strong> Reactor 模式，也被称为 Dispatcher 模式，<strong>核心原理是 Selector 负责监听 I&#x2F;O 事件，在监听到 I&#x2F;O 事件之后，分发（Dispatch）给相关线程进行处理</strong>。</p>
<h4 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h4><p>Reactor 对象监听客户端请求事件，收到事件后通过 Dispatch 进行分发。如果是连接建立的事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接建立之后的业务请求。如果不是连接建立的事件，而是数据的读写事件，则 Reactor 会将事件分发对应的 Handler 来处理，由这里唯一的线程调用 Handler 对象来完成读取数据、业务处理、发送响应的完整流程。当然，该过程中也可能会出现连接不可读或不可写等情况，该单线程会去执行其他 Handler 的逻辑，而不是阻塞等待。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626221855.png"></p>
<p>单 Reactor 单线程的优点就是：线程模型简单，没有引入多线程，自然也就没有多线程并发和竞争的问题。</p>
<p>但其缺点也非常明显，那就是<strong>性能瓶颈问题</strong>，一个线程只能跑在一个 CPU 上，能处理的连接数是有限的，无法完全发挥多核 CPU 的优势。一旦某个业务逻辑耗时较长，这唯一的线程就会卡在上面，无法处理其他连接的请求，程序进入假死的状态，可用性也就降低了。正是由于这种限制，一般只会在<strong>客户端</strong>使用这种线程模型。</p>
<h4 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h4><p>在单 Reactor 多线程的架构中，Reactor 监控到客户端请求之后，如果连接建立的请求，则由 Acceptor 通过 accept 处理，然后创建一个 Handler 对象处理连接建立之后的业务请求。如果不是连接建立请求，则 Reactor 会将事件分发给调用连接对应的 Handler 来处理。到此为止，该流程与单 Reactor 单线程的模型基本一致，<strong>唯一的区别就是执行 Handler 逻辑的线程隶属于一个线程池</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626222342.png"></p>
<p>很明显，单 Reactor 多线程的模型可以充分利用多核 CPU 的处理能力，提高整个系统的吞吐量，但引入多线程模型就要考虑线程并发、数据共享、线程调度等问题。在这个模型中，只有一个线程来处理 Reactor 监听到的所有 I&#x2F;O 事件，其中就包括连接建立事件以及读写事件，当连接数不断增大的时候，这个唯一的 Reactor 线程也会遇到瓶颈。</p>
<h4 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h4><p>为了解决单 Reactor 多线程模型中的问题，我们可以引入多个 Reactor。其中，Reactor 主线程负责通过 Acceptor 对象处理 MainReactor 监听到的连接建立事件，当 Acceptor 完成网络连接的建立之后，MainReactor 会将建立好的连接分配给 SubReactor 进行后续监听。</p>
<p>当一个连接被分配到一个 SubReactor 之上时，会由 SubReactor 负责监听该连接上的读写事件。当有新的读事件（OP_READ）发生时，Reactor 子线程就会调用对应的 Handler 读取数据，然后分发给 Worker 线程池中的线程进行处理并返回结果。待处理结束之后，Handler 会根据处理结果调用 send 将响应返回给客户端，当然此时连接要有可写事件（OP_WRITE）才能发送数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626222425.png"></p>
<p>主从 Reactor 多线程的设计模式解决了单一 Reactor 的瓶颈。<strong>主从 Reactor 职责明确，主 Reactor 只负责监听连接建立事件，SubReactor 只负责监听读写事件</strong>。整个主从 Reactor 多线程架构充分利用了多核 CPU 的优势，可以支持扩展，而且与具体的业务逻辑充分解耦，复用性高。但不足的地方是，在交互上略显复杂，需要一定的编程门槛。</p>
<h4 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h4><p>Netty 同时支持上述几种线程模式</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626222709.png"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>Netty 抽象出两组线程池：BossGroup 专门用于接收客户端的连接，WorkerGroup 专门用于网络的读写</strong>。BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup，相当于一个事件循环组，其中包含多个事件循环 ，每一个事件循环是 NioEventLoop。</p>
<p>NioEventLoop 表示一个不断循环的、执行处理任务的线程，每个 NioEventLoop 都有一个 Selector 对象与之对应，用于监听绑定在其上的连接，这些连接上的事件由 Selector 对应的这条线程处理。每个 NioEventLoopGroup 可以含有多个 NioEventLoop，也就是多个线程。</p>
<p>每个 Boss NioEventLoop 会监听 Selector 上连接建立的 accept 事件，然后处理 accept 事件与客户端建立网络连接，生成相应的 NioSocketChannel 对象，一个 NioSocketChannel 就表示一条网络连接。之后会将 NioSocketChannel 注册到某个 Worker NioEventLoop 上的 Selector 中。</p>
<p>每个 Worker NioEventLoop 会监听对应 Selector 上的 read&#x2F;write 事件，当监听到 read&#x2F;write 事件的时候，会通过 Pipeline 进行处理。一个 Pipeline 与一个 Channel 绑定，在 Pipeline 上可以添加多个 ChannelHandler，每个 ChannelHandler 中都可以包含一定的逻辑，例如编解码等。Pipeline 在处理请求的时候，会按照我们指定的顺序调用 ChannelHandler。</p>
<h2 id="Netty-入门，用它做网络编程都说好（下）"><a href="#Netty-入门，用它做网络编程都说好（下）" class="headerlink" title="Netty 入门，用它做网络编程都说好（下）"></a>Netty 入门，用它做网络编程都说好（下）</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是 Netty 对网络连接的抽象，核心功能是执行网络 I&#x2F;O 操作。不同协议、不同阻塞类型的连接对应不同的 Channel 类型。</p>
<p>常用的 NIO Channel 类型。</p>
<ul>
<li><strong>NioSocketChannel</strong>：对应异步的 TCP Socket 连接。</li>
<li><strong>NioServerSocketChannel</strong>：对应异步的服务器端 TCP Socket 连接。</li>
<li><strong>NioDatagramChannel</strong>：对应异步的 UDP 连接。</li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><strong>Selector 是对多路复用器的抽象</strong>，也是 Java NIO 的核心基础组件之一。Netty 就是基于 Selector 对象实现 I&#x2F;O 多路复用的，在 Selector 内部，会通过系统调用不断地查询这些注册在其上的 Channel 是否有已就绪的 I&#x2F;O 事件，例如，可读事件（OP_READ）、可写事件（OP_WRITE）或是网络连接事件（OP_ACCEPT）等，而无须使用用户线程进行轮询。这样，我们就可以用一个线程监听多个 Channel 上发生的事件。</p>
<p>EventLoop</p>
<p>EventLoopGroup</p>
<h2 id="简易版-RPC-框架实现（上）"><a href="#简易版-RPC-框架实现（上）" class="headerlink" title="简易版 RPC 框架实现（上）"></a>简易版 RPC 框架实现（上）</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230626223647.png"></p>
<h2 id="简易版-RPC-框架实现（下）"><a href="#简易版-RPC-框架实现（下）" class="headerlink" title="简易版 RPC 框架实现（下）"></a>简易版 RPC 框架实现（下）</h2><h2 id="本地缓存：降低-ZooKeeper-压力的一个常用手段"><a href="#本地缓存：降低-ZooKeeper-压力的一个常用手段" class="headerlink" title="本地缓存：降低 ZooKeeper 压力的一个常用手段"></a>本地缓存：降低 ZooKeeper 压力的一个常用手段</h2><h2 id="重试机制是网络操作的基本保证"><a href="#重试机制是网络操作的基本保证" class="headerlink" title="重试机制是网络操作的基本保证"></a>重试机制是网络操作的基本保证</h2><h2 id="ZooKeeper-注册中心实现，官方推荐注册中心实践"><a href="#ZooKeeper-注册中心实现，官方推荐注册中心实践" class="headerlink" title="ZooKeeper 注册中心实现，官方推荐注册中心实践"></a>ZooKeeper 注册中心实现，官方推荐注册中心实践</h2><h2 id="Dubbo-Serialize-层：多种序列化算法，总有一款适合你"><a href="#Dubbo-Serialize-层：多种序列化算法，总有一款适合你" class="headerlink" title="Dubbo Serialize 层：多种序列化算法，总有一款适合你"></a>Dubbo Serialize 层：多种序列化算法，总有一款适合你</h2><h2 id="Dubbo-Remoting-层核心接口分析：这居然是一套兼容所有-NIO-框架的设计？"><a href="#Dubbo-Remoting-层核心接口分析：这居然是一套兼容所有-NIO-框架的设计？" class="headerlink" title="Dubbo Remoting 层核心接口分析：这居然是一套兼容所有 NIO 框架的设计？"></a>Dubbo Remoting 层核心接口分析：这居然是一套兼容所有 NIO 框架的设计？</h2><h2 id="Buffer-缓冲区：我们不生产数据，我们只是数据的搬运工"><a href="#Buffer-缓冲区：我们不生产数据，我们只是数据的搬运工" class="headerlink" title="Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工"></a>Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工</h2><h2 id="Transporter-层核心实现：编解码与线程模型一文打尽（上）"><a href="#Transporter-层核心实现：编解码与线程模型一文打尽（上）" class="headerlink" title="Transporter 层核心实现：编解码与线程模型一文打尽（上）"></a>Transporter 层核心实现：编解码与线程模型一文打尽（上）</h2><h2 id="Transporter-层核心实现：编解码与线程模型一文打尽（下）"><a href="#Transporter-层核心实现：编解码与线程模型一文打尽（下）" class="headerlink" title="Transporter 层核心实现：编解码与线程模型一文打尽（下）"></a>Transporter 层核心实现：编解码与线程模型一文打尽（下）</h2><h2 id="Exchange-层剖析：彻底搞懂-Request-Response-模型（上）"><a href="#Exchange-层剖析：彻底搞懂-Request-Response-模型（上）" class="headerlink" title="Exchange 层剖析：彻底搞懂 Request-Response 模型（上）"></a>Exchange 层剖析：彻底搞懂 Request-Response 模型（上）</h2><h2 id="Exchange-层剖析：彻底搞懂-Request-Response-模型（下）"><a href="#Exchange-层剖析：彻底搞懂-Request-Response-模型（下）" class="headerlink" title="Exchange 层剖析：彻底搞懂 Request-Response 模型（下）"></a>Exchange 层剖析：彻底搞懂 Request-Response 模型（下）</h2><h2 id="核心接口介绍，RPC-层骨架梳理"><a href="#核心接口介绍，RPC-层骨架梳理" class="headerlink" title="核心接口介绍，RPC 层骨架梳理"></a>核心接口介绍，RPC 层骨架梳理</h2><h2 id="从-Protocol-起手，看服务暴露和服务引用的全流程（上）"><a href="#从-Protocol-起手，看服务暴露和服务引用的全流程（上）" class="headerlink" title="从 Protocol 起手，看服务暴露和服务引用的全流程（上）"></a>从 Protocol 起手，看服务暴露和服务引用的全流程（上）</h2><h2 id="从-Protocol-起手，看服务暴露和服务引用的全流程（下）"><a href="#从-Protocol-起手，看服务暴露和服务引用的全流程（下）" class="headerlink" title="从 Protocol 起手，看服务暴露和服务引用的全流程（下）"></a>从 Protocol 起手，看服务暴露和服务引用的全流程（下）</h2><h2 id="加餐：直击-Dubbo-“心脏”，带你一起探秘-Invoker（上）"><a href="#加餐：直击-Dubbo-“心脏”，带你一起探秘-Invoker（上）" class="headerlink" title="加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（上）"></a>加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（上）</h2><h2 id="加餐：直击-Dubbo-“心脏”，带你一起探秘-Invoker（下）"><a href="#加餐：直击-Dubbo-“心脏”，带你一起探秘-Invoker（下）" class="headerlink" title="加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）"></a>加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）</h2><h2 id="复杂问题简单化，代理帮你隐藏了多少底层细节？"><a href="#复杂问题简单化，代理帮你隐藏了多少底层细节？" class="headerlink" title="复杂问题简单化，代理帮你隐藏了多少底层细节？"></a>复杂问题简单化，代理帮你隐藏了多少底层细节？</h2><h2 id="加餐：HTTP-协议-JSON-RPC，Dubbo-跨语言就是如此简单"><a href="#加餐：HTTP-协议-JSON-RPC，Dubbo-跨语言就是如此简单" class="headerlink" title="加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单"></a>加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单</h2><h2 id="Filter-接口，扩展-Dubbo-框架的常用手段指北"><a href="#Filter-接口，扩展-Dubbo-框架的常用手段指北" class="headerlink" title="Filter 接口，扩展 Dubbo 框架的常用手段指北"></a>Filter 接口，扩展 Dubbo 框架的常用手段指北</h2><h2 id="加餐：深潜-Directory-实现，探秘服务目录玄机"><a href="#加餐：深潜-Directory-实现，探秘服务目录玄机" class="headerlink" title="加餐：深潜 Directory 实现，探秘服务目录玄机"></a>加餐：深潜 Directory 实现，探秘服务目录玄机</h2><h2 id="路由机制：请求到底怎么走，它说了算（上）"><a href="#路由机制：请求到底怎么走，它说了算（上）" class="headerlink" title="路由机制：请求到底怎么走，它说了算（上）"></a>路由机制：请求到底怎么走，它说了算（上）</h2><h2 id="路由机制：请求到底怎么走，它说了算（下）"><a href="#路由机制：请求到底怎么走，它说了算（下）" class="headerlink" title="路由机制：请求到底怎么走，它说了算（下）"></a>路由机制：请求到底怎么走，它说了算（下）</h2><h2 id="加餐：初探-Dubbo-动态配置的那些事儿"><a href="#加餐：初探-Dubbo-动态配置的那些事儿" class="headerlink" title="加餐：初探 Dubbo 动态配置的那些事儿"></a>加餐：初探 Dubbo 动态配置的那些事儿</h2><h2 id="负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）"><a href="#负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）" class="headerlink" title="负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）"></a>负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）</h2><h2 id="负载均衡：公平公正物尽其用的负载均衡策略，这里都有（下）"><a href="#负载均衡：公平公正物尽其用的负载均衡策略，这里都有（下）" class="headerlink" title="负载均衡：公平公正物尽其用的负载均衡策略，这里都有（下）"></a>负载均衡：公平公正物尽其用的负载均衡策略，这里都有（下）</h2><h2 id="集群容错：一个好汉三个帮（上）"><a href="#集群容错：一个好汉三个帮（上）" class="headerlink" title="集群容错：一个好汉三个帮（上）"></a>集群容错：一个好汉三个帮（上）</h2><h2 id="集群容错：一个好汉三个帮（下）"><a href="#集群容错：一个好汉三个帮（下）" class="headerlink" title="集群容错：一个好汉三个帮（下）"></a>集群容错：一个好汉三个帮（下）</h2><h2 id="加餐：多个返回值不用怕，Merger-合并器来帮忙"><a href="#加餐：多个返回值不用怕，Merger-合并器来帮忙" class="headerlink" title="加餐：多个返回值不用怕，Merger 合并器来帮忙"></a>加餐：多个返回值不用怕，Merger 合并器来帮忙</h2><h2 id="加餐：模拟远程调用，Mock-机制帮你搞定"><a href="#加餐：模拟远程调用，Mock-机制帮你搞定" class="headerlink" title="加餐：模拟远程调用，Mock 机制帮你搞定"></a>加餐：模拟远程调用，Mock 机制帮你搞定</h2><h2 id="加餐：一键通关服务发布全流程"><a href="#加餐：一键通关服务发布全流程" class="headerlink" title="加餐：一键通关服务发布全流程"></a>加餐：一键通关服务发布全流程</h2><h2 id="加餐：服务引用流程全解析"><a href="#加餐：服务引用流程全解析" class="headerlink" title="加餐：服务引用流程全解析"></a>加餐：服务引用流程全解析</h2><h2 id="服务自省设计方案：新版本新方案"><a href="#服务自省设计方案：新版本新方案" class="headerlink" title="服务自省设计方案：新版本新方案"></a>服务自省设计方案：新版本新方案</h2><h2 id="元数据方案深度剖析，如何避免注册中心数据量膨胀？"><a href="#元数据方案深度剖析，如何避免注册中心数据量膨胀？" class="headerlink" title="元数据方案深度剖析，如何避免注册中心数据量膨胀？"></a>元数据方案深度剖析，如何避免注册中心数据量膨胀？</h2><h2 id="加餐：深入服务自省方案中的服务发布订阅（上）"><a href="#加餐：深入服务自省方案中的服务发布订阅（上）" class="headerlink" title="加餐：深入服务自省方案中的服务发布订阅（上）"></a>加餐：深入服务自省方案中的服务发布订阅（上）</h2><h2 id="加餐：深入服务自省方案中的服务发布订阅（下）"><a href="#加餐：深入服务自省方案中的服务发布订阅（下）" class="headerlink" title="加餐：深入服务自省方案中的服务发布订阅（下）"></a>加餐：深入服务自省方案中的服务发布订阅（下）</h2><h2 id="配置中心设计与实现：集中化配置-and-本地化配置，我都要（上）"><a href="#配置中心设计与实现：集中化配置-and-本地化配置，我都要（上）" class="headerlink" title="配置中心设计与实现：集中化配置 and 本地化配置，我都要（上）"></a>配置中心设计与实现：集中化配置 and 本地化配置，我都要（上）</h2><h2 id="配置中心设计与实现：集中化配置-and-本地化配置，我都要（下）"><a href="#配置中心设计与实现：集中化配置-and-本地化配置，我都要（下）" class="headerlink" title="配置中心设计与实现：集中化配置 and 本地化配置，我都要（下）"></a>配置中心设计与实现：集中化配置 and 本地化配置，我都要（下）</h2><h2 id="结束语-认真学习，缩小差距"><a href="#结束语-认真学习，缩小差距" class="headerlink" title="结束语 认真学习，缩小差距"></a>结束语 认真学习，缩小差距</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393">《Dubbo 源码解读与实战》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/7ea0e382/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/7ea0e382/" class="post-title-link" itemprop="url">《极客时间教程 - 分布式技术原理与算法解析》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-07 13:49:02" itemprop="dateCreated datePublished" datetime="2023-06-07T13:49:02+08:00">2023-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-分布式技术原理与算法解析》笔记"><a href="#《极客时间教程-分布式技术原理与算法解析》笔记" class="headerlink" title="《极客时间教程 - 分布式技术原理与算法解析》笔记"></a>《极客时间教程 - 分布式技术原理与算法解析》笔记</h1><h2 id="开篇词丨四纵四横，带你透彻理解分布式技术"><a href="#开篇词丨四纵四横，带你透彻理解分布式技术" class="headerlink" title="开篇词丨四纵四横，带你透彻理解分布式技术"></a>开篇词丨四纵四横，带你透彻理解分布式技术</h2><h2 id="分布式缘何而起：从单兵，到游击队，到集团军"><a href="#分布式缘何而起：从单兵，到游击队，到集团军" class="headerlink" title="分布式缘何而起：从单兵，到游击队，到集团军"></a>分布式缘何而起：从单兵，到游击队，到集团军</h2><h2 id="分布式系统的指标：啥是分布式的三围"><a href="#分布式系统的指标：啥是分布式的三围" class="headerlink" title="分布式系统的指标：啥是分布式的三围"></a>分布式系统的指标：啥是分布式的三围</h2><h2 id="分布式互斥：有你没我，有我没你"><a href="#分布式互斥：有你没我，有我没你" class="headerlink" title="分布式互斥：有你没我，有我没你"></a>分布式互斥：有你没我，有我没你</h2><h2 id="分布式选举：国不可一日无君"><a href="#分布式选举：国不可一日无君" class="headerlink" title="分布式选举：国不可一日无君"></a>分布式选举：国不可一日无君</h2><h2 id="分布式共识：存异求同"><a href="#分布式共识：存异求同" class="headerlink" title="分布式共识：存异求同"></a>分布式共识：存异求同</h2><h2 id="分布式事务：Allornothing"><a href="#分布式事务：Allornothing" class="headerlink" title="分布式事务：Allornothing"></a>分布式事务：Allornothing</h2><h2 id="分布式锁：关键重地，非请勿入"><a href="#分布式锁：关键重地，非请勿入" class="headerlink" title="分布式锁：关键重地，非请勿入"></a>分布式锁：关键重地，非请勿入</h2><h2 id="答疑篇：分布式技术是如何引爆人工智能的？"><a href="#答疑篇：分布式技术是如何引爆人工智能的？" class="headerlink" title="答疑篇：分布式技术是如何引爆人工智能的？"></a>答疑篇：分布式技术是如何引爆人工智能的？</h2><h2 id="分布式体系结构之集中式结构：一人在上，万人在下"><a href="#分布式体系结构之集中式结构：一人在上，万人在下" class="headerlink" title="分布式体系结构之集中式结构：一人在上，万人在下"></a>分布式体系结构之集中式结构：一人在上，万人在下</h2><h2 id="分布式体系结构之非集中式结构：众生平等"><a href="#分布式体系结构之非集中式结构：众生平等" class="headerlink" title="分布式体系结构之非集中式结构：众生平等"></a>分布式体系结构之非集中式结构：众生平等</h2><h2 id="分布式调度架构之单体调度：物质文明、精神文明一手抓"><a href="#分布式调度架构之单体调度：物质文明、精神文明一手抓" class="headerlink" title="分布式调度架构之单体调度：物质文明、精神文明一手抓"></a>分布式调度架构之单体调度：物质文明、精神文明一手抓</h2><p>定义：单体调度是指，一个集群中只有一个节点运行调度进程，该节点对集群中的其他节点具有访问权限，可以搜集其他节点的资源信息、节点状态等进行统一管理，同时根据用户下发的任务对资源的需求，在调度器中进行任务与资源匹配，然后根据匹配结果将任务指派给其他节点。</p>
<p>架构：单体调度器也叫作集中式调度器，指的是使用中心化的方式去管理资源和调度任务。</p>
<p>特点：<strong>单体调度器拥有全局资源视图和全局任务，可以很容易地实现对任务的约束并实施全局性的调度策略</strong>。</p>
<p>单体调度代表：K8S、Borg 等。</p>
<h2 id="分布式调度架构之两层调度：物质文明、精神文明两手抓"><a href="#分布式调度架构之两层调度：物质文明、精神文明两手抓" class="headerlink" title="分布式调度架构之两层调度：物质文明、精神文明两手抓"></a>分布式调度架构之两层调度：物质文明、精神文明两手抓</h2><p>定义：在两层调度器中，资源的使用状态同时由中央调度器和第二层调度器管理，但中央调度器一般只负责宏观的、大规模的资源分配，业务压力比较小；第二层调度器负责任务与资源的匹配，因此第二层调度可以有多个，以支持不同的任务类型。</p>
<p>特点：解决了单体调度架构中，中央服务器的单点瓶颈问题；相较于单体调度而言，提升了调度效率；支持多种类型的任务。</p>
<p>两层调度代表：YARN、Mesos 等。</p>
<h2 id="分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓"><a href="#分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓" class="headerlink" title="分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓"></a>分布式调度架构之共享状态调度：物质文明、精神文明多手协商抓</h2><p>定义：共享状态调度架构沿袭了单体架构的模式，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度。</p>
<h2 id="分布式通信之远程调用：我是你的千里眼"><a href="#分布式通信之远程调用：我是你的千里眼" class="headerlink" title="分布式通信之远程调用：我是你的千里眼"></a>分布式通信之远程调用：我是你的千里眼</h2><p>本地过程调用（Local Procedure Call, LPC），是指运行在同一台机器上的进程之间的互相通信。</p>
<p>远程过程调用（Remote Procedure Call, RPC），是指不同机器中运行的进程之间的相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务一样，去调用远程机器上的服务。</p>
<h2 id="分布式通信之发布订阅：送货上门"><a href="#分布式通信之发布订阅：送货上门" class="headerlink" title="分布式通信之发布订阅：送货上门"></a>分布式通信之发布订阅：送货上门</h2><h2 id="分布式通信之消息队列：货物自取"><a href="#分布式通信之消息队列：货物自取" class="headerlink" title="分布式通信之消息队列：货物自取"></a>分布式通信之消息队列：货物自取</h2><h2 id="CAP-理论：这顶帽子我不想要"><a href="#CAP-理论：这顶帽子我不想要" class="headerlink" title="CAP 理论：这顶帽子我不想要"></a>CAP 理论：这顶帽子我不想要</h2><p>CAP 是指：在一个分布式系统中， 一致性、可用性和分区容错性，最多只能同时满足其中两项。</p>
<ul>
<li><strong>一致性（C：Consistency）</strong> - 多个数据副本是否能保持一致</li>
<li><strong>可用性（A：Availability）</strong>- 分布式系统在面对各种异常时可以提供正常服务的能力</li>
<li><strong>分区容错性（P：Partition Tolerance）</strong> - 分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障</li>
</ul>
<p>在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的；CAP 理论实际在是要在可用性和一致性之间做权衡。</p>
<ul>
<li>CP - 需要让所有节点下线成为不可用的状态，等待同步完成。</li>
<li>AP - 在同步过程中允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h2 id="分布式数据存储系统之三要素：顾客、导购与货架"><a href="#分布式数据存储系统之三要素：顾客、导购与货架" class="headerlink" title="分布式数据存储系统之三要素：顾客、导购与货架"></a>分布式数据存储系统之三要素：顾客、导购与货架</h2><p>数据的生产和消费</p>
<p>数据特征：结构化数据、半结构化数据、非结构化数据</p>
<p>分区和复制</p>
<h2 id="数据分布方式之哈希与一致性哈希：“掐指一算”与“掐指两算”的事"><a href="#数据分布方式之哈希与一致性哈希：“掐指一算”与“掐指两算”的事" class="headerlink" title="数据分布方式之哈希与一致性哈希：“掐指一算”与“掐指两算”的事"></a>数据分布方式之哈希与一致性哈希：“掐指一算”与“掐指两算”的事</h2><p>分布式数据存储选型的考量维度：</p>
<p>数据均匀：数据存储、访问尽量均衡</p>
<p>数据稳定：当数据存储集群扩容或缩容时，数据分布规则应尽量稳定，不要出现大范围的数据迁移。</p>
<p>节点异构性：应考虑集群中不同节点硬件配置的差异，将数据承载根据配置尽量均衡</p>
<h2 id="分布式数据复制技术：分身有术"><a href="#分布式数据复制技术：分身有术" class="headerlink" title="分布式数据复制技术：分身有术"></a>分布式数据复制技术：分身有术</h2><p>数据复制是指，如何让主备数据库保持数据一致的技术。</p>
<p>复制技术分类</p>
<ul>
<li>同步 - 注重一致性（CP 模型）。数据更新时，主节点必须要同步所有从节点，才提交更新。</li>
<li>异步 - 注重可用性（AP 模型）。数据更新时，主节点处理完后，直接提交更新；从节点异步进行数据的同步。</li>
<li>半同步 - 采用折中处理。数据更新时，主节点同步部分从节点（通常为一个节点或一半节点）成功后，才提交更新。</li>
</ul>
<p>很多分布式存储支持通过配置，切换复制策略，以满足不同场景的需要。</p>
<h2 id="分布式数据之缓存技术：“身手钥钱”随身带"><a href="#分布式数据之缓存技术：“身手钥钱”随身带" class="headerlink" title="分布式数据之缓存技术：“身手钥钱”随身带"></a>分布式数据之缓存技术：“身手钥钱”随身带</h2><h2 id="分布式高可靠之负载均衡：不患寡，而患不均"><a href="#分布式高可靠之负载均衡：不患寡，而患不均" class="headerlink" title="分布式高可靠之负载均衡：不患寡，而患不均"></a>分布式高可靠之负载均衡：不患寡，而患不均</h2><p>负载均衡（Load Balancing）是指将请求或流量均衡地分配到多个服务器或节点上，以实现资源的最优化利用和高效的响应速度。</p>
<p>负载均衡常见策略</p>
<ul>
<li>随机负载均衡<ul>
<li>策略 - 将请求随机分发到候选服务器</li>
<li>特点 - 调用量越大，负载越均衡</li>
<li>适合场景 - 适合服务器硬件相同的场景</li>
</ul>
</li>
<li>轮询负载均衡<ul>
<li>策略 - 将请求依次分发到候选服务器</li>
<li>特点 - 请求完全均匀分发</li>
<li>场景 - 适合服务器硬件相同的场景</li>
</ul>
</li>
<li>最小活跃数负载均衡<ul>
<li>策略 - 将请求分发到连接数&#x2F;请求数最少的候选服务器</li>
<li>特点 - 根据候选服务器当前的请求连接数，动态分配</li>
<li>适合场景 - 适用于对系统负载较为敏感或请求连接时长相差较大的场景</li>
</ul>
</li>
<li>哈希负载均衡<ul>
<li>策略 - 根据一个 key （可以是唯一 ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</li>
<li>特点 - 保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失</li>
<li>适合场景 - 可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</li>
</ul>
</li>
<li>一致性哈希负载均衡<ul>
<li>策略 - 相同的请求尽可能落到同一个服务器上。尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</li>
<li>优点 - 加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</li>
<li>缺点 - 加减节点会造成哈希环中部分数据无法命中。当使用少量节点时，节点变化将大范围影响哈希环中数据映射，不适合少量数据节点的分布式方案。普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li>
<li>适合场景 - 一致性哈希可以很好的解决稳定性问题，可以将所有的存储节点排列在首尾相接的 Hash 环上，每个 key 在计算 Hash 后会顺时针找到临接的存储节点存放。而当有节点加入或退出时，仅影响该节点在 Hash 环上顺时针相邻的后续节点。</li>
</ul>
</li>
</ul>
<h2 id="分布式高可靠之流量控制：大禹治水，在疏不在堵"><a href="#分布式高可靠之流量控制：大禹治水，在疏不在堵" class="headerlink" title="分布式高可靠之流量控制：大禹治水，在疏不在堵"></a>分布式高可靠之流量控制：大禹治水，在疏不在堵</h2><h2 id="分布式高可用之故障隔离：当断不断，反受其乱"><a href="#分布式高可用之故障隔离：当断不断，反受其乱" class="headerlink" title="分布式高可用之故障隔离：当断不断，反受其乱"></a>分布式高可用之故障隔离：当断不断，反受其乱</h2><h2 id="分布式高可用之故障恢复：知错能改，善莫大焉"><a href="#分布式高可用之故障恢复：知错能改，善莫大焉" class="headerlink" title="分布式高可用之故障恢复：知错能改，善莫大焉"></a>分布式高可用之故障恢复：知错能改，善莫大焉</h2><h2 id="答疑篇：如何判断并解决网络分区问题？"><a href="#答疑篇：如何判断并解决网络分区问题？" class="headerlink" title="答疑篇：如何判断并解决网络分区问题？"></a>答疑篇：如何判断并解决网络分区问题？</h2><h2 id="知识串联：以购买火车票的流程串联分布式核心技术"><a href="#知识串联：以购买火车票的流程串联分布式核心技术" class="headerlink" title="知识串联：以购买火车票的流程串联分布式核心技术"></a>知识串联：以购买火车票的流程串联分布式核心技术</h2><h2 id="搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行"><a href="#搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行" class="headerlink" title="搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行"></a>搭建一个分布式实验环境：纸上得来终觉浅，绝知此事要躬行</h2><h2 id="特别放送丨那些你不能错过的分布式系统论文"><a href="#特别放送丨那些你不能错过的分布式系统论文" class="headerlink" title="特别放送丨那些你不能错过的分布式系统论文"></a>特别放送丨那些你不能错过的分布式系统论文</h2><h3 id="分布式理论基础"><a href="#分布式理论基础" class="headerlink" title="分布式理论基础"></a>分布式理论基础</h3><p><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a></p>
<p><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a></p>
<p><a target="_blank" rel="noopener" href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a></p>
<p>CAP Twelve Years Later: How the “Rules” Have Changed</p>
<p>BASE: An Acid Alternative</p>
<p>A Simple Totally Ordered Broadcast Protocol</p>
<p>Virtual Time and Global States of Distributed Systems</p>
<h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><p>Paxos Made Simple</p>
<p>Paxos Made Practical</p>
<p>Paxos Made Live: An Engineering Perspective</p>
<p>Raft: In Search of an Understandable Consensus Algorithm</p>
<p>ZooKeeper: Wait-Free Coordination for Internet-Scale Systems</p>
<p>Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore<br>Impossibility of Distributed Consensus With One Faulty Process</p>
<p>A Brief History of Consensus, 2PC and Transaction Commit</p>
<p>Consensus in the Presence of Partial Synchrony</p>
<h3 id="分布式数据结构"><a href="#分布式数据结构" class="headerlink" title="分布式数据结构"></a>分布式数据结构</h3><p>Chord: A Scalable Peer-to-Peer Lookup Service for Internet Applications</p>
<p>Pastry: Scalable, Distributed Object Location, and Routing for Large-Scale Peerto-Peer Systems</p>
<p>Kademlia: A Peer-to-Peer Information System Based on the XOR Metric</p>
<p>A Scalable Content-Addressable Network</p>
<p>Ceph: A Scalable, High-Performance Distributed File System</p>
<p>The Log-Structured-Merge-Tree</p>
<p>HBase: A NoSQL Database</p>
<p>Tango: Distributed Data Structure over a Shared Log</p>
<h3 id="分布式系统实战"><a href="#分布式系统实战" class="headerlink" title="分布式系统实战"></a>分布式系统实战</h3><p>The Google File System</p>
<p>BigTable: A Distributed Storage System for Structured Data</p>
<p>The Chubby Lock Service for Loosely-Coupled Distributed Systems</p>
<p>Finding a Needle in Haystack: Facebook’s Photo Storage</p>
<p>Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency</p>
<p>Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</p>
<p>Scaling Distributed Machine Learning with the Parameter Server</p>
<p>Dremel: Interactive Analysis of Web-Scale Datasets</p>
<p>Pregel: A System for Large-Scale Graph Processing</p>
<p>Spanner: Google’s Globally-Distributed Database</p>
<p>Dynamo: Amazon’s Highly Available Key-value Store</p>
<p>S4: Distributed Stream Computing Platform</p>
<p>Storm @Twitter</p>
<p>Large-scale Cluster Management at Google with Borg</p>
<p>F1 - The Fault-Tolerant Distributed RDBMS Supporting Google’s Ad Business</p>
<p>Cassandra: A Decentralized Structured Storage System</p>
<p>MegaStore: Providing Scalable, Highly Available Storage for Interactive Services</p>
<p>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</p>
<p>Kafka: A distributed Messaging System for Log Processing</p>
<p>Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046101">分布式协议与算法实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1233ca70/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1233ca70/" class="post-title-link" itemprop="url">微服务之注册和发现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 19:08:50" itemprop="dateCreated datePublished" datetime="2023-05-15T19:08:50+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微服务之注册和发现"><a href="#微服务之注册和发现" class="headerlink" title="微服务之注册和发现"></a>微服务之注册和发现</h1><h2 id="服务注册和发现的基本原理"><a href="#服务注册和发现的基本原理" class="headerlink" title="服务注册和发现的基本原理"></a>服务注册和发现的基本原理</h2><p>服务定义是服务提供者和服务消费者之间的约定，但是在微服务架构中，如何达成这个约定呢？这就依赖于服务注册和发现机制。</p>
<h3 id="注册和发现的角色"><a href="#注册和发现的角色" class="headerlink" title="注册和发现的角色"></a>注册和发现的角色</h3><p>在微服务架构下，服务注册和发现机制中主要有三种角色：</p>
<ul>
<li><strong>服务提供者</strong>（RPC Server &#x2F; Provider）</li>
<li><strong>服务消费者</strong>（RPC Client &#x2F; Consumer）</li>
<li><strong>服务注册中心</strong>（Registry）</li>
</ul>
<p>服务发现通常依赖于<strong>注册中心</strong>来协调服务发现的过程，其步骤如下：</p>
<ol>
<li>服务提供者将接口信息以注册到注册中心。</li>
<li>服务消费者从注册中心读取和订阅服务提供者的地址信息。</li>
<li>如果有可用的服务，注册中心会主动通知服务消费者。</li>
<li>服务消费者根据可用服务的地址列表，调用服务提供者的接口。</li>
</ol>
<p>这个过程很像是生活中的房屋租赁，房东将租房信息挂到中介公司，房客从中介公司查找租房信息。房客如果想要租房东的房子，通过中介公司牵线搭桥，联系上房东，双方谈妥签订协议，就可以正式建立起租赁关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220415171843.png"></p>
<p>主流的服务注册与发现的解决方案，主要有两种：</p>
<ul>
<li><strong>应用内注册与发现</strong>：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。</li>
<li><strong>应用外注册与发现</strong>：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。</li>
</ul>
<h3 id="应用内注册与发现"><a href="#应用内注册与发现" class="headerlink" title="应用内注册与发现"></a>应用内注册与发现</h3><p><strong>应用内注册与发现</strong>方案是：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。最典型的案例要属 Netflix 开源的 Eureka，官方架构图如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220418204148.jfif"></p>
<p>Eureka 的架构主要由三个重要的组件组成：</p>
<ul>
<li><strong>Eureka Server</strong>：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。</li>
<li><strong>服务端的 Eureka Client</strong>：集成在服务端的注册中心 SDK，服务提供者通过调用 SDK，实现服务注册、反注册等功能。</li>
<li><strong>客户端的 Eureka Client</strong>：集成在客户端的注册中心 SDK，服务消费者通过调用 SDK，实现服务订阅、服务更新等功能。</li>
</ul>
<h3 id="应用外注册与发现"><a href="#应用外注册与发现" class="headerlink" title="应用外注册与发现"></a>应用外注册与发现</h3><p><strong>应用外注册与发现</strong>方案是：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。最典型的案例是开源注册中心 Consul。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220418204352.png"></p>
<p>Consul 实现应用外服务注册和发现主要依靠三个重要的组件：</p>
<ul>
<li>Consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/gliderlabs/registrator">Registrator</a>：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/hashicorp/consul-template">Consul Template</a>：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息。</li>
</ul>
<h2 id="注册中心的基本功能"><a href="#注册中心的基本功能" class="headerlink" title="注册中心的基本功能"></a>注册中心的基本功能</h2><p>从服务注册和发现的流程，可以看出，<strong>注册中心是服务发现的核心组件</strong>。常见的注册中心组件有：Nacos、Consul、Zookeeper 等。</p>
<p>注册中心的实现主要涉及几个问题：注册中心需要提供哪些接口，该如何部署；如何存储服务信息；如何监控服务提供者节点的存活；如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。</p>
<h3 id="元数据定义"><a href="#元数据定义" class="headerlink" title="元数据定义"></a>元数据定义</h3><p>构建微服务的首要问题是：服务提供者和服务消费者通信时，如何达成共识。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。</p>
<p>常见的定义服务元数据的方式有：</p>
<ul>
<li><strong>XML 文件</strong> - 如果只是企业内部之间的服务调用，并且都是 Java 语言的话，选择 XML 配置方式是最简单的。</li>
<li><strong>IDL 文件</strong> - 如果企业内部存在多个跨语言服务，建议使用 IDL 文件方式进行描述服务。</li>
<li><strong>REST API</strong> - 如果存在对外开放服务调用的情形的话，使用 REST API 方式则更加通用。</li>
</ul>
<h4 id="XML-文件"><a href="#XML-文件" class="headerlink" title="XML 文件"></a>XML 文件</h4><p><strong>XML 配置方式通过在服务提供者和服务消费者之间维持一份对等的 XML 配置文件，来保证服务消费者按照服务提供者的约定来进行服务调用</strong>。在这种方式下，如果服务提供者变更了接口定义，不仅需要更新服务提供者加载的接口描述文件 server.xml，还需要同时更新服务消费者加载的接口描述文件 client.xml。但这种方式对业务代码侵入性比较高，XML 配置有变更的时候，服务消费者和服务提供者都要更新，所以适合公司内部联系比较紧密的业务之间采用。支持 XML 文件的主流 RPC 有：阿里的 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo</a>（XML 配置示例：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-xml/">基于 Spring XML 开发微服务应用</a>）、微博的 Motan。</p>
<p>XML 文件这种方式的服务发布和引用主要分三个步骤：</p>
<p>（1）服务提供者定义接口，并实现接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The demo service definition.</span></span><br><span class="line">service DemoService &#123;</span><br><span class="line">  rpc <span class="title function_">sayHello</span> <span class="params">(HelloRequest)</span> returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  <span class="type">string</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  <span class="type">string</span> <span class="variable">message</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）服务提供者进程启动时，通过加载 xml 配置文件将接口暴露出去。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20890&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）服务消费者进程启动时，通过加载 xml 配置文件来引入要调用的接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-consumer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">group</span>=<span class="string">&quot;aaa&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.samples.basic.api.DemoService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="IDL-文件"><a href="#IDL-文件" class="headerlink" title="IDL 文件"></a>IDL 文件</h4><p>IDL 就是接口描述语言（interface description language）的缩写，通过一种中立、通用的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。也就是说，<strong>IDL 主要用于跨语言的服务之间的调用</strong>。支持 IDL 文件的主流 RPC 有：阿里的 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo</a>（XML 配置示例：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/idl/">IDL 定义跨语言服务</a>），Facebook 的 <a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a>，Google 的 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc">gRPC</a> 。</p>
<p>以 gRPC 协议为例，gRPC 协议使用 Protobuf 简称 proto 文件来定义接口名、调用参数以及返回值类型。比如文件 helloword.proto 定义了一个接口 SayHello 方法，它的请求参数是 HelloRequest，它的返回值是 HelloReply。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The greeter service definition.</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  rpc <span class="title function_">SayHello</span> <span class="params">(HelloRequest)</span> returns (HelloReply) &#123;&#125;</span><br><span class="line">  rpc <span class="title function_">SayHelloAgain</span> <span class="params">(HelloRequest)</span> returns (HelloReply) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  <span class="type">string</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  <span class="type">string</span> <span class="variable">message</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如服务提供者使用的是 Java 语言，那么利用 protoc 插件即可自动生成 Server 端的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">GreeterImpl</span> <span class="keyword">extends</span> <span class="title class_">GreeterGrpc</span>.GreeterImplBase &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder().setMessage(<span class="string">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class="line">    responseObserver.onNext(reply);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHelloAgain</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">    <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder().setMessage(<span class="string">&quot;Hello again &quot;</span> + req.getName()).build();</span><br><span class="line">    responseObserver.onNext(reply);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如服务消费者使用的也是 Java 语言，那么利用 protoc 插件即可自动生成 Client 端的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;Will try to greet &quot;</span> + name + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">  <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">  HelloReply response;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = blockingStub.sayHello(request);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">    logger.log(Level.WARNING, <span class="string">&quot;RPC failed: &#123;0&#125;&quot;</span>, e.getStatus());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  logger.info(<span class="string">&quot;Greeting: &quot;</span> + response.getMessage());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = blockingStub.sayHelloAgain(request);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">    logger.log(Level.WARNING, <span class="string">&quot;RPC failed: &#123;0&#125;&quot;</span>, e.getStatus());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  logger.info(<span class="string">&quot;Greeting: &quot;</span> + response.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如服务消费者使用的是其他语言，也可以利用相应的插件生成代码。</p>
<p>由此可见，gRPC 协议的服务描述是通过 proto 文件来定义接口的，然后再使用 protoc 来生成不同语言平台的客户端和服务端代码，从而具备跨语言服务调用能力。</p>
<p>有一点特别需要注意的是，在描述接口定义时，IDL 文件需要对接口返回值进行详细定义。如果接口返回值的字段比较多，并且经常变化时，采用 IDL 文件方式的接口定义就不太合适了。一方面可能会造成 IDL 文件过大难以维护，另一方面只要 IDL 文件中定义的接口返回值有变更，都需要同步所有的服务消费者都更新，管理成本就太高了。</p>
<h4 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h4><p>REST API 方式主要被用作 HTTP 或者 HTTPS 协议的接口定义，即使在非微服务架构体系下，也被广泛采用。由于 HTTP 本身就是公开标准网络协议，所以几乎没有什么额外学习成本。支持 REST API 的主流 RPC 有：Eureka，下面以 Eureka 为例。</p>
<p>服务提供者定义接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProviderController</span><span class="params">(DiscoveryClient discoveryClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">services</span> <span class="operator">=</span> <span class="string">&quot;Services: &quot;</span> + discoveryClient.getServices();</span><br><span class="line">        System.out.println(services);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务消费者消费接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsumerController</span><span class="params">(LoadBalancerClient loadBalancerClient,</span></span><br><span class="line"><span class="params">        RestTemplate restTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">        <span class="built_in">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/recv&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">recv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;eureka-provider&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class="string">&quot;:&quot;</span> + serviceInstance.getPort() + <span class="string">&quot;/send&quot;</span>;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h3><p>注册中心本质上是一个用于保存元数据的分布式存储。你如果明白了这一点，就会了解实现一个注册中心的所有要点都是围绕这个目标去构建的。</p>
<p>想要构建微服务，首先要解决的问题是，服务提供者如何发布一个服务，服务消费者如何引用这个服务。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。</p>
<p>服务的<strong>元数据信息</strong>通常有以下信息：</p>
<ul>
<li>服务节点信息，如 IP、端口等。</li>
<li>接口定义，如接口名、请求参数、响应参数等。</li>
<li>请求失败的重试次数</li>
<li>序列化方式</li>
<li>压缩方式</li>
<li>通信协议</li>
<li>等等</li>
</ul>
<p>在具体存储时，注册中心一般会按照“服务 - 分组 - 节点信息”的<strong>层次化的结构</strong>来存储。以 ZooKeeper 为例：</p>
<ul>
<li>在 ZooKeeper 中，数据按目录层级存储，每个目录叫作 znode，并且其有一个唯一的路径标识。</li>
<li>znode 可以包含数据和子 znode。</li>
<li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper_1.png" alt="img"></p>
<h3 id="注册中心-API"><a href="#注册中心-API" class="headerlink" title="注册中心 API"></a>注册中心 API</h3><p>既然是分布式存储，势必要提供支持读写数据的接口，也就是 API，一般来说，需要支持以下功能：</p>
<ul>
<li><strong>服务注册接口</strong>：服务提供者通过调用服务注册接口来完成服务注册。</li>
<li><strong>服务反注册接口</strong>：服务提供者通过调用服务反注册接口来完成服务注销。</li>
<li><strong>心跳汇报接口</strong>：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</li>
<li><strong>服务订阅接口</strong>：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</li>
<li><strong>服务变更查询接口</strong>：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</li>
</ul>
<p>除此之外，为了便于管理，注册中心还必须提供一些后台管理的 API，例如：</p>
<ul>
<li><strong>服务查询接口</strong>：查询注册中心当前注册了哪些服务信息。</li>
<li><strong>服务修改接口</strong>：修改注册中心中某一服务的信息。</li>
</ul>
<h3 id="服务健康检测"><a href="#服务健康检测" class="headerlink" title="服务健康检测"></a>服务健康检测</h3><p>注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。<strong>注册中心通常使用长连接或心跳探测方式检查服务健康状态</strong>。</p>
<p>还是以 ZooKeeper 为例，它是基于 ZooKeeper 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。在 ZooKeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 Session ID。服务端和客户端维持的是一个长连接，在 SESSION_TIMEOUT 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 SESSION_TIMEOUT 时间。如果超过 SESSION_TIMEOUT 后服务端都没有收到客户端的心跳消息，则服务端认为这个 Session 就已经结束了，ZooKeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。</p>
<h3 id="服务状态变更通知"><a href="#服务状态变更通知" class="headerlink" title="服务状态变更通知"></a>服务状态变更通知</h3><p>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。注册中心通常基于服务状态订阅来实现服务状态变更通知。</p>
<p>继续以 ZooKeeper 为例，基于 ZooKeeper 的 Watcher 机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用 ZooKeeper 的 getData 方法订阅服务时，还可以通过监听器 Watcher 的 process 方法获取服务的变更，然后调用 getData 方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p>
<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 理论</a>，三种特性无法同时达成，必须在可用性和一致性之间做取舍。于是，根据不同侧重点，注册中心可以分为 CP 和 AP 两个阵营：</p>
<ul>
<li><strong>CP 型注册中心</strong> - <strong>牺牲可用性来换取数据强一致性</strong>，最典型的例子就是 ZooKeeper，etcd，Consul 了。ZooKeeper 集群内只有一个 Leader，而且在 Leader 无法使用的时候通过 Paxos 算法选举出一个新的 Leader。这个 Leader 的目的就是保证写信息的时候只向这个 Leader 写入，Leader 会同步信息到 Followers，这个过程就可以保证数据的强一致性。但如果多个 ZooKeeper 之间网络出现问题，造成出现多个 Leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 Consul 集群内都是通过 Raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。</li>
<li><strong>AP 型注册中心</strong> - <strong>牺牲一致性（只保证最终一致性）来换取可用性</strong>，最典型的例子就是 Eureka 了。对比下 Zookeeper，Eureka 不用选举一个 Leader，每个 Eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。</li>
</ul>
<p>以开源注册中心 ZooKeeper 为例，ZooKeeper 集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的，这是为什么呢？这就要从 ZooKeeper 的工作原理说起：</p>
<ul>
<li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li>
<li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li>
<li>Leader 负责处理数据更新等操作（ZAB 协议）。</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li>
</ul>
<p>通过上面这种方式，ZooKeeper 保证了高可用性以及数据一致性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper_3.png" alt="img"></p>
<h2 id="注册中心的扩展功能"><a href="#注册中心的扩展功能" class="headerlink" title="注册中心的扩展功能"></a>注册中心的扩展功能</h2><h3 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h3><p>对于服务消费者来说，要能够同时从多个注册中心订阅服务；</p>
<p>对于服务提供者来说，要能够同时向多个注册中心注册服务。</p>
<h3 id="并行订阅服务"><a href="#并行订阅服务" class="headerlink" title="并行订阅服务"></a>并行订阅服务</h3><p>如果只支持串行订阅，如果服务消费者订阅的服务较多，并且某些服务节点的初始化连接过程中出现连接超时的情况，则后续所有的服务节点的初始化连接都需要等待它完成，这就会导致消费者启动非常慢。</p>
<p>可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。</p>
<h3 id="批量注销服务"><a href="#批量注销服务" class="headerlink" title="批量注销服务"></a>批量注销服务</h3><p>在与注册中心的多次交互中，可能由于网络抖动、注册中心集群异常等原因，导致个别调用失败。对于注册中心来说，偶发的注册调用失败对服务调用基本没有影响，其结果顶多就是某一个服务少了一个可用的节点。但偶发的反注册调用失败会导致不可用的节点残留在注册中心中，变成“僵尸节点”。</p>
<p>需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。</p>
<h3 id="服务变更信息增量更新"><a href="#服务变更信息增量更新" class="headerlink" title="服务变更信息增量更新"></a>服务变更信息增量更新</h3><p>为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息。尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。</p>
<h3 id="心跳开关保护机制"><a href="#心跳开关保护机制" class="headerlink" title="心跳开关保护机制"></a>心跳开关保护机制</h3><p>在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。</p>
<p>所以针对这种情况，<strong>需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息</strong>。</p>
<p>我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1&#x2F;10。</p>
<p>当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。</p>
<h3 id="服务节点摘除保护机制"><a href="#服务节点摘除保护机制" class="headerlink" title="服务节点摘除保护机制"></a>服务节点摘除保护机制</h3><p>服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。</p>
<p>如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。</p>
<p><strong>这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点</strong>。</p>
<p>这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。</p>
<h3 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h3><p>在实际的微服务测试和部署时，通常包含多套环境，比如生产环境一套、测试环境一套。开发在进行业务自测、测试在进行回归测试时，一般都是用测试环境，部署的 RPC Server 节点注册到测试的注册中心集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中心集群，这样的话线上流量就会调用到测试环境下的 RPC Server 节点，可能会造成意想不到的后果。</p>
<p>为了防止这种情况发生，注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的 RPC Server 才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h3 id="静态注册中心"><a href="#静态注册中心" class="headerlink" title="静态注册中心"></a>静态注册中心</h3><p>因为服务提供者是向服务消费者提供服务的，服务是否可用，服务消费者应该比注册中心更清楚。因此，可以直接在服务消费者端，根据调用服务提供者是否成功来判定服务提供者是否可用。如果服务消费者调用某一个服务提供者节点连续失败超过一定次数，可以在本地内存中将这个节点标记为不可用。并且每隔一段固定时间，服务消费者都要向标记为不可用的节点发起保活探测，如果探测成功了，就将标记为不可用的节点再恢复为可用状态，重新发起调用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100014401">从 0 开始学微服务</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046201">RPC 实战与核心原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c89c8052/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c89c8052/" class="post-title-link" itemprop="url">微服务之服务调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 19:08:50" itemprop="dateCreated datePublished" datetime="2023-05-15T19:08:50+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微服务之服务调用"><a href="#微服务之服务调用" class="headerlink" title="微服务之服务调用"></a>微服务之服务调用</h1><h2 id="RPC-简介"><a href="#RPC-简介" class="headerlink" title="RPC 简介"></a>RPC 简介</h2><p>通过注册中心，服务消费者和服务提供者就可以感知彼此。但是，要实现交互还必须解决通信问题。</p>
<p>在单体应用中，一次服务调用发生在同一台机器上的同一个进程内部，因此也被称为本地方法调用。在微服务应用中，由于服务提供者和服务消费者运行在不同物理机器上的不同进程内，因此也被称为<strong>远程方法调用</strong>，简称 <strong>RPC（Remote Procedure Call）</strong>。</p>
<p>RPC 是微服务架构的基石，它提供了一种应用间通信的方式。RPC 的主要作用是：</p>
<ul>
<li><strong>屏蔽远程调用跟本地调用的差异</strong>，让用户像调用本地一样去调用远程方法。</li>
<li><strong>隐藏底层网络通信的复杂性</strong>，让用户更聚焦于业务逻辑。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619101023.png"></p>
<h2 id="RPC-核心原理"><a href="#RPC-核心原理" class="headerlink" title="RPC 核心原理"></a>RPC 核心原理</h2><p>RPC 是如何像本地方法调用一样，完成一次请求处理的呢？我们不妨推导一二。首先，服务消费者和服务提供者通常位于网络上两个不同地址，要想交换信息，必须先建立网络连接；建立网络连接后，如果要想识别彼此的信息，必须遵循相同的通信协议；服务提供者和服务消费者，需要采用某种方式数据传输；为了减少传输数据量，还要对数据进行压缩，即序列化。</p>
<p>它的通信流程中需要注意以下环节：</p>
<ul>
<li><strong>传输方式</strong>：RPC 是一个远程调用，因此必然需要通过网络传输数据，且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。</li>
<li><strong>序列化</strong>：在网络中传输的数据只能是二进制数据，而 RPC 请求时，发送的都是对象。因此，请求方需要将请求参数转为二进制数据，即<strong>序列化</strong>。RPC 响应方接受到请求，要将二进制数据转换为请求参数，需要<strong>反序列化</strong>。</li>
<li><strong>通信协议</strong>：请求方和响应方要互相识别彼此的信息，需要约定好彼此数据的格式，即协议。大多数的协议至少分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。</li>
<li><strong>动态代理</strong>：为了屏蔽底层通信细节，使用户聚焦自身业务，因此 RPC 框架一般引入了动态代理，通过依赖注入等技术，拦截方法调用，完成远程调用的通信逻辑。</li>
</ul>
<p>下图诠释了以上环节是如何串联起来的：</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220625094814.png" style="zoom:67%;" />

<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="通信协议的作用"><a href="#通信协议的作用" class="headerlink" title="通信协议的作用"></a>通信协议的作用</h3><p>只有二进制才能在网络中传输，所以 RPC 请求在发送到网络中之前，需要把方法调用的请求参数转成二进制；转成二进制后，写入本地 Socket 中，然后被网卡发送到网络设备中。</p>
<p>在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包（合并的前提是同一个 TCP 连接上的数据），至于怎么拆分合并，这其中的细节会涉及到系统参数配置和 TCP 窗口大小。对于服务提供方应用来说，他会从 TCP 通道里面收到很多的二进制数据，那这时候怎么识别出哪些二进制是第一个请求的呢？</p>
<p>这就好比让你读一篇没有标点符号的文章，你要怎么识别出每一句话到哪里结束呢？很简单啊，我们加上标点，完成断句就好了。为了避免语义不一致的事情发生，我们就需要在发送请求的时候设定一个边界，然后在收到请求的时候按照这个设定的边界进行数据分割。这个边界语义的表达，就是我们所说的协议。</p>
<p><strong>通信协议</strong>要解决的是：客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。</p>
<h3 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h3><p>HTTP 通信是基于应用层 HTTP 协议的，而 HTTP 协议又是基于传输层 TCP 协议的。一次 HTTP 通信过程就是发起一次 HTTP 调用，而一次 HTTP 调用就会建立一个 TCP 连接，经历<strong>三次握手</strong>的过程来建立连接。完成请求后，再经历一次<strong>四次挥手</strong>的过程来断开连接。</p>
<p>TCP 通信的过程分为四个步骤：<strong>服务器监听</strong>、<strong>客户端请求</strong>、<strong>连接确认</strong>、<strong>数据传输</strong>。当客户端和服务端建立网络连接后，就可以发起请求了。但网络不一定总是可靠的，经常会遇到网络闪断、连接超时、服务端宕机等各种异常，通常的处理手段有两种：<strong>链路存活检测</strong>和<strong>断连重试</strong>。</p>
<p>通过两种通信方式的对比，不难看出：HTTP 通信由于每次都要建立 TCP 连接，而建立连接又较为耗时，所以 <strong>HTTP 通信性能是不如 TCP 通信的</strong>。</p>
<h3 id="为何需要设计-RPC-协议"><a href="#为何需要设计-RPC-协议" class="headerlink" title="为何需要设计 RPC 协议"></a>为何需要设计 RPC 协议</h3><p>既然有了现成的 HTTP 协议，还有必要设计 RPC 协议吗？</p>
<p>有必要。因为 HTTP 这些通信标准协议，数据包中的实际请求数据相对于数据包本身要小很多，有很多无用的内容；并且 HTTP 属于无状态协议，无法将请求和响应关联，每次请求要重新建立连接。这对于高性能的 RPC 来说，HTTP 协议难以满足需求，所以有必要设计一个<strong>紧凑的私有协议</strong>。</p>
<h3 id="如何设计-RPC-协议"><a href="#如何设计-RPC-协议" class="headerlink" title="如何设计 RPC 协议"></a>如何设计 RPC 协议</h3><p>首先，必须先明确消息的边界，即确定消息的长度。因此，至少要分为：消息长度+消息内容两部分。</p>
<p>接下来，我们会发现，在使用过程中，仅消息长度，不足以明确通信中的很多细节：如序列化方式是怎样的？是否消息压缩？压缩格式是怎样的？如果协议发生变化，需要明确协议版本等等。</p>
<p>综上，一个 RPC 协议大概会由下图中的这些参数组成：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619102052.png"></p>
<h3 id="可扩展的协议"><a href="#可扩展的协议" class="headerlink" title="可扩展的协议"></a>可扩展的协议</h3><p>前面所述的协议属于定长协议头，那也就是说往后就不能再往协议头里加新参数了，如果加参<br>数就会导致线上兼容问题。</p>
<p>为了保证能平滑地升级改造前后的协议，我们有必要设计一种支持可扩展的协议。其关键在于让协议头支持可扩展，扩展后协议头的长度就不能定长了。那要实现读取不定长的协议头里面的内容，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个固定的写入协议头的长度。整体协议就变成了三部分内容：固定部分、协议头内容、协议体内容。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619102833.png"></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote>
<p>有兴趣深入了解 JDK 序列化方式，可以参考：<a href="https://dunwu.github.io/waterdrop/pages/737e5233/">Java 序列化</a></p>
</blockquote>
<p>由于，网络传输的数据必须是二进制数据，而调用方请求的出参、入参都是对象。因此，必须将对象转换可传输的二进制，并且要求转换算法是可逆的。</p>
<ul>
<li><strong>序列化（serialize）</strong>：序列化是将对象转换为二进制数据。</li>
<li><strong>反序列化（deserialize）</strong>：反序列化是将二进制数据转换为对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619110947.png"></p>
<p>序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。</p>
<h3 id="序列化技术"><a href="#序列化技术" class="headerlink" title="序列化技术"></a>序列化技术</h3><p>Java 领域，常见的序列化技术如下</p>
<ul>
<li>JDK 序列化：JDK 内置的二进制序列化方式</li>
<li>其他二进制序列化<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">Protobuf</a></li>
<li><a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">Hessian</a></li>
</ul>
</li>
<li>JSON 序列化<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">Fastjson</a></li>
</ul>
</li>
</ul>
<h3 id="序列化技术选型"><a href="#序列化技术选型" class="headerlink" title="序列化技术选型"></a>序列化技术选型</h3><p>市面上有如此多的序列化技术，那么我们在应用时如何选择呢?</p>
<p>序列化技术选型，需要考量的维度，根据重要性从高到低，依次有：</p>
<ul>
<li><strong>安全性</strong>：是否存在漏洞。如果存在漏洞，就有被攻击的可能性。</li>
<li><strong>兼容性</strong>：版本升级后的兼容性是否很好，是否支持更多的对象类型，是否是跨平台、跨语言的。服务调用的稳定性与可靠性，要比服务的性能更加重要。</li>
<li><strong>性能</strong><ul>
<li><strong>时间开销</strong>：序列化、反序列化的耗时性能自然越小越好。</li>
<li><strong>空间开销</strong>：序列化后的数据越小越好，这样网络传输效率就高。</li>
</ul>
</li>
<li><strong>易用性</strong>：类库是否轻量化，API 是否简单易懂。</li>
</ul>
<p>鉴于以上的考量，序列化技术的选型建议如下：</p>
<ul>
<li>JDK 序列化：性能较差，且有很多使用限制，不建议使用。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a>、<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">Protobuf</a>：适用于<strong>对性能敏感，对开发体验要求不高</strong>。</li>
<li><a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">Hessian</a>：适用于<strong>对开发体验敏感，性能有要求</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a>、<a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">Fastjson</a>：适用于对序列化后的数据要求有<strong>良好的可读性</strong>（转为 json 、xml 形式）。</li>
</ul>
<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><p>由于 RPC 每次通信，都要经过序列化、反序列化的过程，所以序列化方式，会直接影响 RPC 通信的性能。除了选择合适的序列化技术，如何合理使用序列化也非常重要。</p>
<p>RPC 序列化常见的使用不当的情况如下：</p>
<ul>
<li><p><strong>对象过于复杂、庞大</strong> - 对象过于复杂、庞大，会降低序列化、反序列化的效率，并增加传输开销，从而导致响应时延增大。</p>
<ul>
<li>过于复杂：存在多层的嵌套，比如 A 对象关联 B 对象，B 对象又聚合 C 对象，C 对象又关联聚合很多其他对象</li>
<li>过于庞大：比如一个大 List 或者大 Map</li>
</ul>
</li>
<li><p><strong>对象有复杂的继承关系</strong> - 对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。大多数序列化框架在进行序列化时，如果发现类有继承关系，会不停地寻找父类，遍历属性。</p>
</li>
<li><p><strong>使用序列化框架不支持的类作为入参类</strong> - 比如 Hessian 框架，他天然是不支持 LinkHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。</p>
</li>
</ul>
<h3 id="序列化要点"><a href="#序列化要点" class="headerlink" title="序列化要点"></a>序列化要点</h3><p>前面已经列举了常见的序列化问题，既然明确了问题，就要针对性预防。RPC 序列化时要注意以下几点：</p>
<ol>
<li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；</li>
<li>入参对象与返回值对象体积不要太大，更不要传太大的集合；</li>
<li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；</li>
<li>对象不要有复杂的继承关系，最好不要有父子类的情况。</li>
</ol>
<h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p>一次 RPC 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。可见，通信时 RPC 实现的核心。</p>
<p>常见的网络 IO 模型有：同步阻塞（BIO）、同步非阻塞（NIO）、异步非阻塞（AIO）。</p>
<h3 id="同步阻塞方式（BIO）"><a href="#同步阻塞方式（BIO）" class="headerlink" title="同步阻塞方式（BIO）"></a>同步阻塞方式（BIO）</h3><p>同步阻塞方式的工作流程大致为：客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大的线程数瓶颈，新来的请求就没法处理了。</p>
<p>BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630212345.png" alt="img"></p>
<h3 id="同步非阻塞方式-NIO"><a href="#同步非阻塞方式-NIO" class="headerlink" title="同步非阻塞方式 (NIO)"></a>同步非阻塞方式 (NIO)</h3><p><strong>同步非阻塞方式 (NIO)</strong> 的工作流程大致为：客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I&#x2F;O 多路复用技术进行处理。就是把多个 I&#x2F;O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。</p>
<h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><p>IO 多路复用（Reactor 模式）在高并发场景下使用最为广泛，很多知名软件都应用了这一技术，如：Netty、Redis、Nginx 等。什么是 IO 多路复用？字面上的理解，多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。IO 多路复用分为 select，poll 和 epoll。</p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717154300" alt="img"></p>
<p>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。</p>
<p>应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样很浪费 CPU 和性能。</p>
<p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717154716.jfif" alt="img"></p>
<p>Netty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。</p>
<p>Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。</p>
<p>Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socketd 的读写<br>操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。</p>
<p>Netty 还提供 FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法实现了零拷<br>贝，这与 Linux 中的 sendfile 方式在原理上也是一样的。</p>
<h4 id="NIO-vs-BIO"><a href="#NIO-vs-BIO" class="headerlink" title="NIO vs BIO"></a>NIO vs BIO</h4><p>NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。</p>
<p>BIO 与 NIO 最重要的区别是数据打包和传输的方式：<strong>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据</strong>。</p>
<ul>
<li><strong>面向流的 BIO 一次处理一个字节数据</strong>：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</li>
<li><strong>面向块的 NIO 一次处理一个数据块</strong>，按块处理数据比按流处理数据要快得多。但是面向块的 NIO 缺少一些面向流的 BIO 所具有的优雅性和简单性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630212248.png" alt="img"></p>
<h3 id="异步非阻塞方式-AIO"><a href="#异步非阻塞方式-AIO" class="headerlink" title="异步非阻塞方式 (AIO)"></a>异步非阻塞方式 (AIO)</h3><p><strong>异步非阻塞方式 (AIO)</strong> 的大致工作流程为：客户端只需要发起一个 I&#x2F;O 操作然后立即返回，等 I&#x2F;O 操作真正完成以后，客户端会得到 I&#x2F;O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I&#x2F;O 读写操作，因为真正的 I&#x2F;O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。</p>
<p>AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I&#x2F;O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100014401">从 0 开始学微服务</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046201">RPC 实战与核心原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9ad65ff2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9ad65ff2/" class="post-title-link" itemprop="url">HBase Java API 管理功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-13 16:36:48" itemprop="dateCreated datePublished" datetime="2023-04-13T16:36:48+08:00">2023-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-Java-API-管理功能"><a href="#HBase-Java-API-管理功能" class="headerlink" title="HBase Java API 管理功能"></a>HBase Java API 管理功能</h1><h2 id="初始化-Admin-实例"><a href="#初始化-Admin-实例" class="headerlink" title="初始化 Admin 实例"></a>初始化 Admin 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br></pre></td></tr></table></figure>

<h2 id="管理命名空间"><a href="#管理命名空间" class="headerlink" title="管理命名空间"></a>管理命名空间</h2><h3 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TableName[] tableNames = admin.listTableNamesByNamespace(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (TableName tableName : tableNames) &#123;</span><br><span class="line">    System.out.println(tableName.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NamespaceDescriptor</span> <span class="variable">namespace</span> <span class="operator">=</span> NamespaceDescriptor.create(<span class="string">&quot;test&quot;</span>).build();</span><br><span class="line">admin.createNamespace(namespace);</span><br></pre></td></tr></table></figure>

<h3 id="修改命名空间"><a href="#修改命名空间" class="headerlink" title="修改命名空间"></a>修改命名空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NamespaceDescriptor</span> <span class="variable">namespace</span> <span class="operator">=</span> NamespaceDescriptor.create(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                                                   .addConfiguration(<span class="string">&quot;Description&quot;</span>, <span class="string">&quot;Test Namespace&quot;</span>)</span><br><span class="line">                                                   .build();</span><br><span class="line">admin.modifyNamespace(namespace);</span><br></pre></td></tr></table></figure>

<h3 id="删除命名空间"><a href="#删除命名空间" class="headerlink" title="删除命名空间"></a>删除命名空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.deleteNamespace(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;test:test&quot;</span>);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(Bytes.toBytes(<span class="string">&quot;cf&quot;</span>));</span><br><span class="line">tableDescriptor.addFamily(columnDescriptor);</span><br><span class="line">admin.createTable(tableDescriptor);</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.deleteTable(TableName.valueOf(<span class="string">&quot;test:test&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始表</span></span><br><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;test:test&quot;</span>);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;cf1&quot;</span>);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName)</span><br><span class="line">    .addFamily(columnDescriptor)</span><br><span class="line">    .setValue(<span class="string">&quot;Description&quot;</span>, <span class="string">&quot;Original Table&quot;</span>);</span><br><span class="line">admin.createTable(tableDescriptor, Bytes.toBytes(<span class="number">1L</span>), Bytes.toBytes(<span class="number">10000L</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改表</span></span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">newTableDescriptor</span> <span class="operator">=</span> admin.getTableDescriptor(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">newColumnDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;cf2&quot;</span>);</span><br><span class="line">newTableDescriptor.addFamily(newColumnDescriptor)</span><br><span class="line">                  .setMaxFileSize(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024L</span>)</span><br><span class="line">                  .setValue(<span class="string">&quot;Description&quot;</span>, <span class="string">&quot;Modified Table&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改表必须先禁用再想修改</span></span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line">admin.modifyTable(tableName, newTableDescriptor);</span><br></pre></td></tr></table></figure>

<h3 id="禁用表"><a href="#禁用表" class="headerlink" title="禁用表"></a>禁用表</h3><p>需要注意：HBase 表在删除前，必须先禁用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.disableTable(TableName.valueOf(<span class="string">&quot;test:test&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="启用表"><a href="#启用表" class="headerlink" title="启用表"></a>启用表</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.enableTable(TableName.valueOf(<span class="string">&quot;test:test&quot;</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="查看表是否有效"><a href="#查看表是否有效" class="headerlink" title="查看表是否有效"></a>查看表是否有效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> admin.isTableAvailable(tableName);</span><br><span class="line">System.out.println(<span class="string">&quot;Table available: &quot;</span> + isOk);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11321037.html">《HBase 权威指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/larsgeorge/hbase-book">《HBase 权威指南》官方源码</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/581702">连接 HBase 的正确姿势</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/711bcaf8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/711bcaf8/" class="post-title-link" itemprop="url">HBase Java API 其他高级特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-31 16:20:27" itemprop="dateCreated datePublished" datetime="2023-03-31T16:20:27+08:00">2023-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-Java-API-其他高级特性"><a href="#HBase-Java-API-其他高级特性" class="headerlink" title="HBase Java API 其他高级特性"></a>HBase Java API 其他高级特性</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>HBase 提供了一种高级功能：计数器（counter）。<strong>HBase 计数器可以用于实时统计，无需延时较高的批量处理操作</strong>。HBase 有一种机制可以将列当作计数器：即读取并修改（其实就是一种 CAS 模式），其保证了在一次操作中的原子性。否则，用户需要对一行数据加锁，然后读取数据，再对当前数据做加法，最后写回 HBase 并释放行锁，这一系列操作会引起大量的资源竞争问题。</p>
<p>早期的 HBase 版本会在每次计数器更新操作调用一次 RPC 请求，新版本中可以在一次 RPC 请求中完成多个计数器的更新操作，但是多个计数器必须在同一行。</p>
<h3 id="计数器使用-Shell-命令行"><a href="#计数器使用-Shell-命令行" class="headerlink" title="计数器使用 Shell 命令行"></a>计数器使用 Shell 命令行</h3><p>计数器不需要初始化，创建一个新列时初始值为 0，第一次 <code>incr</code> 操作返回 1。</p>
<p>计数器使用 <code>incr</code> 命令，增量可以是正数也可以是负数，但是必须是长整数 Long：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr <span class="string">&#x27;&lt;table&gt;&#x27;</span>,<span class="string">&#x27;&lt;row&gt;&#x27;</span>,<span class="string">&#x27;&lt;column&gt;&#x27;</span>,[<span class="string">&#x27;&lt;increment-value&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>计数器使用的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:<span class="number">0</span>&gt; create <span class="string">&#x27;counters&#x27;</span>,<span class="string">&#x27;daily&#x27;</span>,<span class="string">&#x27;weekly&#x27;</span>,<span class="string">&#x27;monthly&#x27;</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.2260</span> seconds</span><br><span class="line"></span><br><span class="line">hbase(main):002:<span class="number">0</span>&gt; incr <span class="string">&#x27;counters&#x27;</span>,<span class="string">&#x27;20190301&#x27;</span>,<span class="string">&#x27;daily:hites&#x27;</span>,<span class="number">1</span></span><br><span class="line">COUNTER VALUE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">hbase(main):003:<span class="number">0</span>&gt; inc<span class="string">r&#x27;counters&#x27;</span>,<span class="string">&#x27;20190301&#x27;</span>,<span class="string">&#x27;daily:hites&#x27;</span>,<span class="number">1</span></span><br><span class="line">COUNTER VALUE = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">hbase(main):004:<span class="number">0</span>&gt; get_counter <span class="string">&#x27;counters&#x27;</span>,<span class="string">&#x27;20190301&#x27;</span>,<span class="string">&#x27;daily:hites&#x27;</span></span><br><span class="line">COUNTER VALUE = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，增加的参数必须是长整型 Long，如果按照错误的格式更新了计数器（如字符串格式），下次调用 <code>incr</code> 会得到错误的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):005:<span class="number">0</span>&gt; put <span class="string">&#x27;counters&#x27;</span>,<span class="string">&#x27;20190301&#x27;</span>,<span class="string">&#x27;daily:clicks&#x27;</span>,<span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.3250</span> seconds</span><br><span class="line"></span><br><span class="line">hbase(main):006:<span class="number">0</span>&gt; inc<span class="string">r&#x27;counters&#x27;</span>,<span class="string">&#x27;20190301&#x27;</span>,<span class="string">&#x27;daily:clicks&#x27;</span>,<span class="number">1</span></span><br><span class="line">COUNTER VALUE = <span class="number">3530822107858468865</span></span><br></pre></td></tr></table></figure>

<h3 id="单计数器"><a href="#单计数器" class="headerlink" title="单计数器"></a>单计数器</h3><p>操作一个计数器，类似 shell 命令 <code>incr</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HTable</span> <span class="variable">table</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTable</span>(conf, <span class="string">&quot;counters&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">cnt1</span> <span class="operator">=</span> table.incrementColumnValue(Bytes.toBytes(<span class="string">&quot;20190301&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;daily&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;hits&quot;</span>),</span><br><span class="line">    <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">cnt2</span> <span class="operator">=</span> table.incrementColumnValue(Bytes.toBytes(<span class="string">&quot;20190301&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;daily&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;hits&quot;</span>),</span><br><span class="line">    <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> table.incrementColumnValue(Bytes.toBytes(<span class="string">&quot;20190301&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;daily&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;hits&quot;</span>),</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="多计数器"><a href="#多计数器" class="headerlink" title="多计数器"></a>多计数器</h3><p>使用 <code>Table</code> 的 <code>increment()</code> 方法可以操作一行的多个计数器，需要构建 <code>Increment</code> 实例，并且指定行键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTable table  = <span class="keyword">new</span> <span class="built_in">HTable</span>(conf, <span class="string">&quot;counters&quot;</span>);</span><br><span class="line"></span><br><span class="line">Increment incr1 = <span class="keyword">new</span> <span class="built_in">Increment</span>(Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;20190301&quot;</span>));</span><br><span class="line">incr<span class="number">1.</span><span class="built_in">addColumn</span>(Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;daily&quot;</span>), Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;clicks&quot;</span>),<span class="number">1</span>);</span><br><span class="line">incr<span class="number">1.</span><span class="built_in">addColumn</span>(Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;daily&quot;</span>), Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;hits&quot;</span>), <span class="number">1</span>);</span><br><span class="line">incr<span class="number">1.</span><span class="built_in">addColumn</span>(Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;weekly&quot;</span>), Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;clicks&quot;</span>), <span class="number">2</span>);</span><br><span class="line">incr<span class="number">1.</span><span class="built_in">addColumn</span>(Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;weekly&quot;</span>), Bytes.<span class="built_in">toBytes</span>(<span class="string">&quot;hits&quot;</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Result result = table.<span class="built_in">increment</span>(incr1);</span><br><span class="line"><span class="keyword">for</span>(Cell cell : result.<span class="built_in">rawCells</span>()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Increment 类还有一种构造器：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Increment(<span class="built_in">byte</span>[] row, RowLock rowLock)</span><br></pre></td></tr></table></figure>

<p><code>rowLock</code> 参数可选，可以设置用户自定义锁，可以限制其他写程序操作此行，但是不保证读的操作性。</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="连接管理简介"><a href="#连接管理简介" class="headerlink" title="连接管理简介"></a>连接管理简介</h3><p>在 HBase Java API 中，<code>Connection</code> 类代表了一个集群连接，封装了与多台服务器（Matser&#x2F;Region Server）的底层连接以及与 zookeeper 的连接。<code>Connection</code> 通过 <code>ConnectionFactory</code> 类实例化，而连接的生命周期则由调用者管理，调用者必须显示调用 <code>close()</code> 来释放连接。<code>Connection</code> 是线程安全的。创建 <code>Connection</code> 实例的开销很高，因此一个进程只需要实例化一个 <code>Connection</code> 即可。</p>
<p><code>Table</code> 接口用于对指定的 HBase 表进行 CRUD 操作。一般，通过 <code>Connection</code> 获取 <code>Table</code> 实例，用完后，调用 <code>close()</code> 释放连接。</p>
<p><code>Admin</code> 接口主要用于创建、删除、查看、启用&#x2F;禁用 HBase 表，以及一些其他管理操作。一般，通过 <code>Connection</code> 获取 <code>Admin</code> 实例，用完后，调用 <code>close()</code> 释放连接。</p>
<p><code>Table</code> 和 <code>Admin</code> 实例都是轻量级且并非线程安全的。建议每个线程只实例化一个 <code>Table</code> 或 <code>Admin</code> 实例。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>问题：HBase 为什么没有提供 <code>Connection</code> 的连接池来获取更好的性能？是否需要自定义 <code>Connection</code> 连接池？</p>
<p>答：不需要。官方对于 <code>Connection</code> 的使用说明中，明确指出：对于高并发多线程访问的应用程序，一个进程中只需要预先创建一个 <code>Connection</code>。</p>
<p>问题：HBase 老版本中 <code>HTablePool</code> 为什么废弃？是否需要自定义 Table 的连接池？</p>
<p>答：不需要。Table 和 Admin 的连接本质上是复用 Connection，实例化是一个较为轻量级的操作，因此，并不需要缓存或池化。实际上，HBase Java API 官方就是这么建议的。 </p>
<p>下面是管理 HBase 连接的一个正确编程模型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有进程共用一个 connection 对象</span></span><br><span class="line">connection = ConnectionFactory.createConnection(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程使用单独的 table 对象</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(<span class="string">&quot;tableName&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   admin.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11321037.html">《HBase 权威指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/larsgeorge/hbase-book">《HBase 权威指南》官方源码</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/581702">连接 HBase 的正确姿势</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"c0a02e3edd251d4948a514bea2f0f938"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
