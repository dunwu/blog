<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/31/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/31/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/31/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/7eb4d9b1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/7eb4d9b1/" class="post-title-link" itemprop="url">Filebeat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elastic/" itemprop="url" rel="index"><span itemprop="name">elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Beats 是安装在服务器上的数据中转代理。</p>
<p>Beats 可以将数据直接传输到 Elasticsearch 或传输到 Logstash 。</p>
<p><img src="https://www.elastic.co/guide/en/beats/libbeat/current/images/beats-platform.png" alt="img"></p>
<p>Beats 有多种类型，可以根据实际应用需要选择合适的类型。</p>
<p>常用的类型有：</p>
<ul>
<li><strong>Packetbeat：</strong>网络数据包分析器，提供有关您的应用程序服务器之间交换的事务的信息。</li>
<li><strong>Filebeat：</strong>从您的服务器发送日志文件。</li>
<li><strong>Metricbeat：</strong>是一个服务器监视代理程序，它定期从服务器上运行的操作系统和服务收集指标。</li>
<li><strong>Winlogbeat：</strong>提供 Windows 事件日志。</li>
</ul>
<blockquote>
<p><strong>参考</strong></p>
<p>更多 Beats 类型可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/libbeat/current/community-beats.html">community-beats</a></p>
<p><strong>说明</strong></p>
<p>由于本人工作中只应用了 FileBeat，所以后面内容仅介绍 FileBeat 。</p>
</blockquote>
<h3 id="FileBeat-的作用"><a href="#FileBeat-的作用" class="headerlink" title="FileBeat 的作用"></a>FileBeat 的作用</h3><p>相比 Logstash，FileBeat 更加轻量化。</p>
<p>在任何环境下，应用程序都有停机的可能性。 Filebeat 读取并转发日志行，如果中断，则会记住所有事件恢复联机状态时所在位置。</p>
<p>Filebeat 带有内部模块（auditd，Apache，Nginx，System 和 MySQL），可通过一个指定命令来简化通用日志格式的收集，解析和可视化。</p>
<p>FileBeat 不会让你的管道超负荷。FileBeat 如果是向 Logstash 传输数据，当 Logstash 忙于处理数据，会通知 FileBeat 放慢读取速度。一旦拥塞得到解决，FileBeat 将恢复到原来的速度并继续传播。</p>
<p><img src="https://www.elastic.co/guide/en/beats/filebeat/current/images/filebeat.png" alt="img"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Unix &#x2F; Linux 系统建议使用下面方式安装，因为比较通用。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-<span class="number">6</span>.<span class="number">1</span>.<span class="number">1</span>-linux-x86_64.tar.gz</span><br><span class="line"><span class="attribute">tar</span> -zxf filebeat-<span class="number">6</span>.<span class="number">1</span>.<span class="number">1</span>-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-installation.html">filebeat-installation</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p>首先，必须要知道的是：<code>filebeat.yml</code> 是 filebeat 的配置文件。其路径会因为你安装方式而有所不同。</p>
<p>Beat 所有系列产品的配置文件都基于 <a target="_blank" rel="noopener" href="http://www.yaml.org/">YAML</a> 格式，FileBeat 当然也不例外。</p>
<p>更多 filebeat 配置内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html">配置 filebeat</a></p>
<p>更多 filebeat.yml 文件格式内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/libbeat/6.1/config-file-format.html">filebeat.yml 文件格式</a></p>
</blockquote>
<p>filebeat.yml 部分配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat:</span></span><br><span class="line">  <span class="attr">prospectors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">      <span class="attr">multiline:</span></span><br><span class="line">        <span class="attr">pattern:</span> <span class="string">&#x27;^[&#x27;</span></span><br><span class="line">        <span class="attr">match:</span> <span class="string">after</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong></p>
<p>更多 filebeat 配置内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html">配置 filebeat</a></p>
<p>更多 filebeat.yml 文件格式内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/libbeat/6.1/config-file-format.html">filebeat.yml 文件格式</a></p>
</blockquote>
<h3 id="重要配置项"><a href="#重要配置项" class="headerlink" title="重要配置项"></a>重要配置项</h3><blockquote>
<p>下面我将列举 Filebeat 的较为重要的配置项。</p>
<p>如果想了解更多配置信息，可以参考：</p>
<p>更多 filebeat 配置内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html">配置 filebeat</a></p>
<p>更多 filebeat.yml 文件格式内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/libbeat/6.1/config-file-format.html">filebeat.yml 文件格式</a></p>
</blockquote>
<h4 id="filebeat-prospectors"><a href="#filebeat-prospectors" class="headerlink" title="filebeat.prospectors"></a>filebeat.prospectors</h4><p>（文件监视器）用于指定需要关注的文件。</p>
<p><strong>示例</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br></pre></td></tr></table></figure>

<h4 id="output-elasticsearch"><a href="#output-elasticsearch" class="headerlink" title="output.elasticsearch"></a>output.elasticsearch</h4><p>如果你希望使用 filebeat 直接向 elasticsearch 输出数据，需要配置 output.elasticsearch 。</p>
<p><strong>示例</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&#x27;192.168.1.42:9200&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="output-logstash"><a href="#output-logstash" class="headerlink" title="output.logstash"></a>output.logstash</h4><p>如果你希望使用 filebeat 向 logstash 输出数据，然后由 logstash 再向 elasticsearch 输出数据，需要配置 output.logstash。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>相比于向 elasticsearch 输出数据，个人更推荐向 logstash 输出数据。</p>
<p>因为 logstash 和 filebeat 一起工作时，如果 logstash 忙于处理数据，会通知 FileBeat 放慢读取速度。一旦拥塞得到解决，FileBeat 将恢复到原来的速度并继续传播。这样，可以减少管道超负荷的情况。</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&#x27;127.0.0.1:5044&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>此外，还需要在 logstash 的配置文件（如 logstash.conf）中指定 beats input 插件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">  <span class="string">beats</span> &#123;</span><br><span class="line">    <span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span> <span class="comment"># 此端口需要与 filebeat.yml 中的端口相同</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># The filter part of this file is commented out to indicate that it is</span></span><br><span class="line"><span class="comment"># optional.</span></span><br><span class="line"><span class="comment"># filter &#123;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line">  <span class="string">elasticsearch</span> &#123;</span><br><span class="line">    <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">    <span class="string">manage_template</span> <span class="string">=&gt;</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;[@metadata][beat]&#125;</span>-<span class="template-variable">%&#123;[@metadata][version]&#125;</span>-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">    <span class="string">document_type</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;[@metadata][type]&#125;</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setup-kibana"><a href="#setup-kibana" class="headerlink" title="setup.kibana"></a>setup.kibana</h4><p>如果打算使用 Filebeat 提供的 Kibana 仪表板，需要配置 setup.kibana 。</p>
<p><strong>示例</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&#x27;localhost:5601&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="setup-template-settings"><a href="#setup-template-settings" class="headerlink" title="setup.template.settings"></a>setup.template.settings</h4><p>在 Elasticsearch 中，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.1/indices-templates.html">索引模板</a>用于定义设置和映射，以确定如何分析字段。</p>
<p>在 Filebeat 中，setup.template.settings 用于配置索引模板。</p>
<p>Filebeat 推荐的索引模板文件由 Filebeat 软件包安装。如果您接受 filebeat.yml 配置文件中的默认配置，Filebeat 在成功连接到 Elasticsearch 后自动加载模板。</p>
<p>您可以通过在 Filebeat 配置文件中配置模板加载选项来禁用自动模板加载，或加载自己的模板。您还可以设置选项来更改索引和索引模板的名称。</p>
<blockquote>
<p><strong>参考</strong></p>
<p>更多内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-template.html">filebeat-template</a></p>
<p><strong>说明</strong></p>
<p>如无必要，使用 Filebeat 配置文件中的默认索引模板即可。</p>
</blockquote>
<h4 id="setup-dashboards"><a href="#setup-dashboards" class="headerlink" title="setup.dashboards"></a>setup.dashboards</h4><p>Filebeat 附带了示例 Kibana 仪表板。在使用仪表板之前，您需要创建索引模式 <code>filebeat- *</code>，并将仪表板加载到 Kibana 中。为此，您可以运行 <code>setup</code> 命令或在 <code>filebeat.yml</code> 配置文件中配置仪表板加载。</p>
<p>为了在 Kibana 中加载 Filebeat 的仪表盘，需要在 <code>filebeat.yml</code> 配置中启动开关：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup.dashboards.enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong></p>
<p>更多内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-dashboards.html">configuration-dashboards</a></p>
</blockquote>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>filebeat 提供了一系列命令来完成各种功能。</p>
<p>执行命令方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat COMMAND</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考</strong></p>
<p>更多内容可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/command-line-options.html">command-line-options</a></p>
<p><strong>说明</strong></p>
<p>个人认为命令行没有必要一一掌握，因为绝大部分功能都可以通过配置来完成。且通过命令行指定功能这种方式要求每次输入同样参数，不利于固化启动方式。</p>
<p>最重要的当然是启动命令 run 了。</p>
<p><strong>示例</strong> 指定配置文件启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./filebeat run -e -c filebeat.yml -d <span class="string">&quot;publish&quot;</span></span><br><span class="line">./filebeat -e -c filebeat.yml -d <span class="string">&quot;publish&quot;</span> <span class="comment"># run 可以省略</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/beats/filebeat">Filebeat</a> 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/beats/metricbeat">Metricbeat</a> 内部集成了一系列模块，用以简化常见日志格式（例如 NGINX、Apache 或诸如 Redis 或 Docker 等系统指标）的收集、解析和可视化过程。</p>
</blockquote>
<ul>
<li>配置 elasticsearch 和 kibana</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">output.<span class="params">elasticsearch:</span></span><br><span class="line">  <span class="params">hosts:</span> [<span class="string">&quot;myEShost:9200&quot;</span>]</span><br><span class="line">  <span class="params">username:</span> <span class="string">&quot;elastic&quot;</span></span><br><span class="line">  <span class="params">password:</span> <span class="string">&quot;elastic&quot;</span></span><br><span class="line">setup.<span class="params">kibana:</span></span><br><span class="line">  <span class="params">host:</span> <span class="string">&quot;mykibanahost:5601&quot;</span></span><br><span class="line">  <span class="params">username:</span> <span class="string">&quot;elastic&quot;</span></span><br><span class="line">  <span class="params">password:</span> <span class="string">&quot;elastic</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>username 和 password 是可选的，如果不需要认证则不填。</p>
</blockquote>
<ul>
<li>初始化环境</li>
</ul>
<p>执行下面命令，filebeat 会加载推荐索引模板。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat setup -e</span><br></pre></td></tr></table></figure>

<ul>
<li>指定模块</li>
</ul>
<p>执行下面命令，指定希望加载的模块。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./filebeat</span> -e <span class="params">--modules</span> system,nginx,mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多内容可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-modules.html">配置 filebeat 模块</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules.html">filebeat 支持模块</a></li>
</ul>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Filebeat 有两个主要组件：</p>
<p>harvester：负责读取一个文件的内容。它会逐行读取文件内容，并将内容发送到输出目的地。</p>
<p>prospector：负责管理 harvester 并找到所有需要读取的文件源。比如类型是日志，prospector 就会遍历制定路径下的所有匹配要求的文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/path2/*.log</span></span><br></pre></td></tr></table></figure>

<p>Filebeat 保持每个文件的状态，并经常刷新注册表文件中的磁盘状态。状态用于记住 harvester 正在读取的最后偏移量，并确保发送所有日志行。</p>
<p>Filebeat 将每个事件的传递状态存储在注册表文件中。所以它能保证事件至少传递一次到配置的输出，没有数据丢失。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/beats">Beats 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/beats">Beats Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/libbeat/current/index.html">Beats 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1a5e0339/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1a5e0339/" class="post-title-link" itemprop="url">Kibana</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elastic/" itemprop="url" rel="index"><span itemprop="name">elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>通过 Kibana，您可以对自己的 Elasticsearch 进行可视化，还可以在 Elastic Stack 中进行导航，这样您便可以进行各种操作了，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><blockquote>
<p>版本：Elastic Stack 7.4</p>
</blockquote>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>安装步骤如下：</p>
<ol>
<li>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/kibana">kibana 官方下载地址</a> 下载所需版本包并解压到本地。</li>
<li>修改 <code>config/kibana.yml</code> 配置文件，设置 <code>elasticsearch.url</code> 指向 Elasticsearch 实例。</li>
<li>运行 <code>bin/kibana</code> （Windows 上运行 <code>bin\kibana.bat</code>）</li>
<li>在浏览器上访问 <a target="_blank" rel="noopener" href="http://localhost:5601/">http://localhost:5601</a></li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>单击侧面导航栏中的 <code>检索（Discover）</code> ，可以显示 <code>Kibana</code> 的数据查询功能功能。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/current/images/tutorial-discover.png" alt="img"></p>
<p>在搜索栏中，您可以输入 Elasticsearch 查询条件来搜索您的数据。您可以在 <code>Discover</code> 页面中浏览结果并在 <code>Visualize</code> 页面中创建已保存搜索条件的可视化。</p>
<p>当前索引模式显示在查询栏下方。索引模式确定提交查询时搜索哪些索引。要搜索一组不同的索引，请从下拉菜单中选择不同的模式。要添加索引模式（index pattern），请转至 <code>Management/Kibana/Index Patterns</code> 并单击 <code>Add New</code>。</p>
<p>您可以使用字段名称和您感兴趣的值构建搜索。对于数字字段，可以使用比较运算符，如大于（&gt;），小于（&lt;）或等于（&#x3D;）。您可以将元素与逻辑运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code> 链接，全部使用大写。</p>
<p>默认情况下，每个匹配文档都显示所有字段。要选择要显示的文档字段，请将鼠标悬停在“可用字段”列表上，然后单击要包含的每个字段旁边的添加按钮。例如，如果只添加 account_number，则显示将更改为包含五个帐号的简单列表：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-discover-3.png" alt="img"></p>
<p>kibana 的搜索栏遵循 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax">query-string-syntax</a> 文档中所说明的查询语义。</p>
<p>这里说明一些最基本的查询语义。</p>
<p>查询字符串会被解析为一系列的术语和运算符。一个术语可以是一个单词（如：quick、brown）或用双引号包围的短语（如”quick brown”）。</p>
<p>查询操作允许您自定义搜索 - 下面介绍了可用的选项。</p>
<h4 id="2-1-1-字段名称"><a href="#2-1-1-字段名称" class="headerlink" title="2.1.1. 字段名称"></a>2.1.1. 字段名称</h4><p>正如查询字符串查询中所述，将在搜索条件中搜索 default_field，但可以在查询语法中指定其他字段：</p>
<p>例如：</p>
<ul>
<li>查询 <code>status</code> 字段中包含 <code>active</code> 关键字</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">status:</span>active</span><br></pre></td></tr></table></figure>

<ul>
<li><code>title</code> 字段包含 <code>quick</code> 或 <code>brown</code> 关键字。如果您省略 <code>OR</code> 运算符，则将使用默认运算符</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span>(quick <span class="keyword">OR</span> brown)</span><br><span class="line"><span class="symbol">title:</span>(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>author 字段查找精确的短语 “john smith”，即精确查找。</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">author:</span><span class="string">&quot;John Smith&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任意字段 <code>book.title</code>，<code>book.content</code> 或 <code>book.date</code> 都包含 <code>quick</code> 或 <code>brown</code>（注意我们需要如何使用 <code>\*</code> 表示通配符）</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.\*:(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>title 字段包含任意非 null 值</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_exists_</span>:title</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-通配符"><a href="#2-1-2-通配符" class="headerlink" title="2.1.2. 通配符"></a>2.1.2. 通配符</h4><p>ELK 提供了 ? 和 * 两个通配符。</p>
<ul>
<li><code>?</code> 表示任意单个字符；</li>
<li><code>*</code> 表示任意零个或多个字符。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">qu</span>?ck <span class="keyword">bro</span>*</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：通配符查询会使用大量的内存并且执行性能较为糟糕，所以请慎用。</strong> &gt; <strong>提示</strong>：纯通配符 * 被写入 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html">exsits</a> 查询，从而提高了查询效率。因此，通配符 <code>field：*</code> 将匹配包含空值的文档，如：<code>&#123;“field”：“”&#125;</code>，但是如果字段丢失或显示将值置为 null 则不匹配，如：<code>“field”：null&#125;</code> &gt; <strong>提示</strong>：在一个单词的开头（例如：<code>*ing</code>）使用通配符这种方式的查询量特别大，因为索引中的所有术语都需要检查，以防万一匹配。通过将 <code>allow_leading_wildcard</code> 设置为 <code>false</code>，可以禁用。</p>
</blockquote>
<h4 id="2-1-3-正则表达式"><a href="#2-1-3-正则表达式" class="headerlink" title="2.1.3. 正则表达式"></a>2.1.3. 正则表达式</h4><p>可以通过 <code>/</code> 将正则表达式包裹在查询字符串中进行查询</p>
<p>例：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">na</span><span class="symbol">me:</span>/joh?<span class="built_in">n</span>(<span class="comment">ath[oa]n</span>)/</span><br></pre></td></tr></table></figure>

<p>支持的正则表达式语义可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">Regular expression syntax</a></p>
<h4 id="2-1-4-模糊查询"><a href="#2-1-4-模糊查询" class="headerlink" title="2.1.4. 模糊查询"></a>2.1.4. 模糊查询</h4><p>我们可以使用 <code>~</code> 运算符来进行模糊查询。</p>
<p>例：</p>
<p>假设我们实际想查询</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick brown forks</span></span><br></pre></td></tr></table></figure>

<p>但是，由于拼写错误，我们的查询关键字变成如下情况，依然可以查到想要的结果。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quikc<span class="string">\~</span> brwn<span class="string">\~</span> foks<span class="string">\~</span></span><br></pre></td></tr></table></figure>

<p>这种模糊查询使用 Damerau-Levenshtein 距离来查找所有匹配最多两个更改的项。所谓的更改是指单个字符的插入，删除或替换，或者两个相邻字符的换位。</p>
<p>默认编辑距离为 <code>2</code>，但编辑距离为 <code>1</code> 应足以捕捉所有人类拼写错误的 80％。它可以被指定为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quikc</span>\~<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-近似检索"><a href="#2-1-5-近似检索" class="headerlink" title="2.1.5. 近似检索"></a>2.1.5. 近似检索</h4><p>尽管短语查询（例如，<code>john smith</code>）期望所有的词条都是完全相同的顺序，但是近似查询允许指定的单词进一步分开或以不同的顺序排列。与模糊查询可以为单词中的字符指定最大编辑距离一样，近似搜索也允许我们指定短语中单词的最大编辑距离：</p>
<p>例</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fox quick&quot;</span><span class="string">\~5</span></span><br></pre></td></tr></table></figure>

<p>字段中的文本越接近查询字符串中指定的原始顺序，该文档就越被认为是相关的。当与上面的示例查询相比时，短语 <code>&quot;quick fox&quot;</code> 将被认为比 <code>&quot;quick brown fox&quot;</code> 更近似查询条件。</p>
<h4 id="2-1-6-范围"><a href="#2-1-6-范围" class="headerlink" title="2.1.6. 范围"></a>2.1.6. 范围</h4><p>可以为日期，数字或字符串字段指定范围。闭区间范围用方括号 <code>[min TO max]</code> 和开区间范围用花括号 <code>&#123;min TO max&#125;</code> 来指定。</p>
<p>我们不妨来看一些示例。</p>
<ul>
<li>2012 年的所有日子</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:[<span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span> TO <span class="number">2012</span>-<span class="number">12</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>数字 1 到 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>alpha</code> 和 <code>omega</code> 之间的标签，不包括 <code>alpha</code> 和 <code>omega</code></li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span>&#123;alpha TO omega&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>10 以上的数字</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>:[<span class="number">10</span> <span class="keyword">TO</span> *]</span><br></pre></td></tr></table></figure>

<ul>
<li>2012 年以前的所有日期</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:&#123;* TO <span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此外，开区间和闭区间也可以组合使用</p>
<ul>
<li>数组 1 到 5，但不包括 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>一边无界的范围也可以使用以下语法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:&gt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&gt;=<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当然，你也可以使用 AND 运算符来得到连个查询结果的交集</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:(&gt;=<span class="number">10</span> AND &lt;<span class="number">20</span>)</span><br><span class="line"><span class="attribute">age</span>:(+&gt;=<span class="number">10</span> +&lt;<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-Boosting"><a href="#2-1-7-Boosting" class="headerlink" title="2.1.7. Boosting"></a>2.1.7. Boosting</h4><p>使用操作符 <code>^</code> 使一个术语比另一个术语更相关。例如，如果我们想查找所有有关狐狸的文档，但我们对狐狸特别感兴趣：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick</span>^<span class="number">2</span> fox</span><br></pre></td></tr></table></figure>

<p>默认提升值是 1，但可以是任何正浮点数。 0 到 1 之间的提升减少了相关性。</p>
<p>增强也可以应用于短语或组：</p>
<figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&quot;john smith&quot;</span><span class="keyword">^2</span><span class="language-xml">   (foo bar)</span><span class="keyword">^4</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-布尔操作"><a href="#2-1-8-布尔操作" class="headerlink" title="2.1.8. 布尔操作"></a>2.1.8. 布尔操作</h4><p>默认情况下，只要一个词匹配，所有词都是可选的。搜索 <code>foo bar baz</code> 将查找包含 <code>foo</code> 或 <code>bar</code> 或 <code>baz</code> 中的一个或多个的任何文档。我们已经讨论了上面的<code>default_operator</code>，它允许你强制要求所有的项，但也有布尔运算符可以在查询字符串本身中使用，以提供更多的控制。</p>
<p>首选的操作符是 <code>+</code>（此术语必须存在）和 <code>-</code> （此术语不得存在）。所有其他条款是可选的。例如，这个查询：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick <span class="keyword">brown </span>+fox -news</span><br></pre></td></tr></table></figure>

<p>这条查询意味着：</p>
<ul>
<li>fox 必须存在</li>
<li>news 必须不存在</li>
<li>quick 和 brown 是可有可无的</li>
</ul>
<p>熟悉的运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code>（也写成 <code>&amp;&amp;</code>，<code>||</code> 和 <code>!</code>）也被支持。然而，这些操作符有一定的优先级：<code>NOT</code> 优先于 <code>AND</code>，<code>AND</code> 优先于 <code>OR</code>。虽然 <code>+</code> 和 <code>-</code> 仅影响运算符右侧的术语，但 <code>AND</code> 和 <code>OR</code> 会影响左侧和右侧的术语。</p>
<h4 id="2-1-9-分组"><a href="#2-1-9-分组" class="headerlink" title="2.1.9. 分组"></a>2.1.9. 分组</h4><p>多个术语或子句可以用圆括号组合在一起，形成子查询</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(quick <span class="keyword">OR </span><span class="keyword">brown) </span><span class="keyword">AND </span>fox</span><br></pre></td></tr></table></figure>

<p>可以使用组来定位特定的字段，或者增强子查询的结果：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat<span class="symbol">us:</span>(active <span class="built_in">OR</span> pending) tit<span class="symbol">le:</span>(full <span class="built_in">text</span> <span class="built_in">search</span>)^<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-10-保留字"><a href="#2-1-10-保留字" class="headerlink" title="2.1.10. 保留字"></a>2.1.10. 保留字</h4><p>如果你需要使用任何在你的查询本身中作为操作符的字符（而不是作为操作符），那么你应该用一个反斜杠来转义它们。例如，要搜索（1 + 1）&#x3D; 2，您需要将查询写为 <code>\(1\+1\)\=2</code></p>
<p>保留字符是：<code>+ - = &amp;&amp; || &gt; &lt; ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \ /</code></p>
<p>无法正确地转义这些特殊字符可能会导致语法错误，从而阻止您的查询运行。</p>
<h4 id="2-1-11-空查询"><a href="#2-1-11-空查询" class="headerlink" title="2.1.11. 空查询"></a>2.1.11. 空查询</h4><p>如果查询字符串为空或仅包含空格，则查询将生成一个空的结果集。</p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>要想使用可视化的方式展示您的数据，请单击侧面导航栏中的 <code>可视化（Visualize）</code>。</p>
<p>Visualize 工具使您能够以多种方式（如饼图、柱状图、曲线图、分布图等）查看数据。要开始使用，请点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png"></p>
<p>有许多可视化类型可供选择。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png"></p>
<p>下面，我们来看创建几个图标示例：</p>
<h4 id="2-2-1-Pie"><a href="#2-2-1-Pie" class="headerlink" title="2.2.1. Pie"></a>2.2.1. Pie</h4><p>您可以从保存的搜索中构建可视化文件，也可以输入新的搜索条件。要输入新的搜索条件，首先需要选择一个索引模式来指定要搜索的索引。</p>
<p>默认搜索匹配所有文档。最初，一个“切片”包含整个饼图：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png"></p>
<p>要指定在图表中展示哪些数据，请使用 Elasticsearch 存储桶聚合。分组汇总只是将与您的搜索条件相匹配的文档分类到不同的分类中，也称为分组。</p>
<p>为每个范围定义一个存储桶：</p>
<ol>
<li>单击 <code>Split Slices</code>。</li>
<li>在 <code>Aggregation</code> 列表中选择 <code>Terms</code>。_注意：这里的 Terms 是 Elk 采集数据时定义好的字段或标签_。</li>
<li>在 <code>Field</code> 列表中选择 <code>level.keyword</code>。</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-7fb2042dc6d59520.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h4 id="2-2-2-Vertical-Bar"><a href="#2-2-2-Vertical-Bar" class="headerlink" title="2.2.2. Vertical Bar"></a>2.2.2. Vertical Bar</h4><p>我们在展示一下如何创建柱状图。</p>
<ol>
<li>点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。选择 <code>Vertical Bar</code></li>
<li>选择索引模式。由于您尚未定义任何 bucket ，因此您会看到一个大栏，显示与默认通配符查询匹配的文档总数。</li>
<li>指定 Y 轴所代表的字段</li>
<li>指定 X 轴所代表的字段</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-5aa7627284c19a56.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h3 id="报表"><a href="#报表" class="headerlink" title="报表"></a>报表</h3><p><code>报表（Dashboard）</code> 可以整合和共享 <code>Visualize</code> 集合。</p>
<ol>
<li>点击侧面导航栏中的 Dashboard。</li>
<li>点击添加显示保存的可视化列表。</li>
<li>点击之前保存的 <code>Visualize</code>，然后点击列表底部的小向上箭头关闭可视化列表。</li>
<li>将鼠标悬停在可视化对象上会显示允许您编辑，移动，删除和调整可视化对象大小的容器控件。</li>
</ol>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Kibana-No-Default-Index-Pattern-Warning"><a href="#Kibana-No-Default-Index-Pattern-Warning" class="headerlink" title="Kibana No Default Index Pattern Warning"></a>Kibana No Default Index Pattern Warning</h3><p><strong>问题：</strong>安装 ELK 后，访问 kibana 页面时，提示以下错误信息：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning No default <span class="keyword">index</span> pattern. You must <span class="keyword">select</span> <span class="keyword">or</span> <span class="keyword">create</span> one <span class="keyword">to</span> <span class="keyword">continue</span>.</span><br><span class="line">...</span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">fetch</span> <span class="keyword">mapping</span>. <span class="keyword">Do</span> you have indices matching the pattern?</span><br></pre></td></tr></table></figure>

<p>这就说明 logstash 没有把日志写入到 elasticsearch。</p>
<p><strong>解决方法：</strong></p>
<p>检查 logstash 与 elasticsearch 之间的通讯是否有问题，一般问题就出在这。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/kibana">Kibana 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/kibana">Kibana Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/kibana/current/index.html">Kibana 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/0d754bce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/0d754bce/" class="post-title-link" itemprop="url">Logstash</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elastic/" itemprop="url" rel="index"><span itemprop="name">elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash</a> 是开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Logstash 是 Elasticsearch 的最佳数据管道。</p>
<p>Logstash 是插件式管理模式，在输入、过滤、输出以及编码过程中都可以使用插件进行定制。Logstash 社区有超过 200 种可用插件。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Logstash 有两个必要元素：<code>input</code> 和 <code>output</code> ，一个可选元素：<code>filter</code>。</p>
<p>这三个元素，分别代表 Logstash 事件处理的三个阶段：输入 &gt; 过滤器 &gt; 输出。</p>
<p><img src="https://www.elastic.co/guide/en/logstash/current/static/images/basic_logstash_pipeline.png" alt="img"></p>
<ul>
<li>input 负责从数据源采集数据。</li>
<li>filter 将数据修改为你指定的格式或内容。</li>
<li>output 将数据传输到目的地。</li>
</ul>
<p>在实际应用场景中，通常输入、输出、过滤器不止一个。Logstash 的这三个元素都使用插件式管理方式，用户可以根据应用需要，灵活的选用各阶段需要的插件，并组合使用。</p>
<p>后面将对插件展开讲解，暂且不表。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>安装步骤如下：</p>
<p>（1）在 <a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/logstash">logstash 官方下载地址</a> 下载所需版本包并解压到本地。</p>
<p>（2）添加一个 <code>logstash.conf</code> 文件，指定要使用的插件以及每个插件的设置。举个简单的例子：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123; <span class="keyword">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123; hosts <span class="operator">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; codec <span class="operator">=&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）运行 <code>bin/logstash -f logstash.conf</code> （Windows 上运行<code>bin/logstash.bat -f logstash.conf</code>）</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="设置文件"><a href="#设置文件" class="headerlink" title="设置文件"></a>设置文件</h3><ul>
<li>**<code>logstash.yml</code>**：logstash 的默认启动配置文件</li>
<li>**<code>jvm.options</code>**：logstash 的 JVM 配置文件。</li>
<li><strong><code>startup.options</code></strong> (Linux)：包含系统安装脚本在 <code>/usr/share/logstash/bin</code> 中使用的选项为您的系统构建适当的启动脚本。安装 Logstash 软件包时，系统安装脚本将在安装过程结束时执行，并使用 <code>startup.options</code> 中指定的设置来设置用户，组，服务名称和服务描述等选项。</li>
</ul>
<h3 id="logstash-yml-设置项"><a href="#logstash-yml-设置项" class="headerlink" title="logstash.yml 设置项"></a>logstash.yml 设置项</h3><p>节选部分设置项，更多项请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html">https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.name</code></td>
<td>节点名</td>
<td>机器的主机名</td>
</tr>
<tr>
<td><code>path.data</code></td>
<td>Logstash 及其插件用于任何持久性需求的目录。</td>
<td><code>LOGSTASH_HOME/data</code></td>
</tr>
<tr>
<td><code>pipeline.workers</code></td>
<td>同时执行管道的过滤器和输出阶段的工作任务数量。如果发现事件正在备份，或 CPU 未饱和，请考虑增加此数字以更好地利用机器处理能力。</td>
<td>Number of the host’s CPU cores</td>
</tr>
<tr>
<td><code>pipeline.batch.size</code></td>
<td>尝试执行过滤器和输出之前，单个工作线程从输入收集的最大事件数量。较大的批量处理大小一般来说效率更高，但是以增加的内存开销为代价。您可能必须通过设置 <code>LS_HEAP_SIZE</code> 变量来有效使用该选项来增加 JVM 堆大小。</td>
<td><code>125</code></td>
</tr>
<tr>
<td><code>pipeline.batch.delay</code></td>
<td>创建管道事件批处理时，在将一个尺寸过小的批次发送给管道工作任务之前，等待每个事件需要多长时间（毫秒）。</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>pipeline.unsafe_shutdown</code></td>
<td>如果设置为 true，则即使在内存中仍存在 inflight 事件时，也会强制 Logstash 在关闭期间退出。默认情况下，Logstash 将拒绝退出，直到所有接收到的事件都被推送到输出。启用此选项可能会导致关机期间数据丢失。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>path.config</code></td>
<td>主管道的 Logstash 配置路径。如果您指定一个目录或通配符，配置文件将按字母顺序从目录中读取。</td>
<td>Platform-specific. See [<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/6.1/docs/static/settings-file.asciidoc#dir-layout">dir-layout]</a>.</td>
</tr>
<tr>
<td><code>config.string</code></td>
<td>包含用于主管道的管道配置的字符串。使用与配置文件相同的语法。</td>
<td>None</td>
</tr>
<tr>
<td><code>config.test_and_exit</code></td>
<td>设置为 true 时，检查配置是否有效，然后退出。请注意，使用此设置不会检查 grok 模式的正确性。 Logstash 可以从目录中读取多个配置文件。如果将此设置与 log.level：debug 结合使用，则 Logstash 将记录组合的配置文件，并注掉其源文件的配置块。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.automatic</code></td>
<td>设置为 true 时，定期检查配置是否已更改，并在配置更改时重新加载配置。这也可以通过 SIGHUP 信号手动触发。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.interval</code></td>
<td>Logstash 检查配置文件更改的时间间隔。</td>
<td><code>3s</code></td>
</tr>
<tr>
<td><code>config.debug</code></td>
<td>设置为 true 时，将完全编译的配置显示为调试日志消息。您还必须设置<code>log.level：debug</code>。警告：日志消息将包括任何传递给插件配置作为明文的“密码”选项，并可能导致明文密码出现在您的日志！</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.support_escapes</code></td>
<td>当设置为 true 时，带引号的字符串将处理转义字符。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>modules</code></td>
<td>配置时，模块必须处于上表所述的嵌套 YAML 结构中。</td>
<td>None</td>
</tr>
<tr>
<td><code>http.host</code></td>
<td>绑定地址</td>
<td><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td><code>http.port</code></td>
<td>绑定端口</td>
<td><code>9600</code></td>
</tr>
<tr>
<td><code>log.level</code></td>
<td>日志级别。有效选项：fatal &gt; error &gt; warn &gt; info &gt; debug &gt; trace</td>
<td><code>info</code></td>
</tr>
<tr>
<td><code>log.format</code></td>
<td>日志格式。json （JSON 格式）或 plain （原对象）</td>
<td><code>plain</code></td>
</tr>
<tr>
<td><code>path.logs</code></td>
<td>Logstash 自身日志的存储路径</td>
<td><code>LOGSTASH_HOME/logs</code></td>
</tr>
<tr>
<td><code>path.plugins</code></td>
<td>在哪里可以找到自定义的插件。您可以多次指定此设置以包含多个路径。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>通过命令行启动 logstash 的方式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash [options]</span><br></pre></td></tr></table></figure>

<p>其中 <code>options</code> 是您可以指定用于控制 Logstash 执行的命令行标志。</p>
<p>在命令行上设置的任何标志都会覆盖 Logstash 设置文件（<code>logstash.yml</code>）中的相应设置，但设置文件本身不会更改。</p>
<blockquote>
<p><strong>注</strong></p>
<p>虽然可以通过指定命令行参数的方式，来控制 logstash 的运行方式，但显然这么做很麻烦。</p>
<p>建议通过指定配置文件的方式，来控制 logstash 运行，启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>若想了解更多的命令行参数细节，请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html">https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html</a></p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>上节，我们了解到，logstash 可以执行 <code>bin/logstash -f logstash.conf</code> ，按照配置文件中的参数去覆盖默认设置文件（<code>logstash.yml</code>）中的设置。</p>
<p>这节，我们就来学习一下这个配置文件如何配置参数。</p>
<h4 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h4><p>在工作原理一节中，我们已经知道了 Logstash 主要有三个工作阶段 input 、filter、output。而 logstash 配置文件文件结构也与之相对应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input &#123;&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个部分都包含一个或多个插件的配置选项。如果指定了多个过滤器，则会按照它们在配置文件中的显示顺序应用它们。</p>
</blockquote>
<h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p>插件的配置由插件名称和插件的一个设置块组成。</p>
<p>下面的例子中配置了两个输入文件配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="function"><span class="params">path</span> =&gt;</span> <span class="string">&quot;/var/log/messages&quot;</span></span><br><span class="line">    type =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="function"><span class="params">path</span> =&gt;</span> <span class="string">&quot;/var/log/apache/access.log&quot;</span></span><br><span class="line">    type =&gt; <span class="string">&quot;apache&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以配置的设置因插件类型而异。你可以参考： <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a>, 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a> 。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>一个插件可以要求设置的值是一个特定的类型，比如布尔值，列表或哈希值。以下值类型受支持。</p>
<ul>
<li>Array</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users =&gt; [ &#123;<span class="function"><span class="params">id</span> =&gt;</span> <span class="number">1</span>, <span class="function"><span class="params">name</span> =&gt;</span> bob&#125;, &#123;<span class="function"><span class="params">id</span> =&gt;</span> <span class="number">2</span>, <span class="function"><span class="params">name</span> =&gt;</span> jane&#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>Lists</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">path</span>) =&gt;</span> [<span class="string">&#x27;/var/log/messages&#x27;</span>, <span class="string">&#x27;/var/log/*.log&#x27;</span>]</span><br><span class="line">;<span class="function">(<span class="params">uris</span>) =&gt;</span> [<span class="string">&#x27;http://elastic.co&#x27;</span>, <span class="string">&#x27;http://example.net&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">ssl_enable</span>) =&gt;</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bytes</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_bytes =&gt; <span class="string">&quot;1113&quot;</span>   # <span class="number">1113</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;10MiB&quot;</span>  # <span class="number">10485760</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;100kib&quot;</span> # <span class="number">102400</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;180 mb&quot;</span> # <span class="number">180000000</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li>Codec</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">codec</span>) =&gt;</span> <span class="string">&#x27;json&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Hash</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;field1&quot;</span> =&gt; <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="string">&quot;field2&quot;</span> =&gt; <span class="string">&quot;value2&quot;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Number</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">port</span>) =&gt;</span> <span class="number">33</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Password</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">my_password</span>) =&gt;</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>URI</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">my_uri</span>) =&gt;</span> <span class="string">&#x27;http://foo:bar@example.net&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Path</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">my_path</span>) =&gt;</span> <span class="string">&#x27;/tmp/logstash&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>String</p>
</li>
<li><p>转义字符</p>
</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><blockquote>
<p>Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p>
</blockquote>
<h4 id="常用-input-插件"><a href="#常用-input-插件" class="headerlink" title="常用 input 插件"></a>常用 input 插件</h4><ul>
<li><strong>file</strong>：从文件系统上的文件读取，就像 UNIX 命令 <code>tail -0F</code> 一样</li>
<li><strong>syslog：</strong>在众所周知的端口 514 上侦听系统日志消息，并根据 RFC3164 格式进行解析</li>
<li><strong>redis：</strong>从 redis 服务器读取，使用 redis 通道和 redis 列表。 Redis 经常用作集中式 Logstash 安装中的“代理”，它将来自远程 Logstash“托运人”的 Logstash 事件排队。</li>
<li><strong>beats：</strong>处理由 Filebeat 发送的事件。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote>
<p>过滤器是 Logstash 管道中的中间处理设备。如果符合特定条件，您可以将条件过滤器组合在一起，对事件执行操作。</p>
</blockquote>
<h4 id="常用-filter-插件"><a href="#常用-filter-插件" class="headerlink" title="常用 filter 插件"></a>常用 filter 插件</h4><ul>
<li><strong>grok：</strong>解析和结构任意文本。 Grok 目前是 Logstash 中将非结构化日志数据解析为结构化和可查询的最佳方法。</li>
<li><strong>mutate：</strong>对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段。</li>
<li><strong>drop：</strong>完全放弃一个事件，例如调试事件。</li>
<li><strong>clone：</strong>制作一个事件的副本，可能会添加或删除字段。</li>
<li><strong>geoip：</strong>添加有关 IP 地址的地理位置的信息（也可以在 Kibana 中显示惊人的图表！）</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a></p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><blockquote>
<p>输出是 Logstash 管道的最后阶段。一个事件可以通过多个输出，但是一旦所有输出处理完成，事件就完成了执行。</p>
</blockquote>
<h4 id="常用-output-插件"><a href="#常用-output-插件" class="headerlink" title="常用 output 插件"></a>常用 output 插件</h4><ul>
<li><strong>elasticsearch：</strong>将事件数据发送给 Elasticsearch（推荐模式）。</li>
<li><strong>file：</strong>将事件数据写入文件或磁盘。</li>
<li><strong>graphite：</strong>将事件数据发送给 graphite（一个流行的开源工具，存储和绘制指标。 <a target="_blank" rel="noopener" href="http://graphite.readthedocs.io/en/latest/%EF%BC%89%E3%80%82">http://graphite.readthedocs.io/en/latest/）。</a></li>
<li><strong>statsd：</strong>将事件数据发送到 statsd （这是一种侦听统计数据的服务，如计数器和定时器，通过 UDP 发送并将聚合发送到一个或多个可插入的后端服务）。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
<h3 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h3><p>用于格式化对应的内容。</p>
<h4 id="常用-codec-插件"><a href="#常用-codec-插件" class="headerlink" title="常用 codec 插件"></a>常用 codec 插件</h4><ul>
<li><strong>json：</strong>以 JSON 格式对数据进行编码或解码。</li>
<li><strong>multiline：</strong>将多行文本事件（如 java 异常和堆栈跟踪消息）合并为单个事件。</li>
</ul>
<p>更多插件请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>前面的内容都是对 Logstash 的介绍和原理说明。接下来，我们来实战一些常见的应用场景。</p>
<h3 id="传输控制台数据"><a href="#传输控制台数据" class="headerlink" title="传输控制台数据"></a>传输控制台数据</h3><blockquote>
<p>stdin input 插件从标准输入读取事件。这是最简单的 input 插件，一般用于测试场景。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>（1）创建 <code>logstash-input-stdin.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input &#123; stdin &#123; &#125; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash-input-stdin.conf</span><br></pre></td></tr></table></figure>

<h3 id="传输-logback-日志"><a href="#传输-logback-日志" class="headerlink" title="传输 logback 日志"></a>传输 logback 日志</h3><blockquote>
<p>elk 默认使用的 Java 日志工具是 log4j2 ，并不支持 logback 和 log4j。</p>
<p>想使用 logback + logstash ，可以使用 <a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 。<a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 提供了 UDP &#x2F; TCP &#x2F; 异步方式来传输日志数据到 logstash。</p>
<p>如果你使用的是 log4j ，也不是不可以用这种方式，只要引入桥接 jar 包即可。如果你对 log4j 、logback ，或是桥接 jar 包不太了解，可以参考我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
</blockquote>
<h4 id="TCP-应用"><a href="#TCP-应用" class="headerlink" title="TCP 应用"></a>TCP 应用</h4><p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-tcp.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">tcp &#123;</span><br><span class="line">  <span class="function"><span class="params">port</span> =&gt;</span> <span class="number">9251</span></span><br><span class="line">  codec =&gt; json_lines</span><br><span class="line">  mode =&gt; server</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- logback 依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-TCP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> destination 是 logstash 服务的 host:port，</span></span><br><span class="line"><span class="comment"> 相当于和 logstash 建立了管道，将日志数据定向传输到 logstash</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.28.32:9251<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-TCP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h4 id="UDP-应用"><a href="#UDP-应用" class="headerlink" title="UDP 应用"></a>UDP 应用</h4><p>UDP 和 TCP 的使用方式大同小异。</p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-udp.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">udp &#123;</span><br><span class="line">  <span class="function"><span class="params">port</span> =&gt;</span> <span class="number">9250</span></span><br><span class="line">  codec =&gt; json</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<p>与 <strong>TCP 应用</strong> 一节中的引入依赖包完全相同。</p>
<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-UDP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashSocketAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>192.168.28.32<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>9250<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-UDP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h3 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h3><blockquote>
<p>在 Java Web 领域，需要用到一些重要的工具，例如 Tomcat 、Nginx 、Mysql 等。这些不属于业务应用，但是它们的日志数据对于定位问题、分析统计同样很重要。这时无法使用 logback 方式将它们的日志传输到 logstash。</p>
<p>如何采集这些日志文件呢？别急，你可以使用 logstash 的 file input 插件。</p>
<p>需要注意的是，传输文件这种方式，必须在日志所在的机器上部署 logstash 。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-file.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">  <span class="function"><span class="params">path</span> =&gt;</span> [<span class="string">&quot;/var/log/nginx/access.log&quot;</span>]</span><br><span class="line">  type =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"> <span class="keyword">if</span> [type] == <span class="string">&quot;nginx-access-log&quot;</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">   <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">   index =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-file.conf</code></p>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html</a></p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="启动、终止应用"><a href="#启动、终止应用" class="headerlink" title="启动、终止应用"></a>启动、终止应用</h3><p>如果你的 logstash 每次都是通过指定配置文件方式启动。不妨建立一个启动脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> xxx 进入 logstash 安装目录下的 bin 目录</span></span><br><span class="line">logstash -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>如果你的 logstash 运行在 linux 系统下，不妨使用 nohup 来启动一个守护进程。这样做的好处在于，即使关闭终端，应用仍会运行。</p>
<p><strong>创建 startup.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./logstash -f logstash.conf &gt;&gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>终止应用没有什么好方法，你只能使用 ps -ef | grep logstash ，查出进程，将其 kill 。不过，我们可以写一个脚本来干这件事：</p>
<p><strong>创建 shutdown.sh</strong></p>
<p>脚本不多解释，请自行领会作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID=`ps -ef | grep logstash | awk &#x27;&#123; print $2&#125;&#x27; | head -n 1`</span><br><span class="line">kill -9 $&#123;PID&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/logstash">Logstash 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chenryn/logstash-best-practice-cn">ELK Stack 权威指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/judasn/Linux-Tutorial/blob/master/ELK-Install-And-Settings.md">ELK（Elasticsearch、Logstash、Kibana）安装和配置</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/4c174dbb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/4c174dbb/" class="post-title-link" itemprop="url">ElasticSearch API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ElasticSearch-API"><a href="#ElasticSearch-API" class="headerlink" title="ElasticSearch API"></a>ElasticSearch API</h1><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a> 是一个分布式、RESTful 风格的搜索和数据分析引擎</strong>，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a> 基于搜索库 <a target="_blank" rel="noopener" href="https://github.com/apache/lucene-solr">Lucene</a> 开发。ElasticSearch 隐藏了 Lucene 的复杂性，提供了简单易用的 REST API &#x2F; Java API 接口（另外还有其他语言的 API 接口）。</p>
<p>_以下简称 ES_。</p>
<p>REST API 最详尽的文档应该参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html">ES 官方 REST API</a></p>
</blockquote>
<h2 id="ElasticSearch-API-简介"><a href="#ElasticSearch-API-简介" class="headerlink" title="ElasticSearch API 简介"></a>ElasticSearch API 简介</h2><p>Elasticsearch 官方提供了很多版本的 Java 客户端，包含但不限于：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html">Transport Client</a> - 7.0 废弃，8.0 移除。</li>
<li>Java REST 客户端</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html">Elasticsearch Java API Client</a> -</li>
</ul>
<p>如果当前是：8.X 版本，推荐 Elasticsearch <code>Java API</code>客户端。</p>
<p>如果当前是：7.X 版本且不考虑升级，推荐 <code>High Level REST</code>客户端。</p>
<p>如果当前是：5.X、6.X 版本，推荐尽早升级集群版本。</p>
<h3 id="Elasticsearch-Java-API-Client-快速入门"><a href="#Elasticsearch-Java-API-Client-快速入门" class="headerlink" title="Elasticsearch Java API Client 快速入门"></a>Elasticsearch Java API Client 快速入门</h3><p>:::detail 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个低级的客户端</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>)).build();</span><br><span class="line"><span class="comment">//创建 JSON 对象映射器</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">RestClientTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"><span class="comment">//创建 API 客户端</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"><span class="comment">//查询所有索引-------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">GetIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().get(query -&gt; query.index(<span class="string">&quot;_all&quot;</span>));</span><br><span class="line"><span class="keyword">final</span> <span class="type">IndexState</span> <span class="variable">products</span> <span class="operator">=</span> response.result().get(<span class="string">&quot;products&quot;</span>);</span><br><span class="line">System.out.println(products.toString());</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">client.shutdown();</span><br><span class="line">transport.close();</span><br><span class="line">restClient.close();</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="Transport-Client-快速入门"><a href="#Transport-Client-快速入门" class="headerlink" title="Transport Client 快速入门"></a>Transport Client 快速入门</h3><p><code>TransportClient</code> 使用 <code>transport</code> 模块远程连接到 Elasticsearch 集群。它不会加入集群，而只是获取一个或多个初始传输地址，并以轮询方式与它们通信。</p>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html</a></p>
</blockquote>
<p>:::detail 示例</p>
<p>启动客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动</span></span><br><span class="line"><span class="type">TransportClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreBuiltTransportClient</span>(Settings.EMPTY)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> <span class="title class_">TransportAddress</span>(InetAddress.getByName(<span class="string">&quot;host1&quot;</span>), <span class="number">9300</span>))</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> <span class="title class_">TransportAddress</span>(InetAddress.getByName(<span class="string">&quot;host2&quot;</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<p>配置集群名称</p>
<p>注意，如果使用的集群名称与 “elasticsearch” 不同，则必须设置集群名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Settings</span> <span class="variable">settings</span> <span class="operator">=</span> Settings.builder()</span><br><span class="line">        .put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;myClusterName&quot;</span>).build();</span><br><span class="line"><span class="type">TransportClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreBuiltTransportClient</span>(settings);</span><br><span class="line"><span class="comment">// Add transport addresses and do something with the client...</span></span><br></pre></td></tr></table></figure>

<p>启用 sniffing</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Settings</span> <span class="variable">settings</span> <span class="operator">=</span> Settings.builder()</span><br><span class="line">        .put(<span class="string">&quot;client.transport.sniff&quot;</span>, <span class="literal">true</span>).build();</span><br><span class="line"><span class="type">TransportClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreBuiltTransportClient</span>(settings);</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="ElasticSearch-Rest"><a href="#ElasticSearch-Rest" class="headerlink" title="ElasticSearch Rest"></a>ElasticSearch Rest</h2><h3 id="ElasticSearch-Rest-API-语法格式"><a href="#ElasticSearch-Rest-API-语法格式" class="headerlink" title="ElasticSearch Rest API 语法格式"></a>ElasticSearch Rest API 语法格式</h3><p>向 Elasticsearch 发出的请求的组成部分与其它普通的 HTTP 请求是一样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">&#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27;</span> -d <span class="string">&#x27;&lt;BODY&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERB</code>：HTTP 方法，支持：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, <code>DELETE</code></li>
<li><code>PROTOCOL</code>：http 或者 https 协议（只有在 Elasticsearch 前面有 https 代理的时候可用）</li>
<li><code>HOST</code>：Elasticsearch 集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫 localhost</li>
<li><code>PORT</code>：Elasticsearch HTTP 服务所在的端口，默认为 9200 PATH API 路径（例如、_count 将返回集群中文档的数量），</li>
<li><code>PATH</code>：可以包含多个组件，例如 <code>_cluster/stats</code> 或者 <code>_nodes/stats/jvm</code></li>
<li><code>QUERY_STRING</code>：一些可选的查询请求参数，例如？pretty 参数将使请求返回更加美观易读的 JSON 数据</li>
<li><code>BODY</code>：一个 JSON 格式的请求主体（如果请求需要的话）</li>
</ul>
<p>ElasticSearch Rest API 分为两种：</p>
<ul>
<li><strong>URI Search</strong>：在 URL 中使用查询参数</li>
<li><strong>Request Body Search</strong>：基于 JSON 格式的、更加完备的 DSL</li>
</ul>
<p>URI Search 示例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220530072511.png"></p>
<p>Request Body Search 示例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220530072654.png"></p>
<h3 id="索引-API"><a href="#索引-API" class="headerlink" title="索引 API"></a>索引 API</h3><blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-indices.html">Elasticsearch 官方之 cat 索引 API</a></p>
</blockquote>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>新建 Index，可以直接向 ES 服务器发出 <code>PUT</code> 请求。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123; ... any settings ... &#125;,</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type_one&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        <span class="string">&quot;type_two&quot;</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /user</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;number_of_shards&quot;</span>: 3,</span><br><span class="line">      <span class="string">&quot;number_of_replicas&quot;</span>: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器返回一个 JSON 对象，里面的 <code>acknowledged</code> 字段表示操作成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;index&quot;</span>:<span class="string">&quot;user&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想禁止自动创建索引，可以通过在 <code>config/elasticsearch.yml</code> 的每个节点下添加下面的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.<span class="property">auto_create_index</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>然后，我们可以通过发送 <code>DELETE</code> 请求，删除这个 Index。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /user</span><br></pre></td></tr></table></figure>

<p>删除多个索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /index_one,index_two</span><br><span class="line"><span class="variable constant_">DELETE</span> /index_*</span><br></pre></td></tr></table></figure>

<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>可以通过 GET 请求查看索引信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看索引相关信息</span></span><br><span class="line">GET kibana_sample_data_ecommerce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引的文档总数</span></span><br><span class="line">GET kibana_sample_data_ecommerce/_count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看前 10 条文档，了解文档格式</span></span><br><span class="line">GET kibana_sample_data_ecommerce/_search</span><br><span class="line"></span><br><span class="line"><span class="comment"># _cat indices API</span></span><br><span class="line"><span class="comment"># 查看 indices</span></span><br><span class="line">GET /_cat/indices/kibana*?v&amp;s=index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态为绿的索引</span></span><br><span class="line">GET /_cat/indices?v&amp;health=green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照文档个数排序</span></span><br><span class="line">GET /_cat/indices?v&amp;s=docs.count:desc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看具体的字段</span></span><br><span class="line">GET /_cat/indices/kibana*?pri&amp;v&amp;h=health,index,pri,rep,docs.count,mt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引占用的内存</span></span><br><span class="line">GET /_cat/indices?v&amp;h=i,tm&amp;s=tm:desc</span><br></pre></td></tr></table></figure>

<h3 id="索引别名"><a href="#索引别名" class="headerlink" title="索引别名"></a>索引别名</h3><p>ES 的索引别名就是给一个索引或者多个索引起的另一个名字，典型的应用场景是针对索引使用的平滑切换。</p>
<p>首先，创建索引 my_index，然后将别名 my_alias 指向它，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">PUT /my_index/_alias/my_alias</span><br></pre></td></tr></table></figure>

<p>也可以通过如下形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;add&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在一次请求中增加别名和移除别名混合使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;remove&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">    &#123; <span class="string">&quot;add&quot;</span>: &#123; <span class="string">&quot;index&quot;</span>: <span class="string">&quot;my_index_v2&quot;</span>, <span class="string">&quot;alias&quot;</span>: <span class="string">&quot;my_alias&quot;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果别名与索引是一对一的，使用别名索引文档或者查询文档是可以的，但是如果别名和索引是一对多的，使用别名会发生错误，因为 ES 不知道把文档写入哪个索引中去或者从哪个索引中读取文档。</p>
</blockquote>
<p>ES 索引别名有个典型的应用场景是平滑切换，更多细节可以查看 <a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/elasticsearch-index-smooth-shift.html">Elasticsearch（ES）索引零停机（无需重启）无缝平滑切换的方法</a>。</p>
<h3 id="打开-关闭索引"><a href="#打开-关闭索引" class="headerlink" title="打开&#x2F;关闭索引"></a>打开&#x2F;关闭索引</h3><p>通过在 <code>POST</code> 中添加 <code>_close</code> 或 <code>_open</code> 可以打开、关闭索引。</p>
<p>打开索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开索引</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_open</span><br><span class="line"><span class="comment"># 关闭索引</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_close</span><br></pre></td></tr></table></figure>

<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############Create Document############</span></span><br><span class="line"><span class="comment">#create document. 自动生成 _id</span></span><br><span class="line">POST <span class="built_in">users</span>/_doc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;user&quot;</span> : <span class="string">&quot;Mike&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post_date&quot;</span> : <span class="string">&quot;2019-04-15T14:12:12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span> : <span class="string">&quot;trying out Kibana&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#create document. 指定 Id。如果 id 已经存在，报错</span></span><br><span class="line">PUT <span class="built_in">users</span>/_doc/1?op_type=create</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span> : <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post_date&quot;</span> : <span class="string">&quot;2019-05-15T14:12:12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span> : <span class="string">&quot;trying out Elasticsearch&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#create document. 指定 ID 如果已经存在，就报错</span></span><br><span class="line">PUT <span class="built_in">users</span>/_create/1</span><br><span class="line">&#123;</span><br><span class="line">     <span class="string">&quot;user&quot;</span> : <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post_date&quot;</span> : <span class="string">&quot;2019-05-15T14:12:12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span> : <span class="string">&quot;trying out Elasticsearch&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Get Document by ID</span></span><br><span class="line"><span class="comment">#Get the document by ID</span></span><br><span class="line">GET <span class="built_in">users</span>/_doc/1</span><br><span class="line"></span><br><span class="line"><span class="comment">###  Index &amp; Update</span></span><br><span class="line"><span class="comment">#Update 指定 ID  （先删除，在写入）</span></span><br><span class="line">GET <span class="built_in">users</span>/_doc/1</span><br><span class="line"></span><br><span class="line">PUT <span class="built_in">users</span>/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;user&quot;</span> : <span class="string">&quot;Mike&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#GET users/_doc/1</span></span><br><span class="line"><span class="comment">#在原文档上增加字段</span></span><br><span class="line">POST <span class="built_in">users</span>/_update/1/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;post_date&quot;</span> : <span class="string">&quot;2019-05-15T14:12:12&quot;</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span> : <span class="string">&quot;trying out Elasticsearch&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Delete by Id</span></span><br><span class="line"><span class="comment"># 删除文档</span></span><br><span class="line">DELETE <span class="built_in">users</span>/_doc/1</span><br><span class="line"></span><br><span class="line"><span class="comment">### Bulk 操作</span></span><br><span class="line"><span class="comment">#执行两次，查看每次的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行第 1 次</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行第 2 次</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### mget 操作</span></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#URI 中指定 index</span></span><br><span class="line">GET /test/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : [<span class="string">&quot;field3&quot;</span>, <span class="string">&quot;field4&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">                <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;user&quot;</span>],</span><br><span class="line">                <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;user.location&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### msearch 操作</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_msearch</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span> : &#123;<span class="string">&quot;match_all&quot;</span> : &#123;&#125;&#125;,<span class="string">&quot;size&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span> : <span class="string">&quot;kibana_sample_data_flights&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span> : &#123;<span class="string">&quot;match_all&quot;</span> : &#123;&#125;&#125;,<span class="string">&quot;size&quot;</span>:2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 清除测试数据</span></span><br><span class="line"><span class="comment">#清除数据</span></span><br><span class="line">DELETE <span class="built_in">users</span></span><br><span class="line">DELETE <span class="built_in">test</span></span><br><span class="line">DELETE test2</span><br></pre></td></tr></table></figure>

<h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><h4 id="指定-ID"><a href="#指定-ID" class="headerlink" title="指定 ID"></a>指定 ID</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /_index/_type/_create/_id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /user/_doc/_create/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：指定 Id，如果 id 已经存在，则报错</p>
</blockquote>
<h4 id="自动生成-ID"><a href="#自动生成-ID" class="headerlink" title="自动生成 ID"></a>自动生成 ID</h4><p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /_index/_type</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /user/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;超级管理员&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /_index/_doc/_id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /user/_doc/1</span><br></pre></td></tr></table></figure>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="先删除，再写入"><a href="#先删除，再写入" class="headerlink" title="先删除，再写入"></a>先删除，再写入</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /_index/_type/_id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /user/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;超级管理员&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在原文档上增加字段"><a href="#在原文档上增加字段" class="headerlink" title="在原文档上增加字段"></a>在原文档上增加字段</h4><p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /_index/_update/_id</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /user/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;age&quot;</span> : <span class="string">&quot;30&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="指定-ID-查询"><a href="#指定-ID-查询" class="headerlink" title="指定 ID 查询"></a>指定 ID 查询</h4><p>语法格式：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GET</span> /<span class="variable">_index</span>/<span class="variable">_type</span>/<span class="variable">_id</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /user/_doc/1</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span><span class="punctuation">:</span> <span class="number">536248</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;found&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>返回的数据中，<code>found</code> 字段表示查询成功，<code>_source</code> 字段返回原始记录。</p>
<p>如果 id 不正确，就查不到数据，<code>found</code> 字段就是 <code>false</code></p>
<h4 id="查询所有记录"><a href="#查询所有记录" class="headerlink" title="查询所有记录"></a>查询所有记录</h4><p>使用 <code>GET</code> 方法，直接请求 <code>/index/type/_search</code>，就会返回所有记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/user/admin/_search?pretty&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span> : 1,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : 3,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span> : 3,</span><br><span class="line">    <span class="string">&quot;skipped&quot;</span> : 0,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span> : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : 2,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span> : 1.0,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;WWuoDG8BHwECs7SiYn93&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span> : 1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;系统管理&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span> : 1.0,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;超级管理员&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p>
<ul>
<li><code>total</code>：返回记录数，本例是 2 条。</li>
<li><code>max_score</code>：最高的匹配程度，本例是<code>1.0</code>。</li>
<li><code>hits</code>：返回的记录组成的数组。</li>
</ul>
<p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>ES 的查询非常特别，使用自己的 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> <span class="string">&#x27;localhost:9200/user/admin/_search?pretty&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html">Match 查询</a>，指定的匹配条件是<code>desc</code>字段里面包含”软件”这个词。返回结果如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span> : <span class="number">0.38200712</span>,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;WWuoDG8BHwECs7SiYn93&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span> : <span class="number">0.38200712</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;系统管理&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span> : <span class="number">0.3487891</span>,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;user&quot;</span> : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">          <span class="string">&quot;title&quot;</span> : <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;超级管理员&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Elastic 默认一次返回 10 条结果，可以通过<code>size</code>字段改变这个设置，还可以通过<code>from</code>字段，指定位移。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/user/admin/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;from&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码指定，从位置 1 开始（默认是从位置 0 开始），只返回一条结果。</p>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/user/admin/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码搜索的是<code>软件 or 系统</code>。</p>
<p>如果要执行多个关键词的<code>and</code>搜索，必须使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html">布尔查询</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> <span class="string">&#x27;localhost:9200/user/admin/_search?pretty&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">  &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="string">   &quot;must&quot;: [</span></span><br><span class="line"><span class="string">    &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;管理&quot; &#125; &#125;,</span></span><br><span class="line"><span class="string">    &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;超级&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">   ]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h3><p>支持在一次 API 调用中，对不同的索引进行操作</p>
<p>支持四种类型操作</p>
<ul>
<li>index</li>
<li>create</li>
<li>update</li>
<li>delete</li>
</ul>
<p>操作中单条操作失败，并不会影响其他操作。</p>
<p>返回结果包括了每一条操作执行的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上面的示例如果执行多次，执行结果都不一样。</p>
</blockquote>
<h3 id="批量读取"><a href="#批量读取" class="headerlink" title="批量读取"></a>批量读取</h3><p>读多个索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读一个索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;docs&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : [<span class="string">&quot;field3&quot;</span>, <span class="string">&quot;field4&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span> : &#123;</span><br><span class="line">                <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;user&quot;</span>],</span><br><span class="line">                <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;user.location&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST kibana_sample_data_ecommerce/_msearch</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span> : &#123;<span class="string">&quot;match_all&quot;</span> : &#123;&#125;&#125;,<span class="string">&quot;size&quot;</span>:1&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span> : <span class="string">&quot;kibana_sample_data_flights&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span> : &#123;<span class="string">&quot;match_all&quot;</span> : &#123;&#125;&#125;,<span class="string">&quot;size&quot;</span>:2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URI-Search-查询语义"><a href="#URI-Search-查询语义" class="headerlink" title="URI Search 查询语义"></a>URI Search 查询语义</h3><p>Elasticsearch URI Search 遵循 QueryString 查询语义，其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /movies/_search?q=2012&amp;<span class="built_in">df</span>=title&amp;<span class="built_in">sort</span>=year:desc&amp;from=0&amp;size=10&amp;<span class="built_in">timeout</span>=1s</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>q</code></strong> 指定查询语句，使用 QueryString 语义</li>
<li><strong><code>df</code></strong> 默认字段，不指定时</li>
<li><strong><code>sort</code></strong> 排序：from 和 size 用于分页</li>
<li><strong><code>profile</code></strong> 可以查看查询时如何被执行的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /movies/_search?q=title:2012&amp;<span class="built_in">sort</span>=year:desc&amp;from=0&amp;size=10&amp;<span class="built_in">timeout</span>=1s</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Term-和-Phrase"><a href="#Term-和-Phrase" class="headerlink" title="Term 和 Phrase"></a>Term 和 Phrase</h4><p>Beautiful Mind 等效于 Beautiful OR Mind</p>
<p>“Beautiful Mind” 等效于 Beautiful AND Mind</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Term 查询</span></span><br><span class="line">GET /movies/_search?q=title:Beautiful Mind</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用引号，Phrase 查询</span></span><br><span class="line">GET /movies/_search?q=title:<span class="string">&quot;Beautiful Mind&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分组与引号"><a href="#分组与引号" class="headerlink" title="分组与引号"></a>分组与引号</h4><p>title:(Beautiful AND Mind)</p>
<p>title&#x3D;”Beautiful Mind”</p>
<h4 id="AND、OR、NOT-或者-、-、"><a href="#AND、OR、NOT-或者-、-、" class="headerlink" title="AND、OR、NOT 或者 &amp;&amp;、||、!"></a>AND、OR、NOT 或者 &amp;&amp;、||、!</h4><blockquote>
<p>注意：AND、OR、NOT 必须大写</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔操作符</span></span><br><span class="line">GET /movies/_search?q=title:(Beautiful AND Mind)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:(Beautiful NOT Mind)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><ul>
<li><code>[]</code> 表示闭区间</li>
<li><code>&#123;&#125;</code> 表示开区间</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范围查询 , 区间写法</span></span><br><span class="line">GET /movies/_search?q=title:beautiful AND year:&#123;2010 TO 2018%7D</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:beautiful AND year:[* TO 2018]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算数符号"><a href="#算数符号" class="headerlink" title="算数符号"></a>算数符号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2010 年以后的记录</span></span><br><span class="line">GET /movies/_search?q=year:&gt;2010</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2010 年到 2018 年的记录</span></span><br><span class="line">GET /movies/_search?q=year:(&gt;2010 &amp;&amp; &lt;=2018)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2010 年到 2018 年的记录</span></span><br><span class="line">GET /movies/_search?q=year:(+&gt;2010 +&lt;=2018)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h4><ul>
<li><code>?</code> 代表 1 个字符</li>
<li><code>*</code> 代表 0 或多个字符</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /movies/_search?q=title:mi?d</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:b*</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>title:[bt]oy</p>
<h4 id="模糊匹配与近似查询"><a href="#模糊匹配与近似查询" class="headerlink" title="模糊匹配与近似查询"></a>模糊匹配与近似查询</h4><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相似度在 1 个字符以内</span></span><br><span class="line">GET /movies/_search?q=title:beautifl~1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相似度在 2 个字符以内</span></span><br><span class="line">GET /movies/_search?q=title:<span class="string">&quot;Lord Rings&quot;</span>~2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Request-Body-DSL"><a href="#Request-Body-DSL" class="headerlink" title="Request Body &amp; DSL"></a>Request Body &amp; DSL</h3><p>Elasticsearch 除了 URI Search 查询方式，还支持将查询语句通过 Http Request Body 发起查询。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;profile&quot;</span>:<span class="string">&quot;true&quot;</span>,</span><br><span class="line">	<span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">	  <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;profile&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 10,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>最好在数字型或日期型字段上排序</p>
<p>因为对于多值类型或分析过的字段排序，系统会选一个值，无法得知该值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;profile&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;order_date&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 10,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="source-过滤"><a href="#source-过滤" class="headerlink" title="_source 过滤"></a>_source 过滤</h4><p>如果 <code>_source</code> 没有存储，那就只返回匹配的文档的元数据</p>
<p><code>_source</code> 支持使用通配符，如：<code>_source[&quot;name*&quot;, &quot;desc*&quot;]</code></p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;profile&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_source&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;order_date&quot;</span>,</span><br><span class="line">    <span class="string">&quot;category.keyword&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 10,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;profile&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;new_field&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>:<span class="string">&quot;doc[&#x27;order_date&#x27;].value+&#x27; hello&#x27;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 10,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用查询表达式-Match"><a href="#使用查询表达式-Match" class="headerlink" title="使用查询表达式 - Match"></a>使用查询表达式 - Match</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;last christmas&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;last christmas&quot;</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="短语搜索-Match-Phrase"><a href="#短语搜索-Match-Phrase" class="headerlink" title="短语搜索 - Match Phrase"></a>短语搜索 - Match Phrase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;last christmas&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集群-API"><a href="#集群-API" class="headerlink" title="集群 API"></a>集群 API</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html">Elasticsearch 官方之 Cluster API</a></p>
</blockquote>
<p>一些集群级别的 API 可能会在节点的子集上运行，这些节点可以用节点过滤器指定。例如，任务管理、节点统计和节点信息 API 都可以报告来自一组过滤节点而不是所有节点的结果。</p>
<p>节点过滤器以逗号分隔的单个过滤器列表的形式编写，每个过滤器从所选子集中添加或删除节点。每个过滤器可以是以下之一：</p>
<ul>
<li><code>_all</code>：将所有节点添加到子集</li>
<li><code>_local</code>：将本地节点添加到子集</li>
<li><code>_master</code>：将当前主节点添加到子集</li>
<li>根据节点 ID 或节点名将匹配节点添加到子集</li>
<li>根据 IP 地址或主机名将匹配节点添加到子集</li>
<li>使用通配符，将节点名、地址名或主机名匹配的节点添加到子集</li>
<li><code>master:true</code>, <code>data:true</code>, <code>ingest:true</code>, <code>voting_only:true</code>, <code>ml:true</code> 或 <code>coordinating_only:true</code>, 分别意味着将所有主节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有协调节点添加到子集中。</li>
<li><code>master:false</code>, <code>data:false</code>, <code>ingest:false</code>, <code>voting_only:true</code>, <code>ml:false</code> 或 <code>coordinating_only:false</code>, 分别意味着将所有主节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有协调节点排除在子集外。</li>
<li>配对模式，使用 <code>*</code> 通配符，格式为 <code>attrname:attrvalue</code>，将所有具有自定义节点属性的节点添加到子集中，其名称和值与相应的模式匹配。自定义节点属性是通过 <code>node.attr.attrname: attrvalue</code> 形式在配置文件中设置的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果没有给出过滤器，默认是查询所有节点</span></span><br><span class="line">GET /_nodes</span><br><span class="line"><span class="comment"># 查询所有节点</span></span><br><span class="line">GET /_nodes/_all</span><br><span class="line"><span class="comment"># 查询本地节点</span></span><br><span class="line">GET /_nodes/_local</span><br><span class="line"><span class="comment"># 查询主节点</span></span><br><span class="line">GET /_nodes/_master</span><br><span class="line"><span class="comment"># 根据名称查询节点（支持通配符）</span></span><br><span class="line">GET /_nodes/node_name_goes_here</span><br><span class="line">GET /_nodes/node_name_goes_*</span><br><span class="line"><span class="comment"># 根据地址查询节点（支持通配符）</span></span><br><span class="line">GET /_nodes/10.0.0.3,10.0.0.4</span><br><span class="line">GET /_nodes/10.0.0.*</span><br><span class="line"><span class="comment"># 根据规则查询节点</span></span><br><span class="line">GET /_nodes/_all,master:<span class="literal">false</span></span><br><span class="line">GET /_nodes/data:<span class="literal">true</span>,ingest:<span class="literal">true</span></span><br><span class="line">GET /_nodes/coordinating_only:<span class="literal">true</span></span><br><span class="line">GET /_nodes/master:<span class="literal">true</span>,voting_only:<span class="literal">false</span></span><br><span class="line"><span class="comment"># 根据自定义属性查询节点（如：查询配置文件中含 node.attr.rack:2 属性的节点）</span></span><br><span class="line">GET /_nodes/rack:2</span><br><span class="line">GET /_nodes/ra*:2</span><br><span class="line">GET /_nodes/ra*:2*</span><br></pre></td></tr></table></figure>

<h3 id="集群健康-API"><a href="#集群健康-API" class="headerlink" title="集群健康 API"></a>集群健康 API</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br><span class="line">GET /_cluster/health?level=shards</span><br><span class="line">GET /_cluster/health/kibana_sample_data_ecommerce,kibana_sample_data_flights</span><br><span class="line">GET /_cluster/health/kibana_sample_data_flights?level=shards</span><br></pre></td></tr></table></figure>

<h3 id="集群状态-API"><a href="#集群状态-API" class="headerlink" title="集群状态 API"></a>集群状态 API</h3><p>集群状态 API 返回表示整个集群状态的元数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/state</span><br></pre></td></tr></table></figure>

<h3 id="节点-API"><a href="#节点-API" class="headerlink" title="节点 API"></a>节点 API</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodes.html">Elasticsearch 官方之 cat Nodes API</a>——返回有关集群节点的信息。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认的字段</span></span><br><span class="line">GET /_cat/nodes?v=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 查看指定的字段</span></span><br><span class="line">GET /_cat/nodes?v=<span class="literal">true</span>&amp;h=<span class="built_in">id</span>,ip,port,v,m</span><br></pre></td></tr></table></figure>

<h3 id="分片-API"><a href="#分片-API" class="headerlink" title="分片 API"></a>分片 API</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html">Elasticsearch 官方之 cat Shards API</a>——shards 命令是哪些节点包含哪些分片的详细视图。它会告诉你它是主还是副本、文档数量、它在磁盘上占用的字节数以及它所在的节点。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认的字段</span></span><br><span class="line">GET /_cat/shards</span><br><span class="line"><span class="comment"># 根据名称查询分片（支持通配符）</span></span><br><span class="line">GET /_cat/shards/my-index-*</span><br><span class="line"><span class="comment"># 查看指定的字段</span></span><br><span class="line">GET /_cat/shards?h=index,shard,prirep,state,unassigned.reason</span><br></pre></td></tr></table></figure>

<h3 id="监控-API"><a href="#监控-API" class="headerlink" title="监控 API"></a>监控 API</h3><p>Elasticsearch 中集群相关的健康、统计等相关的信息都是围绕着 <code>cat</code> API 进行的。</p>
<p>通过 GET 请求发送 cat，下面列出了所有可用的 API：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat</span><br><span class="line"></span><br><span class="line">=^.^=</span><br><span class="line">/_cat/allocation</span><br><span class="line">/_cat/shards</span><br><span class="line">/_cat/shards/&#123;index&#125;</span><br><span class="line">/_cat/master</span><br><span class="line">/_cat/nodes</span><br><span class="line">/_cat/tasks</span><br><span class="line">/_cat/indices</span><br><span class="line">/_cat/indices/&#123;index&#125;</span><br><span class="line">/_cat/segments</span><br><span class="line">/_cat/segments/&#123;index&#125;</span><br><span class="line">/_cat/count</span><br><span class="line">/_cat/count/&#123;index&#125;</span><br><span class="line">/_cat/recovery</span><br><span class="line">/_cat/recovery/&#123;index&#125;</span><br><span class="line">/_cat/health</span><br><span class="line">/_cat/pending_tasks</span><br><span class="line">/_cat/aliases</span><br><span class="line">/_cat/aliases/&#123;<span class="built_in">alias</span>&#125;</span><br><span class="line">/_cat/thread_pool</span><br><span class="line">/_cat/thread_pool/&#123;thread_pools&#125;</span><br><span class="line">/_cat/plugins</span><br><span class="line">/_cat/fielddata</span><br><span class="line">/_cat/fielddata/&#123;fields&#125;</span><br><span class="line">/_cat/nodeattrs</span><br><span class="line">/_cat/repositories</span><br><span class="line">/_cat/snapshots/&#123;repository&#125;</span><br><span class="line">/_cat/templates</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#elasticsearch.clients">https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#elasticsearch.clients</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6fd84297/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6fd84297/" class="post-title-link" itemprop="url">Elasticsearch CRUD</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-CRUD"><a href="#Elasticsearch-CRUD" class="headerlink" title="Elasticsearch CRUD"></a>Elasticsearch CRUD</h1><p>::: info 概述</p>
<p><strong>CRUD</strong> 由英文单词 <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete 的首字母组成，即<strong>增删改查</strong>。</p>
<p>本文通过介绍基本的 Elasticsearch CRUD 方法，向读者呈现如何访问 Elasticsearch 数据。<br>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/6fd84297/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/86b2f921/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/86b2f921/" class="post-title-link" itemprop="url">Elasticsearch 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h1><p>::: info 概述</p>
<p>Elasticsearch 是一个基于 Lucene 的搜索和数据分析工具，它提供了一个分布式服务。Elasticsearch 是遵从 Apache 开源条款的一款开源产品，是当前主流的企业级搜索引擎。</p>
<p>本文简单介绍了 Elasticsearch 的功能、特性、简史、概念，可以让读者在短时间内对于 Elasticsearch 有一个初步的认识。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/86b2f921/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/35fdbdda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/35fdbdda/" class="post-title-link" itemprop="url">Elasticsearch 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-运维"><a href="#Elasticsearch-运维" class="headerlink" title="Elasticsearch 运维"></a>Elasticsearch 运维</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a> 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
</blockquote>
<h2 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch 官方下载安装说明</a></p>
</blockquote>
<p>（1）下载解压</p>
<p>访问 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/elasticsearch">官方下载地址</a> ，选择需要的版本，下载解压到本地。</p>
<p>（2）运行</p>
<p>运行 <code>bin/elasticsearch</code> (Windows 系统上运行 <code>bin\elasticsearch.bat</code> )</p>
<p>（3）访问</p>
<p>执行 <code>curl http://localhost:9200/</code> 测试服务是否启动</p>
<h2 id="Elasticsearch-集群规划"><a href="#Elasticsearch-集群规划" class="headerlink" title="Elasticsearch 集群规划"></a>Elasticsearch 集群规划</h2><p>ElasticSearch 集群需要根据业务实际情况去合理规划。</p>
<p>需要考虑的问题点：</p>
<ul>
<li>集群部署几个节点？</li>
<li>有多少个索引？</li>
<li>每个索引有多大数据量？</li>
<li>每个索引有多少个分片？</li>
</ul>
<p>一个参考规划：</p>
<ul>
<li>3 台机器，每台机器是 6 核 64G 的。</li>
<li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li>
<li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li>
</ul>
<h2 id="Elasticsearch-配置"><a href="#Elasticsearch-配置" class="headerlink" title="Elasticsearch 配置"></a>Elasticsearch 配置</h2><p>ES 的默认配置文件为 <code>config/elasticsearch.yml</code></p>
<p>基本配置说明如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="comment">#配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">&#x27;Franz Kafka&#x27;</span></span><br><span class="line"><span class="comment">#节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#指定该节点是否存储索引数据，默认为true。</span></span><br><span class="line"><span class="attr">index.number_of_shards:</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#设置默认索引分片个数，默认为5片。</span></span><br><span class="line"><span class="attr">index.number_of_replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#设置默认索引副本个数，默认为1个副本。</span></span><br><span class="line"><span class="attr">path.conf:</span> <span class="string">/path/to/conf</span></span><br><span class="line"><span class="comment">#设置配置文件的存储路径，默认是es根目录下的config文件夹。</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/path/to/data</span></span><br><span class="line"><span class="comment">#设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：</span></span><br><span class="line"><span class="comment">#path.data: /path/to/data1,/path/to/data2</span></span><br><span class="line"><span class="attr">path.work:</span> <span class="string">/path/to/work</span></span><br><span class="line"><span class="comment">#设置临时文件的存储路径，默认是es根目录下的work文件夹。</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/path/to/logs</span></span><br><span class="line"><span class="comment">#设置日志文件的存储路径，默认是es根目录下的logs文件夹</span></span><br><span class="line"><span class="attr">path.plugins:</span> <span class="string">/path/to/plugins</span></span><br><span class="line"><span class="comment">#设置插件的存放路径，默认是es根目录下的plugins文件夹</span></span><br><span class="line"><span class="attr">bootstrap.mlockall:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把#ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要#允许elasticsearch的进程可以锁住内存，linux下可以通过`ulimit -l unlimited`命令。</span></span><br><span class="line"><span class="attr">network.bind_host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。</span></span><br><span class="line"><span class="attr">network.publish_host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#这个参数是用来同时设置bind_host和publish_host上面两个参数。</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#设置节点间交互的tcp端口，默认是9300。</span></span><br><span class="line"><span class="attr">transport.tcp.compress:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#设置是否压缩tcp传输时的数据，默认为false，不压缩。</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#设置对外服务的http端口，默认为9200。</span></span><br><span class="line"><span class="attr">http.max_content_length:</span> <span class="string">100mb</span></span><br><span class="line"><span class="comment">#设置内容的最大容量，默认100mb</span></span><br><span class="line"><span class="attr">http.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#是否使用http协议对外提供服务，默认为true，开启。</span></span><br><span class="line"><span class="attr">gateway.type:</span> <span class="string">local</span></span><br><span class="line"><span class="comment">#gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的#HDFS，和amazon的s3服务器，其它文件系统的设置方法下次再详细说。</span></span><br><span class="line"><span class="attr">gateway.recover_after_nodes:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#设置集群中N个节点启动时进行数据恢复，默认为1。</span></span><br><span class="line"><span class="attr">gateway.recover_after_time:</span> <span class="string">5m</span></span><br><span class="line"><span class="comment">#设置初始化数据恢复进程的超时时间，默认是5分钟。</span></span><br><span class="line"><span class="attr">gateway.expected_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#设置这个集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复。</span></span><br><span class="line"><span class="attr">cluster.routing.allocation.node_initial_primaries_recoveries:</span> <span class="number">4</span></span><br><span class="line"><span class="comment">#初始化数据恢复时，并发恢复线程的个数，默认为4。</span></span><br><span class="line"><span class="attr">cluster.routing.allocation.node_concurrent_recoveries:</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#添加删除节点或负载均衡时并发恢复线程的个数，默认为4。</span></span><br><span class="line"><span class="attr">indices.recovery.max_size_per_sec:</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。</span></span><br><span class="line"><span class="attr">indices.recovery.concurrent_streams:</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）</span></span><br><span class="line"><span class="attr">discovery.zen.ping.timeout:</span> <span class="string">3s</span></span><br><span class="line"><span class="comment">#设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。</span></span><br><span class="line"><span class="attr">discovery.zen.ping.multicast.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#设置是否打开多播发现节点，默认是true。</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&#x27;host1&#x27;</span>, <span class="string">&#x27;host2:port&#x27;</span>, <span class="string">&#x27;host3[portX-portY]&#x27;</span>]</span><br><span class="line"><span class="comment">#设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。</span></span><br></pre></td></tr></table></figure>

<h2 id="Elasticsearch-FAQ"><a href="#Elasticsearch-FAQ" class="headerlink" title="Elasticsearch FAQ"></a>Elasticsearch FAQ</h2><h3 id="elasticsearch-不允许以-root-权限来运行"><a href="#elasticsearch-不允许以-root-权限来运行" class="headerlink" title="elasticsearch 不允许以 root 权限来运行"></a>elasticsearch 不允许以 root 权限来运行</h3><p><strong>问题：</strong>在 Linux 环境中，elasticsearch 不允许以 root 权限来运行。</p>
<p>如果以 root 身份运行 elasticsearch，会提示这样的错误：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can<span class="built_in"> not</span> run elasticsearch <span class="keyword">as</span><span class="built_in"> root</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong>使用非 root 权限账号运行 elasticsearch</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户组</span></span><br><span class="line">groupadd elk</span><br><span class="line"><span class="comment"># 创建新用户，-g elk 设置其用户组为 elk，-p elk 设置其密码为 elk</span></span><br><span class="line">useradd elk -g elk -p elk</span><br><span class="line"><span class="comment"># 更改 /opt 文件夹及内部文件的所属用户及组为 elk:elk</span></span><br><span class="line"><span class="built_in">chown</span> -R elk:elk /opt <span class="comment"># 假设你的 elasticsearch 安装在 opt 目录下</span></span><br><span class="line"><span class="comment"># 切换账号</span></span><br><span class="line">su elk</span><br></pre></td></tr></table></figure>

<h3 id="vm-max-map-count-不低于-262144"><a href="#vm-max-map-count-不低于-262144" class="headerlink" title="vm.max_map_count 不低于 262144"></a>vm.max_map_count 不低于 262144</h3><p><strong>问题：</strong><code>vm.max_map_count</code> 表示虚拟内存大小，它是一个内核参数。elasticsearch 默认要求 <code>vm.max_map_count</code> 不低于 262144。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span> virtual memory areas <span class="keyword">vm</span>.max_map_count [<span class="number">65530</span>] <span class="keyword">is</span> too low, increase <span class="keyword">to</span> at least [<span class="number">262144</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>你可以执行以下命令，设置 <code>vm.max_map_count</code> ，但是重启后又会恢复为原值。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.<span class="attribute">max_map_count</span>=262144</span><br></pre></td></tr></table></figure>

<p>持久性的做法是在 <code>/etc/sysctl.conf</code> 文件中修改 <code>vm.max_map_count</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vm.max_map_count=262144&quot;</span> &gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>如果运行环境为 docker 容器，可能会限制执行 sysctl 来修改内核参数。</p>
<p>这种情况下，你只能选择直接修改宿主机上的参数了。</p>
</blockquote>
<h3 id="nofile-不低于-65536"><a href="#nofile-不低于-65536" class="headerlink" title="nofile 不低于 65536"></a>nofile 不低于 65536</h3><p><strong>问题：</strong> <code>nofile</code> 表示进程允许打开的最大文件数。elasticsearch 进程要求可以打开的最大文件数不低于 65536。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span> <span class="built_in">file</span> descriptors [<span class="number">4096</span>] <span class="keyword">for</span> elasticsearch <span class="built_in">process</span> is too low, increase <span class="built_in">to</span> <span class="keyword">at</span> least [<span class="number">65536</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>在 <code>/etc/security/limits.conf</code> 文件中修改 <code>nofile</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 65536&quot;</span> &gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 131072&quot;</span> &gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<h3 id="nproc-不低于-2048"><a href="#nproc-不低于-2048" class="headerlink" title="nproc 不低于 2048"></a>nproc 不低于 2048</h3><p><strong>问题：</strong> <code>nproc</code> 表示最大线程数。elasticsearch 要求最大线程数不低于 2048。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max<span class="built_in"> number</span> <span class="keyword">of</span> threads [<span class="number">1024</span>] <span class="keyword">for</span> user [user] <span class="literal">is</span> too low, increase <span class="keyword">to</span> <span class="keyword">at</span> <span class="keyword">least</span> [<span class="number">2048</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>在 <code>/etc/security/limits.conf</code> 文件中修改 <code>nproc</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nproc 2048&quot;</span> &gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nproc 4096&quot;</span> &gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch 官方下载安装说明</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rpm.html#rpm">Install Elasticsearch with RPM</a></li>
<li><a target="_blank" rel="noopener" href="http://siye1982.github.io/2015/09/17/es-optimize/">Elasticsearch 使用积累</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/be9ae09c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/be9ae09c/" class="post-title-link" itemprop="url">Elasticsearch 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/" itemprop="url" rel="index"><span itemprop="name">elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-面试"><a href="#Elasticsearch-面试" class="headerlink" title="Elasticsearch 面试"></a>Elasticsearch 面试</h1><h2 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro-what-is-es.html">Elasticsearch 官方文档之基础知识</a></li>
</ul>
</blockquote>
<h3 id="【简单】什么是-ES？"><a href="#【简单】什么是-ES？" class="headerlink" title="【简单】什么是 ES？"></a>【简单】什么是 ES？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411241734774.png" alt="Elasticsearch"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch"><strong>Elasticsearch</strong></a> 是一个开源的分布式<strong>搜索和分析引擎</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a> <strong>基于搜索库 <a target="_blank" rel="noopener" href="https://github.com/apache/lucene-solr">Lucene</a> 开发</strong>。Elasticsearch 隐藏了 Lucene 的复杂性，提供了简单易用的 REST API &#x2F; Java API 接口（另外还有其他语言的 API 接口）。</p>
<p>Elasticsearch 是<strong>面向文档</strong>的，它将复杂数据结构序列化为 <strong>JSON</strong> 形式存储。</p>
<p>Elasticsearch 提供<strong>近实时</strong>（Near Realtime，缩写 NRT）的<strong>全文搜索</strong>。近实时是指：</p>
<ul>
<li>从写入数据到数据可以被搜索，存在较小的延迟（大概是 1s）。</li>
<li>基于 Elasticsearch 执行搜索和分析可以达到秒级。</li>
</ul>
<h3 id="【简单】ES-有哪些应用场景？"><a href="#【简单】ES-有哪些应用场景？" class="headerlink" title="【简单】ES 有哪些应用场景？"></a>【简单】ES 有哪些应用场景？</h3><p>Elasticsearch 的主要功能如下：</p>
<ul>
<li><strong>海量数据的分布式存储及集群管理</strong></li>
<li><strong>提供丰富的近实时搜索能力</strong></li>
<li><strong>海量数据的近实时分析（聚合）</strong></li>
</ul>
<p>Elasticsearch 被广泛应用于以下场景：</p>
<ul>
<li><strong>搜索</strong><ul>
<li><strong>全文检索</strong> - Elasticsearch 通过快速搜索大型数据集，使复杂的搜索查询变得更加容易。它对于需要即时和相关搜索结果的网站、应用程序或企业特别有用。</li>
<li><strong>自动补全和拼写纠正</strong> - 可以在用户输入内容时，实时提供自动补全和拼写纠正，以增加用户体验并提高搜索效率。</li>
<li><strong>地理空间搜索</strong> - 使用地理空间查询搜索位置并计算空间关系。</li>
<li>近实时分析 - Elasticsearch 能够进行实时分析，使其适用于追踪实时数据的仪表板，例如用户活动、用户画像等，分析后进行推送。</li>
</ul>
</li>
<li><strong>可观测性</strong><ul>
<li><strong>日志、指标和链路追踪</strong> - 收集、存储和分析来自应用程序、系统和服务的日志、指标和追踪。</li>
<li><strong>性能监控</strong> - 监控和分析业务关键性能指标。</li>
<li><strong>OpenTelemetry</strong> - 使用 OpenTelemetry 标准，将遥测数据采集到 Elastic Stack。</li>
</ul>
</li>
</ul>
<h3 id="【简单】ES-有哪些里程碑版本？"><a href="#【简单】ES-有哪些里程碑版本？" class="headerlink" title="【简单】ES 有哪些里程碑版本？"></a>【简单】ES 有哪些里程碑版本？</h3><p>Elasticsearch 里程碑版本：</p>
<ul>
<li>1.0（2014 年）</li>
<li>5.0（2016 年）<ul>
<li>Lucene 6.x</li>
<li>默认打分机制从 TD-IDF 改为 BM25</li>
<li>增加 Keyword 类型</li>
</ul>
</li>
<li>6.0（2017 年）<ul>
<li>Lucene 7.x</li>
<li>跨集群复制</li>
<li>索引生命周期管理</li>
<li>SQL 的支持</li>
</ul>
</li>
<li>7.0（2019 年）<ul>
<li>Lucene 8.0</li>
<li>移除 Type</li>
<li>ECK （用于支持 K8S）</li>
<li>集群协调</li>
<li>High Level Rest Client</li>
<li>Script Score 查询</li>
</ul>
</li>
<li>8.0（2022 年）<ul>
<li>Lucene 9.0</li>
<li>向量搜索</li>
<li>支持 OpenTelemetry</li>
</ul>
</li>
</ul>
<h3 id="【简单】什么是-Elasic-Stack-ELK-？"><a href="#【简单】什么是-Elasic-Stack-ELK-？" class="headerlink" title="【简单】什么是 Elasic Stack(ELK)？"></a>【简单】什么是 Elasic Stack(ELK)？</h3><p>Elastic Stack 通常被用来作为日志采集、检索、可视化的解决方案。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411231210104.png" alt="ELK"></p>
<p>Elastic Stack 也常被称为 ELK，这是 Elastic 公司旗下三款产品 <a target="_blank" rel="noopener" href="https://www.elastic.co/elasticsearch">Elasticsearch</a> 、<a target="_blank" rel="noopener" href="https://www.elastic.co/products/logstash">Logstash</a> 、<a target="_blank" rel="noopener" href="https://www.elastic.co/kibana">Kibana</a> 的首字母组合。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/elasticsearch">Elasticsearch</a> 负责存储数据，并提供对数据的检索和分析。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/logstash">Logstash</a> 传输和处理你的日志、事务或其他数据。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/kibana">Kibana</a> 将 Elasticsearch 的数据分析并渲染为可视化的报表。</li>
</ul>
<p>Elastic Stack，在 ELK 的基础上扩展了一些新的产品。如：<a target="_blank" rel="noopener" href="https://www.elastic.co/beats">Beats</a>，这是针对不同类型数据的轻量级采集器套件。</p>
<p>此外，基于 Elastic Stack，其技术生态还可以和一些主流的分布式中间件进行集成，以应对各种不同的场景。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411231211496.png" alt="Elastic Stack"></p>
<h2 id="Elasticsearch-CRUD"><a href="#Elasticsearch-CRUD" class="headerlink" title="Elasticsearch CRUD"></a>Elasticsearch CRUD</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html">Elasticsearch 官方文档之 REST API</a></li>
</ul>
</blockquote>
<h3 id="【简单】如何在-ES-中-CRUD？"><a href="#【简单】如何在-ES-中-CRUD？" class="headerlink" title="【简单】如何在 ES 中 CRUD？"></a>【简单】如何在 ES 中 CRUD？</h3><p>Elasticsearch 的基本 CRUD 方式如下：</p>
<ul>
<li><strong>添加索引</strong><ul>
<li><code>PUT &lt;index&gt;/_create/&lt;id&gt;</code> - 指定 id，如果 id 已存在，报错</li>
<li><code>POST &lt;index&gt;/_doc</code> - 自动生成 <code>_id</code></li>
</ul>
</li>
<li><strong>删除索引</strong> - <code>DELETE /&lt;index&gt;？pretty</code></li>
<li><strong>更新索引</strong> - <code>POST &lt;index&gt;/_update/&lt;id&gt;</code></li>
<li><strong>查询索引</strong> - <code>GET &lt;index&gt;/_doc/&lt;id&gt;</code></li>
<li><strong>批量更新</strong> - <code>bulk</code> API 支持 <code>index/create/update/delete</code></li>
<li><strong>批量查询</strong> - <code>_mget</code> 和 <code>_msearch</code> 可以用于批量查询</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/quickstart.html">Quick starts</a></p>
</blockquote>
<h2 id="Elasticsearch-Mapping"><a href="#Elasticsearch-Mapping" class="headerlink" title="Elasticsearch Mapping"></a>Elasticsearch Mapping</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html">Elasticsearch 官方文档之 Mapping</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/351.html">Elasticsearch 从入门到实践之 Mapping</a></li>
</ul>
</blockquote>
<h3 id="【简单】ES-支持哪些数据类型？"><a href="#【简单】ES-支持哪些数据类型？" class="headerlink" title="【简单】ES 支持哪些数据类型？"></a>【简单】ES 支持哪些数据类型？</h3><p>Elasticsearch 支持丰富的数据类型，常见的有：</p>
<ul>
<li>文本类型：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html"><code>text</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html#keyword-field-type"><code>keyword</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html#constant-keyword-field-type"><code>constant_keyword</code></a>、 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html#wildcard-field-type"><code>wildcard</code></a></li>
<li>二进制类型：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/binary.html"><code>binary</code></a></li>
<li>数值类型：<code>long</code>、<code>float</code> 等</li>
<li>日期类型：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html"><code>date</code></a></li>
<li>布尔类型：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/boolean.html"><code>boolean</code></a></li>
<li>对象类型：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/object.html"><code>object</code></a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html"><code>nested</code></a></li>
</ul>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html">数据类型</a></p>
</blockquote>
<h3 id="【简单】ES-如何识别字段的数据类型？"><a href="#【简单】ES-如何识别字段的数据类型？" class="headerlink" title="【简单】ES 如何识别字段的数据类型？"></a>【简单】ES 如何识别字段的数据类型？</h3><p>在 Elasticsearch 中，<code>Mapping</code>（映射），用来定义一个文档以及其所包含的字段如何被存储和索引，可以在映射中事先定义字段的数据类型、字段的权重、分词器等属性，就如同在关系型数据库中创建数据表时会设置字段的类型。简言之，<strong>Mapping 定义了索引中的文档有哪些字段及其类型、这些字段是如何存储和索引的，就好像数据库的表定义一样。</strong></p>
<p>Mapping 会把 json 文档映射成 Lucene 所需要的扁平格式</p>
<p>一个 Mapping 属于一个索引的 Type</p>
<ul>
<li>每个文档都属于一个 Type</li>
<li>一个 Type 有一个 Mapping 定义</li>
<li>7.0 开始，不需要在 Mapping 定义中指定 type 信息</li>
</ul>
<p>每个 <code>document</code> 都是 <code>field</code> 的集合，每个 <code>field</code> 都有自己的数据类型。映射数据时，可以创建一个 <code>mapping</code>，其中包含与 <code>document</code> 相关的 <code>field</code> 列表。映射定义还包括元数据 <code>field</code>，例如 <code>_source</code> ，它自定义如何处理 <code>document</code> 的关联元数据。</p>
<p>在 Elasticsearch 中，映射可分为<strong>静态映射</strong>和<strong>动态映射</strong>。在关系型数据库中写入数据之前首先要建表，在建表语句中声明字段的属性，在 Elasticsearch 中，则不必如此，Elasticsearch 最重要的功能之一就是让你尽可能快地开始探索数据，文档写入 Elasticsearch 中，它会根据字段的类型自动识别，这种机制称为<strong>动态映射</strong>，而<strong>静态映射</strong>则是写入数据之前对字段的属性进行手工设置。</p>
<h4 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h4><p>Elasticsearch 官方将静态映射称为<strong>显式映射（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/explicit-mapping.html">Explicit mapping</a>）</strong>。<strong>静态映射</strong>是在创建索引时手工指定索引映射。静态映射和 SQL 中在建表语句中指定字段属性类似。相比动态映射，通过静态映射可以添加更详细、更精准的配置信息。</p>
<p>例如：</p>
<ul>
<li>哪些字符串字段应被视为全文字段。</li>
<li>哪些字段包含数字、日期或地理位置。</li>
<li>日期值的格式。</li>
<li>用于控制动态添加字段的自定义规则。</li>
</ul>
<p>【示例】创建索引时，显示指定 mapping</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my-index-<span class="number">000001</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:    &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:  &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>  &#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:   &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】在已存在的索引中，指定一个 field 的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my-index-<span class="number">000001</span>/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;employee-id&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】查看 mapping</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /my-index-000001/_mapping</span><br></pre></td></tr></table></figure>

<p>【示例】查看指定 field 的 mapping</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="keyword">my</span>-<span class="keyword">index</span>-<span class="number">000001</span>/_mapping/<span class="keyword">field</span>/employee-id</span><br></pre></td></tr></table></figure>

<h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><p>动态映射机制，允许用户不手动定义映射，Elasticsearch 会自动识别字段类型。在实际项目中，如果遇到的业务在导入数据之前不确定有哪些字段，也不清楚字段的类型是什么，使用动态映射非常合适。当 Elasticsearch 在文档中碰到一个以前没见过的字段时，它会利用动态映射来决定该字段的类型，并自动把该字段添加到映射中。</p>
<p>示例：创建一个名为 <code>data</code> 的索引、其 <code>mapping</code> 类型为 <code>_doc</code>，并且有一个类型为 <code>long</code> 的字段 <code>count</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT data/_doc/1</span><br><span class="line">&#123; <span class="string">&quot;count&quot;</span>: 5 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Elasticsearch-存储"><a href="#Elasticsearch-存储" class="headerlink" title="Elasticsearch 存储"></a>Elasticsearch 存储</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html">Elasticsearch 官方文档之索引</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/354.html">Elasticsearch 从入门到实践之倒排索引的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f">https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f</a></li>
</ul>
</blockquote>
<h3 id="【简单】ES-的逻辑存储是怎样设计的？"><a href="#【简单】ES-的逻辑存储是怎样设计的？" class="headerlink" title="【简单】ES 的逻辑存储是怎样设计的？"></a>【简单】ES 的逻辑存储是怎样设计的？</h3><p>Elasticsearch 的逻辑存储被设计为层级结构，自上而下依次为：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411260812733.png" alt="Elasticsearch 逻辑存储"></p>
<p>各层级结构的说明如下：</p>
<p>（1）<strong>Document（文档）</strong></p>
<p>Elasticsearch 是面向文档的，这意味着读写数据的最小单位是文档。Elasticsearch 以 JSON 文档的形式序列化和存储数据。文档是一组字段，这些字段是包含数据的键值对。每个文档都有一个唯一的 ID。</p>
<p>一个简单的 Elasticsearch 文档可能如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-first-elasticsearch-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DyFpo5EBxE8fzbb95DOa&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;found&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;john@smith.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;first_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bio&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Eco-warrior and defender of the weak&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;interests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dolphins&quot;</span><span class="punctuation">,</span> <span class="string">&quot;whales&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;join_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024/05/01&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Elasticsearch 中的 document 是无模式的，也就是并非所有 document 都必须拥有完全相同的字段，它们不受限于同一个模式。</p>
<p>（2）<strong>Field（字段）</strong></p>
<p>field 包含数据的键值对。默认情况下，Elasticsearch 对每个字段中的所有数据建立索引，并且每个索引字段都具有专用的优化数据结构。</p>
<p><code>document</code> 包含数据和元数据。<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html"><strong>Metadata Field（元数据字段）</strong></a> 是存储有关文档信息的系统字段。在 Elasticsearch 中，元数据字段都以 <code>_</code> 开头。常见的元数据字段有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index-field.html"><code>_index</code></a> - 文档所属的索引</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html"><code>_id</code></a> - 文档的 ID</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html"><code>_source</code></a> - 表示文档原文的 JSON</li>
</ul>
<p>（3）<strong>Type（类型）</strong></p>
<p>在 Elasticsearch 中，<strong>type 是 document 的逻辑分类</strong>。每个 index 里可以有一个或多个 type。</p>
<p>不同的 type 应该有相似的结构（schema）。举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。</p>
<blockquote>
<p>注意：Elasticsearch 7.x 版已彻底移除 type。</p>
</blockquote>
<p>（4）<strong>Index（索引）</strong></p>
<p>在 Elasticsearch 中，<strong>可以将 index 视为 document 的集合</strong>。</p>
<p>Elasticsearch 会为所有字段建立索引，经过处理后写入一个倒排索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elasticsearch 数据管理的顶层单位就叫做 Index。它是单个数据库的同义词。每个 Index 的名字必须是小写。</p>
<p>（5）Elasticsearch 概念和 RDBM 概念</p>
<table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>DB</th>
</tr>
</thead>
<tbody><tr>
<td>索引（index）</td>
<td>数据库（database）</td>
</tr>
<tr>
<td>类型（type，6.0 废弃，7.0 移除）</td>
<td>数据表（table）</td>
</tr>
<tr>
<td>文档（docuemnt）</td>
<td>行（row）</td>
</tr>
<tr>
<td>字符（field）</td>
<td>列（column）</td>
</tr>
<tr>
<td>映射（mapping）</td>
<td>表结构（schema）</td>
</tr>
</tbody></table>
<h3 id="【简单】ES-的物理存储是怎样设计的？"><a href="#【简单】ES-的物理存储是怎样设计的？" class="headerlink" title="【简单】ES 的物理存储是怎样设计的？"></a>【简单】ES 的物理存储是怎样设计的？</h3><p>Elasticsearch 的物理存储，天然使用了分布式设计。</p>
<p>每个 Elasticsearch 进程都从属于一个 cluster，一个 cluster 可以有一个或多个 node（即 Elasticsearch 进程）。</p>
<p>Elasticsearch 存储会将每个 index 分为多个 shard，而 shard 可以分布在集群中不同节点上。正是由于这个机制，使得 Elasticsearch 有了水平扩展的能力。shard 也是 Elasticsearch 将数据从一个节点迁移到拎一个节点的最小单位。</p>
<p>Elasticsearch 的每个 shard 对应一个 Lucene index（一个包含倒排索引的文件目录）。Lucene index 又会被分解为多个 segment。segment 是索引中的内部存储元素，由于写入效率的考虑，所以被设计为不可变更的。segment 会定期 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-merge.html">合并</a> 较大的 segment，以保持索引大小。简单来说，Lucene 就是一个 jar 包，里面包含了封装好的构建、管理倒排索引的算法代码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411260815446.png" alt="Elasticsearch 物理存储"></p>
<h3 id="【中等】什么是倒排索引？"><a href="#【中等】什么是倒排索引？" class="headerlink" title="【中等】什么是倒排索引？"></a>【中等】什么是倒排索引？</h3><p>既然有倒排索引，顾名思义，有与之相对的正排索引。这里，以实现一个诗词检索器为例，来说明一下正排索引和倒排索引的区别。</p>
<p><strong>正排索引是 ID 到数据的映射关系</strong>。如下所示，每首诗词用一个 ID 唯一识别。如果，我们要查找诗歌内容中是否包含某个关键字，就不得不在内容的完整文本中进行检索，效率很低。即使针对文档内容创建传统 RDBM 的索引（通常为 B+ 树结构），查找效率依然低下，并且会产生较大的额外存储空间开销。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>文档标题</th>
<th>文档内容</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>望月怀远</td>
<td>海上生明月，天涯共此时…</td>
</tr>
<tr>
<td>2</td>
<td>春江花月夜</td>
<td>春江潮水连海平，海上明月共潮生…</td>
</tr>
<tr>
<td>3</td>
<td>静夜思</td>
<td>床前明月光，疑是地上霜。举头望明月，低头思故乡。</td>
</tr>
<tr>
<td>4</td>
<td>锦瑟</td>
<td>沧海月明珠有泪，蓝田日暖玉生烟…</td>
</tr>
</tbody></table>
<p>倒排索引的实现与正排索引相反。<strong>将文本分词后保存为多个词项，词项到 ID 的映射关系称为倒排索引（Inverted index）</strong>。</p>
<table>
<thead>
<tr>
<th>词项</th>
<th>ID</th>
<th>词频</th>
</tr>
</thead>
<tbody><tr>
<td>月</td>
<td>1, 2, 3, 4</td>
<td>1：1 次、2：1 次、3：2 次、4：1 次</td>
</tr>
<tr>
<td>明月</td>
<td>1, 2, 3</td>
<td>1：1 次、2：1 次、3：2 次</td>
</tr>
<tr>
<td>海</td>
<td>1, 2, 4</td>
<td>1：1 次、2：1 次、4：1 次</td>
</tr>
</tbody></table>
<p>除了要保存词项与 ID 的关系外，还需要保存这个词项在对应文档出现的位置、偏移量等信息，这是因为很多检索的场景中还需要判断关键词前后的内容是否符合搜索要求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411260816781.png" alt="Elasticsearch 倒排索引"></p>
<p>有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>明月</code>，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li>
</ul>
<h3 id="【中等】什么是字典树？"><a href="#【中等】什么是字典树？" class="headerlink" title="【中等】什么是字典树？"></a>【中等】什么是字典树？</h3><p>Trie（字典树），也被称为前缀树，是一种树状数据结构，用于有效检索键值对。它通常用于实现字典和自动补全功能，使其成为许多搜索算法的基本组件。</p>
<p>Trie 遵循一个规则：如果两个字符串有共同的前缀，那么它们在 Trie 中将具有相同的祖先。</p>
<p>Trie 的检索能力也可以使用 Hash 替代，但是 Trie 比 Hash 更高效。此外，Trie 有 Hash 不具备的<strong>优点</strong>：Trie 支持前缀搜索和排序。Trie 的主要<strong>缺点</strong>是：存储词项需要额外的空间，对于长文本，空间可能会变得很大。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411301547515.png" alt="字典树"></p>
<h3 id="【困难】ES-如何实现倒排索引？"><a href="#【困难】ES-如何实现倒排索引？" class="headerlink" title="【困难】ES 如何实现倒排索引？"></a>【困难】ES 如何实现倒排索引？</h3><p>在 Elasticsearch 中，数据存储、检索实际上是基于 Lucene 实现。</p>
<p>一个 Elasticsearch shard 对应一个 Lucene index，</p>
<p>Elasticsearch 的每个 shard 对应一个 Lucene index（一个包含倒排索引的文件目录）。Lucene index 又会被分解为多个 segment。segment 是索引中的内部存储元素，由于写入效率的考虑，所以被设计为不可变更的。segment 会定期 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-merge.html">合并</a> 较大的 segment，以保持索引大小。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503110718277.png" alt="Elasticsearch 倒排索引"></p>
<p>倒排索引的组成主要有 3 个部分：</p>
<ul>
<li><strong>Term Dictionary</strong> - <strong>Term Dictionary 用于保存 term（词项）</strong>。由于 ES 会对 document 中的每个 field 都进行分词，所以数据量可能会非常大。<ul>
<li>Term Dictionary 存储数据时，先将所有的 term 进行排序，然后将 Term Dictionary 中有共同前缀的 term 抽取出来进行分块存储；再对共同前缀做索引，最后通过索引就可以找到公共前缀对应的块在 Term Dictionary 文件中的偏移地址。</li>
<li>由于每个块中都有共同前缀，所以不需要再保存每个 Term 的全部内容，只需要保存其后缀即可，而且这些后缀都是排好序的。</li>
</ul>
</li>
<li><strong>Term Index</strong> - <strong>Term Index 是 Term Dictionary 的索引</strong>。由于 Term Dictionary 存储的 term 可能会非常多，为了提高查询效率，从而设计了 Term Index。<ul>
<li>为了提高检索效率以及节省空间，Term Index 只使用公共前缀做索引。</li>
<li><strong>Lucene 中实现 Term Index 采用了 FST 算法</strong>。FST 是一种非常复杂的结构，可以把它简单理解为一个<strong>占用空间小且高效的 KV 数据结构</strong>，有点类似于 Trie（字典树）。FST 有以下的特点：<ul>
<li>通过对 Term Dictionary 数据的前缀复用，压缩了存储空间；</li>
<li>高效的查询性能，<code>O(len(prefix))</code> 的复杂度；</li>
<li>构建后不可修改，因此 Lucene segment 也不允许修改。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Posting List</strong> - <strong>Posting List 保存着每个 term 的映射信息</strong>。如文档 ID、词频、位置等。Lucene 把这些数据分成 3 个文件进行存储：<ul>
<li><code>.doc</code> 文件，记录了文档 ID 信息和 term 的词频，还额外记录了跳表的信息，用来加速文档 ID 的查询；并且还记录了 term 在 <code>.pos</code> 和 <code>.pay</code> 文件中的位置，有助于进行快速读取。</li>
<li><code>.pay</code> 文件，记录了 payload 信息和 term 在 doc 中的偏移信息；</li>
<li><code>.pos</code> 文件，记录了 term 在 doc 中的位置信息。</li>
</ul>
</li>
</ul>
<h2 id="Elasticsearch-搜索"><a href="#Elasticsearch-搜索" class="headerlink" title="Elasticsearch 搜索"></a>Elasticsearch 搜索</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-with-elasticsearch.html">Elasticsearch 官方文档之搜索数据</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/detail/100030501-102659">极客时间教程 - Elasticsearch 核心技术与实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/358.html">Elasticsearch 从入门到实践之分布式文档搜索机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-with-elasticsearch.html">Elasticsearch 官方文档之搜索数据</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html">Elasticsearch 官方文档之全文查询</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html">Elasticsearch 官方文档之词项查询</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/compound-queries.html">Elasticsearch 官方文档之组合查询</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html">Elasticsearch 官方文档之推荐查询</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html">Elasticsearch 官方文档之查询和过滤上下文</a></li>
</ul>
</blockquote>
<h3 id="【简单】ES-索引别名有什么用？"><a href="#【简单】ES-索引别名有什么用？" class="headerlink" title="【简单】ES 索引别名有什么用？"></a>【简单】ES 索引别名有什么用？</h3><p>Elasticsearch 中的别名可用于更轻松地管理和使用索引。别名允许同时对多个索引执行操作，或者通过隐藏底层索引结构的复杂性来简化索引管理。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/aliases.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/aliases.html</a></p>
</blockquote>
<h3 id="【简单】ES-中有哪些全文搜索-API？"><a href="#【简单】ES-中有哪些全文搜索-API？" class="headerlink" title="【简单】ES 中有哪些全文搜索 API？"></a>【简单】ES 中有哪些全文搜索 API？</h3><p>ES 支持全文搜索的 API 主要有以下几个：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-intervals-query.html">intervals</a> - 根据匹配词的顺序和近似度返回文档。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html">match</a> - <strong>匹配查询</strong>，用于执行全文搜索的标准查询，包括模糊匹配和短语或邻近查询。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-bool-prefix-query.html">match_bool_prefix</a> - 对检索文本分词，并根据这些分词构造一个布尔查询。除了最后一个分词之外的每个分词都进行 term 查询。最后一个分词用于 <code>prefix</code> 查询；其他分词都进行 <code>term</code> 查询。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html">match_phrase</a> - <strong>短语匹配查询</strong>，短语匹配会将检索内容分词，这些词语必须全部出现在被检索内容中，并且顺序必须一致，默认情况下这些词都必须连续。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html">match_phrase_prefix</a> - 与 <code>match_phrase</code> 查询类似，但对最后一个单词执行通配符搜索。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html">multi_match</a> 支持多字段 match 查询</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-combined-fields-query.html">combined_fields</a> - 匹配多个字段，就像它们已索引到一个组合字段中一样。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html">query_string</a> - 支持紧凑的 Lucene <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/8.16/query-dsl-query-string-query.html#query-string-syntax">query string（查询字符串）语法</a>，允许指定 <code>AND|OR|NOT</code> 条件和单个查询字符串中的多字段搜索。仅适用于专家用户。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html">simple_query_string</a> - 更简单、更健壮的 <code>query_string</code> 语法版本，适合直接向用户公开。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html">Elasticsearch 官方文档之全文查询</a></p>
</blockquote>
<h3 id="【简单】ES-中有哪些词项搜索-API？"><a href="#【简单】ES-中有哪些词项搜索-API？" class="headerlink" title="【简单】ES 中有哪些词项搜索 API？"></a>【简单】ES 中有哪些词项搜索 API？</h3><p><strong><code>Term</code>（词项）是表达语意的最小单位</strong>。搜索和利用统计语言模型进行自然语言处理都需要处理 Term。</p>
<p>全文查询在执行查询之前会分析查询字符串。与全文查询不同，<strong>词项级别查询不会分词</strong>，而是将输入作为一个整体，在倒排索引中查找准确的词项。并且使用相关度计算公式为每个包含该词项的文档进行相关度计算。一言以概之：<strong>词项查询是对词项进行精确匹配</strong>。词项查询通常用于结构化数据，如数字、日期和枚举类型。</p>
<p>ES 支持词项搜索的 API 主要有以下几个：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html">exists</a></strong> - 返回在指定字段上有值的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html">fuzzy</a></strong> - 模糊查询，返回包含与搜索词相似的词的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-ids-query.html">ids</a></strong> - 根据 ID 返回文档。此查询使用存储在 <code>_id</code> 字段中的文档 ID。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html">prefix</a></strong> - 前缀查询，用于查询某个字段中包含指定前缀的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html">range</a></strong> - 范围查询，用于匹配在某一范围内的数值型、日期类型或者字符串型字段的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html">regexp</a></strong> - 正则匹配查询，返回与正则表达式相匹配的词项所属的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html">term</a></strong> - 用来查找指定字段中包含给定单词的文档。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html">terms</a></strong> - 与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html"><strong><code>term</code></strong></a> 相似，但可以搜索多个值。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-set-query.html">terms set</a></strong> - 与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html"><strong><code>term</code></strong></a> 相似，但可以定义返回文档所需的匹配词数。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html">wildcard</a></strong> - 通配符查询，返回与通配符模式匹配的文档。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html">Elasticsearch 官方文档之词项查询</a></p>
</blockquote>
<h3 id="【简单】ES-支持哪些组合查询？"><a href="#【简单】ES-支持哪些组合查询？" class="headerlink" title="【简单】ES 支持哪些组合查询？"></a>【简单】ES 支持哪些组合查询？</h3><p>复合查询就是把一些简单查询组合在一起实现更复杂的查询需求，除此之外，复合查询还可以控制另外一个查询的行为。</p>
<p>复合查询有以下类型：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html"><code>bool</code></a> - 布尔查询，可以组合多个过滤语句来过滤文档。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html"><code>boosting</code></a> - 提供调整相关性打分的能力，在 <code>positive</code> 块中指定匹配文档的语句，同时降低在 <code>negative</code> 块中也匹配的文档的得分。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html"><code>constant_score</code></a> - 使用 <code>constant_score</code> 可以将 <code>query</code> 转化为 <code>filter</code>，filter 可以忽略相关性算分的环节，并且 filter 可以有效利用缓存，从而提高查询的性能。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-dis-max-query.html"><code>dis_max</code></a> - 返回匹配了一个或者多个查询语句的文档，但只将最佳匹配的评分作为相关性算分返回。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html"><code>function_score</code></a> - 支持使用函数来修改查询返回的分数。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/compound-queries.html">Elasticsearch 官方文档之组合查询</a></p>
</blockquote>
<h3 id="【简单】ES-中的-query-和-filter-有什么区别？"><a href="#【简单】ES-中的-query-和-filter-有什么区别？" class="headerlink" title="【简单】ES 中的 query 和 filter 有什么区别？"></a>【简单】ES 中的 query 和 filter 有什么区别？</h3><p>在 Elasticsearch 中，可以在两个不同的上下文中执行查询：</p>
<ul>
<li><code>query</code> context - <strong>有相关性计算</strong>，采用相关性算法，计算文档与查询关键词之间的相关度，并根据评分（<code>_score</code>）大小排序。</li>
<li><code>filter</code> context - <strong>无相关性计算</strong>，可以利用缓存，性能更好。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html">Elasticsearch 官方文档之查询和过滤上下文</a></p>
</blockquote>
<h3 id="【中等】ES-支持哪些推荐查询？"><a href="#【中等】ES-支持哪些推荐查询？" class="headerlink" title="【中等】ES 支持哪些推荐查询？"></a>【中等】ES 支持哪些推荐查询？</h3><p>ES 通过 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html"><strong><code>Suggester</code></strong></a> 提供了推荐搜索能力，可以用于文本纠错，文本自动补全等场景。</p>
<p>根据使用场景的不同，ES 提供了以下 4 种 Suggester：</p>
<ul>
<li><strong>Term Suggester</strong> - 基于词项的纠错补全。</li>
<li><strong>Phrase Suggester</strong> - 基于短语的纠错补全。</li>
<li><strong>Completion Suggester</strong> - 自动补全单词，输入词语的前半部分，自动补全单词。</li>
<li><strong>Context Suggester</strong> - 基于上下文的补全提示，可以实现上下文感知推荐。</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html">Elasticsearch 官方文档之推荐查询</a></p>
</blockquote>
<h3 id="【困难】ES-为什么会有深分页问题？"><a href="#【困难】ES-为什么会有深分页问题？" class="headerlink" title="【困难】ES 为什么会有深分页问题？"></a>【困难】ES 为什么会有深分页问题？</h3><p>在 Elasticsearch 中，支持三种分页查询方式：</p>
<ul>
<li>from + size - 可以使用 <code>from</code> 和 <code>size</code> 参数分别指定查询的起始页和每页记录数。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after"><code>search_after</code></a> - 不支持指定页数，只能向下翻页；并且需要指定 sort，并保证值是唯一的。然后，可以反复使用上次结果中最后一个文档的 sort 值进行查询。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results">scroll</a> - 类似于 RDBMS 中的游标，只允许向下翻页。每次下一页查询后，使用返回结果的 scroll id 来作为下一次翻页的标记。scroll 查询会在搜索初始化阶段会生成快照，后续数据的变化无法及时体现在查询结果，因此更加适合一次性批量查询或非实时数据的分页查询。</li>
</ul>
<p>前文中，我们已经了解了 ES 两阶段搜索流程（Query 和 Fetch）。从中不难发现，这种搜索方式在分页查询时会出现以下情况：</p>
<ul>
<li>每个 shard 要扫描 <code>from + size</code> 条数据；</li>
<li>coordinate node 需要接收并处理 <code>(from + size) * primary_shard_num</code> 条数据。</li>
</ul>
<p><strong>如果 from 或 size 很大，需要处理的数据量也会很大，代价很高，这就是深分页产生的原因</strong>。为了避免深分页，ES 默认限制 <code>from + size</code> 不能超过 10000，可以通过 <code>index.max_result_window</code> 设置。</p>
<p>如何解决 Elasticsearch 深分页问题？</p>
<p>ES 官方提供了另外两种分页查询方式 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after"><code>search_after</code></a> + PIT 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results">scroll</a>（注意：官方已不再推荐） 来避免深分页问题。</p>
<h2 id="Elasticsearch-聚合"><a href="#Elasticsearch-聚合" class="headerlink" title="Elasticsearch 聚合"></a>Elasticsearch 聚合</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/detail/100030501-102659">极客时间教程 - Elasticsearch 核心技术与实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">Elasticsearch 官方文档之聚合</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/348.html">Elasticsearch 从入门到实践之聚合</a></li>
</ul>
</blockquote>
<h3 id="【简单】什么是聚合？ES-中有哪些聚合？"><a href="#【简单】什么是聚合？ES-中有哪些聚合？" class="headerlink" title="【简单】什么是聚合？ES 中有哪些聚合？"></a>【简单】什么是聚合？ES 中有哪些聚合？</h3><p>在数据库中，聚合是指将数据进行分组统计，得到一个汇总的结果。例如，计算总和、平均值、最大值或最小值等操作。</p>
<p>Elasticsearch 将聚合分为三类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html"><strong>Metric（指标聚合）</strong></a></td>
<td>根据字段值进行<strong>统计</strong>计算</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html"><strong>Bucket（桶聚合）</strong></a></td>
<td>根据字段值、范围或其他条件进行<strong>分组</strong></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html"><strong>Pipeline（管道聚合）</strong></a></td>
<td>对其他聚合输出的结果进行<strong>再次聚合</strong></td>
</tr>
</tbody></table>
<h3 id="【中等】ES-如何对海量数据（过亿）进行聚合计算？"><a href="#【中等】ES-如何对海量数据（过亿）进行聚合计算？" class="headerlink" title="【中等】ES 如何对海量数据（过亿）进行聚合计算？"></a>【中等】ES 如何对海量数据（过亿）进行聚合计算？</h3><p>Elasticsearch 支持 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html"><code>cardinality</code>（近似计算非重复值）</a> 。它提供一个字段的基数，即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h2 id="Elasticsearch-分析"><a href="#Elasticsearch-分析" class="headerlink" title="Elasticsearch 分析"></a>Elasticsearch 分析</h2><h3 id="【简单】什么是文本分析？为什么需要文本分析？"><a href="#【简单】什么是文本分析？为什么需要文本分析？" class="headerlink" title="【简单】什么是文本分析？为什么需要文本分析？"></a>【简单】什么是文本分析？为什么需要文本分析？</h3><p>Elasticsearch 中存储的数据可以粗略分为：</p>
<ul>
<li><strong>词项数据</strong> - 采用<strong>精确查询</strong>。比较两条词项数据是否相对，实际是比较二者的二进制数据，结果只有相等或不相等。</li>
<li><strong>文本数据</strong> - 采用<strong>全文搜索</strong>。比较两个文本数据是否相等，没有太大意义，一般只会比较二者是否相似。相似性比较，是通过相关性评分来评估的。而计算相关性评分，需要对全文先分词处理，然后对分词后的词项进行统计才能进行相似性评估。</li>
</ul>
<p><strong>Elasticsearch 文本分析是将非结构化文本转换为一组词项（term）的过程</strong>。</p>
<p>文本分析可以分为两个方面：</p>
<ul>
<li><strong>Tokenization（分词化）</strong> - 分词化将文本分解成更小的块，称为分词。在大多数情况下，这些分词是单独的 term（词项）。</li>
<li><strong>Normalization（标准化）</strong> - 经过分词后的文本只能进行词项匹配，但是无法进行同义词匹配。为解决这个问题，可以将文本进行标准化处理。例如：将 <code>foxes</code> 标准化为 <code>fox</code>。</li>
</ul>
<h3 id="【简单】ES-中的分析器是什么？"><a href="#【简单】ES-中的分析器是什么？" class="headerlink" title="【简单】ES 中的分析器是什么？"></a>【简单】ES 中的分析器是什么？</h3><p>文本分析由 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><strong>analyzer（分析器）</strong></a> 执行，分析器是一组控制整个过程的规则。无论是索引还是搜索，都需要使用分析器。</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><strong>analyzer（分析器）</strong></a> 由三个组件组成：零个或多个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">Character Filters（字符过滤器）</a>、有且仅有一个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">Tokenizer（分词器）</a>、零个或多个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">Token Filters（分词过滤器）</a>。分析的执行顺序为：<code>character filters -&gt; tokenizer -&gt; token filters</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012129250.png"></p>
<p>Elasticsearch 内置的分析器：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html"><code>standard</code></a> - 根据单词边界将文本划分为多个 term，如 Unicode 文本分割算法所定义。它删除了大多数标点符号、小写 term，并支持删除停用词。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simple-analyzer.html"><code>simple</code></a> - 遇到非字母字符时将文本划分为多个 term，并将其转为小写。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-whitespace-analyzer.html"><code>whitespace</code></a> - 遇到任何空格时将文本划分为多个 term，不转换为小写。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-analyzer.html"><code>stop</code></a> - 与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simple-analyzer.html"><code>simple</code></a> 相似，同时支持删除停用词（如：the、a、is）。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-keyword-analyzer.html"><code>keyword</code></a> - 部分词，直接将输入当做输出。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-analyzer.html"><code>pattern</code></a> - 使用正则表达式将文本拆分为 term。它支持小写和非索引字。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-fingerprint-analyzer.html"><code>fingerprint</code></a> - 可创建用于重复检测的指纹。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html">语言分析器</a> - 提供了 30 多种常见语言的分词器。</li>
</ul>
<p>默认情况下，Elasticsearch 使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html"><strong>standard analyzer（标准分析器）</strong></a>，它开箱即用，适用于大多数使用场景。Elasticsearch 也允许定制分析器。</p>
<h4 id="Character-Filters（字符过滤器）"><a href="#Character-Filters（字符过滤器）" class="headerlink" title="Character Filters（字符过滤器）"></a>Character Filters（字符过滤器）</h4><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">Character Filters（字符过滤器）</a> 将原始文本作为字符流接收，并可以通过添加、删除或更改字符来转换文本。分析器可以有<strong>零个或多个</strong> <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html">Character Filters（字符过滤器）</a>，如果配置了多个，它会按照配置的顺序执行。</p>
<p>Elasticsearch 内置的字符过滤器：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-htmlstrip-charfilter.html"><code>html_strip</code></a> - <code>html_strip</code>字符过滤器用于去除 HTML 元素（如 <code>&lt;b&gt;</code>）并转义 HTML 实体（如 <code>&amp;amp;</code>）。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-mapping-charfilter.html"><code>mapping</code></a> - <code>mapping</code> 字符过滤器用于将指定字符串的任何匹配项替换为指定的替换项。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-replace-charfilter.html"><code>pattern_replace</code></a> - <code>pattern_replace</code> 字符筛选器将匹配正则表达式的任何字符替换为指定的替换。</li>
</ul>
<h4 id="Tokenizer（分词器）"><a href="#Tokenizer（分词器）" class="headerlink" title="Tokenizer（分词器）"></a>Tokenizer（分词器）</h4><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">Tokenizer（分词器）</a> 接收字符流，将其分解为分词（通常是单个单词），并输出一个分词流。分词器还负责记录每个 term 的顺序或位置，以及该 term 所代表的原始单词的开始和结束字符偏移量。分析器<strong>有且仅有一个</strong> <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html">Tokenizer（分词器）</a>。</p>
<p>Elasticsearch 内置的分词器：</p>
<ul>
<li>面向单词的分词器<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-tokenizer.html"><code>standard</code></a> - 将文本划分为单词边界上的 term，如 Unicode 文本分割算法所定义。它会删除大多数标点符号。它是大多数语言的最佳选择。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-letter-tokenizer.html"><code>letter</code></a> - 遇到非字母字符时将文本划分为多个 term。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenizer.html"><code>lowercase</code></a> - 到非字母字符时将文本划分为多个 term，并将其转为小写。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-whitespace-tokenizer.html"><code>whitespace</code></a> - 遇到任何空格时将文本划分为多个 term。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-uaxurlemail-tokenizer.html"><code>uax_url_email</code></a> - 与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-tokenizer.html"><code>standard</code></a> 相似，不同之处在于它将 URL 和电子邮件地址识别为单个分词。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-classic-tokenizer.html"><code>classic</code></a> - 基于语法的英语分词器。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-thai-tokenizer.html"><code>thai</code></a> - 将泰语文本分割为单词。</li>
</ul>
</li>
<li>部分单词分词器<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html"><code>n-gram</code></a> - 遇到指定字符列表（例如空格或标点符号）中的任何一个时，将文本分解为单词，然后返回每个单词的 n-gram：一个连续字母的滑动窗口，例如 <code>quick</code>→ <code>[qu， ui， ic， ck]</code>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html"><code>edge_n-gram</code></a> - 遇到指定字符列表（例如空格或标点符号）中的任何一个时，将文本分解为单词，然后返回锚定到单词开头的每个单词的 n 元语法，例如 <code>quick</code> → <code>[q， qu， qui， quic， quick]</code>。</li>
</ul>
</li>
<li>结构化文本分词器<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-keyword-tokenizer.html"><code>keyword</code></a> - 接受给定的任何文本，并输出与单个 term 完全相同的文本。它可以与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html"><code>lowercase</code></a> 等分词过滤器结合使用，以规范化分析的 term。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html"><code>pattern</code></a> - 使用正则表达式在文本与单词分隔符匹配时将文本拆分为 term，或者将匹配的文本捕获为 term。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simplepattern-tokenizer.html"><code>simple_pattern</code></a> - 使用正则表达式将匹配的文本捕获为 term。它使用正则表达式特征的受限子集，并且通常比 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html"><code>pattern</code></a> 更快。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-chargroup-tokenizer.html"><code>char_group</code></a> - 可以通过要拆分的字符集进行配置，这通常比运行正则表达式代价更小。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simplepatternsplit-tokenizer.html"><code>simple_pattern_split</code></a> - 使用与 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simplepattern-tokenizer.html"><code>simple_pattern</code></a> 分词器相同的受限正则表达式子集，但在匹配项处拆分输入，而不是将匹配项作为 term 返回。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html"><code>path_hierarchy</code></a> - 基于文件系统的路径分隔符，进行拆分，例如 <code>/foo/bar/baz</code> → <code>[/foo, /foo/bar, /foo/bar/baz ]</code> 。</li>
</ul>
</li>
</ul>
<h4 id="Token-Filters（分词过滤器）"><a href="#Token-Filters（分词过滤器）" class="headerlink" title="Token Filters（分词过滤器）"></a>Token Filters（分词过滤器）</h4><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">Token Filters（分词过滤器）</a> 接收分词流，并可以添加、删除或更改分词。常用的分词过滤器有： <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html"><code>lowercase</code>（小写转换）</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-tokenfilter.html"><code>stop</code>（停用词处理）</a>、<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html"><code>synonym</code>（同义词处理）</a> 等等。分析器可以有零个或多个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html">Token Filters（分词过滤器）</a>，如果配置了多个，它会按照配置的顺序执行。</p>
<p>Elasticsearch 内置了很多分词过滤器，这里列举几个常见的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-classic-tokenfilter.html"><code>classic</code></a> - 从单词末尾删除英语所有格 （<code>&#39;s</code>），并删除首字母缩略词中的点。它使用 Lucene 的 <a target="_blank" rel="noopener" href="https://lucene.apache.org/core/9_12_0/analysis/common/org/apache/lucene/analysis/standard/ClassicFilter.html">ClassicFilter</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html"><code>lowercase</code></a> - 将分词转为小写。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-tokenfilter.html"><code>stop</code></a> - 从分词中删除 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stop_word">stop word（停用词）</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html"><code>synonym</code></a> - 允许在分析过程中轻松处理 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-with-synonyms.html">近义词</a>。</li>
</ul>
<h3 id="【中等】如果需要中文分词怎么办？"><a href="#【中等】如果需要中文分词怎么办？" class="headerlink" title="【中等】如果需要中文分词怎么办？"></a>【中等】如果需要中文分词怎么办？</h3><p>在英文中，单词有自然的空格作为分隔。</p>
<p>在中文中，分词有以下难点：</p>
<ul>
<li>中文不能根据一个个汉字进行分词</li>
<li>不同于英文可以根据自然的空格进行分词；中文中一般不会有空格。</li>
<li>同一句话，在不同的上下文中，有不同个理解。例如：这个苹果，不大好吃；这个苹果，不大，好吃！</li>
</ul>
<p>可以使用一些插件来获得对中文更好的分析能力：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-icu.html">analysis-icu</a> - 添加了扩展的 Unicode 支持，包括更好地分析亚洲语言、Unicode 规范化、Unicode 感知大小写折叠、排序规则支持和音译。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/infinilabs/analysis-ik">elasticsearch-analysis-ik</a> - 支持自定义词库，支持热更新分词字典</li>
<li><a target="_blank" rel="noopener" href="https://github.com/microbun/elasticsearch-thulac-plugin">elasticsearch-thulac-plugin</a> - 清华大学自然语言处理和社会人文计算实验室的一套中文分词器。</li>
</ul>
<h2 id="Elasticsearch-复制"><a href="#Elasticsearch-复制" class="headerlink" title="Elasticsearch 复制"></a>Elasticsearch 复制</h2><h3 id="【中等】ES-如何保证高可用？"><a href="#【中等】ES-如何保证高可用？" class="headerlink" title="【中等】ES 如何保证高可用？"></a>【中等】ES 如何保证高可用？</h3><p><strong>ES 通过副本机制实现高可用</strong>。ES 的数据副本模型参考了 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf">PacificA 算法</a>。</p>
<p>ES 必须满足以下条件才能运行：</p>
<ul>
<li>至少需要 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-quorums.html">选举一个主节点</a></li>
<li>每个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">角色</a> 至少一个节点</li>
<li>每个 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html">分片</a> 至少有一个副本（主副本）</li>
</ul>
<p>默认的情况下，ES 的数据写入只需要保证主副本写入了即可，ES 在写上选择的是<strong>可用性优先</strong>，而并不是像 PacificA 协议那样的强一致性。而数据读取方面，ES 可能会读取到没有 commit 的数据，所以 ES 的数据读取可能产生不一致的情况。</p>
<p>在数据恢复方面，系统可以借助 GlobalCheckpoint 和 LocalCheckpoint 来加速数据恢复的过程。如果集群中只有旧的副本可用，那么可以使用 <strong>allocate_stale_primary 将一个指定的旧分片分配为主分片，但会造成数据丢失，慎用！</strong></p>
<blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/high-availability.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/high-availability.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/362.html">Elasticsearch 从入门到实践之副本策略</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/363.html">Elasticsearch 从入门到实践之 ES 的数据副本模型</a></li>
</ul>
</blockquote>
<h3 id="【中等】ES-是如何实现选主的？"><a href="#【中等】ES-是如何实现选主的？" class="headerlink" title="【中等】ES 是如何实现选主的？"></a>【中等】ES 是如何实现选主的？</h3><p>发起选主流程的条件：</p>
<ul>
<li>只有 master-eligible 节点（通过 <code>node.master: true</code> 设置）才能发起选主流程。</li>
<li>该 master-eligible 节点的当前状态不是 master。</li>
<li>该 master-eligible 节点通过 ZenDiscovery 模块的 ping 操作询问其已知的集群其他节点是否连接到 master。</li>
<li>包括本节点在内，当前已有超过 <code>discovery.zen.minimum_master_nodes</code> 个节点没有连接到 master。</li>
</ul>
<blockquote>
<p>一般，应设置 <code>discovery.zen.minimum_master_nodes</code> 为 <code>N / 2 + 1</code>，以保证各种分布式决议能得到大多数节点认可。当集群由于故障（如：通信失联）被分割成多个子集群时，节点数未达到半数以上的子集群，不允许进行选主。以此，来避免出现<strong>脑裂</strong>问题。</p>
</blockquote>
<p>选主流程：</p>
<ul>
<li>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发现彼此）和 Unicast（单播模块，包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</li>
<li>对所有 master-eligible 节点根据 nodeId 字典排序：每次选举时，每个节点都把自己所知道的节点排一次序，然后选出 id 最小的节点，投票该节点为 master 节点。</li>
<li>如果对某个节点的投票数达到一定的值（<code>投票数 &gt; N / 2 + 1</code>），并且该节点自己也投票自己，那这个节点就当选 master；否则，重新发起选举，直到满足上述条件。</li>
</ul>
<h3 id="【中等】ES-如何避免脑裂问题？"><a href="#【中等】ES-如何避免脑裂问题？" class="headerlink" title="【中等】ES 如何避免脑裂问题？"></a>【中等】ES 如何避免脑裂问题？</h3><p>ES 集群采用主从架构模式，集群中有且只能有一个 Master 存在。</p>
<p>现在假设这样一种场景，ES 集群部署在 2 个不同的机房。若两个机房网络断连，其中没有主节点的机房进行选主，产生了一个新的主节点。这时，就同时存在了两个主节点，它们各自负责处理接收的请求，会存在数据不一致。一旦，两个机房恢复通信，又将以哪个主节点为主，数据不一致问题怎么办，这就是<strong>脑裂</strong>问题。</p>
<p>那如何避免产生脑裂呢？<strong>ES 使用了 Quorum 机制来避免脑裂，在进行选主的时候，需要超过半数 Master 候选节点参与选主才行</strong>。假如有 5 个 Master 候选节点，如果要成功选举出 Master，必须有 (5 &#x2F; 2) + 1 &#x3D; 3 个 Master 候选节点参与选主才行。</p>
<p>在 6.x 及之前的版本使用 Zen Discovery 的集群协调子系统，Zen Discovery 允许用户通过使用 <code>discovery.zen.minimum_master_nodes</code> 设置来决定多少个符合主节点条件的节点可以选举出主节点。通常，只有 Master Eligible 节点（Master 候选节点）数大于 Quorum 的时候才能进行选主。计算公式如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quorum = (<span class="keyword">Master</span> <span class="title">候选节点数 / 2</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Elasticsearch 7.0 中，重新设计并重建了集群协调子系统：</p>
<ul>
<li>移除了 <code>discovery.zen.minimum_master_nodes</code> 设置，让 Elasticsearch 自己选择可以形成法定数量的节点。</li>
<li>典型的主节点选举只需很短时间就能完成。</li>
<li>集群的扩充和缩减变得更加安全和简单，并且大幅降低了因系统配置不当而可能造成数据丢失的风险。</li>
<li>节点状态记录比以往清晰很多，有助于诊断它们不能加入集群的原因，或者为何不能选举出主节点。</li>
</ul>
<h3 id="【中等】Elasticsearch-集群中有哪些不同类型的节点？"><a href="#【中等】Elasticsearch-集群中有哪些不同类型的节点？" class="headerlink" title="【中等】Elasticsearch 集群中有哪些不同类型的节点？"></a>【中等】Elasticsearch 集群中有哪些不同类型的节点？</h3><p>Elasticsearch 中的节点是指集群中的单个 Elasticsearch 进程实例。节点用于存储数据并参与集群的索引和搜索功能。</p>
<p>节点间会相互通信以分配数据和工作负载，从而确保集群的平衡和高性能。节点可以配置不同的角色，这些角色决定了它们在集群中的职责。</p>
<p>可以通过在 <code>elasticsearch.yml</code> 中设置 <code>node.roles</code> 来为节点分配角色。</p>
<p>ES 中主要有以下节点类型：</p>
<table>
<thead>
<tr>
<th align="left">节点类型</th>
<th align="left">说明</th>
<th align="left">配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>master eligible node</strong></td>
<td align="left"><strong>候选主节点</strong>。一旦成为主节点，可以管理整个集群：创建、更新、删除索引；添加或删除节点；为节点分配分片。</td>
<td align="left">低配置的 CPU、内存、磁盘</td>
</tr>
<tr>
<td align="left"><strong>data node</strong></td>
<td align="left"><strong>数据节点</strong>。负责数据的存储和读取。</td>
<td align="left">高配置的 CPU、内存、磁盘</td>
</tr>
<tr>
<td align="left"><strong>coordinating node</strong></td>
<td align="left"><strong>协调节点</strong>。负责请求的分发，结果的汇总。</td>
<td align="left">高配置的 CPU、中等配置的内存、低配置的磁盘</td>
</tr>
<tr>
<td align="left">ingest node</td>
<td align="left"><strong>预处理节点</strong>。负责处理数据、数据转换。</td>
<td align="left">高配置的 CPU、中等配置的内存、低配置的磁盘</td>
</tr>
<tr>
<td align="left">warm &amp; hot node</td>
<td align="left">存储冷、热数据的数据节点。</td>
<td align="left">Hot 类型的节点，都是高配配置，Warm 都是中低配即可</td>
</tr>
</tbody></table>
<h2 id="Elasticsearch-分片"><a href="#Elasticsearch-分片" class="headerlink" title="Elasticsearch 分片"></a>Elasticsearch 分片</h2><h3 id="【中等】ES-是如何实现水平扩展的？"><a href="#【中等】ES-是如何实现水平扩展的？" class="headerlink" title="【中等】ES 是如何实现水平扩展的？"></a>【中等】ES 是如何实现水平扩展的？</h3><p>Elasticsearch 通过分片来实现水平扩展。在 Elasticsearch 中，分片是索引的逻辑划分。索引可以有一个或多个分片，并且每个分片可以存储在集群中的不同节点上。分片用于在多个节点之间分配数据，从而提高性能和可扩展性。</p>
<p>Elasticsearch 中有两种类型的分片：</p>
<ul>
<li>primary shard（主分片） - 用于存储原始数据。适当增加主分片数，可以提升 Elasticsearch 集群的吞吐量和整体容量。</li>
<li>replica shard（副本分片） - 用于存储数据备份。</li>
</ul>
<p>默认情况下，每个索引都有 1 个主分片（早期版本，默认每个索引有 5 个主分片）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411221525828.png"></p>
<h3 id="【中等】ES-如何选择读写数据映射到哪个分片上？"><a href="#【中等】ES-如何选择读写数据映射到哪个分片上？" class="headerlink" title="【中等】ES 如何选择读写数据映射到哪个分片上？"></a>【中等】ES 如何选择读写数据映射到哪个分片上？</h3><p>为了避免出现数据倾斜，系统需要一种高效的方式把数据均匀分散到各个节点上<strong>存储</strong>，并且<strong>在检索的时候可以快速找到</strong>文档所在的节点与分片。这就需要确立路由算法，使得数据可以映射到指定的节点上。</p>
<p>常见的路由方式如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>算法</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">随机算法</td>
<td align="left">写数据时，随机写入到一个节点中；读数据时，由于不知道查询数据存在于哪个节点，所以需要遍历所有节点。</td>
</tr>
<tr>
<td align="left">路由表</td>
<td align="left">由中心节点统一维护数据的路由表，以保证唯一性；但是，中心化产生了新的问题：单点故障、数据越大，路由表越大、单点容易称为性能瓶颈、数据迁移复杂等。</td>
</tr>
<tr>
<td align="left">哈希取模</td>
<td align="left">对 key 值进行哈希计算，然后根据节点数取模，以确定节点。</td>
</tr>
</tbody></table>
<p>ES 的数据路由算法是根据文档 ID 和 routing key 来确定 Shard ID 的过程。<strong>默认的情况下 routing key 为文档 ID</strong>，路由算法一般情况下的计算公式如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shard_number</span> = hash(_routing) % numer_of_primary_shards</span><br></pre></td></tr></table></figure>

<p>也可以在请求中指定 routing key，下面是新增数据的时候指定 routing 的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT &lt;index&gt;/_doc/&lt;<span class="built_in">id</span>&gt;?routing=routing_key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;field1&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;field2&quot;</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加数据时，如果不指定文档 ID，ES 会自动分片一个随机 ID。这种情况下，结合 Hash 算法，可以保证数据被均匀分布到各个分片中。如果指定文档 ID，或指定 routing key，Hash 计算得出的值可能会不够随机，从而导致数据倾斜。</p>
<p><strong>index 一旦设置了主分片数就不能修改，如果要修改就需要 reindex（即数据迁移）</strong>。之所以如此，就是因为：一旦修改了主分片数，即等于修改了原 Hash 计算中的变量，无法再通过 Hash 计算正确路由到数据存储的分片。</p>
<h3 id="【中等】如何合理设置-ES-分片？"><a href="#【中等】如何合理设置-ES-分片？" class="headerlink" title="【中等】如何合理设置 ES 分片？"></a>【中等】如何合理设置 ES 分片？</h3><p>ES 索引设置多分片有以下好处：</p>
<ul>
<li>多分片如果分布在不同的节点，查询可以在不同分片上并行执行，提升查询速度；</li>
<li>数据写入时，会分散在不同节点存储，避免数据倾斜。</li>
</ul>
<p>设置多少分片合适：</p>
<p>一般，<strong>分片数要大于节点数</strong>，这样可以保证：一旦集群中有新的数据节点加入，ES 会自动对分片数进行再均衡，使得分片尽量在集群中分布均匀。</p>
<p><strong>分片数也不宜设置过多</strong>，这会带来一些问题：</p>
<ul>
<li>每一个 ES 分片对应一个 Lucene 索引，Lucene 索引存储在一个文件系统的目录中，它又可以分为多个 Segment，每个存储在一个文件中。因此，过多的分片意味着过多的文件，这会导致较大的读写性能开销。</li>
<li>此外，分片的元数据信息由 Master 节点维护，分片过多，会增加管理负担。建议，<strong>集群的总分片数控制在 10w 以内</strong>。</li>
</ul>
<p>单数据节点分片限制：</p>
<ul>
<li><strong>每个非冻结数据节点 1000 个分片</strong>，通过 <code>cluster.max_shards_per_node</code> 控制</li>
<li><strong>每个冻结数据节点 3000 个分片</strong>，通过 <code>cluster.max_shards_per_node.frozen</code> 控制</li>
</ul>
<p>此外，分片大小也要有所限制：</p>
<ul>
<li>理论上，<strong>一个分片最多包含约 20 亿个文档（<code>Integer.MAX_VALUE - 128</code>）</strong>。但是，经验表明，<strong>每个分片的文档数量最好保持在 2 亿以下</strong>。</li>
<li><strong>非日志型（搜索型、线上业务型） ES 的单分片容量最好在 [10GB, 30GB] 范围内</strong>；</li>
<li><strong>日志型 ES 的单分片容量最好在 [30GB, 50GB] 范围内</strong>；</li>
</ul>
<p>分片大小的上下限可以分别通过 <code>max_primary_shard_size</code> 和 <code>min_primary_shard_size</code> 来控制。</p>
<blockquote>
<p>扩展：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster">https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster</a></li>
<li><a target="_blank" rel="noopener" href="https://elastic.ac.cn/guide/en/elasticsearch/reference/current/size-your-shards.html">https://elastic.ac.cn/guide/en/elasticsearch/reference/current/size-your-shards.html</a></li>
</ul>
</blockquote>
<h2 id="Elasticsearch-架构"><a href="#Elasticsearch-架构" class="headerlink" title="Elasticsearch 架构"></a>Elasticsearch 架构</h2><h3 id="【困难】ES-搜索数据的流程是怎样的？"><a href="#【困难】ES-搜索数据的流程是怎样的？" class="headerlink" title="【困难】ES 搜索数据的流程是怎样的？"></a>【困难】ES 搜索数据的流程是怎样的？</h3><p>在 Elasticsearch 中，搜索一般分为两个阶段，query 和 fetch 阶段。可以简单的理解，query 阶段确定要取哪些 doc，fetch 阶段取出具体的 doc。</p>
<p>Query 阶段会根据搜索条件遍历每个分片（主分片或者副分片中的其一）中的数据，返回符合条件的前 N 条数据的 ID 和排序值，然后在协调节点中对所有分片的数据进行排序，获取前 N 条数据的 ID。</p>
<p><strong>Query 阶段的流程</strong>如下：</p>
<ol>
<li>客户端发送请求到任意一个节点，这个 node 成为 coordinate node（协调节点）。coordinate node 创建一个大小为 from + size 的优先级队列用来存放结果。</li>
<li>coordinate node 对 document 进行路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>每个分片在本地执行搜索请求，并将查询结果打分排序，然后将结果保存到 from + size 大小的有序队列中。</li>
<li>接着，每个分片将结果返回给 coordinate node，coordinate node 对数据进行汇总处理：合并、排序、分页，将汇总数据存到一个大小为 from + size 的全局有序队列。</li>
</ol>
<p>需要注意的是，在协调节点转发搜索请求的时候，如果有 N 个 Shard 位于同一个节点时，并不会合并这些请求，而是发生 N 次请求！</p>
<p>在 Fetch 阶段，协调节点会从 Query 阶段产生的全局排序列表中确定需要取回的文档 ID 列表，然后通过路由算法计算出各个文档对应的分片，并且用 multi get 的方式到对应的分片上获取文档数据。</p>
<p><strong>Fetch 阶段的流程</strong>如下：</p>
<ol>
<li>coordinate node 确定需要获取哪些文档，然后向相关节点发起 multi get 请求；</li>
<li>分片所在节点读取文档数据，并且进行 <code>_source</code> 字段过滤、处理高亮参数等，然后把处理后的文档数据返回给协调节点；</li>
<li>coordinate node 汇总所有数据后，返回给客户端。</li>
</ol>
<h3 id="【困难】ES-存储数据的流程是怎样的？"><a href="#【困难】ES-存储数据的流程是怎样的？" class="headerlink" title="【困难】ES 存储数据的流程是怎样的？"></a>【困难】ES 存储数据的流程是怎样的？</h3><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/read/elasticsearch/359.html">Elasticsearch 从入门到实践之分布式文档的存储流程</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/es-write-query-search.md">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/es-write-query-search.md</a></li>
</ul>
<p>:::</p>
<p>::: tip 关键点</p>
<ul>
<li><strong>集群角度</strong>：请求任意节点，路由转发到主分片；主分片写入本地，然后复制数据到副本分片；最后响应客户端</li>
<li><strong>分片角度</strong>：对内容做格式校验、分词</li>
<li><strong>节点角度</strong>：持久化、refresh Lucene Segment，flush(fsync) Translog</li>
</ul>
<p>:::</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503110752784.png"></p>
<p>ES 存储数据的流程可以从三个角度来阐述：</p>
<ul>
<li><p>从<strong>集群</strong>的角度来看，数据写入会先路由到主分片，在主分片上写入成功后，会并发写副本分片，最后响应给客户端。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012126135.png"></p>
</li>
<li><p>从<strong>分片</strong>的角度来看，数据到达分片后，需要对内容进行格式校验、分词处理然后再索引数据。</p>
</li>
<li><p>从<strong>节点</strong>的角度来看，ES 数据持久化的步骤可归纳为：<strong>Refresh、写 Translog、Flush、Merge。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012127951.png"></p>
<ul>
<li>默认，ES 会每秒执行一次 <strong>Refresh</strong> 操作，把 Index Buffer 的数据写入磁盘中，但不会调用 fsync 刷盘。ES 提供近实时搜索的原因是因为数据被 Refresh 后才能被检索出来 。</li>
<li>为了保证数据不丢失，在<strong>写完 Index Buffer 后，ES 还要写 Translog</strong>。Translog 是追加写入的，并且默认是调用 fsync 进行刷盘的。</li>
<li><strong>Flush</strong> 操作会将 Filesystem Cache 中的数据持久化到磁盘中，默认 30 分钟或者在 Translog 写满时（默认 512 MB）触发执行。Flush 将磁盘缓存持久化到磁盘后，会清空 Translog。</li>
<li>最后，ES 和 Lucene 会自动执行 <strong>Merge</strong> 操作，清理过多的 Segment 文件，这个时候被标记为删除的文档会正式被物理删除。</li>
</ul>
</li>
</ul>
<h3 id="【中等】ES-相关性计算和聚合计算为什么会有计算偏差？"><a href="#【中等】ES-相关性计算和聚合计算为什么会有计算偏差？" class="headerlink" title="【中等】ES 相关性计算和聚合计算为什么会有计算偏差？"></a>【中等】ES 相关性计算和聚合计算为什么会有计算偏差？</h3><p>在 ES 中，不仅仅是普通搜索，相关性计算（评分）和聚合计算也是先在每个 shard 的本地进行计算，再由 coordinate node 进行汇总。由于分片的本地计算是独立的，只能基于数据子集来进行计算，所以难免出现数据偏差。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012144894.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412012145912.png"></p>
<p>解决这个问题的方式也有多种：</p>
<ul>
<li>当数据量不大的情况下，<strong>设置主分片数为 1</strong>，这意味着在数据全集上进行聚合。 但这种方案不太现实。</li>
<li><strong>设置 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-shard-size"><code>shard_size</code></a> 参数</strong>，将计算数据范围变大，<strong>牺牲整体性能，提高精准度</strong>。shard_size 的默认值是 <code>size * 1.5 + 10</code>。</li>
<li><strong>使用 DFS Query Then Fetch</strong>， 在 URL 参数中指定：<code>_search?search_type=dfs_query_then_fetch</code>。这样设定之后，ES 先会把每个分片的词频和文档频率的数据汇总到协调节点进行处理，然后再进行相关性算分。这样的话会消耗更多的 CPU 和内存资源，效率低下！</li>
<li>尽量保证数据均匀地分布在各个分片中。</li>
</ul>
<h3 id="【困难】ES-如何保证读写一致？"><a href="#【困难】ES-如何保证读写一致？" class="headerlink" title="【困难】ES 如何保证读写一致？"></a>【困难】ES 如何保证读写一致？</h3><p><strong>乐观锁机制</strong> - 可以通过版本号使用乐观锁并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>对于读操作，可以设置 replication 为 sync（默认），这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数、_preference 为 primary 来查询主分片，确保文档是最新版本。</p>
<h3 id="【困难】ES-查询速度为什么快？"><a href="#【困难】ES-查询速度为什么快？" class="headerlink" title="【困难】ES 查询速度为什么快？"></a>【困难】ES 查询速度为什么快？</h3><ul>
<li><strong>倒排索引</strong> - Elasticsearch 查询速度快最核心的点在于使用倒排索引。<ul>
<li>在 Elasticsearch 中，为了提高查询效率，它对存储的文档进行了分词处理。分词是将连续的文本切分成一个个独立的词项的过程。对文本进行分词后，Elasticsearch 会为每个词项创建一个倒排索引。这样，当用户进行查询时，Elasticsearch 只需要在倒排索引中查找匹配的词项，从而快速地定位到相关的文档。</li>
<li>正向索引的结构是每个文档和关键字做关联，每个文档都有与之对应的关键字，记录关键字在文档中出现的位置和次数；而倒排索引则是将文档中的词项和文档的 ID 进行关联，这样就可以通过词项快速找到包含它的文档。</li>
</ul>
</li>
<li><strong>分片</strong> - Elasticsearch 通过分片，支持分布式存储和搜索，可以实现搜索的并行处理和负载均衡。</li>
</ul>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1922613">https://cloud.tencent.com/developer/article/1922613</a></p>
</blockquote>
<h3 id="【中等】ES-生产环境部署情况是怎样的？"><a href="#【中等】ES-生产环境部署情况是怎样的？" class="headerlink" title="【中等】ES 生产环境部署情况是怎样的？"></a>【中等】ES 生产环境部署情况是怎样的？</h3><p><strong>典型问题</strong></p>
<ul>
<li>你们的 Elasticsearch 生产环境部署情况是怎样的？</li>
<li>你们的 Elasticsearch 生产环境集群规模有多大？</li>
<li>你们的 Elasticsearch 生产环境中有多少索引，每个索引大概有多少个分片？</li>
</ul>
<p><strong>知识点</strong></p>
<p>根据实际 Elasticsearch 集群情况描述，以下是一个案例：</p>
<ul>
<li><strong>版本</strong>：6.3.2</li>
<li><strong>集群规模</strong>：21 个节点，8 核 16G 内存，400G 磁盘</li>
<li><strong>容量</strong>：6600GB&#x2F;8400GB，900+ 索引、1.3 万分片、150 亿+ 文档</li>
<li><strong>增量</strong>：日增 4 百万文档，5 GB</li>
</ul>
<h2 id="Elasticsearch-优化"><a href="#Elasticsearch-优化" class="headerlink" title="Elasticsearch 优化"></a>Elasticsearch 优化</h2><h3 id="【中等】使用-ES-有哪些最佳实践？"><a href="#【中等】使用-ES-有哪些最佳实践？" class="headerlink" title="【中等】使用 ES 有哪些最佳实践？"></a>【中等】使用 ES 有哪些最佳实践？</h3><ul>
<li><strong>索引</strong><ul>
<li>大索引应拆分，增强性能，减少风险</li>
<li>index 可以按日期拆分为 **<code>index_yyyyMMdd</code>**，然后用 alias 映射</li>
</ul>
</li>
<li><strong>分片</strong>：分片太大会导致查询慢、数据迁移和恢复时间长<ul>
<li>非日志型业务分片不超过 <strong>30 GB</strong></li>
<li>日志型业务分片不超过 <strong>50 GB</strong></li>
<li>单分片文档数不超过 <strong>21 亿</strong></li>
<li>单节点分片数不要超过 <strong>600</strong> 个</li>
</ul>
</li>
<li><strong>文档</strong><ul>
<li>单个文档大小不能超过 <strong>100MB</strong></li>
</ul>
</li>
<li><strong>字段</strong><ul>
<li>一个索引中的字段数默认最大为 <strong>1000</strong>，但是不建议超过 <strong>100</strong></li>
<li>text 和 keyword 必须理清楚，keyword 是不会进行分词。</li>
<li>对于 <code>keyword</code> 类型，默认只索引前 <strong>256</strong> 个字符。超过此长度的字符串将不会被索引（即无法被term查询、聚合）。可以通过 <code>ignore_above</code> 参数调整。</li>
</ul>
</li>
<li><strong>Settings 设置</strong><ul>
<li>分片数设置后，不可修改</li>
<li>副本数默认 1 个</li>
</ul>
</li>
<li><strong>Mapping 设置</strong><ul>
<li>text 数据类型默认是关闭 fielddate</li>
<li>关闭 <code>_source</code> 会导致无法使用 reindex</li>
<li><code>copy_to</code> 虽然方便，但会显著增加索引大小和写入开销。只在明确需要跨字段搜索时才使用。</li>
</ul>
</li>
<li><strong>Refresh</strong><ul>
<li>写入时，尽量不要执行 refresh，在并发较大的情况下，ES 负载可能会被打满。</li>
</ul>
</li>
<li><strong>索引别名</strong><ul>
<li>尽量使用索引的别名，在类似于进行索引字段类型变更需要进行索引重建的时候会减少很多的问题。</li>
<li>别名的下面可以挂载多个索引，若是索引拆分之后业务验证允许可以这么使用。</li>
<li>alias 下面可以挂多个索引，但是需要注意的是每次请求很容易放大，比如说 alias 挂了 50 个索引，每个索引有 5 个分片，那么从集群的维度来看一共就是 50*5&#x3D;250 次 query 和 fetch，很容易导致读放大的情况。</li>
</ul>
</li>
</ul>
<h3 id="【中等】ES-JVM-设置需要注意什么？"><a href="#【中等】ES-JVM-设置需要注意什么？" class="headerlink" title="【中等】ES JVM 设置需要注意什么？"></a>【中等】ES JVM 设置需要注意什么？</h3><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/blog/a-heap-of-trouble">A Heap of Trouble: Managing Elasticsearch’s Managed Heap</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/HotSpot/CompressedOops">https://wiki.openjdk.org/display/HotSpot/CompressedOops</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liujianyangbj/article/details/108049482">https://blog.csdn.net/liujianyangbj/article/details/108049482</a></li>
</ul>
<p>:::</p>
<p>::: tip 关键点</p>
<p><code>-Xms</code> 和 <code>-Xmx</code> 设置 JVM，JVM 内存不超过 32GB</p>
<p>:::</p>
<p>ES 实际上是一个 Java 进程，因此也需要考虑 JVM 设置。关于 ES JVM 的设置，有以下几点建议：</p>
<ul>
<li>从 ES6 开始，支持 64 位的 JVM</li>
<li>将内存 <code>Xms</code> 和 <code>Xmx</code> 设置一样，需要注意过多的堆可能会使垃圾回收停顿时间过长</li>
<li>一般，将 50％ 的可用内存分配给 ES</li>
<li>ES 内存不要超过 32 GB</li>
</ul>
<p>实际上，一般而言，<strong>绝大部分 JVM 内存最好都不要超过 32 GB</strong>，不仅仅是 ES 内存。</p>
<p>对于 32 位系统来说，JVM 的对象指针占用 32 位（4 byte），可以表示 <code>2^32</code> 个内存地址。由于，CPU 寻址的最小单位是 byte，<code>2^32</code> byte 即 4GB，也就是说 JVM 最大可以支持 4GB。对于 64 位系统来说，如果直接引用，就需要使用 64 位的指针，相比 32 位 指针，多使用了一倍的内存。并且，指针在主内存和各级缓存间移动数据时，会占用更大的带宽。</p>
<p>Java 使用了一种叫做 <a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/HotSpot/CompressedOops">Compressed oops</a> 的技术来进行优化。该技术利用 Java 对象按照 8 字节对齐的机制，让 Java 对象指针指向一个映射地址偏移量（非真实 64 位 地址）。这种方式可以寻址最大位 32 GB 的内存空间。一旦超出 32 GB，就无法利用压缩指针技术，对象指针只能指向真实内存地址，这会造成空间的浪费。</p>
<h3 id="【中等】ES-主机有哪些优化点？"><a href="#【中等】ES-主机有哪些优化点？" class="headerlink" title="【中等】ES 主机有哪些优化点？"></a>【中等】ES 主机有哪些优化点？</h3><ul>
<li>关闭缓存 swap;</li>
<li>堆内存设置为：Min（节点内存&#x2F;2, 32GB）;</li>
<li>设置最大文件句柄数；</li>
<li>线程池+队列大小根据业务需要做调整；</li>
<li>磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</li>
</ul>
<h3 id="【中等】ES-索引数据多，如何优化？"><a href="#【中等】ES-索引数据多，如何优化？" class="headerlink" title="【中等】ES 索引数据多，如何优化？"></a>【中等】ES 索引数据多，如何优化？</h3><ul>
<li><strong>动态索引</strong> - 如果单索引数据量过大，可以创建索引模板，并周期性创建新索引（举例来说，索引名为 blog_yyyyMMdd），实现数据的分解。</li>
<li><strong>冷热数据分离</strong> - 将一定范围（如：一周、一月等）的数据作为热数据，其他数据作为冷数据。针对冷数据，可以考虑定期 force_merge + shrink 进行压缩，以节省存储空间和检索效率。</li>
<li><strong>分区再均衡</strong> - Elasticsearch 集群可以动态根据节点数的变化，调整索引分片在集群上的分布。但需要注意的是，要提前合理规划好索引的分片数：分片数过少，则增加节点也无法水平扩展；分片数过多，影响 Elasticsearch 读写效率。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itshujia.com/books/elasticsearch">Elasticsearch 从入门到实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.turing.com/interview-questions/elasticsearch">https://www.turing.com/interview-questions/elasticsearch</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rkm-ravi94/awesome-devops-interview/blob/main/elasticsearch.md">https://github.com/rkm-ravi94/awesome-devops-interview/blob/main/elasticsearch.md</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8eb835ba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8eb835ba/" class="post-title-link" itemprop="url">Java 虚拟机之垃圾收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-07 09:21:16" itemprop="dateCreated datePublished" datetime="2020-06-07T09:21:16+08:00">2020-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-虚拟机之垃圾收集"><a href="#Java-虚拟机之垃圾收集" class="headerlink" title="Java 虚拟机之垃圾收集"></a>Java 虚拟机之垃圾收集</h1><blockquote>
<p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。<strong>垃圾回收主要是针对 Java 堆和方法区进行</strong>。</p>
</blockquote>
<h2 id="对象是否回收"><a href="#对象是否回收" class="headerlink" title="对象是否回收"></a>对象是否回收</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reference Counting）的原理是：在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>引用计数算法简单、高效，但是存在循环引用问题——两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为循环引用的存在，所以 <strong>Java 虚拟机不适用引用计数算法</strong>。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过 <strong>GC Roots</strong> 作为起始点进行搜索，JVM 将能够到达到的对象视为<strong>存活</strong>，不可达的对象视为<strong>死亡</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-root.png" />
<p>可达性分析算法</p>
</div>

<p><strong>可作为 GC Roots 的对象</strong>包括下面几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象（Native 方法）</li>
<li>方法区中，类静态属性引用的对象</li>
<li>方法区中，常量引用的对象</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 具有四种强度不同的引用类型。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p><strong>被强引用（Strong Reference）关联的对象不会被垃圾收集器回收。</strong></p>
<p>强引用：使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>被软引用（Soft Reference）关联的对象，只有在内存不够的情况下才会被回收。</strong></p>
<p>软引用：使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>被弱引用（Weak Reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。</strong></p>
<p>使用 <code>WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><code>WeakHashMap</code> 的 <code>Entry</code> 继承自 <code>WeakReference</code>，主要用来实现缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>Tomcat 中的 <code>ConcurrentCache</code> 就使用了 <code>WeakHashMap</code> 来实现缓存功能。<code>ConcurrentCache</code> 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 <code>ConcurrentHashMap</code> 实现，longterm 使用 <code>WeakHashMap</code>，保证了不常使用的对象容易被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">            <span class="built_in">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p>使用 <code>PhantomReference</code> 来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。</p>
<p><strong>方法区的垃圾收集主要回收两部分：废弃的常量和不再使用的类型</strong>。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p>可以通过 <code>-Xnoclassgc</code> 参数来控制是否对类进行卸载。</p>
<p>在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 <code>ClassLoader</code> 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</p>
<p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此**最好不要使用 <code>finalize()</code>**。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="垃圾收集性能"><a href="#垃圾收集性能" class="headerlink" title="垃圾收集性能"></a>垃圾收集性能</h3><p>垃圾收集器的性能指标主要有两点：</p>
<ul>
<li><strong>停顿时间</strong> - 停顿时间是因为 GC 而导致程序不能工作的时间长度。</li>
<li><strong>吞吐量</strong> - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。</li>
</ul>
<h3 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记 - 清除（Mark-Sweep）"></a>标记 - 清除（Mark-Sweep）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-sweep.jpg" />
</div>

<p>将需要回收的对象进行标记，然后清理掉被标记的对象。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，内存碎片过多可能导致无法给大对象分配内存。</li>
</ul>
<h3 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记 - 整理（Mark-Compact）"></a>标记 - 整理（Mark-Compact）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-compact.jpg" />
</div>

<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>
<h3 id="标记-复制（Copying）"><a href="#标记-复制（Copying）" class="headerlink" title="标记 - 复制（Copying）"></a>标记 - 复制（Copying）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-copying.jpg" />
</div>

<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都<strong>采用这种收集算法来回收年轻代</strong>，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 <code>-XX:SurvivorRatio</code> 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将 Java 堆分为年轻代和老年代。</p>
<ul>
<li>年轻代使用：<strong>复制</strong> 算法</li>
<li>老年代使用：<strong>标记 - 清理</strong> 或者 <strong>标记 - 整理</strong> 算法</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png" />
</div>

<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 <code>Eden</code> 区域，作为对象初始分配的区域；两个 <code>Survivor</code>，有时候也叫 <code>from</code>、<code>to</code> 区域，被用来放置从 Minor GC 中保留下来的对象。</p>
<p>JVM 会随意选取一个 <code>Survivor</code> 区域作为 <code>to</code>，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 <code>from</code> 区域的对象，拷贝到这个<code>to</code>区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
<p>Java 虚拟机会记录 <code>Survivor</code> 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code>），那么该对象将被晋升（promote）至老年代。另外，如果单个 <code>Survivor</code> 区已经被占用了 50%（对应虚拟机参数 <code>-XX:TargetSurvivorRatio</code>），那么较高复制次数的对象也会被晋升至老年代。</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>放置长生命周期的对象，通常都是从 <code>Survivor</code> 区域拷贝过来的对象。当然，也有特殊情况，如果对象较大，JVM 会试图直接分配在 <code>Eden</code> 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存。在 JDK 8 之后就不存在永久代这块儿了。</p>
<h4 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h4><p>这里顺便提一下，JVM 允许对堆空间大小、各代空间大小进行设置，以调整 JVM GC。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xss</code></td>
<td>虚拟机栈大小。</td>
</tr>
<tr>
<td><code>-Xms</code></td>
<td>堆空间初始值。</td>
</tr>
<tr>
<td><code>-Xmx</code></td>
<td>堆空间最大值。</td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代空间大小。</td>
</tr>
<tr>
<td><code>-XX:NewSize</code></td>
<td>新生代空间初始值。</td>
</tr>
<tr>
<td><code>-XX:MaxNewSize</code></td>
<td>新生代空间最大值。</td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 <code>eden</code> 区为 80% 的大小，两个 <code>survivor</code> 分别为 10% 的大小。</td>
</tr>
<tr>
<td><code>-XX:PermSize</code></td>
<td>永久代空间的初始值。</td>
</tr>
<tr>
<td><code>-XX:MaxPermSize</code></td>
<td>永久代空间的最大值。</td>
</tr>
</tbody></table>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-overview.jpg" />
</div>

<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<p>注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。</p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>串行收集器（Serial）是最基本、发展历史最悠久的收集器。</p>
<p>串行收集器是 <strong><code>client</code> 模式下的默认收集器配置</strong>。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<p><strong>串行收集器采用单线程 stop-the-world 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-serial.jpg" />
<p>Serial / Serial Old 收集器运行示意图</p>
</div>

<p>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。</p>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><blockquote>
<p>开启选项：<code>-XX:+UseSerialGC</code></p>
<p>打开此开关后，使用 <strong>Serial</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseParallelGC</code></p>
<p>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
<p>开启选项：<code>-XX:+UseParallelOldGC</code></p>
<p>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Parallel Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器</strong>。</p>
<ul>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li>
<li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
</ul>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">吞吐量 </span>=<span class="string"> 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</span></span><br></pre></td></tr></table></figure>

<p><strong>并行收集器是 server 模式下的默认收集器。</strong></p>
<p>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。<strong>并行收集器年轻代采用复制算法，老年代采用标记-整理</strong>，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<p><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</strong></p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-parallel.jpg" />
<p>Parallel / Parallel Old 收集器运行示意图</p>
</div>

<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code> - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。</li>
<li><code>-XX:GCTimeRatio</code> - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。</li>
</ul>
<p>缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>Parallel Scavenge 收集器还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（<code>-Xmn</code>）、Eden 和 Survivor 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>是 Parallel Scavenge 收集器的老年代版本，使用<strong>多线程和 “标记-整理” 算法</strong>。</p>
<h3 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseConcMarkSweepGC</code></p>
<p>打开此开关后，使用 <strong>CMS</strong> + <strong>ParNew</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<p>并发标记清除收集器是以获取最短停顿时间为目标。</p>
<p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 <code>Concurrent Mode Failure</code> ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><strong>CMS 收集器是一种以获取最短停顿时间为目标的收集器。</strong></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<h5 id="CMS-回收机制"><a href="#CMS-回收机制" class="headerlink" title="CMS 回收机制"></a>CMS 回收机制</h5><p>CMS 收集器运行步骤如下：</p>
<ol>
<li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li><strong>并发清除</strong>：回收在标记阶段被鉴定为不可达的对象。不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-cms.jpg" />
<p>CMS 收集器运行示意图</p>
</div>

<h5 id="CMS-回收年轻代详细步骤"><a href="#CMS-回收年轻代详细步骤" class="headerlink" title="CMS 回收年轻代详细步骤"></a>CMS 回收年轻代详细步骤</h5><p><strong>（1）堆空间被分割为三块空间</strong></p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide1.png" alt="img"><br>年轻代分割成一个 Eden 区和两个 Survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 FullGC 否则不会压缩。</p>
<p><strong>（2）CMS 年轻代垃圾收集如何工作</strong></p>
<p>年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，CMS 的堆看起来应该是这个样子。对象分散在年老代区域里。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide2.png" alt="img"></p>
<p>使用 CMS，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 FullGC。</p>
<p><strong>（3）年轻代收集</strong></p>
<p>从 Eden 和 Survivor 区复制活跃对象到另一个 Survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide3.png" alt="img"><br><strong>（4）年轻代回收之后</strong></p>
<p>一次年轻代垃圾收集之后，Eden 区和其中一个 Survivor 区被清空。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide4.png" alt="img"><br>最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。</p>
<h5 id="CMS-回收年老代详细步骤"><a href="#CMS-回收年老代详细步骤" class="headerlink" title="CMS 回收年老代详细步骤"></a>CMS 回收年老代详细步骤</h5><p><strong>（1）CMS 的年老代收集</strong></p>
<p>发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide5.png" alt="img"></p>
<ul>
<li>初始标记是一个短暂暂停的、可达对象被标记的阶段。</li>
<li>并发标记寻找活跃对象在应用连续执行时。</li>
<li>最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。</li>
</ul>
<p><strong>（2）年老代收集-并发清除</strong></p>
<p>在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide6.png" alt="img"><br><strong>注意：</strong>未被标记的对象等于死亡对象</p>
<p><strong>（3）年老代收集-清除之后</strong></p>
<p>清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide7.png" alt="img"><br>最后，CMS 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。</p>
<h5 id="CMS-特点"><a href="#CMS-特点" class="headerlink" title="CMS 特点"></a>CMS 特点</h5><p>CMS 收集器具有以下缺点：</p>
<ul>
<li>并发收集 - 并发指的是用户线程和 GC 线程同时运行。</li>
<li>吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾 - 可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。<ul>
<li>可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。</li>
</ul>
</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。<ul>
<li>可以使用 <code>-XX:+UseCMSCompactAtFullCollection</code> ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。</li>
<li>可以使用 <code>-XX:CMSFullGCsBeforeCompaction</code> ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。</li>
</ul>
</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><blockquote>
<p>开启选项：<code>-XX:+UseParNewGC</code></p>
</blockquote>
<p>ParNew 收集器其实是 Serial 收集器的多线程版本。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-par-new.jpg" />
<p>ParNew 收集器运行示意图</p>
</div>

<p>是 Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 后的默认年轻代收集器。</p>
<p>ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 -<code>XX:ParallelGCThreads</code> 参数来设置线程数。</p>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseG1GC</code></p>
</blockquote>
<p>前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 <strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p>
<p>G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。</p>
<h4 id="分代和分区"><a href="#分代和分区" class="headerlink" title="分代和分区"></a>分代和分区</h4><p>旧的垃圾收集器一般采取分代收集，Java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。</p>
<p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-g1-heap-allocation.png" />
</div>

<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<h4 id="G1-回收机制"><a href="#G1-回收机制" class="headerlink" title="G1 回收机制"></a>G1 回收机制</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-g1.jpg" />
<p>G1 收集器运行示意图</p>
</div>

<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong> - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong> - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h4 id="G1-回收年轻代详细步骤"><a href="#G1-回收年轻代详细步骤" class="headerlink" title="G1 回收年轻代详细步骤"></a>G1 回收年轻代详细步骤</h4><p><strong>（1）G1 初始堆空间</strong></p>
<p>堆空间是一个被分成许多固定大小区域的内存块。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide8.png" alt="img"><br>Java 虚拟机启动时选定区域大小。Java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32M 的区域。</p>
<p><strong>（2）G1 堆空间分配</strong></p>
<p>实际上，这些区域被映射成 Eden、Survivor、年老代空间的逻辑表述形式。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt="img"><br>图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。</p>
<p>明显的区域可以被分配成 Eden、Survivor、Old 区域。另外，有第四种类型的区域叫做*极大区域 (Humongous regions)*。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。</p>
<p><strong>注意：</strong>写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。</p>
<p><strong>（3）G1 的年轻代</strong></p>
<p>堆空间被分割成大约 2000 个区域。最小 1M，最大 32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide10.png" alt="img"><br><strong>注意：</strong>区域没有必要像旧的收集器一样是保持连续的。</p>
<p><strong>（4）G1 的年轻代收集</strong></p>
<p>活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png" alt="img"><br>这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 Eden 和 Survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。</p>
<p>这个方法使重调区域大小变得很容易，按需把它们调大或调小。</p>
<p><strong>（5）G1 年轻代回收的尾声</strong></p>
<p>活跃对象被疏散到 Survivor 或者年老代区域。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png" alt="img"><br>最近晋升的对象显示为深蓝色。Survivor 区域显示为绿色。</p>
<p>关于 G1 的年轻代回收做以下总结：</p>
<ul>
<li>堆空间是一块单独的内存空间被分割成多个区域。</li>
<li>年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。</li>
<li>年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。</li>
<li>年轻代垃圾收集使用多线程并行回收。</li>
<li>活跃对象被复制到新的 Survivor 区或者年老代区域。</li>
</ul>
<h4 id="G1-回收年老代详细步骤"><a href="#G1-回收年老代详细步骤" class="headerlink" title="G1 回收年老代详细步骤"></a>G1 回收年老代详细步骤</h4><p><strong>（1）初始标记阶段</strong></p>
<p>年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为* GC pause (young)(inital-mark)*</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png" alt="img"><br><strong>（2）并发标记阶段</strong></p>
<p>如果发现空区域 (“X”标示的），在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png" alt="img"><br><strong>（3）重新标记阶段</strong></p>
<p>空的区域被清除和回收掉。所有区域的活性在此时计算。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png" alt="img"><br><strong>（4）复制&#x2F;清理阶段</strong></p>
<p>G1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为* [GC pause (mixed)]*。所以年轻代和年老代在同一时间被回收。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png" alt="img"><br><strong>（5）复制&#x2F;清理阶段之后</strong></p>
<p>被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行&#x2F;并行&#x2F;并发</th>
<th align="center">年轻代&#x2F;老年代</th>
<th align="center">收集算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Serial</strong></td>
<td align="center">串行</td>
<td align="center">年轻代</td>
<td align="center">标记-复制</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td align="center"><strong>Serial Old</strong></td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td>
</tr>
<tr>
<td align="center"><strong>ParNew</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">标记-复制</td>
<td align="center">响应速度优先</td>
<td align="center">多 CPU 环境时在 Server 模式下与 CMS 配合</td>
</tr>
<tr>
<td align="center"><strong>Parallel Scavenge</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">标记-复制</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>Parallel Old</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>CMS</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或 B&#x2F;S 系统服务端上的 Java 应用</td>
</tr>
<tr>
<td align="center"><strong>G1</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">年轻代 + 老年代</td>
<td align="center">标记-整理 + 标记-复制</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换 CMS</td>
</tr>
</tbody></table>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，也就是在堆上分配。主要分配在年轻代的 Eden 区上，少数情况下也可能直接分配在老年代中。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><strong>当 <code>Eden</code> 区空间不足时，触发 Minor GC</strong>。</p>
<p><strong>Minor GC 发生在年轻代上</strong>，因为年轻代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
<p>Minor GC 工作流程：</p>
<ol>
<li><p>Java 应用不断创建对象，通常都是分配在 <code>Eden</code> 区域，当其空间不足时（达到设定的阈值），触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。</p>
</li>
<li><p>经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件。这时候，另外一个 Survivor 区域则会成为 <code>To</code> 区域，Eden 区域的存活对象和 <code>From</code> 区域对象，都会被复制到 <code>To</code> 区域，并且存活的年龄计数会被加 1。</p>
</li>
<li><p>类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 <code>-XX:MaxTenuringThreshold</code> 参数指定。</p>
</li>
</ol>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p><strong>Full GC 发生在老年代上</strong>，老年代对象和年轻代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><strong>（一）对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在年轻代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<p><strong>（二）大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
<p><strong>（三）长期存活的对象进入老年代</strong></p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p>
<p><strong>（四）动态对象年龄判定</strong></p>
<p>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<p><strong>（五）空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那这时也要改为进行一次 Full GC。</p>
<h4 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>（1）调用 <code>System.gc()</code></strong></p>
<p>此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 <code>-XX:DisableExplicitGC</code> 来禁止 RMI 调用 <code>System.gc()</code>。</p>
<p><strong>（2）老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。</p>
<p><strong>（3）方法区空间不足</strong></p>
<p>JVM 规范中运行时数据区域中的<strong>方法区</strong>，在 HotSpot 虚拟机中又被习惯称为<strong>永久代</strong>，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 <code>java.lang.OutOfMemoryError: PermGen space</code> 错误。为避免永久代占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。</p>
<p><strong>（4）Minor GC 的平均晋升空间大小大于老年代可用空间</strong></p>
<p>如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p>
<p><strong>（5）对象大小大于 To 区和老年代的可用内存</strong></p>
<p>由 <code>Eden</code> 区、<code>From</code> 区向 <code>To</code> 区复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/doulist/2545443/">从表到里学习 JVM 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coderlius/article/details/79272773">详解 JVM Garbage First(G1) 垃圾收集器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanggang807/article/details/45956325">G1 垃圾收集器入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Getting Started with the G1 Garbage Collector</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1337a0f7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1337a0f7/" class="post-title-link" itemprop="url">深入理解 Java 反射和动态代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-04 13:51:01" itemprop="dateCreated datePublished" datetime="2020-06-04T13:51:01+08:00">2020-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-反射和动态代理"><a href="#深入理解-Java-反射和动态代理" class="headerlink" title="深入理解 Java 反射和动态代理"></a>深入理解 Java 反射和动态代理</h1><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/xmind/Java%E5%8F%8D%E5%B0%84.svg" alt="img"></p>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li>
<li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li>
<li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li>
<li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li>
</ul>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><ul>
<li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li>
<li><strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li>
<li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li>
</ul>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553611895164.png" alt="img"></p>
<p>类加载的完整过程如下：</p>
<ol>
<li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li>
<li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li>
<li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li>
</ol>
<h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p>
<p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p>
<p>举例来说，假如定义了以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p>步骤说明：</p>
<ol>
<li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li>
<li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li>
<li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li>
</ol>
<h3 id="方法的反射调用"><a href="#方法的反射调用" class="headerlink" title="方法的反射调用"></a>方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p>
<p><code>Method.invoke</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Method</span> <span class="keyword">extends</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">    ... <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">      ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Method.invoke</code> 方法实际上委派给 <code>MethodAccessor</code> 接口来处理。它有两个已有的具体实现：</p>
<ul>
<li><code>NativeMethodAccessorImpl</code>：本地方法来实现反射调用</li>
<li><code>DelegatingMethodAccessorImpl</code>：委派模式来实现反射调用</li>
</ul>
<p>每个 <code>Method</code> 实例的第一次反射调用都会生成一个委派实现（<code>DelegatingMethodAccessorImpl</code>），它所委派的具体实现便是一个本地实现（<code>NativeMethodAccessorImpl</code>）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 <code>Method</code> 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>
<p>【示例】通过抛出异常方式 打印 <code>Method.invoke</code> 调用轨迹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo01&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        method.invoke(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// java.lang.Exception: #0</span></span><br><span class="line"><span class="comment">//     at io.github.dunwu.javacore.reflect.MethodDemo01.target(MethodDemo01.java:12)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br></pre></td></tr></table></figure>

<p>先调用 <code>DelegatingMethodAccessorImpl</code>；然后调用 <code>NativeMethodAccessorImpl</code>，最后调用实际方法。</p>
<p>为什么反射调用<code>DelegatingMethodAccessorImpl</code> 作为中间层，而不是直接交给本地实现？</p>
<p>其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。</p>
<p>考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 <code>-Dsun.reflect.inflationThreshold</code> 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。</p>
<p>【示例】执行 java -verbose:class MethodDemo02 启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo02&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            method.invoke(<span class="literal">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">java.lang.Exception: #<span class="number">14</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded sun.reflect.ClassFileConstants from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.AccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorFactory from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVector from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorImpl from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassFileAssembler from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.UTF8 from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label$PatchInfo from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.util.ArrayList$Itr from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]</span><br><span class="line">java.lang.Exception: #<span class="number">15</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">java.lang.Exception: #<span class="number">16</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>

<p>可以看到，从第 16 次开始后，都是使用 <code>DelegatingMethodAccessorImpl</code> ，不再使用本地实现 <code>NativeMethodAccessorImpl</code>。</p>
<h3 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的 Object 数组</li>
<li>基本类型的自动装箱、拆箱</li>
<li>还有最重要的方法内联</li>
</ul>
<p><code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p>
<blockquote>
<p>注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。</p>
</blockquote>
<p>下面只关注反射调用本身的性能开销。</p>
<p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p>
<p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p>
<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p>
<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="java-lang-reflect-包"><a href="#java-lang-reflect-包" class="headerlink" title="java.lang.reflect 包"></a>java.lang.reflect 包</h3><p>Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。</p>
<p><code>java.lang.reflect</code> 包的核心接口和类如下：</p>
<ul>
<li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li>
<li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li>
<li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li>
<li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li>
<li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li>
<li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li>
<li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li>
</ul>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 <code>Class</code> 对象的三种方法：</p>
<p>（1）**<code>Class.forName</code> 静态方法**</p>
<p>【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;[D&quot;</span>);</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;[[Ljava.lang.String;&quot;</span>);</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span></span><br><span class="line"><span class="comment">//double[]</span></span><br><span class="line"><span class="comment">//java.lang.String[][]</span></span><br></pre></td></tr></table></figure>

<p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p>
<p>（2）<strong>类名 + <code>.class</code></strong></p>
<p>【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="comment">// Class c = b.getClass(); // 编译错误</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="type">boolean</span>.class;</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> java.io.PrintStream.class;</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="type">int</span>[][][].class;</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="comment">//java.io.PrintStream</span></span><br><span class="line"><span class="comment">//int[][][]</span></span><br></pre></td></tr></table></figure>

<p>（3）**<code>Object</code> 的 <code>getClass</code> 方法**</p>
<p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p>
<p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E</span> &#123;A, B&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;foo&quot;</span>.getClass();</span><br><span class="line">        System.out.println(c.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> ReflectClassDemo03.E.A.getClass();</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> bytes.getClass();</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> set.getClass();</span><br><span class="line">        System.out.println(c4.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span></span><br><span class="line"><span class="comment">//byte[]</span></span><br><span class="line"><span class="comment">//java.util.HashSet</span></span><br></pre></td></tr></table></figure>

<h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p>
<ol>
<li><strong>用 <code>instanceof</code> 关键字</strong></li>
<li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceofDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (arrayList <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (List.class.isInstance(arrayList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br></pre></td></tr></table></figure>

<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来创建实例对象主要有两种方式：</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = StringBuilder.class;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> (StringBuilder) c1.newInstance();</span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c2 = String.class;</span><br><span class="line">        <span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c2.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//根据构造器创建实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//aaa</span></span><br><span class="line"><span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>

<h3 id="创建数组实例"><a href="#创建数组实例" class="headerlink" title="创建数组实例"></a>创建数组实例</h3><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，<strong>通过 <code>Array.newInstance</code> 创建数组的实例</strong>。</p>
<p>【示例】利用反射创建数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">array</span> <span class="operator">=</span> Array.newInstance(cls, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">//往数组里添加内容</span></span><br><span class="line">        Array.set(array, <span class="number">0</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">2</span>, <span class="string">&quot;Groovy&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">3</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">4</span>, <span class="string">&quot;Clojure&quot;</span>);</span><br><span class="line">        <span class="comment">//获取某一项的内容</span></span><br><span class="line">        System.out.println(Array.get(array, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Scala</span></span><br></pre></td></tr></table></figure>

<p>其中的 Array 类为 <code>java.lang.reflect.Array</code> 类。我们<code>Array.newInstance</code> 的原型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="type">int</span> length)</span></span><br><span class="line">    <span class="keyword">throws</span> NegativeArraySizeException &#123;</span><br><span class="line">    <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p>
<ul>
<li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li>
<li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li>
<li><code>getFields</code> - 获取所有公有的（public）类成员。</li>
<li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectFieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FieldSpy</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span>[][] b = &#123; &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;, &#123;<span class="literal">true</span>, <span class="literal">true</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">        <span class="keyword">public</span> T val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f1</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f1.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f2.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f3</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f3.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f4</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f4.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Type: class [[Z</span></span><br><span class="line"><span class="comment">//Type: class java.lang.String</span></span><br><span class="line"><span class="comment">//Type: interface java.util.List</span></span><br><span class="line"><span class="comment">//Type: class java.lang.Object</span></span><br></pre></td></tr></table></figure>

<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）：</p>
<ul>
<li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li>
<li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li>
</ul>
<p>获取一个 <code>Method</code> 对象后，可以用 <code>invoke</code> 方法来调用这个方法。</p>
<p><code>invoke</code> 方法的原型为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure>

<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有方法</span></span><br><span class="line">        Method[] methods1 = System.class.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getDeclaredMethods 清单（数量 = &quot;</span> + methods1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有 public 方法</span></span><br><span class="line">        Method[] methods2 = System.class.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getMethods 清单（数量 = &quot;</span> + methods2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods2) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 Method 的 invoke 方法调用 System.currentTimeMillis()</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> System.class.getMethod(<span class="string">&quot;currentTimeMillis&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(method.invoke(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p>
<ul>
<li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li>
<li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li>
</ul>
<p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethodConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getDeclaredConstructors 清单（数量 = &quot;</span> + constructors1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors1) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getConstructors 清单（数量 = &quot;</span> + constructors2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors2) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> String.class.getConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绕开访问限制"><a href="#绕开访问限制" class="headerlink" title="绕开访问限制"></a>绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/xmind/Java%E4%BB%A3%E7%90%86.svg" alt="img"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>静态代理其实就是指设计模式中的代理模式。</p>
<p><strong>代理模式为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-6269723ea61527bd.png" alt="img"></p>
<p><strong>Subject</strong> 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RealSubject</strong> 定义 Proxy 所代表的真实实体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy</strong> 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject real;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == real) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        real.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p>
</blockquote>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p>
<p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553614585028.png" alt="img"></p>
<p>Java 动态代理基于经典代理模式，引入了一个 <code>InvocationHandler</code>，<code>InvocationHandler</code> 负责统一管理所有的方法调用。</p>
<p>动态代理步骤：</p>
<ol>
<li>获取 RealSubject 上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li>
<li>根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li>
<li>将对应的字节码转换为对应的 class 对象；</li>
<li>创建 <code>InvocationHandler</code> 实例 handler，用来处理 <code>Proxy</code> 所有方法调用；</li>
<li>Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li>
</ol>
<p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p>
<p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p>
<p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 <code>InvocationHandler</code> 接口、另一个则是 <code>Proxy</code> 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p>
<h4 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h4><p><code>InvocationHandler</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个动态代理类都必须要实现 <code>InvocationHandler</code> 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 <code>InvocationHandler</code> 这个接口的 <code>invoke</code> 方法来进行调用。</p>
<p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>proxy</strong> - 代理的真实对象。</li>
<li><strong>method</strong> - 所要调用真实对象的某个方法的 <code>Method</code> 对象</li>
<li><strong>args</strong> - 所要调用真实对象某个方法时接受的参数</li>
</ul>
<p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p>
<h4 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h4><p><code>Proxy</code> 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 <code>newProxyInstance</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是得到一个动态的代理对象。</p>
<p>参数说明：</p>
<ul>
<li><strong>loader</strong> - 一个 <code>ClassLoader</code> 对象，定义了由哪个 <code>ClassLoader</code> 对象来对生成的代理对象进行加载。</li>
<li><strong>interfaces</strong> - 一个 <code>Class&lt;?&gt;</code> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li><strong>h</strong> - 一个 <code>InvocationHandler</code> 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 <code>InvocationHandler</code> 对象上</li>
</ul>
<h4 id="JDK-动态代理实例"><a href="#JDK-动态代理实例" class="headerlink" title="JDK 动态代理实例"></a>JDK 动态代理实例</h4><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p>
<p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">bye</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello  &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">bye</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerDemo</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是我们要代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerDemo</span><span class="params">(Object subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Call Method: &quot;</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，来看看我们的 Client 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们要代理的真实对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerDemo</span>(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.hello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> subject.bye();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result is: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看控制台的输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.proxy</span>.<span class="variable">$Proxy0</span></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract void io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span>.InvocationHandlerDemo<span class="variable">$Subject</span><span class="selector-class">.hello</span>(java<span class="selector-class">.lang</span>.String)</span><br><span class="line">Hello  World</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract java<span class="selector-class">.lang</span><span class="selector-class">.String</span> io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span>.InvocationHandlerDemo<span class="variable">$Subject</span><span class="selector-class">.bye</span>()</span><br><span class="line">Goodbye</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Result is: Over</span><br></pre></td></tr></table></figure>

<p>我们首先来看看 <code>com.sun.proxy.$Proxy0</code> 这东西，我们看到，这个东西是由 <code>System.out.println(subject.getClass().getName());</code> 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br></pre></td></tr></table></figure>

<p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象？</strong></p>
<p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p>
<p><strong>同时我们一定要记住，通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号</strong>。</p>
<p>接着我们来看看这两句</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subject.hello(<span class="string">&quot;World&quot;</span>)<span class="comment">;</span></span><br><span class="line">String result <span class="operator">=</span> subject.bye()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p>
<p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</span><br></pre></td></tr></table></figure>

<p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p>
<h4 id="JDK-动态代理小结"><a href="#JDK-动态代理小结" class="headerlink" title="JDK 动态代理小结"></a>JDK 动态代理小结</h4><p>代理类与委托类实现同一接口，主要是通过代理类实现 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法来进行动态代理的，在 <code>invoke</code> 方法中将对方法进行处理。</p>
<p>JDK 动态代理特点：</p>
<ul>
<li><p>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</p>
</li>
<li><p>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</p>
</li>
</ul>
<h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>CGLIB 提供了与 JDK 动态代理不同的方案。很多框架，例如 Spring AOP 中，就使用了 CGLIB 动态代理。</p>
<p>CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。</p>
<p>CGLIB 动态代理的工作步骤：</p>
<ul>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成 <code>Class</code> 对象( 例如使用 <code>Class.forName()</code> 方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象。</li>
</ul>
<p>CGLIB 动态代理特点：</p>
<p>优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。</p>
<p>缺点：不能对 <code>final</code> 类以及 <code>final</code> 方法进行代理。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100010301">极客时间教程 - 深入拆解 Java 虚拟机</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1） - 基础</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java 基础之—反射（非常重要）</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/index.html">官方 Reflection API 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html">Java 的动态代理机制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/24589193">Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/471c80a7e831">深入理解 JDK 动态代理机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/30/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/blog/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/32/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"6421dfb78fb815ed594f73b0a64e4579"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
