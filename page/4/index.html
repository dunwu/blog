<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/4/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6d6841e1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6d6841e1/" class="post-title-link" itemprop="url">《高性能 MySQL》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-02 20:50:31" itemprop="dateCreated datePublished" datetime="2024-10-02T20:50:31+08:00">2024-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《高性能-MySQL》笔记"><a href="#《高性能-MySQL》笔记" class="headerlink" title="《高性能 MySQL》笔记"></a>《高性能 MySQL》笔记</h1><blockquote>
<p>部分章节内容更偏向于 DBA 的工作，在实际的开发工作中相关性较少，直接略过。</p>
</blockquote>
<h2 id="第一章-MySQL-架构与历史"><a href="#第一章-MySQL-架构与历史" class="headerlink" title="第一章 MySQL 架构与历史"></a>第一章 MySQL 架构与历史</h2><h3 id="MySQL-逻辑架构"><a href="#MySQL-逻辑架构" class="headerlink" title="MySQL 逻辑架构"></a>MySQL 逻辑架构</h3><p>MySQL 逻辑架构分为三层：</p>
<ul>
<li>连接层 - 连接管理、认证管理</li>
<li>核心服务层 - 缓存、解析、优化、执行</li>
<li>存储引擎层 - 数据实际读写</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>解决并发问题的最常见方式是加锁。</p>
<ul>
<li><p>排它锁（exclusive lock） - 也叫写锁（write lock）。<strong>锁一次只能被一个线程所持有</strong>。</p>
</li>
<li><p>共享锁（shared lock） - 也叫读锁（read lock）。<strong>锁可被多个线程所持有</strong>。</p>
</li>
</ul>
<p>加锁、解锁，检查锁是否已释放，都需要消耗资源，因此锁定的粒度越小，并发度越高。</p>
<p>MySQL 中支持多种锁粒度：</p>
<ul>
<li>表级锁（table lock） - 锁定整张表，会阻塞其他用户对该表的读写操作。</li>
<li>行级锁（row lock） - 可以最大程度的支持并发处理。</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务就是一组原子性的 SQL 查询。事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li>**原子性 (Atomicity)**：一个事务被视为不可分割的最小工作单元，一个事务的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>**一致性 (Consistency)**：数据库总是从一个一致的状态到另一个一致的状态。事务没有提交，事务的修改就不会保存到数据库中。</li>
<li>**隔离性 (isolation)**：通常来说，一个事务所作的操作在最终提交之前，对其他事务来说是不可见的。</li>
<li>**持久性 (durability)**：一旦事务提交，则其所作的修改就会永久的保存到数据库中。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>SQL 标准提出了四种“事务隔离级别”。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p>
<p>事务隔离级别从低到高分别是：</p>
<ul>
<li><strong>“读未提交（read uncommitted）”</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。<ul>
<li><strong>读未提交存在脏读问题</strong>。“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据。</li>
</ul>
</li>
<li><strong>“读已提交（read committed）” ** - 是指，</strong>事务提交后，其他事务才能看到它的修改**。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。<ul>
<li><strong>读已提交解决了脏读的问题</strong>。</li>
<li><strong>读已提交存在不可重复读问题</strong>。“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致。</li>
<li><strong>读已提交是大多数数据库的默认事务隔离级别</strong>，如 Oracle。</li>
</ul>
</li>
<li><strong>“可重复读（repeatable read）”</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。<ul>
<li><strong>可重复读解决了不可重复读问题</strong>。</li>
<li><strong>可重复读存在幻读问题</strong>。“幻读（phantom read）”是指一个事务内多次读取同一范围的数据过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据。</li>
<li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li>
</ul>
</li>
<li><strong>串行化（serializable ）</strong> - 是指，<strong>强制事务串行执行</strong>，对读取的每一行数据都加锁，一旦出现锁冲突，必须等前面的事务释放锁。<ul>
<li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li>
<li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li>
</ul>
</li>
</ul>
<p>事务隔离级别对并发一致性问题的解决情况：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">丢失修改</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
</tr>
</tbody></table>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或多个事务竞争同一资源，从而导致恶性循环的现象。多个事务视图以不同顺序锁定资源时，就可能会产生死锁；多个事务同时锁定同一资源时，也会产生死锁。</p>
<p>InnoDB 目前处理死锁的方法是<strong>将持有最少行级锁的事务进行回滚</strong>。</p>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>InnoDB 通过事务日志记录修改操作。事务日志的写入采用追加方式，因此是顺序 I&#x2F;O，比随机 I&#x2F;O 快很多。</p>
<p>事务日志持久化后，内存中被修改的数据由后台程序慢慢刷回磁盘，这称为预写日志（Write Ahead Logging，WAL）</p>
<p>如果数据修改以及记录到事务日志并持久化，此时系统崩溃，存储引擎可以在系统重启之后自动恢复数据。</p>
<h4 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h4><p>MySQL 提供了两种事务存储引擎：InnoDB 和 NDB CLuster。</p>
<p>MySQL 默认采用自动提交模式（AUTOCOMMIT）。即如果不显式的声明一个事务，MySQL 会把每一个查询都当作一个事务来操作。</p>
<p>可以通过设置 AUTOCOMMIT 来启用或禁用自动提交模式。</p>
<p>可以通过执行 SET TRANSACTION ISOLATION LEVEL 来设置事务隔离级别。</p>
<p>InnoDB 采用两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 时才会释放，并且所有的锁都在一瞬间释放。</p>
<p>InnoDB 也支持通过特定语句显示加锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 先在表上加上 <span class="keyword">IS</span> 锁，然后对读取的记录加 S 锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 当前读：先在表上加上 IX 锁，然后对读取的记录加 X 锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>可以将 MVCC 视为行级锁的一个变种，它在很多情况下避免了加锁，因此开销更低。</p>
<p>MVCC 是通过保存数据在某个时刻的快照来实现的。也就是说，不管执行多久，每个事务看到的数据是一致的。根据事务开始时间不同， 每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>不同存储引擎实现 MVCC 的方式有所不同，典型的有乐观并发控制和悲观并发控制。</p>
<p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏列来实现。一个列保存了行的创建时间，一个是保存了过期时间。当然存储的不是实际的时间，而是系统版本号（system version number），每开始一个新事务，系统版本号都会自动递增。事务开始时刻的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号作比较。</p>
<ul>
<li><strong>Select</strong> - InnoDB 会根据这两个条件来查询：<ul>
<li>只查找版本号小于或者等于当前事务的数据行，这样可以保证事务读取到的数据要么是在事务开始前就存在的，要么是自己插入或者修改的。</li>
<li>行的删除版本要么未定义，要么大于当前事务的版本号，这样可以保证读取到的数据在事务开始之前没有被删除。</li>
</ul>
</li>
<li><strong>Insert</strong> - InnoDB 为新插入的每一行数据保存当前的系统版本号为行版本号。</li>
<li><strong>Delete</strong> - InnoDB 为删除的每一行保存当前的版本号为行删除标识。</li>
<li><strong>Update</strong> - InnoDB 为插入一条新纪录，保存当前系统版本号为行版本号，同时保存当前系统的版本号到原来的行为行删除标识。</li>
</ul>
<p>MVCC 只在可重复读和读已提交两个隔离级别下工作。</p>
<h3 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h3><p>Mysql 将每个数据库保存为数据目录下的一个子目录。建表时，MySQL 会在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义。因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关：在 Windows 中，大小写不敏感；在 Linux 中，大小写敏感。</p>
<p>Mysql 常见存储引擎</p>
<ul>
<li>InnoDB - 默认事务引擎。</li>
<li>MyISAM - Mysql 5.1 及之前的默认引擎。</li>
<li>Archive</li>
<li>Memory</li>
<li>NDB</li>
</ul>
<h2 id="第二章-MySQL-基准测试（略）"><a href="#第二章-MySQL-基准测试（略）" class="headerlink" title="第二章 MySQL 基准测试（略）"></a><del>第二章 MySQL 基准测试（略）</del></h2><h2 id="第三章-服务器性能剖析（略）"><a href="#第三章-服务器性能剖析（略）" class="headerlink" title="第三章 服务器性能剖析（略）"></a><del>第三章 服务器性能剖析（略）</del></h2><h2 id="第四章-Schema-与数据类型优化"><a href="#第四章-Schema-与数据类型优化" class="headerlink" title="第四章 Schema 与数据类型优化"></a>第四章 Schema 与数据类型优化</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>整数类型有可选的 <code>UNSIGNED</code> 属性，标识不允许负值，大致可以使正数的上限提高一倍。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TINYINT</code></td>
<td align="left">1 字节</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left"><code>SMALLINT</code></td>
<td align="left">2 字节</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left"><code>MEDIUMINT</code></td>
<td align="left">3 字节</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left"><code>INT</code></td>
<td align="left">4 字节</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left"><code>BIGINT</code></td>
<td align="left">8 字节</td>
<td align="left">极大整数值</td>
</tr>
</tbody></table>
<h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><p><code>FLOAT</code> 和 <code>DOUBLE</code> 分别使用 4 个字节、8 个字节存储空间，它们支持使用标准的浮点运算进行近似计算，存在丢失精度的可能。</p>
<p><code>DECIMAL</code> 类型用于存储精确的小数，支持精确计算，但是计算代价高。只有在需要对小数进行精确计算时，才应该使用 <code>DECIMAL</code>，例如财务数据。此外，当数据量较大时，可以考虑使用 BIGINT 代替 DECIMAL，将需要存储的货币单位乘以需要精确的倍数即可。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FLOAT</code></td>
<td align="left">4 字节</td>
<td align="left">单精度浮点数值</td>
</tr>
<tr>
<td align="left"><code>DOUBLE</code></td>
<td align="left">8 字节</td>
<td align="left">双精度浮点数值</td>
</tr>
<tr>
<td align="left"><code>DECIMAL</code></td>
<td align="left"></td>
<td align="left">精确的小数值</td>
</tr>
</tbody></table>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>VARCHAR 类型用于存储可变长字符串。</p>
<p>CHAR 类型是定长字符串。</p>
<p>与 CHAR 和 VARCHAR 类似的类型还有 BINARY 和 VARBINARY，它们存储的是二进制字符串。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CHAR</code></td>
<td align="left">0-255 字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left"><code>VARCHAR</code></td>
<td align="left">0-65535 字节</td>
<td align="left">变长字符串</td>
</tr>
</tbody></table>
<h4 id="BLOB-和-TEXT"><a href="#BLOB-和-TEXT" class="headerlink" title="BLOB 和 TEXT"></a>BLOB 和 TEXT</h4><p><code>BLOB</code> 和 <code>TEXT</code> 都用于存储很大的数据，分别采用二进制和字符串方式存储。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TINYBLOB</code></td>
<td align="left">0-255 字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left"><code>TINYTEXT</code></td>
<td align="left">0-255 字节</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left"><code>BLOB</code></td>
<td align="left">0-65 535 字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left"><code>TEXT</code></td>
<td align="left">0-65 535 字节</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left"><code>MEDIUMBLOB</code></td>
<td align="left">0-16 777 215 字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left"><code>MEDIUMTEXT</code></td>
<td align="left">0-16 777 215 字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left"><code>LONGBLOB</code></td>
<td align="left">0-4 294 967 295 字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left"><code>LONGTEXT</code></td>
<td align="left">0-4 294 967 295 字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">格式</th>
<th align="left">作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3 字节</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
<td></td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3 字节</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
<td></td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1 字节</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
<td></td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8 字节</td>
<td align="left">YYYY-MM-DD hh:mm:ss</td>
<td align="left">混合日期和时间值</td>
<td>有效时间范围为 1000-01-01 00:00:00 到 9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4 字节</td>
<td align="left">YYYY-MM-DD hh:mm:ss</td>
<td align="left">混合日期和时间值，时间戳</td>
<td>有效时间范围为 1970-01-01 00:00:01 到 2038-01-19 03:14:07</td>
</tr>
</tbody></table>
<h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h4><ul>
<li><strong>ENUM</strong> - 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li>
<li><strong>SET</strong> - 集合类型，用于存储多个值，可以选择多个预定义的集合。</li>
</ul>
<h3 id="Schema-设计简单规则"><a href="#Schema-设计简单规则" class="headerlink" title="Schema 设计简单规则"></a>Schema 设计简单规则</h3><ul>
<li>尽量避免过度设计，例如会导致极其复杂查询的 schema 设计，或者有很多列的表设计。</li>
<li>使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用 NULL 值。</li>
<li>尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。</li>
<li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。</li>
<li>尽量使用整型定义标识列。</li>
<li>避免使用 MySQL 已经遗弃的特性，例如制定浮点数的精度，或者整数的显示宽度。</li>
<li>小心使用 ENUM 和 SET，虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱，最好避免使用 BIT。</li>
</ul>
<p>范式意味着不存储冗余数据，但往往需要多关联查询，增加了查询的复杂度；反范式意味着存储冗余数据，但是减少了关联查询。在实际应用中，范式和反范式应当混合使用。</p>
<p>ALTER TABLE 如果操作的是大表，需要耗费大量时间。一般的操作是：用新结构创建一张空表，从旧表查出所有数据插入新表，然后删除旧表。</p>
<p>有两种替代方案：</p>
<ul>
<li>在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换。</li>
<li>影子拷贝：创建一张新表，然后通过重命名和删表操作交换两张表。</li>
</ul>
<h2 id="第五章-创建高性能的索引"><a href="#第五章-创建高性能的索引" class="headerlink" title="第五章 创建高性能的索引"></a>第五章 创建高性能的索引</h2><p>索引是存储引擎用于快速找到记录的一种数据结构。</p>
<p>索引优化应该是对查询性能优化最有效的手段了。</p>
<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。</p>
<h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h4><p>大多数 MySQL 引擎都支持 B-Tree 索引。存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同，各有优劣。例如，MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。再如 MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据主键引用被索引的行。</p>
<p>B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041118763.png"></p>
<p>B-Tree 索引从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。</p>
<p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<p>假设有如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> People(</span><br><span class="line">	last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">	first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">	dob <span class="type">date</span> <span class="keyword">not null</span>,</span><br><span class="line">	gender enum(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>)<span class="keyword">not null</span>,</span><br><span class="line">	key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于表中的每一行数据，索引中包含了 last_name、 first_name 和 dob 列的值。</p>
<p>请注意，索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。看一下最后两个条目，两个人的姓和名都-样，则根据他们的出生日期来排列顺序。</p>
<p>可以使用 B-Tree 索引的查询类型。B-Tree 索引适用于全键值、键值范围或键前缀查找。</p>
<p>其中键前缀查找只适用于根据最左前缀的查找生。前面所述的索引对如下类型的查询有效。</p>
<ul>
<li><em>全值匹配</em> - 全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen、出生于 1960-01-01 的人。</li>
<li><em>匹配最左前缀</em> - 前面提到的索引可用于查找所有姓为 Allen 的人，即只使用索引的第一列。</li>
<li><em>匹配列前缀</em> - 也可以只匹配某–列的值的开头部分。例如前面提到的索引可用于查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。</li>
<li><em>匹配范围值</em> - 例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。</li>
<li><em>精确匹配某一列并范围匹配另外一列</em> - 前面提到的索引也可用于查找所有姓为 Allen, 并且名字是字母 K 开头的人。即第一列 last_ name 全匹配，第二列 first_name 范围匹配。</li>
<li><em>只访问索引的查询</em> - B-Tree 通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行。也叫做覆盖索引。</li>
</ul>
<p>因为索引树中的节点是有序的，所以除了按值查找外，索引还可以用于查询中的排序操作。</p>
<p>B-Tree 索引的限制：</p>
<ul>
<li><strong>如果不是按照索引的最左列开始查找，则无法使用索引</strong>。例如上面例子中的索引无法用于查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。</li>
<li><strong>不能跳过索引中的列</strong>。也就是说，前面所述的索引无法用于查找姓为 Smith 并且在某个特定日期出生的人。如果不指定名 (first_name)，则 MySQL 只能使用索引的第一列。</li>
<li><strong>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</strong>。例如有查询 <code>WHERE last_name=&#39; Smith&#39; AND first_name LIKE &#39;J%&#39; AND dob = &#39;1976-12-23&#39;</code> ，这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引 (hashindex) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。</p>
<p>对于每一行数据，存储引擎都会对所有的索引列计算-一个哈希码 (hash code), 哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>哈希索引的限制：</p>
<ul>
<li><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以<strong>不能使用索引中的值来避免读取行</strong>。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</p>
</li>
<li><p>哈希索引数据并不是按照索引值顺序存储的，所以也就<strong>无法用于排序</strong>。</p>
</li>
<li><p>哈希索引也<strong>不支持部分索引列匹配查找</strong>，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A, 则无法使用该索引。</p>
</li>
<li><p>哈希索引<strong>只支持等值比较查询</strong>，包括 <code>=</code>、<code>IN()</code>、 <code>&lt;=&gt;</code> （注意 <code>&lt;&gt;</code> 和 <code>&lt;=&gt;</code> 是不同的操作）。也不支持任何范围查询，例如 <code>WHERE price &gt; 100</code>。</p>
</li>
<li><p><strong>访问哈希索引的数据非常快</strong>，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</p>
</li>
<li><p><strong>如果哈希冲突很多的话，一些索引维护操作的代价也会很高</strong>。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</p>
</li>
</ul>
<h4 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引 (R-Tree)"></a>空间数据索引 (R-Tree)</h4><p>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。</p>
<p>查询时，可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。MySQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对 GIS 的解决方案做得比较好的是 PostgreSQL 的 PostGIS</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<p>全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。</p>
<p>全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。</p>
<p>在相同的列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突，全文索引适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件操作。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>索引有以下优点：</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I&#x2F;O 变为顺序 I&#x2F;O。</li>
</ol>
<p>索引是最好的解决方案吗？</p>
<ul>
<li><p>对于非常小的表，大部分情况下简单的全表扫描更高效。</p>
</li>
<li><p>对于中到大型的表，索引就非常有效。</p>
</li>
<li><p>但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。例如可以使用分区技术。</p>
</li>
<li><p>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录。哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于大型系统，这是一个常用的技巧。</p>
</li>
</ul>
<h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><p>正确地创建和使用索引是实现高性能查询的基础。</p>
<h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p><strong>独立的列</strong>是指索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>下面两个例子都无法使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_ id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> TO_DAYS(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> TO_ DAYS(date_col) <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。一种策略是，可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值和总记录数的比值。索引的选择性越高则查询效率越高。</p>
<p>对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL <strong>不允许索引这些列的完整长度</strong>。</p>
<p>前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。通常来说，选择性能够接近 0.03，基本上就可用了。</p>
<p>计算前缀索引选择性的示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> (city, <span class="number">3</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel3,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> (city, <span class="number">4</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel4,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> (city, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel5,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> (city, <span class="number">6</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> se16,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> (city, <span class="number">7</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel7,</span><br><span class="line"><span class="keyword">FROM</span> sakila.city demo;</span><br></pre></td></tr></table></figure>

<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p><strong>在多个列上建立独立的单列索引大部分情况下并不能提高 MySQL 的查询性能。</strong></p>
<p>例如，表 film_actor 在字段 film_id 和 actor_id 上各有一个单列索引。但对于下面这个查询 WHERE 条件，这两个单列索引都不是好的选择：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>
<p>如何选择索引的列顺序：</p>
<ul>
<li>将选择性最高的列放到索引最前列。</li>
<li>可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> payment <span class="keyword">WHERE</span> staff.id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> customer._id <span class="operator">=</span> <span class="number">584</span>;</span><br></pre></td></tr></table></figure>

<p>是应该创建一个 (staff<em>id, customer</em> id) 索引还是应该颠倒一下顺序？</p>
<p>可以跑一些查询来确定在这个表中值的分布情况，并确定哪个列的选择性更高。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。<strong>聚簇</strong>表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表<strong>只能有一个聚簇索引</strong>。</p>
<p>具体的细节依赖于其实现方式，在 InnoDB 中，数据行实际上存放在索引的<strong>叶子页 (leaf page)</strong> 中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041119862.png"></p>
<p>聚簇索引的优点：</p>
<ul>
<li><strong>可以把相关数据保存在一起</strong>，访问数据时，可以减少磁盘 I&#x2F;O。</li>
<li><strong>数据访问更快</strong>。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li><strong>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</strong>。</li>
</ul>
<p>聚簇索引的缺点：</p>
<ul>
<li><strong>聚簇数据最大限度地提高了 I&#x2F;O 密集型应用的性能</strong>，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li><strong>插入速度严重依赖于插入顺序</strong>。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。</li>
<li><strong>更新聚簇索引列的代价很高</strong>，因为会强制 InnoDB 将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，<strong>可能面临页分裂 (page split) 的问题</strong>。当行的主键值要求必须将这一行插人到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li><strong>聚簇索引可能导致全表扫描变慢</strong>，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li>
<li><strong>二级索引 （非聚簇索引）可能比想象的要更大</strong>，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li><strong>二级索引访问需要两次索引查找</strong>，而不是一次。（回表）</li>
</ul>
<h4 id="InnoDB-和-MyISAM-的数据分布对比"><a href="#InnoDB-和-MyISAM-的数据分布对比" class="headerlink" title="InnoDB 和 MyISAM 的数据分布对比"></a>InnoDB 和 MyISAM 的数据分布对比</h4><p>MyISAM 存储引擎采用非聚簇索引存储数据，而 InnoDB 存储引擎采用聚簇索引存储数据。</p>
<p>来看下 MyISAM 和 InnoDB 是如何存储下面的表：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test (</span><br><span class="line">    col1 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col2 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(col1),</span><br><span class="line">    KEY(col2),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于 MyISAM，其数据分布比较简单，按照数据插入的顺序存储在磁盘上。对于每一行数据，都是一个行号，从 0 开始递增。由于行是定长的，所以 MyISAM 可以从表的开头跳过所需的字节找到需要的行（有点类似于数组）。如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041138948.png"></p>
<p>MyISAM 使用主键索引查找数据时，在 B+Tree 的叶子节点除了存储索引键之外，还保存了每个键所处的行指针（可以理解为行号）。当找到某个索引键对应的行指针后，就能定位到它对应的数据。如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041138993.png"></p>
<p>对于 MyISAM 的二级索引，它的存储方式跟主键索引没有什么区别，如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041216856.png"></p>
<p><strong>所以对于 MyISAM 来讲，主键索引和其它索引在存储结构上并没有什么区别。主键索引就是一个名为 PRIMARY 的惟一非空索引</strong>。</p>
<p>对于 InnoDB 来讲，主键索引是聚簇的，也就是主键索引就是表，所以不像 MyISAM 那样需要独立的行存储。 聚簇索引的每个叶子节点都包含了主键值、事务 ID、用于事务和 MVCC 的回滚指针以及所有剩余列（这个例子中是 col2）。对于 InnoDB 的主键索引，数据分布如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041216040.png"></p>
<p>InnoDB 的二级索引和聚簇索引区别比较大，它的二级索引的叶子节点存储的不是”行指针”，而是主键值。存储主键值带来的好处是，InnoDB 在移动行时无须更新二级索引的这个指针。如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041217784.png"></p>
<p><strong>由于 InnoDB 是通过主键聚集数据，所以使用 InnoDB 时，一定要指定主键，如果没有定义主键，InnoDB 会选择一个惟一的非空索引代替，如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</strong></p>
<p><strong>由于聚簇索引插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式，所以通常我们都使用一个递增 ID 作为主键。</strong></p>
<p>最后，我们使用一个比较抽象的图，对比一下聚簇和非聚簇的数据分布：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410041217744.png"></p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含所有需要查询的字段的值，我们就称之为“ 覆盖索引”。覆盖索引能极大地提高性能。</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MySQL 就会极大地减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于 I&#x2F;O 密集型的范围查询会比随机从磁盘读取每一行数据的 I&#x2F;O 要少得多。</li>
<li>一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。</li>
<li>InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以 MySQL 只能使用 B-Tree 索引做覆盖索引。</p>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>如果 <code>EXPLAIN</code> 出来的 <code>type</code> 列的值为 <code>index</code>, 则说明 MySQL 使用了索引扫描来做排序（不要和 <code>Extra</code> 列的 <code>Using index</code> 搞混淆了）。</p>
<p>MySQL 可以使用同一个索引既满足排序，又用于查找行。只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL 才能够使用索引来对结果做排序。</p>
<h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。</p>
<h2 id="第六章-查询性能优化"><a href="#第六章-查询性能优化" class="headerlink" title="第六章 查询性能优化"></a>第六章 查询性能优化</h2><h3 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h3><h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><h3 id="MySQL-查询优化器的局限性"><a href="#MySQL-查询优化器的局限性" class="headerlink" title="MySQL 查询优化器的局限性"></a>MySQL 查询优化器的局限性</h3><h3 id="查询优化器的提示（hint"><a href="#查询优化器的提示（hint" class="headerlink" title="查询优化器的提示（hint)"></a>查询优化器的提示（hint)</h3><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><h2 id="第七章-MySQL-高级特性（略）"><a href="#第七章-MySQL-高级特性（略）" class="headerlink" title="第七章 MySQL 高级特性（略）"></a><del>第七章 MySQL 高级特性（略）</del></h2><h2 id="第八章-优化服务器设置（略）"><a href="#第八章-优化服务器设置（略）" class="headerlink" title="第八章 优化服务器设置（略）"></a><del>第八章 优化服务器设置（略）</del></h2><h2 id="第九章-操作系统和硬件优化（略）"><a href="#第九章-操作系统和硬件优化（略）" class="headerlink" title="第九章 操作系统和硬件优化（略）"></a><del>第九章 操作系统和硬件优化（略）</del></h2><h2 id="第十章-复制"><a href="#第十章-复制" class="headerlink" title="第十章 复制"></a>第十章 复制</h2><h3 id="复杂概述"><a href="#复杂概述" class="headerlink" title="复杂概述"></a>复杂概述</h3><h3 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h3><h3 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h3><h3 id="复制拓扑"><a href="#复制拓扑" class="headerlink" title="复制拓扑"></a>复制拓扑</h3><h3 id="复制和容量规划"><a href="#复制和容量规划" class="headerlink" title="复制和容量规划"></a>复制和容量规划</h3><h3 id="复制管理和维护"><a href="#复制管理和维护" class="headerlink" title="复制管理和维护"></a>复制管理和维护</h3><h3 id="复制的问题和解决方案"><a href="#复制的问题和解决方案" class="headerlink" title="复制的问题和解决方案"></a>复制的问题和解决方案</h3><h3 id="复制有多快"><a href="#复制有多快" class="headerlink" title="复制有多快"></a>复制有多快</h3><h3 id="MySQL-复制的高级特性"><a href="#MySQL-复制的高级特性" class="headerlink" title="MySQL 复制的高级特性"></a>MySQL 复制的高级特性</h3><h3 id="其他复制技术"><a href="#其他复制技术" class="headerlink" title="其他复制技术"></a>其他复制技术</h3><h2 id="第十一章-可扩展的-MySQL（略）"><a href="#第十一章-可扩展的-MySQL（略）" class="headerlink" title="第十一章 可扩展的 MySQL（略）"></a><del>第十一章 可扩展的 MySQL（略）</del></h2><h2 id="第十二章-高可用性（略）"><a href="#第十二章-高可用性（略）" class="headerlink" title="第十二章 高可用性（略）"></a><del>第十二章 高可用性（略）</del></h2><h2 id="第十三章-云端的-MySQL（略）"><a href="#第十三章-云端的-MySQL（略）" class="headerlink" title="第十三章 云端的 MySQL（略）"></a><del>第十三章 云端的 MySQL（略）</del></h2><h2 id="第十四章-应用层优化（略）"><a href="#第十四章-应用层优化（略）" class="headerlink" title="第十四章 应用层优化（略）"></a><del>第十四章 应用层优化（略）</del></h2><h2 id="第十五章-备份与恢复（略）"><a href="#第十五章-备份与恢复（略）" class="headerlink" title="第十五章 备份与恢复（略）"></a><del>第十五章 备份与恢复（略）</del></h2><h2 id="第十六章-MySQL-用户工具（略）"><a href="#第十六章-MySQL-用户工具（略）" class="headerlink" title="第十六章 MySQL 用户工具（略）"></a><del>第十六章 MySQL 用户工具（略）</del></h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a3867b8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a3867b8f/" class="post-title-link" itemprop="url">《MongoDB 权威指南》笔记一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-29 07:45:34" itemprop="dateCreated datePublished" datetime="2024-09-29T07:45:34+08:00">2024-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MongoDB-权威指南》笔记一"><a href="#《MongoDB-权威指南》笔记一" class="headerlink" title="《MongoDB 权威指南》笔记一"></a>《MongoDB 权威指南》笔记一</h1><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35688800/">《MongoDB 权威指南》</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/a3867b8f/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/85c7bc97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/85c7bc97/" class="post-title-link" itemprop="url">《MongoDB 权威指南》笔记二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-29 07:45:34" itemprop="dateCreated datePublished" datetime="2024-09-29T07:45:34+08:00">2024-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MongoDB-权威指南》笔记二"><a href="#《MongoDB-权威指南》笔记二" class="headerlink" title="《MongoDB 权威指南》笔记二"></a>《MongoDB 权威指南》笔记二</h1><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35688800/">《MongoDB 权威指南》</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/85c7bc97/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/dfbb5978/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/dfbb5978/" class="post-title-link" itemprop="url">《SQL 必知必会》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-29 07:45:34" itemprop="dateCreated datePublished" datetime="2024-09-29T07:45:34+08:00">2024-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《SQL-必知必会》笔记"><a href="#《SQL-必知必会》笔记" class="headerlink" title="《SQL 必知必会》笔记"></a>《SQL 必知必会》笔记</h1><h2 id="第-1-课-了解-SQL"><a href="#第-1-课-了解-SQL" class="headerlink" title="第 1 课 了解 SQL"></a>第 1 课 了解 SQL</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul>
<li>数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>
<li>表（table） - 某种特定类型数据的结构化清单。</li>
<li>模式 - 关于数据库和表的布局及特性的信息。</li>
<li>列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。</li>
<li>数据类型 - 所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允许）该列中存储的数据。</li>
<li>行（row） - 表中的一个记录。</li>
<li>主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。表中的任何列都可以作为主键，只要它满足以下条件：<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每一行都必须具有一个主键值（主键列不允许 NULL 值）；</li>
<li>主键列中的值不允许修改或更新；</li>
<li>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。</li>
</ul>
</li>
</ul>
<h3 id="什么是-SQL"><a href="#什么是-SQL" class="headerlink" title="什么是 SQL"></a>什么是 SQL</h3><p>SQL 是 Structured Query Language（结构化查询语言）的缩写。SQL 是一种专门用来与数据库沟通的语言。</p>
<h2 id="第-2-课-检索数据"><a href="#第-2-课-检索数据" class="headerlink" title="第 2 课 检索数据"></a>第 2 课 检索数据</h2><p>作为 SQL 组成部分的保留字。关键字不能用作表或列的名字。</p>
<p>检索单列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>检索多列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>检索所有列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>检索去重</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>限制数量</p>
<p>检索 TOP5 数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server 和 Access</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DB2</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL、MariaDB、PostgreSQL 或者 SQLite</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 检索从第 5 行起的 5 行数据</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line">LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- MySQL 和 MariaDB 中，上面的示例可以简化如下</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line">LIMIT <span class="number">5</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>使用注释</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="comment">-- 这是一条注释</span></span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"># 这是一条注释</span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SELECT prod_name, vend_id</span></span><br><span class="line"><span class="comment">FROM Products; */</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<h2 id="第-3-课-排序检索数据"><a href="#第-3-课-排序检索数据" class="headerlink" title="第 3 课 排序检索数据"></a>第 3 课 排序检索数据</h2><p>SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。例如，SELECT 语句中的 FROM 子句。</p>
<p>ORDER BY 子句取一个或多个列的名字，据此对输出进行排序。ORDER BY 支持两种排序方式：ASC（升序） 和 DESC（降序）。</p>
<p>按单列排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>按多列排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br></pre></td></tr></table></figure>

<p>按列位置排序（不推荐）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>指定排序方向</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-4-课-过滤数据"><a href="#第-4-课-过滤数据" class="headerlink" title="第 4 课 过滤数据"></a>第 4 课 过滤数据</h2><p>只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。</p>
<p>在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">3.49</span>;</span><br></pre></td></tr></table></figure>

<p>检索所有价格小于 10 美元的产品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>检索所有不是供应商 DLL01 制造的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面两条查询语句作用相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">!=</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>检索价格在 5 美元和 10 美元之间的所有产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>检索所有没有邮件地址的顾客</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> CUSTOMERS</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-5-课-高级数据过滤"><a href="#第-5-课-高级数据过滤" class="headerlink" title="第 5 课 高级数据过滤"></a>第 5 课 高级数据过滤</h2><ul>
<li><strong>AND</strong> - AND 用来表示检索满足所有给定条件的行。</li>
<li><strong>OR</strong> - OR 用来表示检索匹配任一给定条件的行。</li>
</ul>
<h3 id="组合-WHERE-子句"><a href="#组合-WHERE-子句" class="headerlink" title="组合 WHERE 子句"></a>组合 WHERE 子句</h3><p>检索由供应商 DLL01 制造且价格小于等于 4 美元的所有产品的名称和价格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>检索由供应商 DLL01 或供应商 BRS01 制造的所有产品的名称和价格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>WHERE 子句可以包含任意数目的 AND 和 OR 操作符。允许两者结合以进行复杂、高级的过滤。</p>
<p>SQL 在处理 OR 操作符前，优先处理 AND 操作符。</p>
<p>下面的示例中，SQL 会理解为由供应商 BRS01 制造的价格为 10 美元以上的所有产品，以及由供应商 DLL01 制造的所有产品，而不管其价格如何。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>任何时候使用具有 AND 和 OR 操作符的 WHERE 子句，都应该使用圆括号明确地分组操作符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IN-操作符"><a href="#IN-操作符" class="headerlink" title="IN 操作符"></a>IN 操作符</h3><p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN 取一组由逗号分隔、括在圆括号中的合法值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> ( <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span> )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>和下面的示例作用相同</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>为什么要使用 IN 操作符？其优点如下。</p>
<ul>
<li>在有很多合法选项时，IN 操作符的语法更清楚，更直观。</li>
<li>在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。</li>
<li>IN 操作符一般比一组 OR 操作符执行得更快。</li>
<li>IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 HERE 子句。</li>
</ul>
<h3 id="NOT-操作符"><a href="#NOT-操作符" class="headerlink" title="NOT 操作符"></a>NOT 操作符</h3><p>NOT 用来否定其后条件的关键字。</p>
<p>检索除 DLL01 之外的所有供应商制造的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>和下面的示例作用相同</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DLL01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<h2 id="第-6-课-用通配符进行过滤"><a href="#第-6-课-用通配符进行过滤" class="headerlink" title="第 6 课 用通配符进行过滤"></a>第 6 课 用通配符进行过滤</h2><p>通配符（wildcard）用来匹配值的一部分的特殊字符。</p>
<p>搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件。</p>
<p>在搜索子句中使用通配符，必须使用 LIKE 操作符。LIKE 指示 DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p>%表示任何字符出现任意次数。</p>
<p>检索所有产品名以 Fish 开头的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;Fish%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>匹配任何位置上包含文本 bean bag 的值，<br>不论它之前或之后出现什么字符。</p>
<p>检索产品名中包含 bean bag 的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>检索产品名中以 F 开头，y 结尾的产品</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;F%y&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>下划线（_）的用途与%一样，但它只匹配单个字符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[ ]）通配符"></a>方括号（[ ]）通配符</h3><p>方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。</p>
<blockquote>
<p>说明：并不是所有 DBMS 都支持用来创建集合的 []。只有微软的 Access 和 SQL Server 支持集合。</p>
</blockquote>
<p>找出所有名字以 J 或 M 开头的联系人：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_contact <span class="keyword">LIKE</span> <span class="string">&#x27;[JM]%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_contact;</span><br></pre></td></tr></table></figure>

<h2 id="第-7-课-创建计算字段"><a href="#第-7-课-创建计算字段" class="headerlink" title="第 7 课 创建计算字段"></a>第 7 课 创建计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>拼接字符串值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Access 和 SQL Server</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> vend_country <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DB2、Oracle、PostgreSQL、SQLite 和 Open Office Base</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> vend_country <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 或 MariaDB</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(vend_name, <span class="string">&#x27; (&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p>去除字符串中的空格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Access 和 SQL Server</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DB2、Oracle、PostgreSQL、SQLite 和 Open Office Base</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> RTRIM(vend_country) <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>使用别名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Access 和 SQL Server</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DB2、Oracle、PostgreSQL、SQLite 和 Open Office Base</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> RTRIM(vend_country) <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 和 MariaDB</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(vend_name, <span class="string">&#x27; (&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<h3 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h3><p>汇总物品的价格（单价乘以订购数量）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20008</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-8-课-使用函数处理数据"><a href="#第-8-课-使用函数处理数据" class="headerlink" title="第 8 课 使用函数处理数据"></a>第 8 课 使用函数处理数据</h2><p>大多数 SQL 实现支持以下类型的函数：</p>
<ul>
<li>算术函数</li>
<li>文本处理函数</li>
<li>时间处理函数</li>
<li>聚合函数</li>
<li>返回 DBMS 正使用的特殊信息（如返回用户登录信息）的系统函数</li>
</ul>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LEFT()（或使用子字符串函数）</td>
<td>返回字符串左边的字符</td>
</tr>
<tr>
<td>LENGTH()（也使用 DATALENGTH() 或 LEN()）</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>LOWER()（Access 使用 LCASE()）</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>去掉字符串左边的空格</td>
</tr>
<tr>
<td>RIGHT()（或使用子字符串函数）</td>
<td>返回字符串右边的字符</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>去掉字符串右边的空格</td>
</tr>
<tr>
<td>SOUNDEX()</td>
<td>返回字符串的 SOUNDEX 值</td>
</tr>
<tr>
<td>UPPER()（Access 使用 UCASE()）</td>
<td>将字符串转换为大写</td>
</tr>
</tbody></table>
<p>UPPER() 将文本转换为大写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, <span class="built_in">UPPER</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATEPART(yy, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Access</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATEPART(<span class="string">&#x27;yyyy&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- PostgreSQL</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATE_PART(<span class="string">&#x27;year&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> to_number(to_char(order_date, <span class="string">&#x27;YYYY&#x27;</span>)) <span class="operator">=</span> <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 和 MariaDB</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="number">2012</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ABS()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>COS()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>EXP()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>SIN()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>SQRT()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>TAN()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h2 id="第-9-课-汇总数据"><a href="#第-9-课-汇总数据" class="headerlink" title="第 9 课 汇总数据"></a>第 9 课 汇总数据</h2><p>聚集函数（aggregate function）对某些行运行的函数，计算并返回一个值。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG() 通过对表中行数计数并计算其列值之和，求得该列的平均值。</p>
<p>使用 AVG() 返回 Products 表中所有产品的平均价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>COUNT() 函数进行计数。可利用 COUNT() 确定表中行的数目或符合特定条件的行的数目。</p>
<p>返回 Customers 表中顾客的总数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>

<p>只对具有电子邮件地址的客户计数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(cust_email) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>

<p>MAX() 返回指定列中的最大值。</p>
<p>返回 Products 表中最贵物品的价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>MIN() 返回指定列的最小值。</p>
<p>返回 Products 表中最便宜物品的价格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> min_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<p>SUM() 用来返回指定列值的和（总计）。</p>
<p>返回订单中所有物品数量之和</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_items,</span><br><span class="line"><span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line"><span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line"><span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>

<h2 id="第-10-课-分组数据"><a href="#第-10-课-分组数据" class="headerlink" title="第 10 课 分组数据"></a>第 10 课 分组数据</h2><p>分组是使用 SELECT 语句的 GROUP BY 子句建立的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 要点：</p>
<ul>
<li>GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li>
<li>如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。</li>
<li>大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。</li>
<li>除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。</li>
<li>如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。</li>
<li>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</li>
</ul>
<p>HAVING 要点：</p>
<p>HAVING 非常类似于 WHERE。唯一的差别是，WHERE 过滤行，而 HAVING 过滤分组。</p>
<p>过滤两个以上订单的分组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>列出具有两个以上产品且其价格大于等于 4 的供应商：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>检索包含三个或更多物品的订单号和订购物品的数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>要按订购物品的数目排序输出，需要添加 ORDER BY 子句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> items</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句中使用时必须遵循的次序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure>

<h2 id="第-11-课-使用子查询"><a href="#第-11-课-使用子查询" class="headerlink" title="第 11 课 使用子查询"></a>第 11 课 使用子查询</h2><p>子查询（subquery），即嵌套在其他查询中的查询。</p>
<p>假如需要列出订购物品 RGAN01 的所有顾客，应该怎样检索？下面列出具体的步骤。</p>
<p>(1) 检索包含物品 RGAN01 的所有订单的编号。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">order_num</span></span><br><span class="line"><span class="section">-----------</span></span><br><span class="line">20007</span><br><span class="line">20008</span><br></pre></td></tr></table></figure>

<p>(2) 检索具有前一步骤列出的订单编号的所有顾客的 ID。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="number">20007</span>,<span class="number">20008</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cust_id</span></span><br><span class="line"><span class="section">----------</span></span><br><span class="line">1000000004</span><br><span class="line">1000000005</span><br></pre></td></tr></table></figure>

<p>(3) 检索前一步骤返回的所有顾客 ID 的顾客信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="string">&#x27;1000000004&#x27;</span>,<span class="string">&#x27;1000000005&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>现在，结合这两个查询，把第一个查询（返回订单号的那一个）变为子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                    <span class="keyword">FROM</span> orderitems</span><br><span class="line">                    <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>再进一步结合第三个查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="第-12-课-联结表"><a href="#第-12-课-联结表" class="headerlink" title="第 12 课 联结表"></a>第 12 课 联结表</h2><p>笛卡尔积 - 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
<p>内联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>

<p>联结多个表</p>
<p>下面两个 SQL 等价：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id <span class="operator">=</span> orders.cust_id <span class="keyword">AND</span> orderitems.order_num <span class="operator">=</span> orders.order_num <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="第-13-课-创建高级联结"><a href="#第-13-课-创建高级联结" class="headerlink" title="第 13 课 创建高级联结"></a>第 13 课 创建高级联结</h2><p>自联结</p>
<p>给与 Jim Jones 同一公司的所有顾客发送一封信件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> (<span class="keyword">SELECT</span> cust_name</span><br><span class="line">                   <span class="keyword">FROM</span> customers</span><br><span class="line">                   <span class="keyword">WHERE</span> cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自联结方式</span></span><br><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c1, customers <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name <span class="operator">=</span> c2.cust_name <span class="keyword">AND</span> c2.cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>自然联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id <span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>左外联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">       <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">       <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>右外联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">       <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> orders.cust_id <span class="operator">=</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<p>全外联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line">       <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.cust_id <span class="operator">=</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 FULLOUTER JOIN 语法。</p>
</blockquote>
<p>使用带聚集函数的联结</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id,</span><br><span class="line">  <span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">       <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<h2 id="第-14-课-组合查询"><a href="#第-14-课-组合查询" class="headerlink" title="第 14 课 组合查询"></a>第 14 课 组合查询</h2><p>主要有两种情况需要使用组合查询：</p>
<ul>
<li>在一个查询中从不同的表返回结构数据；</li>
<li>对一个表执行多个查询，按一个查询返回数据。</li>
</ul>
<p>把 Illinois、Indiana、Michigan 等州的缩写传递给 IN 子句，检索出这些州的所有行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;IN&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>找出所有 Fun4All</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>组合这两条语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>UNION 默认从查询结果集中自动去除了重复的行；如果想返回所有的匹配行，可使用 UNION ALL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-15-课-插入数据"><a href="#第-15-课-插入数据" class="headerlink" title="第 15 课 插入数据"></a>第 15 课 插入数据</h2><p>插入完整的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面两条 SQL 等价</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> Customers</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000000006&#x27;</span>, <span class="string">&#x27;Toy Land&#x27;</span>, <span class="string">&#x27;123 Any Street&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;NY&#x27;</span>, <span class="string">&#x27;11111&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000000006&#x27;</span>, <span class="string">&#x27;Toy Land&#x27;</span>, <span class="string">&#x27;123 Any Street&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>插入行的一部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1000000006&#x27;</span>, <span class="string">&#x27;Toy Land&#x27;</span>, <span class="string">&#x27;123 Any Street&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;NY&#x27;</span>, <span class="string">&#x27;11111&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>插入某些查询的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country</span><br><span class="line"><span class="keyword">FROM</span> CustNew;</span><br></pre></td></tr></table></figure>

<p>从一个表复制到另一个表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> CustCopy</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MariaDB、MySQL、Oracle、PostgreSQL 和 SQLite</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> CustCopy <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>

<h2 id="第-16-课-更新和删除数据"><a href="#第-16-课-更新和删除数据" class="headerlink" title="第 16 课 更新和删除数据"></a>第 16 课 更新和删除数据</h2><p>更新单列</p>
<p>更新客户 1000000005 的电子邮件地址</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_email <span class="operator">=</span> <span class="string">&#x27;kim@thetoystore.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000005&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>更新多列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_contact <span class="operator">=</span> <span class="string">&#x27;Sam Roberts&#x27;</span>, cust_email <span class="operator">=</span> <span class="string">&#x27;sam@toyland.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000006&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>从表中删除特定的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000006&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>更新和删除的指导原则</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键，尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的 WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关联的行。</li>
<li>有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。</li>
</ul>
<h2 id="第-17-课-创建和操纵表"><a href="#第-17-课-创建和操纵表" class="headerlink" title="第 17 课 创建和操纵表"></a>第 17 课 创建和操纵表</h2><p>创建表</p>
<p>利用 CREATE TABLE 创建表，必须给出下列信息：</p>
<ul>
<li>新表的名字，在关键字 CREATE TABLE 之后给出；</li>
<li>表列的名字和定义，用逗号分隔；</li>
<li>有的 DBMS 还要求指定表的位置。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> products (</span><br><span class="line">  prod_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  vend_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  prod_name <span class="type">CHAR</span>(<span class="number">254</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  prod_price <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  prod_desc <span class="type">VARCHAR</span>(<span class="number">1000</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>添加列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>删除列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> CustCopy;</span><br></pre></td></tr></table></figure>

<h2 id="第-18-课-使用视图"><a href="#第-18-课-使用视图" class="headerlink" title="第 18 课 使用视图"></a>第 18 课 使用视图</h2><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>视图的一些常见应用</p>
<p>重用 SQL 语句</p>
<ul>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</li>
<li>使用表的一部分而不是整个表。</li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>创建视图</p>
<p>创建一个名为 ProductCustomers 的视图，它联结三个表，返回已订购了任意产品的所有顾客的列表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ProductCustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> Customers, Orders, OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> OrderItems.order_num <span class="operator">=</span> Orders.order_num;</span><br></pre></td></tr></table></figure>

<p>检索订购了产品 RGAN01 的顾客</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> ProductCustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-19-课-使用存储过程"><a href="#第-19-课-使用存储过程" class="headerlink" title="第 19 课 使用存储过程"></a>第 19 课 使用存储过程</h2><p>创建存储过程</p>
<p>对邮件发送清单中具有邮件地址的顾客进行计数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> MailingListCount (</span><br><span class="line">  ListCount <span class="keyword">OUT</span> <span class="type">INTEGER</span></span><br><span class="line">) <span class="keyword">IS</span></span><br><span class="line">v_rows <span class="type">INTEGER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">INTO</span> v_rows</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">ListCount :<span class="operator">=</span> v_rows;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-20-课-管理事务处理"><a href="#第-20-课-管理事务处理" class="headerlink" title="第 20 课 管理事务处理"></a>第 20 课 管理事务处理</h2><p>使用事务处理（transaction processing），通过确保成批的 SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性。</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>事务开始结束标记</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MariaDB 和 MySQL</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- PostgreSQL</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>SQL 的 ROLLBACK 命令用来回退（撤销）SQL 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>一般的 SQL 语句都是针对数据库表直接执行和编写的。这就是所谓的隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。</p>
<p>在事务处理块中，提交不会隐式进行。进行明确的提交，使用 COMMIT 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">DELETE</span> OrderItems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">DELETE</span> Orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION</span><br></pre></td></tr></table></figure>

<p>要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。在 SQL 中，这些占位符称为保留点。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MariaDB、MySQL 和 Oracle</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line">SAVE TRANSACTION delete1;</span><br><span class="line"><span class="keyword">ROLLBACK</span> TRANSACTION delete1;</span><br></pre></td></tr></table></figure>

<h2 id="第-21-课-使用游标"><a href="#第-21-课-使用游标" class="headerlink" title="第 21 课 使用游标"></a>第 21 课 使用游标</h2><p>SQL 检索操作返回一组称为结果集的行，这组返回的行都是与 SQL 语句相匹配的行（零行或多行）。简单地使用 SELECT 语句，没有办法得到第一行、下一行或前 10 行。</p>
<p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。</p>
<p>游标要点</p>
<ul>
<li>能够标记游标为只读，使数据能读取，但不能更新和删除。</li>
<li>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。</li>
<li>能标记某些列为可编辑的，某些列为不可编辑的。</li>
<li>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。</li>
<li>指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</li>
</ul>
<p>使用 DECLARE 语句创建游标，这条语句在不同的 DBMS 中有所不同。DECLARE 命名游标，并定义相应的 SELECT 语句，根据需要带 WHERE 和其他子句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DB2、MariaDB、MySQL 和 SQL Server</span></span><br><span class="line"><span class="keyword">DECLARE</span> CustCursor <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle 和 PostgreSQL</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">CURSOR</span> CustCursor</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p>使用 OPEN CURSOR 语句打开游标，在大多数 DBMS 中的语法相同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> <span class="keyword">CURSOR</span> CustCursor</span><br></pre></td></tr></table></figure>

<p>关闭游标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> CustCursor</span><br></pre></td></tr></table></figure>

<h2 id="第-22-课-高级-SQL-特性"><a href="#第-22-课-高级-SQL-特性" class="headerlink" title="第 22 课 高级 SQL 特性"></a>第 22 课 高级 SQL 特性</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束（constraint）管理如何插入或处理数据库数据的规则。</p>
<p>DBMS 通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，用 CREATE TABLE 或 ALTER TABLE 语句。</p>
<p>主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。</p>
<p>表中任意列只要满足以下条件，都可以用于主键</p>
<ul>
<li>任意两行的主键值都不相同。</li>
<li>每行都具有一个主键值（即列中不允许 NULL 值）。</li>
<li>包含主键值的列从不修改或更新。</li>
<li>主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</li>
</ul>
<p>创建表时指定主键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> vendors (</span><br><span class="line">  vend_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  vend_name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  vend_address <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  vend_city <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  vend_state <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  vend_zip <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  vend_country <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>更新表时指定主键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Vendors</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> <span class="keyword">PRIMARY KEY</span> (vend_id);</span><br></pre></td></tr></table></figure>

<p>外键是表中的一列，其值必须列在另一表的主键中。</p>
<p>创建表时指定外键</p>
<p>cust_id 中的任何值都必须是 Customers 表的 cust_id 中的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Orders (</span><br><span class="line">  order_num <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  order_date DATETIME <span class="keyword">NOT NULL</span>,</span><br><span class="line">  cust_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> <span class="keyword">REFERENCES</span> customers(cust_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>更新表时指定外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span></span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (cust_id) <span class="keyword">REFERENCES</span> Customers (cust_id)</span><br></pre></td></tr></table></figure>

<p>唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。</p>
<ul>
<li>表可包含多个唯一约束，但每个表只允许一个主键。</li>
<li>唯一约束列可包含 NULL 值。</li>
<li>唯一约束列可修改或更新。</li>
<li>唯一约束列的值可重复使用。</li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ul>
<p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。</p>
<ul>
<li>检查最小或最大值。例如，防止 0 个物品的订单（即使 0 是合法的数）。</li>
<li>指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。</li>
<li>只允许特定的值。例如，在性别字段中只允许 M 或 F。</li>
</ul>
<p>利用这个约束，任何插入（或更新）的行都会被检查，保证 quantity 大于 0。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> OrderItems (</span><br><span class="line">  order_num <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  order_item <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  prod_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  quantity <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span> <span class="keyword">CHECK</span> (quantity <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">  item_price MONEY <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>检查名为 gender 的列只包含 M 或 F，可编写如下的 ALTER TABLE 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD CONSTRAINT</span> <span class="keyword">CHECK</span> (gender <span class="keyword">LIKE</span> <span class="string">&#x27;[MF]&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引用来排序数据以加快搜索和排序操作的速度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX prod_name_ind</span><br><span class="line"><span class="keyword">ON</span> Products (prod_name);</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作（或组合）相关联。</p>
<p>触发器的一些常见用途</p>
<ul>
<li>保证数据一致。例如，在 INSERT 或 UPDATE 操作中将所有州名转换为大写。</li>
<li>基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。</li>
<li>进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。</li>
<li>计算计算列的值或更新时间戳。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> customer_state</span><br><span class="line"><span class="keyword">ON</span> Customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_state <span class="operator">=</span> <span class="built_in">Upper</span>(cust_state)</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> inserted.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle 和 PostgreSQL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> customer_state</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_state <span class="operator">=</span> <span class="built_in">Upper</span>(cust_state)</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> :OLD.cust_id</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><p>安全性使用 SQL 的 GRANT 和 REVOKE 语句来管理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35167240/">《SQL 必知必会》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/2dfc62ad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/2dfc62ad/" class="post-title-link" itemprop="url">《极客时间教程 - Java 核心技术面试精讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-22 18:33:35" itemprop="dateCreated datePublished" datetime="2024-09-22T18:33:35+08:00">2024-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>40k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>36 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Java-核心技术面试精讲》笔记"><a href="#《极客时间教程-Java-核心技术面试精讲》笔记" class="headerlink" title="《极客时间教程 - Java 核心技术面试精讲》笔记"></a>《极客时间教程 - Java 核心技术面试精讲》笔记</h1><h2 id="开篇词-以面试题为切入点，有效提升你的-Java-内功"><a href="#开篇词-以面试题为切入点，有效提升你的-Java-内功" class="headerlink" title="开篇词 以面试题为切入点，有效提升你的 Java 内功"></a>开篇词 以面试题为切入点，有效提升你的 Java 内功</h2><p>略</p>
<h2 id="谈谈你对-Java-平台的理解？"><a href="#谈谈你对-Java-平台的理解？" class="headerlink" title="谈谈你对 Java 平台的理解？"></a>谈谈你对 Java 平台的理解？</h2><p>【典型回答】</p>
<p>Java 最显著的特性：</p>
<ul>
<li>“<strong>书写一次，到处运行</strong>”（Write once, run anywhere）——跨平台</li>
<li><strong>垃圾收集</strong>（GC, Garbage Collection）——回收、分配内存</li>
</ul>
<p>Java 既是解释型语言，又是编译型语言</p>
<p>【考点分析】</p>
<p>可以由浅入深的梳理 Java 的知识网络</p>
<p>【知识扩展】</p>
<h2 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h2><p>【典型回答】</p>
<p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch）。</p>
<p>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError。</p>
<p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException。</p>
<p>【考点分析】</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240656683.png"></p>
<p><strong>理解 Throwable、Exception、Error 的设计和分类</strong>。</p>
<p><strong>理解 Java 语言中操作 Throwable 的元素和实践</strong>。了解 <code>try &#123;&#125; catch &#123;&#125; finally</code>、try-with-resource、multiple catch、throw&#x2F;throws 等关键机制。</p>
<p>【知识扩展】</p>
<p>尽量不要捕获 Exception、Throwable、Error——使得程序的容错处理不直观</p>
<p>不要生吞异常——会导致无法诊断问题</p>
<p>不要使用 e.printStackTrace()——这个方法会将堆栈输出到标准错误流，难以判断输出到哪里去了</p>
<h2 id="谈谈-final、finally、finalize-有什么不同？"><a href="#谈谈-final、finally、finalize-有什么不同？" class="headerlink" title="谈谈 final、finally、finalize 有什么不同？"></a>谈谈 final、finally、finalize 有什么不同？</h2><p>【典型回答】+【考点分析】</p>
<p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。finalize 被设计成在对象被<strong>垃圾收集前</strong>调用，这就意味着实现了 finalize 方法的对象是个“特殊公民”，JVM 要对它进行额外处理。finalize 本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。使用不当会影响性能，导致程序死锁、挂起等。</p>
<p>【知识扩展】</p>
<p><strong>final 不等于 Immutable！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">List&lt;String&gt; unmodifiableStrList = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">unmodifiableStrList.add(<span class="string">&quot;again&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。</p>
<p>要实现 Immutable，需要将类和类中的所有成员变量都定义为 final，并且只允许存在只读方法。</p>
<h2 id="强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？"></a>强引用、软引用、弱引用、幻象引用有什么区别？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。</p>
<ul>
<li><strong>强引用（Strong Reference）</strong> - 被强引用关联的对象不会被垃圾收集器回收。</li>
<li><strong>软引用（Soft Reference）</strong> - 被软引用关联的对象，只有在内存不够的情况下才会被回收。</li>
<li><strong>弱引用（Weak Reference）</strong> - 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。</li>
<li><strong>虚引用（Phantom Reference）</strong> - 又称为幻象引用或幽灵引用。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder-有什么区别？"><a href="#String、StringBuffer、StringBuilder-有什么区别？" class="headerlink" title="String、StringBuffer、StringBuilder 有什么区别？"></a>String、StringBuffer、StringBuilder 有什么区别？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>String 是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</p>
<p>StringBuffer 是线程安全的 String 工具类。</p>
<p>StringBuilder 和 StringBuffer 功能近似，只是去掉了保证线程安全的 synchronized 锁，减少了开销。</p>
<p><strong>字符串拼接都应该用 StringBuilder 吗？</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<p>下面一段代码，利用不同版本的 JDK 编译，然后再反编译，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcat</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> str + “aa” + “bb”;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先编译再反编译，比如使用不同版本的 JDK：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;/bin/javac StringConcat.java</span><br><span class="line">$&#123;JAVA_HOME&#125;/bin/javap -v StringConcat.class</span><br></pre></td></tr></table></figure>

<p>JDK 8 的输出片段是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">7</span>: aload_0</span><br><span class="line"> <span class="number">8</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String aa</span></span><br><span class="line"><span class="number">13</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">16</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String bb</span></span><br><span class="line"><span class="number">18</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br></pre></td></tr></table></figure>

<p>而在 JDK 9 中，反编译的结果就会有点特别了，片段是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat method</span></span><br><span class="line"><span class="number">1</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 实际是利用了 MethodHandle, 统一了入口</span></span><br><span class="line"><span class="number">0</span>: #<span class="number">15</span> REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</span><br></pre></td></tr></table></figure>

<p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<p>在 JDK 9 中，字符串相加“+”改为用动态方法 <code>makeConcatWithConstants()</code> 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： <code>a+b+c</code> 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。</p>
<p><strong>String 内部存储结构为何从 char 数组转为 byte 数组？</strong></p>
<p>Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。</p>
<p>在 Java 9 中，引入了 Compact Strings 的设计，将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改。紧凑字符串带来的优势，<strong>即更小的内存占用、更快的操作速度</strong>。</p>
<h2 id="动态代理是基于什么原理？"><a href="#动态代理是基于什么原理？" class="headerlink" title="动态代理是基于什么原理？"></a>动态代理是基于什么原理？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>通过反射可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>反射工具类在 java.lang.reflect 包下，主要有：Class、Field、Method、Constructor 等。官方提供的参考文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/index.html">https://docs.oracle.com/javase/tutorial/reflect/index.html</a> 。</p>
<p>反射提供的 AccessibleObject.setAccessible(boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员访问限制！</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多：JDK 动态代理、ASM、cglib、Javassist</p>
<p>动态代理应用了设计模式中的代理模式。</p>
<h2 id="int-和-Integer-有什么区别？"><a href="#int-和-Integer-有什么区别？" class="headerlink" title="int 和 Integer 有什么区别？"></a>int 和 Integer 有什么区别？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>自动装箱、拆箱实际上可以视为一种语法糖。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p>
<p>javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">unboxing</span> <span class="operator">=</span> integer++;</span><br></pre></td></tr></table></figure>

<p>反编译输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method</span></span><br><span class="line">java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line"><span class="number">8</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method</span></span><br><span class="line">java/lang/Integer.intValue:()I</span><br></pre></td></tr></table></figure>

<p>应尽量避免自动装箱、拆箱行为，尤其是性能敏感的场景。</p>
<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>Long 缓存源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LongCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式。</p>
<h2 id="对比-Vector、ArrayList、LinkedList-有何区别？"><a href="#对比-Vector、ArrayList、LinkedList-有何区别？" class="headerlink" title="对比 Vector、ArrayList、LinkedList 有何区别？"></a>对比 Vector、ArrayList、LinkedList 有何区别？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>三者都是实现集合框架中的 List，具体功能也比较近似。</p>
<p>Vector 是 Java 早期提供的线程<strong>安全的动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p>
<p>ArrayList 是应用更加广泛的<strong>动态数组</strong>实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p>
<p>LinkedList 顾名思义是 Java 提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240657167.png"></p>
<h2 id="对比-Hashtable、HashMap、TreeMap-有什么不同？"><a href="#对比-Hashtable、HashMap、TreeMap-有什么不同？" class="headerlink" title="对比 Hashtable、HashMap、TreeMap 有什么不同？"></a>对比 Hashtable、HashMap、TreeMap 有什么不同？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>Hashtable 是早期 Java 类库提供的一个 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p>
<p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以<strong>它是绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p>
<p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(logN) 的时间复杂度，具体顺序可以由指定的 Comparator 或 Comparable 来决定，或者根据键的自然顺序来判断。</p>
<p>LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。</p>
<p><strong>HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定，</strong>比如：</p>
<ul>
<li>equals 相等，hashCode 一定要相等。</li>
<li>重写了 hashCode 也要重写 equals。</li>
<li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>equals 的对称、反射、传递等特性。</li>
</ul>
<p>HashMap 源码实现：</p>
<ul>
<li>容量（capacity）和负载系数（load factor）。</li>
<li>树化 。</li>
</ul>
<h2 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效地线程安全？"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效地线程安全？" class="headerlink" title="如何保证集合是线程安全的 ConcurrentHashMap 如何实现高效地线程安全？"></a>如何保证集合是线程安全的 ConcurrentHashMap 如何实现高效地线程安全？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<h3 id="ConcurrentHashMap-JDK7-实现"><a href="#ConcurrentHashMap-JDK7-实现" class="headerlink" title="ConcurrentHashMap JDK7 实现"></a>ConcurrentHashMap JDK7 实现</h3><p>早期 ConcurrentHashMap，其实现是基于：</p>
<ul>
<li>分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。</li>
<li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240701236.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key.hashCode());</span><br><span class="line">       <span class="comment">//利用位操作替换普通数学运算</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="comment">// 以 Segment 为单位，进行定位</span></span><br><span class="line">        <span class="comment">// 利用 Unsafe 直接进行 volatile access</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而对于 put 操作，首先是通过二次哈希避免哈希冲突，然后以 Unsafe 调用方式，直接获取相应的 Segment，然后进行线程安全的 put 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key.hashCode());</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其核心逻辑实现在下面的内部方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">            <span class="comment">// scanAndLockForPut 会去查找是否有 key 相同 Node</span></span><br><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">// 更新已有 value...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 放置 HashEntry 到特定位置，如果超过阈值，进行 rehash</span></span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码清晰的看出，在进行并发写操作时：</p>
<ul>
<li>ConcurrentHashMap 会获取再入锁，以保证数据一致性，Segment 本身就是基于 ReentrantLock 的扩展实现，所以，在并发修改期间，相应 Segment 是被锁定的。</li>
<li>在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作，你可以在代码里看到相应的注释。重复扫描、检测冲突是 ConcurrentHashMap 的常见技巧。</li>
<li>ConcurrentHashMap 也存在扩容行为。不过有一个明显区别，就是它进行的不是整体的扩容，而是单独对 Segment 进行扩容，细节就不介绍了。</li>
</ul>
<h3 id="ConcurrentHashMap-JDK8-实现"><a href="#ConcurrentHashMap-JDK8-实现" class="headerlink" title="ConcurrentHashMap JDK8 实现"></a>ConcurrentHashMap JDK8 实现</h3><ul>
<li>其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。</li>
<li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li>
<li>数据存储利用 volatile 来保证可见性。</li>
<li>使用 CAS 等操作，在特定场景进行无锁并发操作。</li>
<li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li>
</ul>
<p>先看看现在的数据存储内部实现，我们可以发现 Key 是 final 的，因为在生命周期中，一个条目的 Key 发生变化是不可能的；与此同时 val，则声明为 volatile，以保证可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V val;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">       <span class="comment">// …</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>并发的 put 是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123; <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用 CAS 去进行无锁线程安全操作，如果 bin 是空的</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// 不加锁，进行检查</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">// 细粒度的同步修改操作。..</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Bin 超过阈值，进行树化</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化操作实现在 initTable 里面，这是一个典型的 CAS 使用场景，利用 volatile 的 sizeCtl 作为互斥手段：如果发现竞争性的初始化，就 spin 在那里，等待条件恢复；否则利用 CAS 设置排他标志。如果成功则进行初始化；否则重试。</p>
<p>请参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果发现冲突，进行 spin 等待</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// CAS 成功返回 true，则进入真正的初始化逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-提供了哪些-IO-方式？-NIO-如何实现多路复用？"><a href="#Java-提供了哪些-IO-方式？-NIO-如何实现多路复用？" class="headerlink" title="Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？"></a>Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<ul>
<li>BIO - 传统的 java.io 包，它基于流模型实现。很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。<ul>
<li>InputStream&#x2F;OutputStream 和 Reader&#x2F;Writer 的关系和区别。</li>
</ul>
</li>
<li>NO - 在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。<ul>
<li>BIO 和 NIO 的设计、原理差异</li>
<li>NIO 为什么高性能</li>
<li>NIO 组成<ul>
<li>Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。</li>
<li>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。</li>
<li>Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别：Linux 上依赖于 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java">epoll</a>，Windows 上 NIO2（AIO）模式则是依赖于 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/windows/classes/sun/nio/ch/Iocp.java">iocp</a>。</li>
</ul>
</li>
</ul>
</li>
<li>NIO2 - 在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</li>
</ul>
<h2 id="Java-有几种文件拷贝方式？哪一种最高效？"><a href="#Java-有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="Java 有几种文件拷贝方式？哪一种最高效？"></a>Java 有几种文件拷贝方式？哪一种最高效？</h2><p>【典型回答】</p>
<p>字节流方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);)&#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = is.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>NIO 方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>【考点分析】</p>
<ul>
<li>不同的 copy 方式，底层机制有什么区别？</li>
<li>为什么零拷贝（zero-copy）可能有性能优势？</li>
<li>Buffer 分类与使用。</li>
<li>Direct Buffer 对垃圾收集等方面的影响与实践选择。</li>
</ul>
<p>【知识扩展】</p>
<p>首先，你需要理解用户态空间（User Space）和内核态空间（Kernel Space），这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；而用户态空间，则是给普通应用和服务使用。你可以参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_space%E3%80%82">https://en.wikipedia.org/wiki/User_space。</a></p>
<p>当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240702998.png"></p>
<p>基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p>
<p>transferTo 的传输过程是：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240702146.png"></p>
<h2 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h2><p>【典型回答】+【考点分析】</p>
<p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。</p>
<p>抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。</p>
<p>【知识扩展】</p>
<p>Java 相比于其他面向对象语言，<strong>Java 不支持多继承</strong>。</p>
<p>Java 8 增加了函数式编程的支持，所以又增加了一类定义，即所谓 functional interface，简单说就是只有一个抽象方法的接口，通常建议使用 @FunctionalInterface Annotation 来标记。Lambda 表达式本身可以看作是一类 functional interface，某种程度上这和面向对象可以算是两码事。我们熟知的 Runnable、Callable 之类，都是 functional interface。</p>
<p>从 Java 8 开始，interface 增加了对 default method 的支持。Java 9 以后，甚至可以定义 private default method。Default method 提供了一种二进制兼容的扩展已有接口的办法。</p>
<p>面向对象设计：</p>
<ul>
<li><strong>封装</strong>的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。</li>
<li><strong>继承</strong>是代码复用的基础机制，但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</li>
<li><strong>多态</strong>，你可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数。</li>
</ul>
<p>面向对象设计原则（S.O.L.I.D）</p>
<ul>
<li>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</li>
<li>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</li>
<li>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</li>
<li>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。</li>
<li>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</li>
</ul>
<h2 id="谈谈你知道的设计模式？"><a href="#谈谈你知道的设计模式？" class="headerlink" title="谈谈你知道的设计模式？"></a>谈谈你知道的设计模式？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
<ul>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括：各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括：桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<h2 id="synchronized-和-ReentrantLock-有什么区别呢？"><a href="#synchronized-和-ReentrantLock-有什么区别呢？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别呢？"></a>synchronized 和 ReentrantLock 有什么区别呢？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>synchronized 和 ReentrantLock 的语义基本相同。</p>
<p>synchronized 是内置锁，ReentrantLock 是显式锁，二者的差异有：</p>
<ul>
<li><strong>主动获取锁和释放锁</strong><ul>
<li><code>synchronized</code> 不能主动获取锁和释放锁。获取锁和释放锁都是 JVM 控制的。</li>
<li><code>ReentrantLock</code> 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。</li>
</ul>
</li>
<li><strong>响应中断</strong><ul>
<li><code>synchronized</code> 不能响应中断。</li>
<li><code>ReentrantLock</code> 可以响应中断。</li>
</ul>
</li>
<li><strong>超时机制</strong><ul>
<li><code>synchronized</code> 没有超时机制。</li>
<li><code>ReentrantLock</code> 有超时机制。<code>ReentrantLock</code> 可以设置超时时间，超时后自动释放锁，避免一直等待。</li>
</ul>
</li>
<li><strong>支持公平锁</strong><ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li><code>ReentrantLock</code> 支持非公平锁和公平锁。</li>
</ul>
</li>
<li><strong>是否支持共享</strong><ul>
<li>被 <code>synchronized</code> 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待</li>
<li><code>ReentrantLock</code> 可以基于 <code>Condition</code> 灵活的控制同步条件。</li>
</ul>
</li>
</ul>
<h2 id="synchronized-底层如何实现？什么是锁的升级、降级？"><a href="#synchronized-底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized 底层如何实现？什么是锁的升级、降级？"></a>synchronized 底层如何实现？什么是锁的升级、降级？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>synchronized 代码块是由一对儿 monitorenter&#x2F;monitorexit 指令实现的，Monitor 对象是同步的基本实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#d5e13622">单元</a>。</p>
<p>JDK6 以前，由于 synchronized 阻塞度高，导致性能不佳。JDK6 对此，进行了大量优化，其性能与 <code>ReentrantLock</code> 已基本持平。</p>
<p>在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。</p>
<p>Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200629191250.png" alt="img"></p>
<p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，<code>synchronized</code> 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</p>
<p>Java 1.6 引入了偏向锁和轻量级锁，从而让 <code>synchronized</code> 拥有了四个状态：</p>
<ul>
<li><strong>无锁状态（unlocked）</strong></li>
<li><strong>偏向锁状态（biasble）</strong></li>
<li><strong>轻量级锁状态（lightweight locked）</strong></li>
<li><strong>重量级锁状态（inflated）</strong></li>
</ul>
<p>当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现。</p>
<p>当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<h2 id="一个线程两次调用-start-方法会出现什么情况？"><a href="#一个线程两次调用-start-方法会出现什么情况？" class="headerlink" title="一个线程两次调用 start() 方法会出现什么情况？"></a>一个线程两次调用 start() 方法会出现什么情况？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>Java 的线程是不允许调用 start() 两次的，第二次调用必然会抛出 IllegalThreadStateException。</p>
<p>线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p>
<p>线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。对于我们最熟悉的 Sun&#x2F;Oracle JDK，其线程也经历了一个演进过程，基本上在 Java 1.2 之后，JDK 已经抛弃了所谓的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_threads">Green Thread</a>，也就是用户调度的线程，现在的模型是一对一映射到操作系统内核线程。</p>
<p>如果我们来看 Thread 的源码，你会发现其基本操作逻辑大都是以 JNI 形式调用的本地代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>近几年的 Go 语言等提供了协程（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a>），大大提高了构建并发应用的效率。于此同时，Java 也在 <a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/loom/">Loom</a> 项目中，孕育新的类似轻量级用户线程（Fiber）等机制，也许在不久的将来就可以在新版 JDK 中使用到它。</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408290809602.png"></p>
<p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><strong>开始（NEW）</strong> - 尚未调用 <code>start</code> 方法的线程处于此状态。此状态意味着：<strong>创建的线程尚未启动</strong>。</li>
<li><strong>可运行（RUNNABLE）</strong> - 已经调用了 <code>start</code> 方法的线程处于此状态。此状态意味着，<strong>线程已经准备好了</strong>，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。<ul>
<li>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</li>
</ul>
</li>
<li><strong>阻塞（BLOCKED）</strong> - 此状态意味着：<strong>线程处于被阻塞状态</strong>。表示线程在等待 <code>synchronized</code> 的隐式锁（Monitor lock）。<code>synchronized</code> 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 <code>synchronized</code> 隐式锁的线程释放锁，并且等待的线程获得 <code>synchronized</code> 隐式锁时，就又会从 <code>BLOCKED</code> 转换到 <code>RUNNABLE</code> 状态。</li>
<li><strong>等待（WAITING）</strong> - 此状态意味着：<strong>线程无限期等待，直到被其他线程显式地唤醒</strong>。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code>synchronized</code> 的隐式锁。而等待是主动的，通过调用 <code>Object.wait</code> 等方法进入。<ul>
<li>进入：<code>Object.wait()</code>；退出：<code>Object.notify</code> &#x2F; <code>Object.notifyAll</code></li>
<li>进入：<code>Thread.join()</code>；退出：被调用的线程执行完毕</li>
<li>进入：<code>LockSupport.park()</code>；退出：<code>LockSupport.unpark</code></li>
</ul>
</li>
<li><strong>定时等待（TIMED_WAITING）</strong> - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li>进入：<code>Thread.sleep(long)</code>；退出：时间结束</li>
<li>进入：<code>Object.wait(long)</code>；退出：时间结束 &#x2F; <code>Object.notify</code> &#x2F; <code>Object.notifyAll</code></li>
<li>进入：<code>Thread.join(long)</code>；退出：时间结束 &#x2F; 被调用的线程执行完毕</li>
<li>进入：<code>LockSupport.parkNanos(long)</code>；退出：<code>LockSupport.unpark</code></li>
<li>进入：<code>LockSupport.parkUntil(long)</code>；退出：<code>LockSupport.unpark</code></li>
</ul>
</li>
<li><strong>终止 (TERMINATED)</strong> - 线程 <code>run()</code> 方法执行结束，或者因异常退出了 <code>run()</code> 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<h2 id="什么情况下-Java-程序会产生死锁？如何定位、修复？"><a href="#什么情况下-Java-程序会产生死锁？如何定位、修复？" class="headerlink" title="什么情况下 Java 程序会产生死锁？如何定位、修复？"></a>什么情况下 Java 程序会产生死锁？如何定位、修复？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p><strong>死锁</strong>：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>
<p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409050712813.png"></p>
<h3 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h3><p>首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。</p>
<p>其次，调用 jstack 获取线程栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;\bin\jstack your_pid</span><br></pre></td></tr></table></figure>

<p>然后，分析得到的输出，具体片段如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240702087.png"></p>
<p>最后，结合代码分析线程栈信息。上面这个输出非常明显，找到处于 BLOCKED 状态的线程，按照试图获取（waiting）的锁 ID（请看我标记为相同颜色的数字）查找，很快就定位问题。 jstack 本身也会把类似的简单死锁抽取出来，直接打印出来。</p>
<p>识别死锁总体上可以理解为：<strong>区分线程状态 -&gt; 查看等待目标 -&gt; 对比 Monitor 等持有状态</strong></p>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>只有以下这四个条件都发生时才会出现死锁：</p>
<ul>
<li><strong>互斥</strong>，共享资源 X 和 Y 只能被一个线程占用；</li>
<li><strong>占有且等待</strong>，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li><strong>不可抢占</strong>，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li><strong>循环等待</strong>，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ul>
<p><strong>也就是说只要破坏任意一个，就可以避免死锁的发生</strong>。</p>
<p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p>
<ol>
<li>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。超时释放锁</li>
<li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ol>
<h2 id="Java-并发包提供了哪些并发工具类？"><a href="#Java-并发包提供了哪些并发工具类？" class="headerlink" title="Java 并发包提供了哪些并发工具类？"></a>Java 并发包提供了哪些并发工具类？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>J.U.C 提供了以下方面的工具：</p>
<ul>
<li>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</li>
<li>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</li>
<li>各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</li>
<li>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<p>同步工具：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>，允许一个或多个线程等待某些操作完成。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CyclicBarrier.html">CyclicBarrier</a>，一种辅助性的同步结构，允许多个线程等待到达某个屏障。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a>，Java 版本的信号量实现。</li>
</ul>
<h2 id="并发包中的-ConcurrentLinkedQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#并发包中的-ConcurrentLinkedQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？"></a>并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>关于问题中它们的区别：</p>
<ul>
<li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>而 LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。</li>
</ul>
<p>J.U.C 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent*、CopyOnWrite 和 Blocking 等三类，同样是线程安全容器，可以简单认为：</p>
<ul>
<li>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。</li>
<li>但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</li>
<li>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。</li>
<li>弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。</li>
<li>与此同时，读取的性能具有一定的不确定性。</li>
</ul>
<p>下面这张图是 Java 并发类库提供的各种各样的<strong>线程安全</strong>队列实现，注意，图中并未将非线程安全部分包含进来。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240702121.png"></p>
<p>我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html">Deque</a> 实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如：</p>
<ul>
<li>尾部插入时需要的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#addLast-E-">addLast(e)</a>、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#offerLast-E-">offerLast(e)</a>。</li>
<li>尾部删除所需要的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#removeLast--">removeLast()</a>、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#pollLast--">pollLast()</a>。</li>
</ul>
<p>队列是否有界、无界：</p>
<ul>
<li>ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。</li>
<li>SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。</li>
<li>PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。</li>
<li>DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。</li>
</ul>
<p>如果我们分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现。</p>
<h2 id="Java-并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java-并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java 并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li><code>CachedThreadPool</code>，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 <code>SynchronousQueue</code> 作为工作队列。</li>
<li><code>FixedThreadPool</code>，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>
<li><code>SingleThreadExecutor</code>，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li><code>SingleThreadScheduledExecutor</code> 和 <code>ScheduledThreadPool</code>，创建的是个 <code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li><code>WorkStealingPool</code>，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，利用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Work_stealing">Work-Stealing</a> 算法，并行地处理任务，不保证处理顺序。</li>
</ul>
<p>Executor 框架的基本组成，请参考下面的类图。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240703740.png"></p>
<ul>
<li>Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure>

<p>Executor 的设计是源于 Java 早期线程 API 使用的教训，开发者在实现应用逻辑时，被太多线程创建、调度等不相关细节所打扰。就像我们进行 HTTP 通信，如果还需要自己操作 TCP 握手，开发效率低下，质量也难以保证。</p>
<ul>
<li>ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Future.html">Future</a> 而不是 void 的 submit 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></figure>

<p>线程池设计：</p>
<ul>
<li>工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>线程池的工作线程被抽象为静态内部类 Worker，基于 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a> 实现。</p>
<ul>
<li>ThreadFactory 提供上面所需要的创建线程逻辑。</li>
<li>如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html">ThreadPoolExecutor.AbortPolicy</a> 等默认实现，也可以按照实际需求自定义。</li>
</ul>
<h2 id="AtomicInteger-底层实现原理是什么？如何在自己的产品代码中应用-CAS-操作？"><a href="#AtomicInteger-底层实现原理是什么？如何在自己的产品代码中应用-CAS-操作？" class="headerlink" title="AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？"></a>AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>原子类基于 CAS（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>）技术。从其代码来看，它依赖于 Unsafe 提供的一些底层能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>CAS 底层实现依赖于 CPU 提供的特定原子指令，具体根据体系结构的不同还存在着明显区别。</p>
<p>CAS 的问题：</p>
<ul>
<li>如果并发冲突频繁，CAS 反复自旋重试，会大量消耗 CPU</li>
<li>ABA 问题——可以通过 <code>AtomicStampedReference</code> 解决（增加时间戳、版本号来识别）。</li>
</ul>
<p>AQS 内部数据和方法，可以简单拆分为：</p>
<ul>
<li>一个 volatile 的整数成员表征状态，同时提供了 setState 和 getState 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个先入先出（FIFO）的等待线程队列，以实现多线程间竞争和等待，这是 AQS 机制的核心之一。</li>
<li>各种基于 CAS 的基础操作方法，以及各种期望具体同步结构去实现的 acquire&#x2F;release 方法。</li>
</ul>
<p>利用 AQS 实现一个同步结构，至少要实现两个基本类型的方法，分别是 acquire 操作，获取资源的独占权；还有就是 release 操作，释放对某个资源的独占。</p>
<p>以 ReentrantLock 为例，它内部通过扩展 AQS 实现了 Sync 类型，以 AQS 的 state 来反映锁的持有情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123; …&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 ReentrantLock 对应 acquire 和 release 操作，如果是 CountDownLatch 则可以看作是 await()&#x2F;countDown()，具体实现也有区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排除掉一些细节，整体地分析 acquire 方法逻辑，其直接实现是在 AQS 内部，调用了 tryAcquire 和 acquireQueued，这是两个需要搞清楚的基本部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们来看看 tryAcquire。在 ReentrantLock 中，tryAcquire 逻辑实现在 NonfairSync 和 FairSync 中，分别提供了进一步的非公平或公平性方法，而 AQS 内部 tryAcquire 仅仅是个接近未实现的方法（直接抛异常），这是留个实现者自己定义的操作。</p>
<p>我们可以看到公平性在 ReentrantLock 构建时如何指定的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(); <span class="comment">// 默认是非公平的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以非公平的 tryAcquire 为例，其内部实现了如何配合状态与 CAS 获取锁，注意，对比公平版本的 tryAcquire，它在锁无人占有时，并不检查是否有其他等待者，这里体现了非公平的语义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">// 获取当前 AQS 内部状态量</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 0 表示无人占有，则直接用 CAS 修改状态位，</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">// 不检查排队情况，直接争抢</span></span><br><span class="line">          setExclusiveOwnerThread(current);  <span class="comment">//并设置当前线程独占锁</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//即使状态不是 0，也可能当前线程是锁持有者，因为这是再入锁</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我再来分析 acquireQueued，如果前面的 tryAcquire 失败，代表着锁争抢失败，进入排队竞争阶段。这里就是我们所说的，利用 FIFO 队列，实现线程间对锁的竞争的部分，算是是 AQS 的核心逻辑。</p>
<p>当前线程会被包装成为一个排他模式的节点（EXCLUSIVE），通过 addWaiter 方法添加到队列中。acquireQueued 的逻辑，简要来说，就是如果当前节点的前面是头节点，则试图获取锁，一切顺利则成为新的头节点；否则，有必要则等待，具体处理逻辑请参考我添加的注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 获取前一个节点</span></span><br><span class="line">          <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前一个节点是头结点，表示当前节点合适去 tryAcquire</span></span><br><span class="line">              setHead(node); <span class="comment">// acquire 成功，则设置新的头节点</span></span><br><span class="line">              p.next = <span class="literal">null</span>; <span class="comment">// 将前面节点对当前节点的引用清空</span></span><br><span class="line">              <span class="keyword">return</span> interrupted;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)) <span class="comment">// 检查是否失败后需要 park</span></span><br><span class="line">              interrupted |= parkAndCheckInterrupt();</span><br><span class="line">      &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      cancelAcquire(node);<span class="comment">// 出现异常，取消</span></span><br><span class="line">      <span class="keyword">if</span> (interrupted)</span><br><span class="line">              selfInterrupt();</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里线程试图获取锁的过程基本展现出来了，tryAcquire 是按照特定场景需要开发者去实现的部分，而线程间竞争则是 AQS 通过 Waiter 队列与 acquireQueued 提供的，在 release 方法中，同样会对队列进行对应操作。</p>
<h2 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>类加载过程：</p>
<ul>
<li>加载 - 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象）。</li>
<li>链接<ul>
<li>验证 - 核验字节信息是符合 Java 虚拟机规范。</li>
<li>准备 - 创建类或接口中的静态变量，并初始化静态变量的初始值。</li>
<li>解析 - 将常量池中的符号引用（symbolic reference）替换为直接引用。</li>
</ul>
</li>
<li>初始化 - 真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</li>
</ul>
<p>双亲委派</p>
<ul>
<li>Bootstrap ClassLoader - 负责加载 &#x2F;jre&#x2F;lib 路径下的 jar。可以通过 <code>java -Xbootclasspath</code> 参数修改扫描路径。</li>
<li>Ext ClassLoader - 负责加载 <code>/jre/lib/ext</code> 路径下的 jar。可以通过 <code>-Djava.ext.dirs</code> 参数修改扫描路径。</li>
<li>App ClassLoaer- 负责加载 classpath 路径下的内容。可以通过 -Djava.system.class.loader 参数修改扫描路径。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240704663.png"></p>
<p>通常类加载机制有三个基本特征：</p>
<ul>
<li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider&#x2F;<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">ServiceLoader</a> 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<p>在 JDK 9 中，由于 Jigsaw 项目引入了 Java 平台模块化系统（JPMS），Java SE 的源代码被划分为一系列模块。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240704856.png"></p>
<p>类加载器，类文件容器等都发生了非常大的变化：</p>
<ul>
<li>-Xbootclasspath 参数不可用了。API 已经被划分到具体的模块，所以上文中，利用“-Xbootclasspath&#x2F;p”替换某个 Java 核心类型代码，实际上变成了对相应的模块进行的修补，可以采用下面的解决方案：</li>
</ul>
<p>首先，确认要修改的类文件已经编译好，并按照对应模块（假设是 java.base）结构存放， 然后，给模块打补丁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --patch-module java.base=your_patch yourApp</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib&#x2F;ext 目录存在，JVM 将直接返回<strong>错误</strong>！建议解决办法就是将其放入 classpath 里。</li>
<li>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</li>
<li>rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。</li>
<li>增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化 Layer，可以更加方便的实现类似容器一般的逻辑抽象。</li>
</ul>
<p>结合了 Layer，目前的 JVM 内部结构就变成了下面的层次，内建类加载器都在 BootLayer 中，其他 Layer 内部有自定义的类加载器，不同版本模块可以同时工作在不同的 Layer。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240704234.png"></p>
<h2 id="有哪些方法可以在运行时动态生成一个-Java-类？"><a href="#有哪些方法可以在运行时动态生成一个-Java-类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个 Java 类？"></a>有哪些方法可以在运行时动态生成一个 Java 类？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>可以利用 Java 字节码操纵工具和类库来实现，如：<a target="_blank" rel="noopener" href="https://asm.ow2.io/">ASM</a>、<a target="_blank" rel="noopener" href="http://www.javassist.org/">Javassist</a>、cglib 等</p>
<p>类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                   ProtectionDomain protectionDomain)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                   ProtectionDomain protectionDomain)</span><br></pre></td></tr></table></figure>

<p>JDK 提供的 defineClass 方法，最终都是本地代码实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(ClassLoader loader, String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                  ProtectionDomain pd, String source);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(ClassLoader loader, String name, java.nio.ByteBuffer b,</span><br><span class="line">                                  <span class="type">int</span> off, <span class="type">int</span> len, ProtectionDomain pd,</span><br><span class="line">                                  String source);</span><br></pre></td></tr></table></figure>

<h2 id="谈谈-JVM-内存区域的划分，哪些区域可能发生-OutOfMemoryError"><a href="#谈谈-JVM-内存区域的划分，哪些区域可能发生-OutOfMemoryError" class="headerlink" title="谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError"></a>谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<ul>
<li>首先，<strong>程序计数器</strong>（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</li>
<li>第二，<strong>Java 虚拟机栈</strong>（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。<ul>
<li>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</li>
<li>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</li>
</ul>
</li>
<li>第三，<strong>堆</strong>（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。<ul>
<li>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</li>
</ul>
</li>
<li>第四，<strong>方法区</strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。<ul>
<li>由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</li>
</ul>
</li>
<li>第五，<strong>运行时常量池</strong>（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li>第六，<strong>本地方法栈</strong>（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240705853.png"></p>
<p>OOM 场景：</p>
<ul>
<li>Java heap space - 堆空间溢出</li>
<li>GC overhead limit exceeded - GC 开销超过限制。官方给出的定义是：<strong>超过 <code>98%</code> 的时间用来做 GC 并且回收了不到 <code>2%</code> 的堆内存时会抛出此异常</strong>。这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</li>
<li>PermGen space - Perm （永久代）空间主要用于存放 <code>Class</code> 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。根据上面的定义，可以得出 <strong>PermGen 大小要求取决于加载的类的数量以及此类声明的大小</strong>。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。在 JDK8 之前的版本中，可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。</li>
<li>Metaspace - Java8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。</li>
<li>Unable to create new native thread - 无法新建本地线程。这个错误意味着：<strong>Java 应用程序已达到其可以启动线程数的限制</strong>。</li>
<li>直接内存溢出 - 由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的 Dump 文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是 NIO），那就可以考虑重点检查一下直接内存方面的原因了。</li>
</ul>
<h2 id="如何监控和诊断-JVM-堆内和堆外内存使用？"><a href="#如何监控和诊断-JVM-堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断 JVM 堆内和堆外内存使用？"></a>如何监控和诊断 JVM 堆内和堆外内存使用？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<ul>
<li><code>jps</code> - 显示指定系统内所有的 JVM 进程</li>
<li><code>jstat</code> - 查看 JVM 统计信息（类装载、内存、垃圾收集、JIT 编译等运行数据）</li>
<li><code>jmap</code> - 生成堆内存快照（称为 heapdump 或 dump 文件）</li>
<li><code>jhat</code> - 用来分析 jmap 生成的 dump 文件</li>
<li><code>jstack</code> - 生成线程快照（称为 threaddump 或 coredump 文件）</li>
<li>jinfo - 用于实时查看和调整虚拟机运行参数</li>
<li><code>JConsole</code> - 基于 JMX 的可视化监视与管理工具</li>
<li><code>VisualVM</code> - 多合一故障处理工具</li>
<li><code>MAT</code> - Eclipse 提供的内存分析工具</li>
<li>JMC - <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control</a> 不仅仅能够使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_Management_Extensions">JMX</a> 进行普通的管理、监控任务，还可以配合 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH171">Java Flight Recorder</a>（JFR）技术，以非常低的开销，收集和分析 JVM 底层的 Profiling 和事件等信息。</li>
<li><code>JProfile</code></li>
</ul>
<p>堆结构示意图。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240705463.png"></p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。</p>
<p>JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
<p>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB）。这是 JVM 为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度。TLAB 仍然在堆上，它是分配在 Eden 区域内的。其内部结构比较直观易懂，start、end 就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块儿。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240705117.png"></p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
<h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后，这些数据被存储在元数据空间。</p>
<h3 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h3><ul>
<li>最大堆体积</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx value</span><br></pre></td></tr></table></figure>

<ul>
<li>初始的最小堆体积</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms value</span><br></pre></td></tr></table></figure>

<ul>
<li>老年代和新生代的比例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=value</span><br></pre></td></tr></table></figure>

<p>默认情况下，这个数值是 2，意味着老年代是新生代的 2 倍大；换句话说，新生代是堆大小的 1&#x2F;3。</p>
<ul>
<li>当然，也可以不用比例的方式调整新生代的大小，直接指定下面的参数，设定具体的内存大小数值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=value</span><br></pre></td></tr></table></figure>

<ul>
<li>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1⁄8 大小，也就是新生代的 1&#x2F;10，因为 YoungGen&#x3D;Eden + 2*Survivor，JVM 参数格式是</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=value</span><br></pre></td></tr></table></figure>

<ul>
<li>TLAB 当然也可以调整，JVM 实现了复杂的适应策略，如果你有兴趣可以参考这篇 <a target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/the-real-thing">说明</a>。</li>
</ul>
<h2 id="Java-常见的垃圾收集器有哪些？"><a href="#Java-常见的垃圾收集器有哪些？" class="headerlink" title="Java 常见的垃圾收集器有哪些？"></a>Java 常见的垃圾收集器有哪些？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul>
<li><p>Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。</p>
</li>
<li><p>ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作</p>
</li>
<li><p>CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</p>
</li>
<li><p>Parallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。</p>
</li>
<li><p>G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
</ul>
<h3 id="对象是否回收算法"><a href="#对象是否回收算法" class="headerlink" title="对象是否回收算法"></a>对象是否回收算法</h3><p><strong>引用计数法</strong> - 就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。引用计数法最大的问题是难以处理循环引用。</p>
<p><strong>可达性分析法</strong> - 就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p><strong>标记 - 复制（Copying）</strong> - 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。这实际上也是利用了 CoW 机制。</p>
<p><strong>标记 - 清除（Mark-Sweep）</strong> - 将需要回收的对象进行标记，然后清除。标记和清除过程效率都不高，会产生大量碎片，导致无法给大对象分配内存。</p>
<p><strong>标记 - 整理（Mark-Compact）</strong> - 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h3><p>第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240706966.png"></p>
<p>第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240706215.png"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：</p>
<p><code>-XX:MaxTenuringThreshold=&lt;N&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240706521.png"></p>
<p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 整理算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240707750.png"></p>
<p>通常我们把老年代 GC 叫作 Major GC，将对整个堆进行的清理叫作 Full GC，但是这个也没有那么绝对，因为不同的老年代 GC 算法其实表现差异很大，例如 CMS，“concurrent”就体现在清理工作是与工作线程一起并发运行的。</p>
<h2 id="谈谈你的-GC-调优思路"><a href="#谈谈你的-GC-调优思路" class="headerlink" title="谈谈你的 GC 调优思路"></a>谈谈你的 GC 调优思路</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>GC 调优，从性能角度来看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。</p>
<p>调优思路：</p>
<ul>
<li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li>
<li>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li>
<li>通过分析确定具体调整的参数或者软硬件配置。</li>
<li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li>
</ul>
<h3 id="G1-GC-机制"><a href="#G1-GC-机制" class="headerlink" title="G1 GC 机制"></a>G1 GC 机制</h3><p>G1 内存区域如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240707671.png"></p>
<p>region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region。这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。</p>
<p>在 G1 实现中，年代是个逻辑概念，具体体现在，一部分 region 是作为 Eden，一部分作为 Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。</p>
<p>从 GC 算法的角度，G1 选择的是复合算法，可以简化理解为：</p>
<ul>
<li>在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World 的暂停。</li>
<li>在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行的。</li>
</ul>
<h2 id="Java-内存模型中的-happen-before-是什么？"><a href="#Java-内存模型中的-happen-before-是什么？" class="headerlink" title="Java 内存模型中的 happen-before 是什么？"></a>Java 内存模型中的 happen-before 是什么？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>JMM 为程序中所有的操作定义了一个偏序关系，称之为 <strong><code>先行发生原则（Happens-Before）</code><strong>。</strong>Happens-Before</strong> 是指 <strong>前面一个操作的结果对后续操作是可见的</strong>。</p>
<p><strong>Happens-Before</strong> 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。</p>
<ul>
<li><strong>程序顺序规则</strong> - 在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</li>
<li><strong>锁定规则</strong> - 一个 <code>unLock</code> 操作 Happens-Before 于后面对同一个锁的 <code>lock</code> 操作。</li>
<li><strong>volatile 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作 Happens-Before 于后面对这个变量的读操作。</li>
<li><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法 Happens-Before 于此线程的每个一个动作。</li>
<li><strong>线程终止规则</strong> - 线程中所有的操作都 Happens-Before 于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法是否结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生。</li>
<li><strong>对象终结规则</strong> - 一个对象的初始化完成 Happens-Before 于它的 <code>finalize()</code> 方法的开始。</li>
<li><strong>传递性</strong> - 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
</ul>
<h2 id="Java-程序运行在-Docker-等容器环境有哪些新问题？"><a href="#Java-程序运行在-Docker-等容器环境有哪些新问题？" class="headerlink" title="Java 程序运行在 Docker 等容器环境有哪些新问题？"></a>Java 程序运行在 Docker 等容器环境有哪些新问题？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>虽然看起来 Docker 之类容器和虚拟机非常相似，例如，它也有自己的 shell，能独立安装软件包，运行时与其他容器互不干扰。但是，如果深入分析你会发现，Docker 并不是一种完全的<strong>虚拟化</strong>技术，而更是一种轻量级的<strong>隔离</strong>技术。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240707589.png"></p>
<p>基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC 通信、文件系统挂载点等实现了隔离。对于 CPU、内存、磁盘 IO 等计算资源，则是通过 CGroup 进行管理。</p>
<p>Docker 仅在类似 Linux 内核之上实现了有限的隔离和虚拟化，并不是像传统虚拟化软件那样，独立运行一个新的操作系统。对于 Java 来说，Docker 未完全隐藏底层信息，会产生以下问题：</p>
<p>第一，容器环境对于计算资源的管理方式是全新的，CGroup 作为相对比较新的技术，历史版本的 Java 显然并不能自然地理解相应的资源限制。</p>
<p>第二，namespace 对于容器内的应用细节增加了一些微妙的差异，比如 jcmd、jstack 等工具会依赖于“&#x2F;proc&#x2F;&#x2F;”下面提供的部分信息，但是 Docker 的设计改变了这部分信息的原有结构，我们需要对原有工具进行修改以适应这种变化。</p>
<p><strong>从 JVM 运行机制的角度，为什么这些“沟通障碍”会导致 OOM 等问题呢？</strong></p>
<ul>
<li>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1&#x2F;64；并将堆最大值，设置为系统内存的 1&#x2F;4。</li>
<li>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。</li>
</ul>
<p>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。更加严重的是，JVM 的一些原有诊断或备用机制也会受到影响。为保证服务的可用性，一种常见的选择是依赖“-XX:OnOutOfMemoryError”功能，通过调用处理脚本的形式来做一些补救措施，比如自动重启服务等。但是，这种机制是基于 fork 实现的，当 Java 进程已经过度提交内存时，fork 新的进程往往已经不可能正常运行了。</p>
<p><strong>如何解决这些问题呢？</strong></p>
<p>首先，如果你能够<strong>升级到最新的 JDK 版本</strong>，这个问题就迎刃而解了。针对这种情况，JDK 9 中引入了一些实验性的参数，以方便 Docker 和 Java“沟通”。</p>
<p>如果你可以切换到 JDK 10 或者更新的版本，问题就更加简单了。Java 对容器（Docker）的支持已经比较完善，默认就会自适应各种资源限制和实现差异。</p>
<p>JDK 9 中的实验性改进已经被移植到 Oracle JDK 8u131 之中。</p>
<h2 id="你了解-Java-应用开发中的注入攻击吗？"><a href="#你了解-Java-应用开发中的注入攻击吗？" class="headerlink" title="你了解 Java 应用开发中的注入攻击吗？"></a>你了解 Java 应用开发中的注入攻击吗？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>注入攻击其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。</p>
<ul>
<li>SQL 注入攻击</li>
<li>系统命令注入</li>
<li>XML 注入攻击</li>
</ul>
<h2 id="如何写出安全的-Java-代码？"><a href="#如何写出安全的-Java-代码？" class="headerlink" title="如何写出安全的 Java 代码？"></a>如何写出安全的 Java 代码？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>略</p>
<h2 id="后台服务出现明显“变慢”，谈谈你的诊断思路？"><a href="#后台服务出现明显“变慢”，谈谈你的诊断思路？" class="headerlink" title="后台服务出现明显“变慢”，谈谈你的诊断思路？"></a>后台服务出现明显“变慢”，谈谈你的诊断思路？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240708746.png"></p>
<h2 id="有人说“Lambda-能让-Java-程序慢-30-倍”，你怎么看？"><a href="#有人说“Lambda-能让-Java-程序慢-30-倍”，你怎么看？" class="headerlink" title="有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？"></a>有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>在实际运行中，基于 Lambda&#x2F;Stream 的版本（lambdaMaxInteger），比传统的 for-each 版本（forEachLoopMaxInteger）慢很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个大的 ArrayList，内部是随机的整形数据</span></span><br><span class="line"><span class="keyword">volatile</span> List&lt;Integer&gt; integers = …</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基准测试 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">forEachLoopMaxInteger</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">   <span class="keyword">for</span> (Integer n : integers) &#123;</span><br><span class="line">    max = Integer.max(max, n);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基准测试 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lambdaMaxInteger</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> integers.stream().reduce(Integer.MIN_VALUE, (a, b) -&gt; Integer.max(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码片段更多的开销是源于自动装箱、拆箱（auto-boxing&#x2F;unboxing），而不是源自 Lambda 和 Stream。</p>
<p>一般来说，可以认为 Lambda&#x2F;Stream 提供了与传统方式接近对等的性能，但是如果对于性能非常敏感，就不能完全忽视它在特定场景的性能差异了，例如：<strong>初始化的开销</strong>。 Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html">CallSite</a> 实例。这意味着，如果 Java 应用启动过程引入了很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</p>
<h2 id="JVM-优化-Java-代码时都做了什么？"><a href="#JVM-优化-Java-代码时都做了什么？" class="headerlink" title="JVM 优化 Java 代码时都做了什么？"></a>JVM 优化 Java 代码时都做了什么？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>略</p>
<h2 id="谈谈-MySQL-支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><a href="#谈谈-MySQL-支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"></a>谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>以最常见的 MySQL InnoDB 引擎为例，它是基于 MVCC（Multi-Versioning Concurrency Control）和锁的复合实现，按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次：</p>
<ul>
<li>读未提交（Read uncommitted），就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许脏读出现。</li>
<li>读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许不可重复读和幻象读（Phantom Read）出现。</li>
<li>可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读。</li>
<li>串行化（Serializable），并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别。</li>
</ul>
<p>悲观锁和乐观锁：</p>
<p>悲观锁 - 悲观锁一般就是利用类似 <code>SELECT … FOR UPDATE</code> 这样的语句，对数据加锁，避免其他事务意外修改数据。</p>
<p>乐观锁 - 乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h2 id="谈谈-Spring-Bean-的生命周期和作用域？"><a href="#谈谈-Spring-Bean-的生命周期和作用域？" class="headerlink" title="谈谈 Spring Bean 的生命周期和作用域？"></a>谈谈 Spring Bean 的生命周期和作用域？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<h3 id="Spring-创建-Bean"><a href="#Spring-创建-Bean" class="headerlink" title="Spring 创建 Bean"></a>Spring 创建 Bean</h3><ul>
<li>实例化 Bean 对象。</li>
<li>设置 Bean 属性。</li>
<li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖。具体包括 BeanNameAware、BeanFactoryAware 和 ApplicationContextAware，分别会注入 Bean ID、Bean Factory 或者 ApplicationContext。</li>
<li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization。</li>
<li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法。</li>
<li>调用 Bean 自身定义的 init 方法。</li>
<li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization。</li>
<li>创建过程完毕。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240708158.png"></p>
<h3 id="Spring-销毁-Bean"><a href="#Spring-销毁-Bean" class="headerlink" title="Spring 销毁 Bean"></a>Spring 销毁 Bean</h3><p>Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法。</p>
<p>Spring Bean 有五个作用域，其中最基础的有下面两种：</p>
<ul>
<li>Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例。</li>
<li>Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例。</li>
</ul>
<p>从 Bean 的特点来看，Prototype 适合有状态的 Bean，而 Singleton 则更适合无状态的情况。另外，使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的。</p>
<p>如果是 Web 容器，则支持另外三种作用域：</p>
<ul>
<li>Request，为每个 HTTP 请求创建单独的 Bean 实例。</li>
<li>Session，很显然 Bean 实例的作用域是 Session 范围。<ul>
<li>GlobalSession，用于 Portlet 容器，因为每个 Portlet 有单独的 Session，GlobalSession 提供一个全局性的 HTTP Session。·</li>
</ul>
</li>
</ul>
<h2 id="对比-Java-标准-NIO-类库，你知道-Netty-是如何实现更高性能的吗？"><a href="#对比-Java-标准-NIO-类库，你知道-Netty-是如何实现更高性能的吗？" class="headerlink" title="对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？"></a>对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>多路复用</p>
<p>零拷贝</p>
<p>从 API 能力范围来看，Netty 完全是 Java NIO 框架的一个大大的超集</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240708363.png"></p>
<p>Netty 官方提供的 Server 部分，完整用例请点击 <a target="_blank" rel="noopener" href="http://netty.io/4.1/xref/io/netty/example/echo/package-summary.html">链接</a>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240708879.png"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java">ServerBootstrap</a>，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以 <strong>Fluent</strong> API 等形式完成，相对简化了 API 使用。与之相对应， <a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 则是 Client 端的通常入口。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/Channel.java">Channel</a>，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a>，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/ChannelFuture.java">ChannelFuture</a>，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有 <a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/eb7f751ba519cbcab47d640cd18757f09d077b55/common/src/main/java/io/netty/util/concurrent/Future.java">Future</a> 定义。</li>
<li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a>，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li>
</ul>
<p>参考下面的简化示意图，忽略 Inbound&#x2F;OutBound Handler 的细节，理解这几个基本单元之间的操作流程和对应关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240709828.png"></p>
<p>对比 Java 标准 NIO 的代码，Netty 提供的相对高层次的封装，减少了对 Selector 等细节的操纵，而 EventLoop、Pipeline 等机制则简化了编程模型，开发者不用担心并发等问题，在一定程度上简化了应用代码的开发。</p>
<h2 id="谈谈常用的分布式-ID-的设计方案？Snowflake-是否受冬令时切换影响？"><a href="#谈谈常用的分布式-ID-的设计方案？Snowflake-是否受冬令时切换影响？" class="headerlink" title="谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？"></a>谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</h2><p>【典型回答】+【考点分析】+【知识扩展】</p>
<p>分布式 ID 基本要求：</p>
<ul>
<li>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li>
<li>有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</li>
</ul>
<p>业界方案：</p>
<p>UUID</p>
<p>各种数据库自增序列</p>
<p>雪花算法 - 如 Twitter 早期开源的 <a target="_blank" rel="noopener" href="https://github.com/twitter/snowflake">Snowflake</a> 的实现，其结构定义可以参考下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409240710538.png"></p>
<h2 id="周末福利-一份-Java-工程师必读书单"><a href="#周末福利-一份-Java-工程师必读书单" class="headerlink" title="周末福利 一份 Java 工程师必读书单"></a>周末福利 一份 Java 工程师必读书单</h2><ul>
<li><p>《Java 编程思想》</p>
</li>
<li><p>《Java 核心技术》</p>
</li>
<li><p>《Effective Java》</p>
</li>
<li><p>《Head First 设计模式》</p>
</li>
<li><p>《Java 并发编程实战》</p>
</li>
<li><p>《深入理解 Java 虚拟机》</p>
</li>
<li><p>《Java 性能优化权威指南》</p>
</li>
<li><p>《Spring 实战》</p>
</li>
<li><p>《Netty 实战》</p>
</li>
<li><p>《大型分布式网站架构设计与实践》</p>
</li>
<li><p>《深入分布式缓存：从原理到实践》</p>
</li>
</ul>
<h2 id="周末福利-谈谈我对-Java-学习和面试的看法"><a href="#周末福利-谈谈我对-Java-学习和面试的看法" class="headerlink" title="周末福利 谈谈我对 Java 学习和面试的看法"></a>周末福利 谈谈我对 Java 学习和面试的看法</h2><p>略</p>
<h2 id="结束语-技术没有终点"><a href="#结束语-技术没有终点" class="headerlink" title="结束语 技术没有终点"></a>结束语 技术没有终点</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/82">极客时间教程 - Java 核心技术面试精讲</a> - 极客时间教程——从面试官视角梳理如何解答常见 Java 面试问题</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/33d6187f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/33d6187f/" class="post-title-link" itemprop="url">《极客时间教程 - Java 并发编程实战》笔记三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-30 08:02:52" itemprop="dateCreated datePublished" datetime="2024-08-30T08:02:52+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Java-并发编程实战》笔记三"><a href="#《极客时间教程-Java-并发编程实战》笔记三" class="headerlink" title="《极客时间教程 - Java 并发编程实战》笔记三"></a>《极客时间教程 - Java 并发编程实战》笔记三</h1><h2 id="Immutability-模式：如何利用不变性解决并发问题？"><a href="#Immutability-模式：如何利用不变性解决并发问题？" class="headerlink" title="Immutability 模式：如何利用不变性解决并发问题？"></a>Immutability 模式：如何利用不变性解决并发问题？</h2><p>解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：<strong>不变性（Immutability）模式</strong>。所谓<strong>不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化</strong>。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p>
<h3 id="快速实现具备不可变性的类"><a href="#快速实现具备不可变性的类" class="headerlink" title="快速实现具备不可变性的类"></a>快速实现具备不可变性的类</h3><p><strong>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了</strong>。更严格的做法是<strong>这个类本身也是 final 的</strong>，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性。</p>
<p>经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。它们都严格遵守不可变类的三点要求：<strong>类和属性都是 final 的，所有方法均是只读的</strong>。</p>
<p>Java 的 String 方法也有类似字符替换操作，怎么能说所有方法都是只读的呢？下面的示例代码源自 Java 1.8 SDK，仅保留了关键属性 value[] 和 replace() 方法，你会发现：String 这个类以及它的属性 value[] 都是 final 的；而 replace() 方法的实现，就的确没有修改 value[]，而是将替换后的字符串作为返回值返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">  <span class="comment">// 字符替换</span></span><br><span class="line">  String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar,</span></span><br><span class="line"><span class="params">      <span class="type">char</span> newChar)</span> &#123;</span><br><span class="line">    <span class="comment">//无需替换，直接返回 this</span></span><br><span class="line">    <span class="keyword">if</span> (oldChar == newChar)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">    <span class="type">char</span>[] val = value;</span><br><span class="line">    <span class="comment">//定位到需要替换的字符位置</span></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未找到 oldChar，无需替换</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个 buf[]，这是关键</span></span><br><span class="line">    <span class="comment">//用来保存替换后的字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      buf[j] = val[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> val[i];</span><br><span class="line">      buf[i] = (c == oldChar) ?</span><br><span class="line">        newChar : c;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个新的字符串返回</span></span><br><span class="line">    <span class="comment">//原字符串不会发生任何变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用享元模式避免创建重复对象"><a href="#利用享元模式避免创建重复对象" class="headerlink" title="利用享元模式避免创建重复对象"></a>利用享元模式避免创建重复对象</h3><p><strong>享元模式（Flyweight Pattern）可以减少创建对象的数量，从而减少内存占用。</strong>Java 语言里面 Long、Integer、Short、Byte 等这些基本数据类型的包装类都用到了享元模式。</p>
<p>享元模式本质上其实就是一个<strong>对象池</strong>，利用享元模式创建对象的逻辑也很简单：创建之前，首先去对象池里看看是不是存在；如果已经存在，就利用对象池里的对象；如果不存在，就会新创建一个对象，并且把这个新创建出来的对象放进对象池里。</p>
<p>Long 这个类并没有照搬享元模式，Long 内部维护了一个静态的对象池，仅缓存了 [-128,127] 之间的数字，这个对象池在 JVM 启动的时候就创建好了，而且这个对象池一直都不会变化，也就是说它是静态的。之所以采用这样的设计，是因为 Long 这个对象的状态共有 2^64 种，实在太多，不宜全部缓存，而 [-128,127] 之间的数字利用率最高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">  <span class="comment">// [-128,127] 直接的数字做了缓存</span></span><br><span class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> LongCache</span><br><span class="line">      .cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存，等价于对象池</span></span><br><span class="line"><span class="comment">//仅缓存 [-128,127] 直接的数字</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Long cache[]</span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cache.length; i++)</span><br><span class="line">      cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i-<span class="number">128</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上所有的基础类型的包装类都不适合做锁，因为它们内部用到了享元模式，这会导致看上去私有的锁，其实是共有的。例如在下面代码中，本意是 A 用锁 al，B 用锁 bl，各自管理各自的，互不影响。但实际上 al 和 bl 是一个对象，结果 A 和 B 共用的是一把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  Long al=Long.valueOf(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAX</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (al) &#123;</span><br><span class="line">      <span class="comment">//省略代码无数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  Long bl=Long.valueOf(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBY</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (bl) &#123;</span><br><span class="line">      <span class="comment">//省略代码无数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Immutability-式的注意事项"><a href="#使用-Immutability-式的注意事项" class="headerlink" title="使用 Immutability 式的注意事项"></a>使用 Immutability 式的注意事项</h3><p>在使用 Immutability 模式的时候，需要注意以下两点：</p>
<ol>
<li>对象的所有属性都是 final 的，并不能保证不可变性；</li>
<li>不可变对象也需要正确发布。</li>
</ol>
<p>在 Java 语言中，final 修饰的属性一旦被赋值，就不可以再修改，但是如果属性的类型是普通对象，那么这个普通对象的属性是可以被修改的。例如下面的代码中，Bar 的属性 foo 虽然是 final 的，依然可以通过 setAge() 方法来设置 foo 的属性 age。所以，<strong>在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Foo foo;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    foo.age=a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再看看如何正确地发布不可变对象。不可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的。例如在下面的代码中，Foo 具备不可变性，线程安全，但是类 Bar 并不是线程安全的，类 Bar 中持有对 Foo 的引用 foo，对 foo 这个引用的修改在多线程中并不能保证可见性和原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Foo 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bar 线程不安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setFoo</span><span class="params">(Foo f)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.foo=f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的程序仅仅需要 foo 保持可见性，无需保证原子性，那么可以将 foo 声明为 volatile 变量，这样就能保证可见性。如果你的程序需要保证原子性，那么可以通过原子类来实现。下面的示例代码是合理库存的原子化实现，你应该很熟悉了，其中就是用原子类解决了不可变对象引用的原子性问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeWM</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WMRange</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> upper;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> lower;</span><br><span class="line">    WMRange(<span class="type">int</span> upper,<span class="type">int</span> lower)&#123;</span><br><span class="line">    <span class="comment">//省略构造函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> AtomicReference&lt;WMRange&gt;</span><br><span class="line">    rf = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">WMRange</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">// 设置库存上限</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setUpper</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="type">WMRange</span> <span class="variable">or</span> <span class="operator">=</span> rf.get();</span><br><span class="line">      <span class="comment">// 检查参数合法性</span></span><br><span class="line">      <span class="keyword">if</span>(v &lt; or.lower)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">WMRange</span> <span class="variable">nr</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">          <span class="title class_">WMRange</span>(v, or.lower);</span><br><span class="line">      <span class="keyword">if</span>(rf.compareAndSet(or, nr))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>利用 Immutability 模式解决并发问题，也许你觉得有点陌生，其实你天天都在享受它的战果。Java 语言里面的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。Immutability 模式是最简单的解决并发问题的方法，建议当你试图解决一个并发问题时，可以首先尝试一下 Immutability 模式，看是否能够快速解决。</p>
<p>具备不变性的对象，只有一种状态，这个状态由对象内部所有的不变属性共同决定。其实还有一种更简单的不变性对象，那就是<strong>无状态</strong>。无状态对象内部没有属性，只有方法。除了无状态的对象，你可能还听说过无状态的服务、无状态的协议等等。无状态有很多好处，最核心的一点就是性能。在多线程领域，无状态对象没有线程安全问题，无需同步处理，自然性能很好；在分布式领域，无状态意味着可以无限地水平扩展，所以分布式领域里面性能的瓶颈一定不是出在无状态的服务节点上。</p>
<h2 id="Copy-on-Write-模式：不是延时策略的-COW"><a href="#Copy-on-Write-模式：不是延时策略的-COW" class="headerlink" title="Copy-on-Write 模式：不是延时策略的 COW"></a>Copy-on-Write 模式：不是延时策略的 COW</h2><p>Copy-on-Write，经常被缩写为 COW 或者 CoW，顾名思义就是<strong>写时复制</strong>。</p>
<h3 id="Copy-on-Write-模式的应用领域"><a href="#Copy-on-Write-模式的应用领域" class="headerlink" title="Copy-on-Write 模式的应用领域"></a>Copy-on-Write 模式的应用领域</h3><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write 容器，它们背后的设计思想就是 Copy-on-Write；通过 Copy-on-Write 这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。</p>
<p><strong>Copy-on-Write 最大的应用领域还是在函数式编程领域</strong>。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。</p>
<h3 id="一个真实案例"><a href="#一个真实案例" class="headerlink" title="一个真实案例"></a>一个真实案例</h3><p>Router 的实现代码如下所示，是一种典型 Immutability 模式的实现，需要你注意的是我们重写了 equals 方法，这样 CopyOnWriteArraySet 的 add() 和 remove() 方法才能正常工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Router</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String  ip;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Integer port;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String  iface;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Router</span><span class="params">(String ip,</span></span><br><span class="line"><span class="params">      Integer port, String iface)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.ip = ip;</span><br><span class="line">    <span class="built_in">this</span>.port = port;</span><br><span class="line">    <span class="built_in">this</span>.iface = iface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重写 equals 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Router) &#123;</span><br><span class="line">      <span class="type">Router</span> <span class="variable">r</span> <span class="operator">=</span> (Router)obj;</span><br><span class="line">      <span class="keyword">return</span> iface.equals(r.iface) &amp;&amp;</span><br><span class="line">             ip.equals(r.ip) &amp;&amp;</span><br><span class="line">             port.equals(r.port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略 hashCode 相关代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路由表信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouterTable</span> &#123;</span><br><span class="line">  <span class="comment">//Key: 接口名</span></span><br><span class="line">  <span class="comment">//Value: 路由集合</span></span><br><span class="line">  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt;</span><br><span class="line">    rt = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//根据接口名获取路由表</span></span><br><span class="line">  <span class="keyword">public</span> Set&lt;Router&gt; <span class="title function_">get</span><span class="params">(String iface)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rt.get(iface);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//删除路由</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Router router)</span> &#123;</span><br><span class="line">    Set&lt;Router&gt; set=rt.get(router.iface);</span><br><span class="line">    <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">      set.remove(router);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//增加路由</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Router router)</span> &#123;</span><br><span class="line">    Set&lt;Router&gt; set = rt.computeIfAbsent(</span><br><span class="line">      route.iface, r -&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;());</span><br><span class="line">    set.add(router);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程本地存储模式：没有共享，就没有伤害"><a href="#线程本地存储模式：没有共享，就没有伤害" class="headerlink" title="线程本地存储模式：没有共享，就没有伤害"></a>线程本地存储模式：没有共享，就没有伤害</h2><p><strong>线程封闭</strong>，其本质上就是避免共享。没有共享，自然也就没有并发安全问题。</p>
<p>Java 中，ThreadLocal 就可以做到线程封闭。</p>
<h3 id="ThreadLocal-的使用方法"><a href="#ThreadLocal-的使用方法" class="headerlink" title="ThreadLocal 的使用方法"></a>ThreadLocal 的使用方法</h3><p>SimpleDateFormat 不是线程安全的，如果要保证并发安全，可以使用 ThreadLocal 来解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SafeDateFormat</span> &#123;</span><br><span class="line">  <span class="comment">//定义 ThreadLocal 变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt;</span><br><span class="line">  tl=ThreadLocal.withInitial(</span><br><span class="line">    ()-&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">      <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DateFormat <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不同线程执行下面代码</span></span><br><span class="line"><span class="comment">//返回的 df 是不同的</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> SafeDateFormat.get();</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h3><p>ThreadLocal 的目标是让不同的线程有不同的变量 V，那最直接的方法就是创建一个 Map，它的 Key 是线程，Value 是每个线程拥有的变量 V，ThreadLocal 内部持有这样的一个 Map 就可以了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010704287.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">  Map&lt;Thread, T&gt; locals =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//获取线程变量</span></span><br><span class="line">  T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> locals.get(</span><br><span class="line">      Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置线程变量</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    locals.put(</span><br><span class="line">      Thread.currentThread(), t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的实现里面也有一个 Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010705524.png"></p>
<p>Thread 持有 ThreadLocalMap 的示意图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="comment">//内部持有 ThreadLocalMap</span></span><br><span class="line">  ThreadLocal.ThreadLocalMap</span><br><span class="line">    threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//首先获取线程持有的</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span></span><br><span class="line">      Thread.currentThread()</span><br><span class="line">        .threadLocals;</span><br><span class="line">    <span class="comment">//在 ThreadLocalMap 中</span></span><br><span class="line">    <span class="comment">//查找变量</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span></span><br><span class="line">      map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span>&#123;</span><br><span class="line">    <span class="comment">//内部是数组而不是 Map</span></span><br><span class="line">    Entry[] table;</span><br><span class="line">    <span class="comment">//根据 ThreadLocal 查找 Entry</span></span><br><span class="line">    Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal key)</span>&#123;</span><br><span class="line">      <span class="comment">//省略查找逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Entry 定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span></span><br><span class="line">    <span class="title class_">WeakReference</span>&lt;ThreadLocal&gt;&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 的实现方案里面，ThreadLocal 仅仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在 Thread 里面，这样的设计容易理解。</p>
<p>当然还有一个更加深层次的原因，那就是<strong>不容易产生内存泄露</strong>。在我们的设计方案中，ThreadLocal 持有的 Map 会持有 Thread 对象的引用，这就意味着，只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往都比线程要长，所以这种设计方案很容易导致内存泄露。而 Java 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用（WeakReference），所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。Java 的这种实现方案虽然看上去复杂一些，但是更加安全。</p>
<h3 id="ThreadLocal-与内存泄露"><a href="#ThreadLocal-与内存泄露" class="headerlink" title="ThreadLocal 与内存泄露"></a>ThreadLocal 与内存泄露</h3><p>在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢？原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄露。</p>
<p>那在线程池中，我们该如何正确使用 ThreadLocal 呢？其实很简单，既然 JVM 不能做到自动释放对 Value 的强引用，那我们手动释放就可以了。如何能做到手动释放呢？估计你马上想到** try{}finally{}方案<strong>了，这个简直就是</strong>手动释放资源的利器**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal 增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理 ThreadLocal</span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="InheritableThreadLocal-与继承性"><a href="#InheritableThreadLocal-与继承性" class="headerlink" title="InheritableThreadLocal 与继承性"></a>InheritableThreadLocal 与继承性</h2><p>通过 ThreadLocal 创建的线程变量，其子线程是无法继承的。也就是说你在线程中通过 ThreadLocal 创建了线程变量 V，而后该线程创建了子线程，你在子线程中是无法通过 ThreadLocal 来访问父线程的线程变量 V 的。</p>
<p>如果你需要子线程继承父线程的线程变量，那该怎么办呢？其实很简单，Java 提供了 InheritableThreadLocal 来支持这种特性，InheritableThreadLocal 是 ThreadLocal 子类，所以用法和 ThreadLocal 相同。</p>
<p>不过，完全不建议你在线程池中使用 InheritableThreadLocal，不仅仅是因为它具有 ThreadLocal 相同的缺点——可能导致内存泄露，更重要的原因是：线程池中线程的创建是动态的，很容易导致继承关系错乱，如果你的业务逻辑依赖 InheritableThreadLocal，那么很可能导致业务逻辑计算错误，而这个错误往往比内存泄露更要命。</p>
<h2 id="Guarded-Suspension-模式：等待唤醒机制的规范实现"><a href="#Guarded-Suspension-模式：等待唤醒机制的规范实现" class="headerlink" title="Guarded Suspension 模式：等待唤醒机制的规范实现"></a>Guarded Suspension 模式：等待唤醒机制的规范实现</h2><p>消息队列在互联网大厂中用的非常多，主要用作流量削峰和系统解耦。在这种接入方式中，发送消息和消费结果这两个操作之间是异步的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010706341.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">  String id;</span><br><span class="line">  String content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法可以发送消息</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">  <span class="comment">//省略相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MQ 消息返回后会调用该方法</span></span><br><span class="line"><span class="comment">//该方法的执行线程不同于</span></span><br><span class="line"><span class="comment">//发送消息的线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">  <span class="comment">//省略相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理浏览器发来的请求</span></span><br><span class="line">Respond <span class="title function_">handleWebReq</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//创建一消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">Message</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;&#123;...&#125;&quot;</span>);</span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  send(msg1);</span><br><span class="line">  <span class="comment">//如何等待 MQ 返回的消息呢？</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h3><p><strong>Guarded Suspension</strong> 模式就是“保护性地暂停”。</p>
<p>一个对象 GuardedObject，内部有一个成员变量——受保护的对象，以及两个成员方法——<code>get(Predicate&lt;T&gt; p)</code>和<code>onChanged(T obj)</code>方法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010706780.png"></p>
<p>GuardedObject 的内部实现非常简单，是管程的一个经典用法，核心是：get() 方法通过条件变量的 await() 方法实现等待，onChanged() 方法通过条件变量的 signalAll() 方法实现唤醒功能。逻辑还是很简单的，所以这里就不再详细介绍了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="comment">//受保护的对象</span></span><br><span class="line">  T obj;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span></span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> timeout=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//获取受保护对象</span></span><br><span class="line">  T <span class="title function_">get</span><span class="params">(Predicate&lt;T&gt; p)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//MESA 管程推荐写法</span></span><br><span class="line">      <span class="keyword">while</span>(!p.test(obj))&#123;</span><br><span class="line">        done.await(timeout,</span><br><span class="line">          TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回非空的受保护对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//事件通知方法</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.obj = obj;</span><br><span class="line">      done.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展-Guarded-Suspension-模式"><a href="#扩展-Guarded-Suspension-模式" class="headerlink" title="扩展 Guarded Suspension 模式"></a>扩展 Guarded Suspension 模式</h3><p>Guarded Suspension 模式里 GuardedObject 有两个核心方法，一个是 get() 方法，一个是 onChanged() 方法。很显然，在处理 Web 请求的方法 handleWebReq() 中，可以调用 GuardedObject 的 get() 方法来实现等待；在 MQ 消息的消费方法 onMessage() 中，可以调用 GuardedObject 的 onChanged() 方法来实现唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理浏览器发来的请求</span></span><br><span class="line">Respond <span class="title function_">handleWebReq</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//创建一消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">Message</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;&#123;...&#125;&quot;</span>);</span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  send(msg1);</span><br><span class="line">  <span class="comment">//利用 GuardedObject 实现等待</span></span><br><span class="line">  GuardedObject&lt;Message&gt; go</span><br><span class="line">    =<span class="keyword">new</span> <span class="title class_">GuardObjec</span>&lt;&gt;();</span><br><span class="line">  <span class="type">Message</span> <span class="variable">r</span> <span class="operator">=</span> go.get(</span><br><span class="line">    t-&gt;t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">  <span class="comment">//如何找到匹配的 go？</span></span><br><span class="line">  GuardedObject&lt;Message&gt; go=???</span><br><span class="line">  go.onChanged(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleWebReq() 里面创建了 GuardedObject 对象的实例 go，并调用其 get() 方等待结果，那在 onMessage() 方法中，如何才能够找到匹配的 GuardedObject 对象呢？</p>
<p>可以扩展一下 Guarded Suspension 模式，从而使它能够很方便地解决小灰同学的问题。在小灰的程序中，每个发送到 MQ 的消息，都有一个唯一性的属性 id，所以我们可以维护一个 MQ 消息 id 和 GuardedObject 对象实例的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="comment">//受保护的对象</span></span><br><span class="line">  T obj;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span></span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> timeout=<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//保存所有 GuardedObject</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Object, GuardedObject&gt;</span><br><span class="line">  gos=<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//静态方法创建 GuardedObject</span></span><br><span class="line">  <span class="keyword">static</span> &lt;K&gt; GuardedObject</span><br><span class="line">      <span class="title function_">create</span><span class="params">(K key)</span>&#123;</span><br><span class="line">    GuardedObject go=<span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">    gos.put(key, go);</span><br><span class="line">    <span class="keyword">return</span> go;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &lt;K, T&gt; <span class="keyword">void</span></span><br><span class="line">      <span class="title function_">fireEvent</span><span class="params">(K key, T obj)</span>&#123;</span><br><span class="line">    GuardedObject go=gos.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (go != <span class="literal">null</span>)&#123;</span><br><span class="line">      go.onChanged(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取受保护对象</span></span><br><span class="line">  T <span class="title function_">get</span><span class="params">(Predicate&lt;T&gt; p)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//MESA 管程推荐写法</span></span><br><span class="line">      <span class="keyword">while</span>(!p.test(obj))&#123;</span><br><span class="line">        done.await(timeout,</span><br><span class="line">          TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回非空的受保护对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//事件通知方法</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.obj = obj;</span><br><span class="line">      done.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理浏览器发来的请求</span></span><br><span class="line">Respond <span class="title function_">handleWebReq</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> id=序号生成器。get();</span><br><span class="line">  <span class="comment">//创建一消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">Message</span>(id,<span class="string">&quot;&#123;...&#125;&quot;</span>);</span><br><span class="line">  <span class="comment">//创建 GuardedObject 实例</span></span><br><span class="line">  GuardedObject&lt;Message&gt; go=</span><br><span class="line">    GuardedObject.create(id);</span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  send(msg1);</span><br><span class="line">  <span class="comment">//等待 MQ 消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">r</span> <span class="operator">=</span> go.get(</span><br><span class="line">    t-&gt;t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">  <span class="comment">//唤醒等待的线程</span></span><br><span class="line">  GuardedObject.fireEvent(</span><br><span class="line">    msg.id, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Guarded Suspension 模式本质上是一种等待唤醒机制的实现，只不过 Guarded Suspension 模式将其规范化了。规范化的好处是你无需重头思考如何实现，也无需担心实现程序的可理解性问题，同时也能避免一不小心写出个 Bug 来。但 Guarded Suspension 模式在解决实际问题的时候，往往还是需要扩展的，扩展的方式有很多，本篇文章就直接对 GuardedObject 的功能进行了增强，Dubbo 中 DefaultFuture 这个类也是采用的这种方式，你可以对比着来看，相信对 DefaultFuture 的实现原理会理解得更透彻。当然，你也可以创建新的类来实现对 Guarded Suspension 模式的扩展。</p>
<p>Guarded Suspension 模式也常被称作 Guarded Wait 模式、Spin Lock 模式（因为使用了 while 循环去等待），这些名字都很形象，不过它还有一个更形象的非官方名字：多线程版本的 if。单线程场景中，if 语句是不需要等待的，因为在只有一个线程的条件下，如果这个线程被阻塞，那就没有其他活动线程了，这意味着 if 判断条件的结果也不会发生变化了。但是多线程场景中，等待就变得有意义了，这种场景下，if 判断条件的结果是可能发生变化的。所以，用“多线程版本的 if”来理解这个模式会更简单。</p>
<h2 id="Balking-模式：再谈线程安全的单例模式"><a href="#Balking-模式：再谈线程安全的单例模式" class="headerlink" title="Balking 模式：再谈线程安全的单例模式"></a>Balking 模式：再谈线程安全的单例模式</h2><p>需要快速放弃的一个最常见的例子是各种编辑器提供的自动保存功能。自动保存功能的实现逻辑一般都是隔一定时间自动执行存盘操作，存盘操作的前提是文件做过修改，如果文件没有执行过修改操作，就需要快速放弃存盘操作。下面的示例代码将自动保存功能代码化了，很显然 AutoSaveEditor 这个类不是线程安全的，因为对共享变量 changed 的读写没有使用同步，那如何保证 AutoSaveEditor 的线程安全性呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoSaveEditor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件是否被修改过</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//定时任务线程池</span></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">ses</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时执行自动保存</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startAutoSave</span><span class="params">()</span> &#123;</span><br><span class="line">        ses.scheduleWithFixedDelay(() -&gt; &#123; autoSave(); &#125;, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动存盘操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">autoSave</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//执行存盘操作</span></span><br><span class="line">        <span class="comment">//省略且实现</span></span><br><span class="line">        <span class="built_in">this</span>.execSave();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编辑操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略编辑逻辑</span></span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决这个问题相信你一定手到擒来了：读写共享变量 changed 的方法 autoSave() 和 edit() 都加互斥锁就可以了。这样做虽然简单，但是性能很差，原因是锁的范围太大了。那我们可以将锁的范围缩小，只在读写共享变量 changed 的地方加锁，实现代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动存盘操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">autoSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行存盘操作</span></span><br><span class="line">    <span class="comment">//省略且实现</span></span><br><span class="line">    <span class="built_in">this</span>.execSave();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编辑操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">edit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略编辑逻辑</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Balking-模式的经典实现"><a href="#Balking-模式的经典实现" class="headerlink" title="Balking 模式的经典实现"></a>Balking 模式的经典实现</h3><p>Balking 模式本质上是一种规范化地解决“多线程版本的 if”的方案，对于上面自动保存的例子，使用 Balking 模式规范化之后的写法如下所示，你会发现仅仅是将 edit() 方法中对共享变量 changed 的赋值操作抽取到了 change() 中，这样的好处是将并发处理逻辑和业务逻辑分开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> changed=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//自动存盘操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">autoSave</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行存盘操作</span></span><br><span class="line">  <span class="comment">//省略且实现</span></span><br><span class="line">  <span class="built_in">this</span>.execSave();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编辑操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">edit</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//省略编辑逻辑</span></span><br><span class="line">  ......</span><br><span class="line">  change();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-volatile-实现-Balking-模式"><a href="#用-volatile-实现-Balking-模式" class="headerlink" title="用 volatile 实现 Balking 模式"></a>用 volatile 实现 Balking 模式</h3><p>前面我们用 synchronized 实现了 Balking 模式，这种实现方式最为稳妥，建议你实际工作中也使用这个方案。不过在某些特定场景下，也可以使用 volatile 来实现，但<strong>使用 volatile 的前提是对原子性没有要求</strong>。</p>
<p>在 RPC 框架中，本地路由表是要和注册中心进行信息同步的，应用启动的时候，会将应用依赖服务的路由表从注册中心同步到本地路由表中，如果应用重启的时候注册中心宕机，那么会导致该应用依赖的服务均不可用，因为找不到依赖服务的路由表。为了防止这种极端情况出现，RPC 框架可以将本地路由表自动保存到本地文件中，如果重启的时候注册中心宕机，那么就从本地文件中恢复重启前的路由表。这其实也是一种降级的方案。</p>
<p>自动保存路由表和前面介绍的编辑器自动保存原理是一样的，也可以用 Balking 模式实现，不过我们这里采用 volatile 来实现，实现的代码如下所示。之所以可以采用 volatile 来实现，是因为对共享变量 changed 和 rt 的写操作不存在原子性的要求，而且采用 scheduleWithFixedDelay() 这种调度方式能保证同一时刻只有一个线程执行 autoSave() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由表信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouterTable</span> &#123;</span><br><span class="line">  <span class="comment">//Key: 接口名</span></span><br><span class="line">  <span class="comment">//Value: 路由集合</span></span><br><span class="line">  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt;</span><br><span class="line">    rt = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//路由表是否发生变化</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> changed;</span><br><span class="line">  <span class="comment">//将路由表写入本地文件的线程池</span></span><br><span class="line">  ScheduledExecutorService ses=</span><br><span class="line">    Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">  <span class="comment">//启动定时任务</span></span><br><span class="line">  <span class="comment">//将变更后的路由表写入本地文件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startLocalSaver</span><span class="params">()</span>&#123;</span><br><span class="line">    ses.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">      autoSave();</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, MINUTES);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//保存路由表到本地文件</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">autoSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//将路由表写入本地文件</span></span><br><span class="line">    <span class="comment">//省略其方法实现</span></span><br><span class="line">    <span class="built_in">this</span>.save2Local();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//删除路由</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Router router)</span> &#123;</span><br><span class="line">    Set&lt;Router&gt; set=rt.get(router.iface);</span><br><span class="line">    <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">      set.remove(router);</span><br><span class="line">      <span class="comment">//路由表已发生变化</span></span><br><span class="line">      changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//增加路由</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Router router)</span> &#123;</span><br><span class="line">    Set&lt;Router&gt; set = rt.computeIfAbsent(</span><br><span class="line">      route.iface, r -&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;());</span><br><span class="line">    set.add(router);</span><br><span class="line">    <span class="comment">//路由表已发生变化</span></span><br><span class="line">    changed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Balking 模式有一个非常典型的应用场景就是单次初始化，下面的示例代码是它的实现。这个实现方案中，我们将 init() 声明为一个同步方法，这样同一个时刻就只有一个线程能够执行 init() 方法；init() 方法在第一次执行完时会将 inited 设置为 true，这样后续执行 init() 方法的线程就不会再执行 doInit() 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InitTest</span>&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inited)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略 doInit 的实现</span></span><br><span class="line">    doInit();</span><br><span class="line">    inited=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全的单例模式本质上其实也是单次初始化，所以可以用 Balking 模式来实现线程安全的单例模式，下面的示例代码是其实现。这个实现虽然功能上没有问题，但是性能却很差，因为互斥锁 synchronized 将 getInstance() 方法串行化了，那有没有办法可以优化一下它的性能呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line">    Singleton singleton;</span><br><span class="line">  <span class="comment">//构造方法私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//获取实例（单例）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span></span><br><span class="line">  Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">      singleton=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>办法当然是有的，那就是经典的<strong>双重检查</strong>（Double Check）方案，下面的示例代码是其详细实现。在双重检查方案中，一旦 Singleton 对象被成功创建之后，就不会执行 synchronized(Singleton.class){}相关的代码，也就是说，此时 getInstance() 方法的执行路径是无锁的，从而解决了性能问题。不过需要你注意的是，这个方案中使用了 volatile 来禁止编译优化。至于获取锁后的二次检查，则是出于对安全性负责。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span></span><br><span class="line">    Singleton singleton;</span><br><span class="line">  <span class="comment">//构造方法私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="comment">//获取实例（单例）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton</span><br><span class="line">  <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一次检查</span></span><br><span class="line">    <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">      synchronize(Singleton.class)&#123;</span><br><span class="line">        <span class="comment">//获取锁后二次检查</span></span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">          singleton=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系，Balking 模式只需要用互斥锁就能解决，而 Guarded Suspension 模式则要用到管程这种高级的并发原语；但是从应用的角度来看，它们解决的都是“线程安全的 if”语义，不同之处在于，Guarded Suspension 模式会等待 if 条件为真，而 Balking 模式不会等待。</p>
<p>Balking 模式的经典实现是使用互斥锁，你可以使用 Java 语言内置 synchronized，也可以使用 SDK 提供 Lock；如果你对互斥锁的性能不满意，可以尝试采用 volatile 方案，不过使用 volatile 方案需要你更加谨慎。</p>
<h2 id="Thread-Per-Message-模式：最简单实用的分工方法"><a href="#Thread-Per-Message-模式：最简单实用的分工方法" class="headerlink" title="Thread-Per-Message 模式：最简单实用的分工方法"></a>Thread-Per-Message 模式：最简单实用的分工方法</h2><p>并发编程领域里，解决分工问题也有一系列的设计模式，比较常用的主要有 Thread-Per-Message 模式、Worker Thread 模式、生产者-消费者模式等等。</p>
<h3 id="如何理解-Thread-Per-Message-模式"><a href="#如何理解-Thread-Per-Message-模式" class="headerlink" title="如何理解 Thread-Per-Message 模式"></a>如何理解 Thread-Per-Message 模式</h3><p>现实世界里，很多事情我们都需要委托他人办理，委托他人代办有一个非常大的好处，那就是可以专心做自己的事了。</p>
<p>在编程领域也有很多类似的需求，比如写一个 HTTP Server，创建一个子线程，委托子线程去处理 HTTP 请求。</p>
<p>这种委托他人办理的方式，在并发编程领域被总结为一种设计模式，叫做** Thread-Per-Message 模式**，简言之就是为每个任务分配一个独立的线程。</p>
<h3 id="用-Thread-实现-Thread-Per-Message-模式"><a href="#用-Thread-实现-Thread-Per-Message-模式" class="headerlink" title="用 Thread 实现 Thread-Per-Message 模式"></a>用 Thread 实现 Thread-Per-Message 模式</h3><p>Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。</p>
<p>网络编程里最简单的程序当数 echo 程序了，echo 程序的服务端会原封不动地将客户端的请求发送回客户端。例如，客户端发送 TCP 请求”Hello World”，那么服务端也会返回”Hello World”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span></span><br><span class="line">  ServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">//处理请求</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收请求</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">        <span class="comment">// 每个请求都创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">rb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                sc.read(rb);</span><br><span class="line">                <span class="comment">//模拟处理请求</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">// 写 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">wb</span> <span class="operator">=</span> (ByteBuffer) rb.flip();</span><br><span class="line">                sc.write(wb);</span><br><span class="line">                <span class="comment">// 关闭 Socket</span></span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UncheckedIOException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ssc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个 echo 服务的实现方案是不具备可行性的。原因在于 Java 中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大。所以，为每个请求创建一个新的线程并不适合高并发场景。</p>
<p>Java 语言里，Java 线程是和操作系统线程一一对应的，这种做法本质上是将 Java 线程的调度权完全委托给操作系统，而操作系统在这方面非常成熟，所以这种做法的好处是稳定、可靠，但是也继承了操作系统线程的缺点：创建成本高。为了解决这个缺点，Java 并发包里提供了线程池等工具类。这个思路在很长一段时间里都是很稳妥的方案，但是这个方案并不是唯一的方案。</p>
<p>业界还有另外一种方案，叫做<strong>轻量级线程</strong>。这个方案在 Java 领域知名度并不高，但是在其他编程语言里却叫得很响，例如 Go 语言、Lua 语言里的协程，本质上就是一种轻量级的线程。轻量级的线程，创建的成本很低，基本上和创建一个普通对象的成本相似；并且创建的速度和内存占用相比操作系统线程至少有一个数量级的提升，所以基于轻量级线程实现 Thread-Per-Message 模式就完全没有问题了。</p>
<p>Java 语言目前也已经意识到轻量级线程的重要性了，OpenJDK 有个 Loom 项目，就是要解决 Java 语言的轻量级线程问题，在这个项目中，轻量级线程被叫做** Fiber**。</p>
<h3 id="用-Fiber-实现-Thread-Per-Message-模式"><a href="#用-Fiber-实现-Thread-Per-Message-模式" class="headerlink" title="用 Fiber 实现 Thread-Per-Message 模式"></a>用 Fiber 实现 Thread-Per-Message 模式</h3><p>Loom 项目在设计轻量级线程时，充分考量了当前 Java 线程的使用方式，采取的是尽量兼容的态度，所以使用上还是挺简单的。用 Fiber 实现 echo 服务的示例代码如下所示，对比 Thread 的实现，你会发现改动量非常小，只需要把 <code>new Thread(()-&gt;&#123;…&#125;).start()</code> 换成 <code>Fiber.schedule(()-&gt;&#123;&#125;)</code> 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span></span><br><span class="line">    ServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">//处理请求</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收请求</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">        Fiber.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">rb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                sc.read(rb);</span><br><span class="line">                <span class="comment">//模拟处理请求</span></span><br><span class="line">                LockSupport.parkNanos(<span class="number">2000</span> * <span class="number">1000000</span>);</span><br><span class="line">                <span class="comment">// 写 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">wb</span> <span class="operator">=</span></span><br><span class="line">                    (ByteBuffer) rb.flip()</span><br><span class="line">                sc.write(wb);</span><br><span class="line">                <span class="comment">// 关闭 Socket</span></span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UncheckedIOException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ssc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过压测，可以发现协程方式相比与线程方式，会大大减少线程数。</p>
<h2 id="Worker-Thread-模式：如何避免重复创建线程？"><a href="#Worker-Thread-模式：如何避免重复创建线程？" class="headerlink" title="Worker Thread 模式：如何避免重复创建线程？"></a>Worker Thread 模式：如何避免重复创建线程？</h2><h3 id="Worker-Thread-模式及其实现"><a href="#Worker-Thread-模式及其实现" class="headerlink" title="Worker Thread 模式及其实现"></a>Worker Thread 模式及其实现</h3><p>Worker Thread 模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010734563.png"></p>
<p>这个模式，在 Java 中的方案就是线程池。</p>
<p>下面的示例代码是用线程池实现的 echo 服务端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span></span><br><span class="line">    ServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">//处理请求</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收请求</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">        <span class="comment">// 将请求处理任务提交给线程池</span></span><br><span class="line">        es.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">rb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                sc.read(rb);</span><br><span class="line">                <span class="comment">//模拟处理请求</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">// 写 Socket</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">wb</span> <span class="operator">=</span> (ByteBuffer) rb.flip();</span><br><span class="line">                sc.write(wb);</span><br><span class="line">                <span class="comment">// 关闭 Socket</span></span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UncheckedIOException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ssc.close();</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正确地创建线程池"><a href="#正确地创建线程池" class="headerlink" title="正确地创建线程池"></a>正确地创建线程池</h3><p>Java 的线程池既能够避免无限制地<strong>创建线程</strong>导致 OOM，也能避免无限制地<strong>接收任务</strong>导致 OOM。只不过后者经常容易被我们忽略，例如在上面的实现中，就被我们忽略了。所以强烈建议你<strong>用创建有界的队列来接收任务</strong>。</p>
<p>当请求量大于有界队列的容量时，就需要合理地拒绝请求。如何合理地拒绝呢？这需要你结合具体的业务场景来制定，即便线程池默认的拒绝策略能够满足你的需求，也同样建议你<strong>在创建线程池时，清晰地指明拒绝策略</strong>。</p>
<p>同时，为了便于调试和诊断问题，我也强烈建议你<strong>在实际工作中给线程赋予一个业务相关的名字</strong>。</p>
<p>综合以上，创建线程池的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">50</span>, <span class="number">500</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="comment">//注意要创建有界队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>),</span><br><span class="line">    <span class="comment">//建议根据业务需求实现 ThreadFactory</span></span><br><span class="line">    r -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;echo-&quot;</span> + r.hashCode());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//建议根据业务需求实现 RejectedExecutionHandler</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="避免线程死锁"><a href="#避免线程死锁" class="headerlink" title="避免线程死锁"></a>避免线程死锁</h3><p>使用线程池过程中，还要注意一种<strong>线程死锁</strong>的场景。如果提交到相同线程池的任务不是相互独立的，而是有依赖关系的，那么就有可能导致线程死锁。具体现象是<strong>应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切都正常，但是实际上已经不能正常工作了</strong>。</p>
<p>这个出问题的应用，相关的逻辑精简之后，如下图所示，该应用将一个大型的计算任务分成两个阶段，第一个阶段的任务会等待第二阶段的子任务完成。在这个应用里，每一个阶段都使用了线程池，而且两个阶段使用的还是同一个线程池。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010741505.png"></p>
<p>我们可以用下面的示例代码来模拟该应用，如果你执行下面的这段代码，会发现它永远执行不到最后一行。执行过程中没有任何异常，但是应用已经停止响应了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L1、L2 阶段共用的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//L1 阶段的闭锁</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;L1&quot;</span>);</span><br><span class="line">    <span class="comment">//执行 L1 阶段任务</span></span><br><span class="line">    es.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//L2 阶段的闭锁</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//执行 L2 阶段子任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            es.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;L2&quot;</span>);</span><br><span class="line">                l2.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待 L2 阶段任务执行完</span></span><br><span class="line">        l2.await();</span><br><span class="line">        l1.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等着 L1 阶段任务执行完</span></span><br><span class="line">l1.await();</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面示例代码停止响应后的线程栈，你会发现线程池中的两个线程全部都阻塞在 <code>l2.await();</code> 这行代码上了，也就是说，线程池里所有的线程都在等待 L2 阶段的任务执行完，那 L2 阶段的子任务什么时候能够执行完呢？永远都没那一天了，为什么呢？因为线程池里的线程都阻塞了，没有空闲的线程执行 L2 阶段的任务了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010743782.png"></p>
<p>原因找到了，那如何解决就简单了，最简单粗暴的办法就是将线程池的最大线程数调大，如果能够确定任务的数量不是非常多的话，这个办法也是可行的，否则这个办法就行不通了。其实<strong>这种问题通用的解决方案是为不同的任务创建不同的线程池</strong>。对于上面的这个应用，L1 阶段的任务和 L2 阶段的任务如果各自都有自己的线程池，就不会出现这种问题了。</p>
<p>最后再次强调一下：<strong>提交到相同线程池中的任务一定是相互独立的，否则就一定要慎重</strong>。</p>
<h2 id="两阶段终止模式：如何优雅地终止线程？"><a href="#两阶段终止模式：如何优雅地终止线程？" class="headerlink" title="两阶段终止模式：如何优雅地终止线程？"></a>两阶段终止模式：如何优雅地终止线程？</h2><h3 id="如何理解两阶段终止模式"><a href="#如何理解两阶段终止模式" class="headerlink" title="如何理解两阶段终止模式"></a>如何理解两阶段终止模式</h3><p><strong>两阶段终止模式</strong>，顾名思义，就是将终止过程分成两个阶段：第一个阶段主要是线程 T1 向线程 T2 <strong>发送终止指令</strong>，而第二阶段则是线程 T2 <strong>响应终止指令</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010920384.png"></p>
<p>终止指令，其实包括两方面内容：<strong>interrupt() 方法</strong>和<strong>线程终止的标志位</strong>。</p>
<h3 id="用两阶段终止模式终止监控操作"><a href="#用两阶段终止模式终止监控操作" class="headerlink" title="用两阶段终止模式终止监控操作"></a>用两阶段终止模式终止监控操作</h3><p>实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，详细过程如下图所示。出于对性能的考虑（有些监控项对系统性能影响很大，所以不能一直持续监控），动态采集功能一般都会有终止操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010923997.png"></p>
<p>下面的示例代码是<strong>监控代理</strong>简化之后的实现，start() 方法会启动一个新的线程 rptThread 来执行监控数据采集和回传的功能，stop() 方法需要优雅地终止线程 rptThread，那 stop() 相关功能该如何实现呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//采集线程</span></span><br><span class="line">  Thread rptThread;</span><br><span class="line">  <span class="comment">//启动采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">    rptThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//省略采集、回传实现</span></span><br><span class="line">        report();</span><br><span class="line">        <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">      started = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    rptThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//终止采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//如何实现？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照两阶段终止模式，我们首先需要做的就是将线程 rptThread 状态转换到 RUNNABLE，做法很简单，只需要在调用 <code>rptThread.interrupt()</code> 就可以了。线程 rptThread 的状态转换到 RUNNABLE 之后，如何优雅地终止呢？下面的示例代码中，我们选择的标志位是线程的中断状态：<code>Thread.currentThread().isInterrupted()</code> ，需要注意的是，我们在捕获 Thread.sleep() 的中断异常之后，通过 <code>Thread.currentThread().interrupt()</code> 重新设置了线程的中断状态，因为 JVM 的异常处理会清除线程的中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//采集线程</span></span><br><span class="line">  Thread rptThread;</span><br><span class="line">  <span class="comment">//启动采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">    rptThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">        <span class="comment">//省略采集、回传实现</span></span><br><span class="line">        report();</span><br><span class="line">        <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">      started = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    rptThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//终止采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">    rptThread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码的确能够解决当前的问题，但是建议你在实际工作中谨慎使用。原因在于我们很可能在线程的 run() 方法中调用第三方类库提供的方法，而我们没有办法保证第三方类库正确处理了线程的中断异常，例如第三方类库在捕获到 Thread.sleep() 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以强烈建议你<strong>设置自己的线程终止标志位</strong>，例如在下面的代码中，使用 isTerminated 作为线程终止标志位，此时无论是否正确处理了线程的中断异常，都不会影响线程优雅地终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line">  <span class="comment">//线程终止标志位</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">terminated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//采集线程</span></span><br><span class="line">  Thread rptThread;</span><br><span class="line">  <span class="comment">//启动采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">    terminated = <span class="literal">false</span>;</span><br><span class="line">    rptThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span> (!terminated)&#123;</span><br><span class="line">        <span class="comment">//省略采集、回传实现</span></span><br><span class="line">        report();</span><br><span class="line">        <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">      started = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    rptThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//终止采集功能</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    terminated = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//中断线程 rptThread</span></span><br><span class="line">    rptThread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何优雅地终止线程池"><a href="#如何优雅地终止线程池" class="headerlink" title="如何优雅地终止线程池"></a>如何优雅地终止线程池</h3><p>Java 领域用的最多的还是线程池，而不是手动地创建线程。那我们该如何优雅地终止线程池呢？</p>
<p>线程池提供了两个方法：**shutdown() <strong>和</strong> shutdownNow()**。这两个方法有什么区别呢？要了解它们的区别，就先需要了解线程池的实现原理。</p>
<p>我们曾经讲过，Java 线程池是生产者-消费者模式的一种实现，提交给线程池的任务，首先是进入一个阻塞队列中，之后线程池中的线程从阻塞队列中取出任务执行。</p>
<p>shutdown() 方法是一种很保守的关闭线程池的方法。线程池执行 shutdown() 后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池。</p>
<p>而 shutdownNow() 方法，相对就激进一些了，线程池执行 shutdownNow() 后，会拒绝接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行的机会，不过这些被剥夺执行机会的任务会作为 shutdownNow() 方法的返回值返回。因为 shutdownNow() 方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地结束，就需要正确地处理线程中断。</p>
<p>如果提交到线程池的任务不允许取消，那就不能使用 shutdownNow() 方法终止线程池。不过，如果提交到线程池的任务允许后续以补偿的方式重新执行，也是可以使用 shutdownNow() 方法终止线程池的。<a href="time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F2758xqdzr6uuw">《极客时间教程 - Java 并发编程实战》</a> 这本书第 7 章《取消与关闭》的“shutdownNow 的局限性”一节中，提到一种将已提交但尚未开始执行的任务以及已经取消的正在执行的任务保存起来，以便后续重新执行的方案。</p>
<p>其实分析完 shutdown() 和 shutdownNow() 方法你会发现，它们实质上使用的也是两阶段终止模式，只是终止指令的范围不同而已，前者只影响阻塞队列接收任务，后者范围扩大到线程池中所有的任务。</p>
<h2 id="生产者-消费者模式：用流水线思想提高效率"><a href="#生产者-消费者模式：用流水线思想提高效率" class="headerlink" title="生产者-消费者模式：用流水线思想提高效率"></a>生产者-消费者模式：用流水线思想提高效率</h2><h3 id="生产者-消费者模式的优点"><a href="#生产者-消费者模式的优点" class="headerlink" title="生产者-消费者模式的优点"></a>生产者-消费者模式的优点</h3><p>生产者-消费者模式的核心是一个<strong>任务队列</strong>，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010930317.png"></p>
<p>生产者和消费者没有任何依赖关系，它们彼此之间的通信只能通过任务队列，所以<strong>生产者-消费者模式是一个不错的解耦方案</strong>。</p>
<p>生产者-消费者模式<strong>支持异步，并且能够平衡生产者和消费者的速度差异</strong>。</p>
<h3 id="支持批量执行以提升性能"><a href="#支持批量执行以提升性能" class="headerlink" title="支持批量执行以提升性能"></a>支持批量执行以提升性能</h3><p>监控系统动态采集的案例，其实最终回传的监控数据还是要存入数据库的（如下图）。但被监控系统往往有很多，如果每一条回传数据都直接 INSERT 到数据库，那么这个方案就是上面提到的第一种方案：每个线程 INSERT 一条数据。很显然，更好的方案是批量执行 SQL，那如何实现呢？这就要用到生产者-消费者模式了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010933833.png"></p>
<p>利用生产者-消费者模式实现批量执行 SQL 非常简单：将原来直接 INSERT 数据到数据库的线程作为生产者线程，生产者线程只需将数据添加到任务队列，然后消费者线程负责将任务从任务队列中批量取出并批量执行。</p>
<p>在下面的示例代码中，我们创建了 5 个消费者线程负责批量执行 SQL，这 5 个消费者线程以 <code>while(true)&#123;&#125;</code> 循环方式批量地获取任务并批量地执行。需要注意的是，从任务队列中获取批量任务的方法 pollTasks() 中，首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的方式获取任务；之所以首先采用阻塞方式，是因为如果任务队列中没有任务，这样的方式能够避免无谓的循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line">BlockingQueue&lt;Task&gt; bq=<span class="keyword">new</span></span><br><span class="line">  <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//启动 5 个消费者线程</span></span><br><span class="line"><span class="comment">//执行批量任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">  ExecutorService es=executors</span><br><span class="line">    .newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    es.execute(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">//获取批量任务</span></span><br><span class="line">          List&lt;Task&gt; ts=pollTasks();</span><br><span class="line">          <span class="comment">//执行批量任务</span></span><br><span class="line">          execTasks(ts);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从任务队列中获取批量任务</span></span><br><span class="line">List&lt;Task&gt; <span class="title function_">pollTasks</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">  List&lt;Task&gt; ts=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//阻塞式获取一条任务</span></span><br><span class="line">  <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> bq.take();</span><br><span class="line">  <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">    ts.add(t);</span><br><span class="line">    <span class="comment">//非阻塞式获取一条任务</span></span><br><span class="line">    t = bq.poll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量执行任务</span></span><br><span class="line">execTasks(List&lt;Task&gt; ts) &#123;</span><br><span class="line">  <span class="comment">//省略具体代码无数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持分阶段提交以提升性能"><a href="#支持分阶段提交以提升性能" class="headerlink" title="支持分阶段提交以提升性能"></a>支持分阶段提交以提升性能</h3><p>利用生产者-消费者模式还可以轻松地支持一种分阶段提交的应用场景。我们知道写文件如果同步刷盘性能会很慢，所以对于不是很重要的数据，我们往往采用异步刷盘的方式。</p>
<p>这个日志组件的异步刷盘操作本质上其实就是一种<strong>分阶段提交</strong>。下面我们具体看看用生产者-消费者模式如何实现。在下面的示例代码中，可以通过调用 <code>info()</code>和<code>error()</code> 方法写入日志，这两个方法都是创建了一个日志任务 LogMsg，并添加到阻塞队列中，调用 <code>info()</code>和<code>error()</code> 方法的线程是生产者；而真正将日志写入文件的是消费者线程，在 Logger 这个类中，我们只创建了 1 个消费者线程，在这个消费者线程中，会根据刷盘规则执行刷盘操作，逻辑很简单，这里就不赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;LogMsg&gt; bq = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//flush 批量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="comment">//只需要一个线程写日志</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动写日志线程</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> File.createTempFile(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;.log&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">        <span class="built_in">this</span>.es.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//未刷盘日志数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">preFT</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">LogMsg</span> <span class="variable">log</span> <span class="operator">=</span> bq.poll(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    <span class="comment">//写日志</span></span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="literal">null</span>) &#123;</span><br><span class="line">                        writer.write(log.toString());</span><br><span class="line">                        ++curIdx;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果不存在未刷盘数据，则无需刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (curIdx &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//根据规则刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="literal">null</span> &amp;&amp; log.level == LEVEL.ERROR</span><br><span class="line">                        || curIdx == batchSize</span><br><span class="line">                        || System.currentTimeMillis() - preFT &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">                        writer.flush();</span><br><span class="line">                        curIdx = <span class="number">0</span>;</span><br><span class="line">                        preFT = System.currentTimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写 INFO 级别日志</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        bq.put(<span class="keyword">new</span> <span class="title class_">LogMsg</span>(</span><br><span class="line">            LEVEL.INFO, msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写 ERROR 级别日志</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        bq.put(<span class="keyword">new</span> <span class="title class_">LogMsg</span>(</span><br><span class="line">            LEVEL.ERROR, msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LEVEL</span> &#123;</span><br><span class="line">    INFO,</span><br><span class="line">    ERROR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogMsg</span> &#123;</span><br><span class="line">    LEVEL level;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略构造函数实现</span></span><br><span class="line">    LogMsg(LEVEL lvl, String msg) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略 toString() 实现</span></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计模式模块热点问题答疑"><a href="#设计模式模块热点问题答疑" class="headerlink" title="设计模式模块热点问题答疑"></a>设计模式模块热点问题答疑</h2><p>略</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6ef9bcbd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6ef9bcbd/" class="post-title-link" itemprop="url">《极客时间教程 - Java 并发编程实战》笔记四</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-30 08:02:52" itemprop="dateCreated datePublished" datetime="2024-08-30T08:02:52+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Java-并发编程实战》笔记四"><a href="#《极客时间教程-Java-并发编程实战》笔记四" class="headerlink" title="《极客时间教程 - Java 并发编程实战》笔记四"></a>《极客时间教程 - Java 并发编程实战》笔记四</h1><h2 id="案例分析（一）：高性能限流器-Guava-RateLimiter"><a href="#案例分析（一）：高性能限流器-Guava-RateLimiter" class="headerlink" title="案例分析（一）：高性能限流器 Guava RateLimiter"></a>案例分析（一）：高性能限流器 Guava RateLimiter</h2><p>Guava 是 Google 开源的 Java 类库，提供了一个工具类 RateLimiter。</p>
<p>【示例】使用 RateLimiter 限流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流器流速：2 个请求/秒</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//执行任务的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//记录上一次执行时间</span></span><br><span class="line">prev = System.nanoTime();</span><br><span class="line"><span class="comment">//测试执行 20 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//限流器限流</span></span><br><span class="line">    limiter.acquire();</span><br><span class="line">    <span class="comment">//提交任务异步执行</span></span><br><span class="line">    es.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//打印时间间隔：毫秒</span></span><br><span class="line">        System.out.println((cur - prev) / <span class="number">1000_000</span>);</span><br><span class="line">        prev = cur;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 500</span></span><br><span class="line"><span class="comment">// 499</span></span><br><span class="line"><span class="comment">// 500</span></span><br><span class="line"><span class="comment">// 499</span></span><br></pre></td></tr></table></figure>

<h3 id="经典限流算法：令牌桶算法"><a href="#经典限流算法：令牌桶算法" class="headerlink" title="经典限流算法：令牌桶算法"></a>经典限流算法：令牌桶算法</h3><p>Guava 限流算法采用<strong>令牌桶算法</strong>，其<strong>核心是要想通过限流器，必须拿到令牌</strong>。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。令牌桶算法的详细描述如下：</p>
<ol>
<li>令牌以固定的速率添加到令牌桶中，假设限流的速率是 r&#x2F;秒，则令牌每 1&#x2F;r 秒会添加一个；</li>
<li>假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃；</li>
<li>请求能够通过限流器的前提是令牌桶中有令牌。</li>
</ol>
<p>这个算法中，限流的速率 r 还是比较容易理解的，但令牌桶的容量 b 该怎么理解呢？b 其实是 burst 的简写，意义是<strong>限流器允许的最大突发流量</strong>。比如 b&#x3D;10，而且令牌桶中的令牌已满，此时限流器允许 10 个请求同时通过限流器，当然只是突发流量而已，这 10 个请求会带走 10 个令牌，所以后续的流量只能按照速率 r 通过限流器。</p>
<h3 id="Guava-如何实现令牌桶算法"><a href="#Guava-如何实现令牌桶算法" class="headerlink" title="Guava 如何实现令牌桶算法"></a>Guava 如何实现令牌桶算法</h3><p>Guava 实现令牌桶算法，其关键是<strong>记录并动态计算下一令牌发放的时间</strong>。</p>
<p>假设令牌桶的容量为 b&#x3D;1，限流速率 r &#x3D; 1 个请求&#x2F;秒，如下图所示，如果当前令牌桶中没有令牌，下一个令牌的发放时间是在第 3 秒，而在第 2 秒的时候有一个线程 T1 请求令牌，此时该如何处理呢？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010943737.png"></p>
<p>对于这个请求令牌的线程而言，很显然需要等待 1 秒，因为 1 秒以后（第 3 秒）它就能拿到令牌了。此时需要注意的是，下一个令牌发放的时间也要增加 1 秒，为什么呢？因为第 3 秒发放的令牌已经被线程 T1 预占了。处理之后如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010944198.png"></p>
<p>假设 T1 在预占了第 3 秒的令牌之后，马上又有一个线程 T2 请求令牌，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010945560.png"></p>
<p>很显然，由于下一个令牌产生的时间是第 4 秒，所以线程 T2 要等待两秒的时间，才能获取到令牌，同时由于 T2 预占了第 4 秒的令牌，所以下一令牌产生时间还要增加 1 秒，完全处理之后，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010946590.png"></p>
<p>上面线程 T1、T2 都是在<strong>下一令牌产生时间之前</strong>请求令牌，如果线程在<strong>下一令牌产生时间之后</strong>请求令牌会如何呢？假设在线程 T1 请求令牌之后的 5 秒，也就是第 7 秒，线程 T3 请求令牌，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947529.png"></p>
<p>由于在第 5 秒已经产生了一个令牌，所以此时线程 T3 可以直接拿到令牌，而无需等待。在第 7 秒，实际上限流器能够产生 3 个令牌，第 5、6、7 秒各产生一个令牌。由于我们假设令牌桶的容量是 1，所以第 6、7 秒产生的令牌就丢弃了，其实等价地你也可以认为是保留的第 7 秒的令牌，丢弃的第 5、6 秒的令牌，也就是说第 7 秒的令牌被线程 T3 占有了，于是下一令牌的的产生时间应该是第 8 秒，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947885.png"></p>
<p>通过上面简要地分析们<strong>只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能</strong>。我们可以将上面的这个算法代码化，示例代码如下所示，依然假设令牌桶的容量是 1。关键是** reserve() 方法**，这个方法会为请求令牌的线程预分配令牌，同时返回该线程能够获取令牌的时间。其实现逻辑就是上面提到的：如果线程请求令牌的时间在下一令牌产生时间之后，那么该线程立刻就能够获取令牌；反之，如果请求时间在下一令牌产生时间之前，那么该线程是在下一令牌产生的时间获取令牌。由于此时下一令牌已经被该线程预占，所以下一令牌产生的时间需要加上 1 秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一令牌产生时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="comment">//请求时间在下一令牌产生时间之后</span></span><br><span class="line">        <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">            <span class="comment">//将下一令牌产生时间重置为当前时间</span></span><br><span class="line">            next = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> next;</span><br><span class="line">        <span class="comment">//设置下一令牌产生时间</span></span><br><span class="line">        next += interval;</span><br><span class="line">        <span class="comment">//返回线程需要等待的时间</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(at, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请令牌</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//申请令牌时的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//预占令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> reserve(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> max(at - now, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按照条件等待</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果令牌桶的容量大于 1，又该如何处理呢？按照令牌桶算法，令牌要首先从令牌桶中出，所以我们需要按需计算令牌桶中的数量，当有线程请求令牌时，先从令牌桶中出。具体的代码实现如下所示。我们增加了一个** resync() 方法<strong>，在这个方法中，如果线程请求令牌的时间在下一令牌产生时间之后，会重新计算令牌桶中的令牌数，</strong>新产生的令牌的计算公式是：(now-next)&#x2F;interval**，你可对照上面的示意图来理解。reserve() 方法中，则增加了先从令牌桶中出令牌的逻辑，不过需要注意的是，如果令牌是从令牌桶中出的，那么 next 就无需增加一个 interval 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前令牌桶中的令牌数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">storedPermits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//令牌桶的容量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxPermits</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//下一令牌产生时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求时间在下一令牌产生时间之后，则</span></span><br><span class="line">    <span class="comment">// 1. 重新计算令牌桶中的令牌数</span></span><br><span class="line">    <span class="comment">// 2. 将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">            <span class="comment">//新产生的令牌数</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">newPermits</span> <span class="operator">=</span> (now - next) / interval;</span><br><span class="line">            <span class="comment">//新令牌增加到令牌桶</span></span><br><span class="line">            storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">            <span class="comment">//将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">            next = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        resync(now);</span><br><span class="line">        <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> next;</span><br><span class="line">        <span class="comment">//令牌桶中能提供的令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">fb</span> <span class="operator">=</span> min(<span class="number">1</span>, storedPermits);</span><br><span class="line">        <span class="comment">//令牌净需求：首先减掉令牌桶中的令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nr</span> <span class="operator">=</span> <span class="number">1</span> - fb;</span><br><span class="line">        <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">        next = next + nr * interval;</span><br><span class="line">        <span class="comment">//重新计算令牌桶中的令牌</span></span><br><span class="line">        <span class="built_in">this</span>.storedPermits -= fb;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请令牌</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//申请令牌时的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//预占令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> reserve(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> max(at - now, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按照条件等待</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经典的限流算法有两个，一个是<strong>令牌桶算法（Token Bucket）</strong>，另一个是<strong>漏桶算法（Leaky Bucket）</strong>。令牌桶算法是定时向令牌桶发送令牌，请求能够从令牌桶中拿到令牌，然后才能通过限流器；而漏桶算法里，请求就像水一样注入漏桶，漏桶会按照一定的速率自动将水漏掉，只有漏桶里还能注入水的时候，请求才能通过限流器。令牌桶算法和漏桶算法很像一个硬币的正反面，所以你可以参考令牌桶算法的实现来实现漏桶算法。</p>
<h2 id="案例分析（二）：高性能网络应用框架-Netty"><a href="#案例分析（二）：高性能网络应用框架-Netty" class="headerlink" title="案例分析（二）：高性能网络应用框架 Netty"></a>案例分析（二）：高性能网络应用框架 Netty</h2><h3 id="网络编程性能的瓶颈"><a href="#网络编程性能的瓶颈" class="headerlink" title="网络编程性能的瓶颈"></a>网络编程性能的瓶颈</h3><p>BIO 模型里，所有 read() 操作和 write() 操作都会阻塞当前线程的，如果客户端已经和服务端建立了一个连接，而迟迟不发送数据，那么服务端的 read() 操作会一直阻塞，所以<strong>使用 BIO 模型，一般都会为每个 socket 分配一个独立的线程</strong>，这样就不会因为线程阻塞在一个 socket 上而影响对其他 socket 的读写。BIO 的线程模型如下图所示，每一个 socket 都对应一个独立的线程；为了避免频繁创建、消耗线程，可以采用线程池，但是 socket 和线程之间的对应关系并不会变化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010957084.png"></p>
<p>BIO 这种线程模型适用于 socket 连接不是很多的场景；但是现在的互联网场景，往往需要服务器能够支撑十万甚至百万连接，而创建十万甚至上百万个线程显然并不现实，所以 BIO 线程模型无法解决百万连接的问题。如果仔细观察，你会发现互联网场景中，虽然连接多，但是每个连接上的请求并不频繁，所以线程大部分时间都在等待 I&#x2F;O 就绪。也就是说线程大部分时间都阻塞在那里，这完全是浪费，如果我们能够解决这个问题，那就不需要这么多线程了。</p>
<p>可以用一个线程来处理多个连接，这样线程的利用率就上来了，同时所需的线程数量也跟着降下来了。这个思路很好，可是使用 BIO 相关的 API 是无法实现的，这是为什么呢？因为 BIO 相关的 socket 读写操作都是阻塞式的，而一旦调用了阻塞式 API，在 I&#x2F;O 就绪前，调用线程会一直阻塞，也就无法处理其他的 socket 连接了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010959294.png"></p>
<h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><p>下面是 Reactor 模式的类结构图，其中 Handle 指的是 I&#x2F;O 句柄，在 Java 网络编程里，它本质上就是一个网络连接。Event Handler 很容易理解，就是一个事件处理器，其中 handle_event() 方法处理 I&#x2F;O 事件，也就是每个 Event Handler 处理一个 I&#x2F;O Handle；get_handle() 方法可以返回这个 I&#x2F;O 的 Handle。Synchronous Event Demultiplexer 可以理解为操作系统提供的 I&#x2F;O 多路复用 API，例如 POSIX 标准里的 select() 以及 Linux 里面的 epoll()。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011000910.png"></p>
<p>Reactor 模式的核心自然是 <strong>Reactor 这个类</strong>，其中 register_handler() 和 remove_handler() 这两个方法可以注册和删除一个事件处理器；<strong>handle_events() 方式是核心</strong>，也是 Reactor 模式的发动机，这个方法的核心逻辑如下：首先通过同步事件多路选择器提供的 select() 方法监听网络事件，当有网络事件就绪后，就遍历事件处理器来处理该网络事件。由于网络事件是源源不断的，所以在主程序中启动 Reactor 模式，需要以 <code>while(true)&#123;&#125;</code> 的方式调用 handle_events() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Reactor::handle_events()&#123;</span><br><span class="line">  <span class="comment">//通过同步事件多路选择器提供的</span></span><br><span class="line">  <span class="comment">//select() 方法监听网络事件</span></span><br><span class="line">  select(handlers);</span><br><span class="line">  <span class="comment">//处理网络事件</span></span><br><span class="line">  <span class="keyword">for</span>(h in handlers)&#123;</span><br><span class="line">    h.handle_event();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在主程序中启动事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  handle_events();</span><br></pre></td></tr></table></figure>

<h3 id="Netty-中的线程模型"><a href="#Netty-中的线程模型" class="headerlink" title="Netty 中的线程模型"></a>Netty 中的线程模型</h3><p><strong>Netty 中最核心的概念是事件循环（EventLoop）</strong>，其实也就是 Reactor 模式中的 Reactor，<strong>负责监听网络事件并调用事件处理器进行处理</strong>。在 4.x 版本的 Netty 中，网络连接和 EventLoop 是稳定的多对 1 关系，而 EventLoop 和 Java 线程是 1 对 1 关系，这里的稳定指的是关系一旦确定就不再发生变化。也就是说一个网络连接只会对应唯一的一个 EventLoop，而一个 EventLoop 也只会对应到一个 Java 线程，所以<strong>一个网络连接只会对应到一个 Java 线程</strong>。</p>
<p>一个网络连接对应到一个 Java 线程上，最大的好处就是对于一个网络连接的事件处理是单线程的，这样就<strong>避免了各种并发问题</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011004870.png"></p>
<p>Netty 中还有一个核心概念是** EventLoopGroup**，顾名思义，一个 EventLoopGroup 由一组 EventLoop 组成。实际使用中，一般都会创建两个 EventLoopGroup，一个称为 bossGroup，一个称为 workerGroup。</p>
<p>这个和 socket 处理网络请求的机制有关，socket 处理 TCP 网络连接请求，是在一个独立的 socket 中，每当有一个 TCP 连接成功建立，都会创建一个新的 socket，之后对 TCP 连接的读写都是由新创建处理的 socket 完成的。也就是说<strong>处理 TCP 连接请求和读写请求是通过两个不同的 socket 完成的</strong>。</p>
<p><strong>在 Netty 中，bossGroup 就用来处理连接请求的，而 workerGroup 是用来处理读写请求的</strong>。bossGroup 处理完连接请求后，会将这个连接提交给 workerGroup 来处理， workerGroup 里面有多个 EventLoop，那新的连接会交给哪个 EventLoop 来处理呢？这就需要一个负载均衡算法，Netty 中目前使用的是<strong>轮询算法</strong>。</p>
<h3 id="用-Netty-实现-Echo-程序服务端"><a href="#用-Netty-实现-Echo-程序服务端" class="headerlink" title="用 Netty 实现 Echo 程序服务端"></a>用 Netty 实现 Echo 程序服务端</h3><p>第一个，如果 NettybossGroup 只监听一个端口，那 bossGroup 只需要 1 个 EventLoop 就可以了，多了纯属浪费。</p>
<p>第二个，默认情况下，Netty 会创建“2*CPU 核数”个 EventLoop，由于网络连接与 EventLoop 有稳定的关系，所以事件处理器在处理网络事件的时候是不能有阻塞操作的，否则很容易导致请求大面积超时。如果实在无法避免使用阻塞操作，那可以通过线程池来异步处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件处理器</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line"><span class="comment">//boss 线程组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//worker 线程组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel.class)</span><br><span class="line">     .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">             ch.pipeline().addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    <span class="comment">//bind 服务端端口</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(<span class="number">9090</span>).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//终止工作线程组</span></span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">    <span class="comment">//终止 boss 线程组</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//socket 连接处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理读事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理读完成事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Netty 是一个款优秀的网络编程框架，性能非常好，为了实现高性能的目标，Netty 做了很多优化，例如优化了 ByteBuffer、支持零拷贝等等，和并发编程相关的就是它的线程模型了。Netty 的线程模型设计得很精巧，每个网络连接都关联到了一个线程上，这样做的好处是：对于一个网络连接，读写操作都是单线程执行的，从而避免了并发程序的各种问题。</p>
<h2 id="案例分析（三）：高性能队列-Disruptor"><a href="#案例分析（三）：高性能队列-Disruptor" class="headerlink" title="案例分析（三）：高性能队列 Disruptor"></a>案例分析（三）：高性能队列 Disruptor</h2><p><strong>Disruptor 是一款高性能的有界内存队列</strong>，目前应用非常广泛，Log4j2、Spring Messaging、HBase、Storm 都用到了 Disruptor，那 Disruptor 的性能为什么这么高呢？Disruptor 项目团队曾经写过一篇论文，详细解释了其原因，可以总结为如下：</p>
<ol>
<li>内存分配更加合理，使用 RingBuffer 数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率；对象循环利用，避免频繁 GC。</li>
<li>能够避免伪共享，提升缓存利用率。</li>
<li>采用无锁算法，避免频繁加锁、解锁的性能消耗。</li>
<li>支持批量消费，消费者可以无锁方式消费多个消息。</li>
</ol>
<p>Disruptor 的使用比 Java SDK 提供 BlockingQueue 要复杂一些，但是总体思路还是一致的，其大致情况如下：</p>
<ul>
<li><p>在 Disruptor 中，生产者生产的对象（也就是消费者消费的对象）称为 Event，使用 Disruptor 必须自定义 Event，例如示例代码的自定义 Event 是 LongEvent；</p>
</li>
<li><p>构建 Disruptor 对象除了要指定队列大小外，还需要传入一个 EventFactory，示例代码中传入的是<code>LongEvent::new</code>；</p>
</li>
<li><p>消费 Disruptor 中的 Event 需要通过 handleEventsWith() 方法注册一个事件处理器，发布 Event 则需要通过 publishEvent() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 Event</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LongEvent</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定 RingBuffer 大小，</span></span><br><span class="line"><span class="comment">// 必须是 2 的 N 次方</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(</span><br><span class="line">    LongEvent::<span class="keyword">new</span>,</span><br><span class="line">    bufferSize,</span><br><span class="line">    DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件处理器</span></span><br><span class="line">disruptor.handleEventsWith(</span><br><span class="line">  (event, sequence, endOfBatch) -&gt;</span><br><span class="line">    System.out.println(<span class="string">&quot;E: &quot;</span>+event));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Disruptor</span></span><br><span class="line">disruptor.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 RingBuffer</span></span><br><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer</span><br><span class="line">  = disruptor.getRingBuffer();</span><br><span class="line"><span class="comment">// 生产 Event</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++)&#123;</span><br><span class="line">  bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">  <span class="comment">// 生产者生产消息</span></span><br><span class="line">  ringBuffer.publishEvent(</span><br><span class="line">    (event, sequence, buffer) -&gt;</span><br><span class="line">      event.set(buffer.getLong(<span class="number">0</span>)), bb);</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RingBuffer-如何提升性能"><a href="#RingBuffer-如何提升性能" class="headerlink" title="RingBuffer 如何提升性能"></a>RingBuffer 如何提升性能</h3><p>Java SDK 中 ArrayBlockingQueue 使用<strong>数组</strong>作为底层的数据存储，而 Disruptor 是使用** RingBuffer **作为数据存储。RingBuffer 本质上也是数组。</p>
<p>生产者线程向 ArrayBlockingQueue 增加一个元素，每次增加元素 E 之前，都需要创建一个对象 E，如下图所示，ArrayBlockingQueue 内部有 6 个元素，这 6 个元素都是由生产者线程创建的，由于创建这些元素的时间基本上是离散的，所以这些元素的内存地址大概率也不是连续的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020709300.png"></p>
<p>Disruptor 内部的 RingBuffer 也是用数组实现的，但是这个数组中的所有元素在初始化时是一次性全部创建的，所以这些元素的内存地址大概率是连续的，相关的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;bufferSize; i++)&#123;</span><br><span class="line">  <span class="comment">//entries[] 就是 RingBuffer 内部的数组</span></span><br><span class="line">  <span class="comment">//eventFactory 就是前面示例代码中传入的 LongEvent::new</span></span><br><span class="line">  entries[BUFFER_PAD + i]</span><br><span class="line">    = eventFactory.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中所有元素内存地址连续能提升性能。因为消费者线程在消费的时候，是遵循空间局部性原理的，消费完第 1 个元素，很快就会消费第 2 个元素；当消费第 1 个元素 E1 的时候，CPU 会把内存中 E1 后面的数据也加载进 Cache，如果 E1 和 E2 在内存中的地址是连续的，那么 E2 也就会被加载进 Cache 中，然后当消费第 2 个元素的时候，由于 E2 已经在 Cache 中了，所以就不需要从内存中加载了，这样就能大大提升性能。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020712580.png"></p>
<p>除此之外，在 Disruptor 中，生产者线程通过 publishEvent() 发布 Event 的时候，并不是创建一个新的 Event，而是通过 event.set() 方法修改 Event， 也就是说 RingBuffer 创建的 Event 是可以循环利用的，这样还能避免频繁创建、删除 Event 导致的频繁 GC 问题。</p>
<h3 id="如何避免“伪共享”"><a href="#如何避免“伪共享”" class="headerlink" title="如何避免“伪共享”"></a>如何避免“伪共享”</h3><p><strong>伪共享指的是由于共享缓存行导致缓存无效的场景</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020714249.png"></p>
<p>避免伪共享的方法是：</p>
<p><strong>每个变量独占一个缓存行、不共享缓存行</strong>就可以了，具体技术是<strong>缓存行填充</strong>。比如想让 takeIndex 独占一个缓存行，可以在 takeIndex 的前后各填充 56 个字节，这样就一定能保证 takeIndex 独占一个缓存行。下面的示例代码出自 Disruptor，Sequence 对象中的 value 属性就能避免伪共享，因为这个属性前后都填充了 56 个字节。Disruptor 中很多对象，例如 RingBuffer、RingBuffer 内部的数组都用到了这种填充技术来避免伪共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前：填充 56 字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LhsPadding</span>&#123;</span><br><span class="line">    <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> <span class="keyword">extends</span> <span class="title class_">LhsPadding</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后：填充 56 字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RhsPadding</span> <span class="keyword">extends</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">    <span class="type">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence</span> <span class="keyword">extends</span> <span class="title class_">RhsPadding</span>&#123;</span><br><span class="line">  <span class="comment">//省略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Disruptor-中的无锁算法"><a href="#Disruptor-中的无锁算法" class="headerlink" title="Disruptor 中的无锁算法"></a>Disruptor 中的无锁算法</h3><p>Disruptor 中最复杂的是入队操作，所以我们重点来看看入队操作是如何实现的。</p>
<p>对于入队操作，最关键的要求是不能覆盖没有消费的元素；对于出队操作，最关键的要求是不能读取没有写入的元素，所以 Disruptor 中也一定会维护类似出队索引和入队索引这样两个关键变量。Disruptor 中的 RingBuffer 维护了入队索引，但是并没有维护出队索引，这是因为在 Disruptor 中多个消费者可以同时消费，每个消费者都会有一个出队索引，所以 RingBuffer 的出队索引是所有消费者里面最小的那一个。</p>
<p>下面是 Disruptor 生产者入队操作的核心代码，看上去很复杂，其实逻辑很简单：如果没有足够的空余位置，就出让 CPU 使用权，然后重新计算；反之则用 CAS 设置入队索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者获取 n 个写入位置</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//cursor 类似于入队索引，指的是上次生产到这里</span></span><br><span class="line">  current = cursor.get();</span><br><span class="line">  <span class="comment">//目标是在生产 n 个</span></span><br><span class="line">  next = current + n;</span><br><span class="line">  <span class="comment">//减掉一个循环</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">wrapPoint</span> <span class="operator">=</span> next - bufferSize;</span><br><span class="line">  <span class="comment">//获取上一次的最小消费位置</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">cachedGatingSequence</span> <span class="operator">=</span> gatingSequenceCache.get();</span><br><span class="line">  <span class="comment">//没有足够的空余位置</span></span><br><span class="line">  <span class="keyword">if</span> (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)&#123;</span><br><span class="line">    <span class="comment">//重新计算所有消费者里面的最小值位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gatingSequence</span> <span class="operator">=</span> Util.getMinimumSequence(</span><br><span class="line">        gatingSequences, current);</span><br><span class="line">    <span class="comment">//仍然没有足够的空余位置，出让 CPU 使用权，重新执行下一循环</span></span><br><span class="line">    <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)&#123;</span><br><span class="line">      LockSupport.parkNanos(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从新设置上一次的最小消费位置</span></span><br><span class="line">    gatingSequenceCache.set(gatingSequence);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))&#123;</span><br><span class="line">    <span class="comment">//获取写入位置成功，跳出循环</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="案例分析（四）：高性能数据库连接池-HiKariCP"><a href="#案例分析（四）：高性能数据库连接池-HiKariCP" class="headerlink" title="案例分析（四）：高性能数据库连接池 HiKariCP"></a>案例分析（四）：高性能数据库连接池 HiKariCP</h2><p>业界知名的数据库连接池有不少，例如 c3p0、DBCP、Tomcat JDBC Connection Pool、Druid 等，不过最近最火的是 HiKariCP。</p>
<p><strong>HiKariCP 号称是业界跑得最快的数据库连接池</strong>，这两年发展得顺风顺水，尤其是 Springboot 2.0 将其作为<strong>默认数据库连接池</strong>。</p>
<h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>数据库连接池和线程池一样，都属于池化资源，作用都是避免重量级资源的频繁创建和销毁，对于数据库连接池来说，也就是避免数据库连接频繁创建和销毁。如下图所示，服务端会在运行期持有一定数量的数据库连接，当需要执行 SQL 时，并不是直接创建一个数据库连接，而是从连接池中获取一个；当 SQL 执行完，也并不是将数据库连接真的关掉，而是将其归还到连接池中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020725868.png"></p>
<p>执行数据库操作基本上是一系列规范化的步骤：</p>
<ol>
<li>通过数据源获取一个数据库连接；</li>
<li>创建 Statement；</li>
<li>执行 SQL；</li>
<li>通过 ResultSet 获取 SQL 执行结果；</li>
<li>释放 ResultSet；</li>
<li>释放 Statement；</li>
<li>释放数据库连接。</li>
</ol>
<p>下面的示例代码，通过 <code>ds.getConnection()</code> 获取一个数据库连接时，其实是向数据库连接池申请一个数据库连接，而不是创建一个新的数据库连接。同样，通过 <code>conn.close()</code> 释放一个数据库连接时，也不是直接将连接关闭，而是将连接归还给数据库连接池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接池配置</span></span><br><span class="line"><span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">config.setMinimumIdle(<span class="number">1</span>);</span><br><span class="line">config.setMaximumPoolSize(<span class="number">2</span>);</span><br><span class="line">config.setConnectionTestQuery(<span class="string">&quot;SELECT 1&quot;</span>);</span><br><span class="line">config.setDataSourceClassName(<span class="string">&quot;org.h2.jdbcx.JdbcDataSource&quot;</span>);</span><br><span class="line">config.addDataSourceProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:h2:mem:test&quot;</span>);</span><br><span class="line"><span class="comment">// 创建数据源</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 获取数据库连接</span></span><br><span class="line">  conn = ds.getConnection();</span><br><span class="line">  <span class="comment">// 创建 Statement</span></span><br><span class="line">  stmt = conn.createStatement();</span><br><span class="line">  <span class="comment">// 执行 SQL</span></span><br><span class="line">  rs = stmt.executeQuery(<span class="string">&quot;select * from abc&quot;</span>);</span><br><span class="line">  <span class="comment">// 获取结果</span></span><br><span class="line">  <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//关闭 ResultSet</span></span><br><span class="line">  close(rs);</span><br><span class="line">  <span class="comment">//关闭 Statement</span></span><br><span class="line">  close(stmt);</span><br><span class="line">  <span class="comment">//关闭 Connection</span></span><br><span class="line">  close(conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">(AutoCloseable rs)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">HiKariCP 官方网站</a> 解释了其性能之所以如此之高的秘密。微观上 HiKariCP 程序编译出的字节码执行效率更高，站在字节码的角度去优化 Java 代码，HiKariCP 的作者对性能的执着可见一斑，不过遗憾的是他并没有详细解释都做了哪些优化。而宏观上主要是和两个数据结构有关，一个是 FastList，另一个是 ConcurrentBag。下面我们来看看它们是如何提升 HiKariCP 的性能的。</p>
<h3 id="FastList-解决了哪些性能问题"><a href="#FastList-解决了哪些性能问题" class="headerlink" title="FastList 解决了哪些性能问题"></a>FastList 解决了哪些性能问题</h3><p>按照规范步骤，执行完数据库操作之后，需要依次关闭 ResultSet、Statement、Connection，但是总有粗心的同学只是关闭了 Connection，而忘了关闭 ResultSet 和 Statement。为了解决这种问题，最好的办法是当关闭 Connection 时，能够自动关闭 Statement。为了达到这个目标，Connection 就需要跟踪创建的 Statement，最简单的办法就是将创建的 Statement 保存在数组 ArrayList 里，这样当关闭 Connection 的时候，就可以依次将数组中的所有 Statement 关闭。</p>
<p>HiKariCP 觉得用 ArrayList 还是太慢，当通过 <code>conn.createStatement()</code> 创建一个 Statement 时，需要调用 ArrayList 的 add() 方法加入到 ArrayList 中，这个是没有问题的；但是当通过 <code>stmt.close()</code> 关闭 Statement 的时候，需要调用 ArrayList 的 remove() 方法来将其从 ArrayList 中删除，这里是有优化余地的。</p>
<p>假设一个 Connection 依次创建 6 个 Statement，分别是 S1、S2、S3、S4、S5、S6，按照正常的编码习惯，关闭 Statement 的顺序一般是逆序的，关闭的顺序是：S6、S5、S4、S3、S2、S1，而 ArrayList 的 remove(Object o) 方法是顺序遍历查找，逆序删除而顺序查找，这样的查找效率就太慢了。如何优化呢？很简单，优化成逆序查找就可以了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020729492.png"></p>
<p>HiKariCP 中的 FastList 相对于 ArrayList 的一个优化点就是将 <code>remove(Object element)</code> 方法的<strong>查找顺序变成了逆序查找</strong>。除此之外，FastList 还有另一个优化点，是 <code>get(int index)</code> 方法没有对 index 参数进行越界检查，HiKariCP 能保证不会越界，所以不用每次都进行越界检查。</p>
<h3 id="ConcurrentBag-解决了哪些性能问题"><a href="#ConcurrentBag-解决了哪些性能问题" class="headerlink" title="ConcurrentBag 解决了哪些性能问题"></a>ConcurrentBag 解决了哪些性能问题</h3><p>如果让我们自己来实现一个数据库连接池，最简单的办法就是用两个阻塞队列来实现，一个用于保存空闲数据库连接的队列 idle，另一个用于保存忙碌数据库连接的队列 busy；获取连接时将空闲的数据库连接从 idle 队列移动到 busy 队列，而关闭连接时将数据库连接从 busy 移动到 idle。这种方案将并发问题委托给了阻塞队列，实现简单，但是性能并不是很理想。因为 Java SDK 中的阻塞队列是用锁实现的，而高并发场景下锁的争用对性能影响很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忙碌队列</span></span><br><span class="line">BlockingQueue&lt;Connection&gt; busy;</span><br><span class="line"><span class="comment">//空闲队列</span></span><br><span class="line">BlockingQueue&lt;Connection&gt; idle;</span><br></pre></td></tr></table></figure>

<p>HiKariCP 并没有使用 Java SDK 中的阻塞队列，而是自己实现了一个叫做 ConcurrentBag 的并发容器。ConcurrentBag 的设计最初源自 C#，它的一个核心设计是使用 ThreadLocal 避免部分并发问题，不过 HiKariCP 中的 ConcurrentBag 并没有完全参考 C#的实现，下面我们来看看它是如何实现的。</p>
<p>ConcurrentBag 中最关键的属性有 4 个，分别是：用于存储所有的数据库连接的共享队列 sharedList、线程本地存储 threadList、等待数据库连接的线程数 waiters 以及分配数据库连接的工具 handoffQueue。其中，handoffQueue 用的是 Java SDK 提供的 SynchronousQueue，SynchronousQueue 主要用于线程之间传递数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存储所有的数据库连接</span></span><br><span class="line">CopyOnWriteArrayList&lt;T&gt; sharedList;</span><br><span class="line"><span class="comment">//线程本地存储中的数据库连接</span></span><br><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList;</span><br><span class="line"><span class="comment">//等待数据库连接的线程数</span></span><br><span class="line">AtomicInteger waiters;</span><br><span class="line"><span class="comment">//分配数据库连接的工具</span></span><br><span class="line">SynchronousQueue&lt;T&gt; handoffQueue;</span><br></pre></td></tr></table></figure>

<p>当线程池创建了一个数据库连接时，通过调用 ConcurrentBag 的 add() 方法加入到 ConcurrentBag 中，下面是 add() 方法的具体实现，逻辑很简单，就是将这个连接加入到共享队列 sharedList 中，如果此时有线程在等待数据库连接，那么就通过 handoffQueue 将这个连接分配给等待的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将空闲连接添加到队列</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span>&#123;</span><br><span class="line">  <span class="comment">//加入共享队列</span></span><br><span class="line">  sharedList.add(bagEntry);</span><br><span class="line">  <span class="comment">//如果有等待连接的线程，</span></span><br><span class="line">  <span class="comment">//则通过 handoffQueue 直接分配给等待的线程</span></span><br><span class="line">  <span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; bagEntry.getState() == STATE_NOT_IN_USE</span><br><span class="line">    &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">      <span class="keyword">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ConcurrentBag 提供的 borrow() 方法，可以获取一个空闲的数据库连接，borrow() 的主要逻辑是：</p>
<ol>
<li>首先查看线程本地存储是否有空闲连接，如果有，则返回一个空闲的连接；</li>
<li>如果线程本地存储中无空闲连接，则从共享队列中获取。</li>
<li>如果共享队列中也没有空闲的连接，则请求线程需要等待。</li>
</ol>
<p>需要注意的是，线程本地存储中的连接是可以被其他线程窃取的，所以需要用 CAS 方法防止重复分配。在共享队列中获取空闲连接，也采用了 CAS 方法防止重复分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">borrow</span><span class="params">(<span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span>&#123;</span><br><span class="line">  <span class="comment">// 先查看线程本地存储是否有空闲连接</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; list = threadList.get();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> list.remove(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">T</span> <span class="variable">bagEntry</span> <span class="operator">=</span> weakThreadLocals</span><br><span class="line">      ? ((WeakReference&lt;T&gt;) entry).get()</span><br><span class="line">      : (T) entry;</span><br><span class="line">    <span class="comment">//线程本地存储中的连接也可以被窃取，</span></span><br><span class="line">    <span class="comment">//所以需要用 CAS 方法防止重复分配</span></span><br><span class="line">    <span class="keyword">if</span> (bagEntry != <span class="literal">null</span></span><br><span class="line">      &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bagEntry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程本地存储中无空闲连接，则从共享队列中获取</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">waiting</span> <span class="operator">=</span> waiters.incrementAndGet();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T bagEntry : sharedList) &#123;</span><br><span class="line">      <span class="comment">//如果共享队列中有空闲连接，则返回</span></span><br><span class="line">      <span class="keyword">if</span> (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bagEntry;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共享队列中没有连接，则需要等待</span></span><br><span class="line">    timeout = timeUnit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> currentTime();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">T</span> <span class="variable">bagEntry</span> <span class="operator">=</span> handoffQueue.poll(timeout, NANOSECONDS);</span><br><span class="line">      <span class="keyword">if</span> (bagEntry == <span class="literal">null</span></span><br><span class="line">        || bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">          <span class="keyword">return</span> bagEntry;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//重新计算等待时间</span></span><br><span class="line">      timeout -= elapsedNanos(start);</span><br><span class="line">    &#125; <span class="keyword">while</span> (timeout &gt; <span class="number">10_000</span>);</span><br><span class="line">    <span class="comment">//超时没有获取到连接，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    waiters.decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放连接需要调用 ConcurrentBag 提供的 requite() 方法，该方法的逻辑很简单，首先将数据库连接状态更改为 STATE_NOT_IN_USE，之后查看是否存在等待线程，如果有，则分配给等待线程；如果没有，则将该数据库连接保存到线程本地存储里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放连接</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">requite</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span>&#123;</span><br><span class="line">  <span class="comment">//更新连接状态</span></span><br><span class="line">  bagEntry.setState(STATE_NOT_IN_USE);</span><br><span class="line">  <span class="comment">//如果有等待的线程，则直接分配给线程，无需进入任何队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; waiters.get() &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bagEntry.getState() != STATE_NOT_IN_USE</span><br><span class="line">      || handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i &amp; <span class="number">0xff</span>) == <span class="number">0xff</span>) &#123;</span><br><span class="line">      parkNanos(MICROSECONDS.toNanos(<span class="number">10</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果没有等待的线程，则进入线程本地存储</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; threadLocalList = threadList.get();</span><br><span class="line">  <span class="keyword">if</span> (threadLocalList.size() &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    threadLocalList.add(weakThreadLocals</span><br><span class="line">      ? <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(bagEntry)</span><br><span class="line">      : bagEntry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor-模型：面向对象原生的并发模型"><a href="#Actor-模型：面向对象原生的并发模型" class="headerlink" title="Actor 模型：面向对象原生的并发模型"></a>Actor 模型：面向对象原生的并发模型</h2><h3 id="Hello-Actor-模型"><a href="#Hello-Actor-模型" class="headerlink" title="Hello Actor 模型"></a>Hello Actor 模型</h3><p>Actor 模型本质上是一种计算模型，基本的计算单元称为 Actor，换言之，<strong>在 Actor 模型中，所有的计算都是在 Actor 中执行的</strong>。在面向对象编程里面，一切都是对象；在 Actor 模型里，一切都是 Actor，并且 Actor 之间是完全隔离的，不会共享任何变量。</p>
<p>并发问题的根源就在于共享变量，而 Actor 模型中 Actor 之间不共享变量，所以很多人就把 Actor 模型定义为一种<strong>并发计算模型</strong>。</p>
<p>Java 语言本身并不支持 Actor 模型，所以如果你想在 Java 语言里使用 Actor 模型，就需要借助第三方类库，目前能完备地支持 Actor 模型而且比较成熟的类库就是** Akka **了。</p>
<p>在下面的示例代码中，我们首先创建了一个 ActorSystem（Actor 不能脱离 ActorSystem 存在）；之后创建了一个 HelloActor，Akka 中创建 Actor 并不是 new 一个对象出来，而是通过调用 system.actorOf() 方法创建的，该方法返回的是 ActorRef，而不是 HelloActor；最后通过调用 ActorRef 的 tell() 方法给 HelloActor 发送了一条消息 “Actor” 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该 Actor 当收到消息 message 后，</span></span><br><span class="line"><span class="comment">//会打印 Hello message</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HelloActor</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//创建 Actor 系统</span></span><br><span class="line">  <span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create(<span class="string">&quot;HelloSystem&quot;</span>);</span><br><span class="line">  <span class="comment">//创建 HelloActor</span></span><br><span class="line">  <span class="type">ActorRef</span> <span class="variable">helloActor</span> <span class="operator">=</span></span><br><span class="line">    system.actorOf(Props.create(HelloActor.class));</span><br><span class="line">  <span class="comment">//发送消息给 HelloActor</span></span><br><span class="line">  helloActor.tell(<span class="string">&quot;Actor&quot;</span>, ActorRef.noSender());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息和对象方法的区别"><a href="#消息和对象方法的区别" class="headerlink" title="消息和对象方法的区别"></a>消息和对象方法的区别</h3><p>Actor 中的消息机制，就可以类比这现实世界里的写信。Actor 内部有一个邮箱（Mailbox），接收到的消息都是先放到邮箱里，如果邮箱里有积压的消息，那么新收到的消息就不会马上得到处理，也正是因为 Actor 使用单线程处理消息，所以不会出现并发问题。你可以把 Actor 内部的工作模式想象成只有一个消费者线程的生产者-消费者模式。</p>
<p>在 Actor 模型里，发送消息仅仅是把消息发出去而已，接收消息的 Actor 在接收到消息后，也不一定会立即处理，也就是说** Actor 中的消息机制完全是异步的<strong>。而</strong>调用对象方法<strong>，实际上是</strong>同步**的，对象方法 return 之前，调用方会一直等待。</p>
<p>除此之外，<strong>调用对象方法</strong>，需要持有对象的引用，<strong>所有的对象必须在同一个进程中</strong>。而在 Actor 中发送消息，类似于现实中的写信，只需要知道对方的地址就可以，<strong>发送消息和接收消息的 Actor 可以不在一个进程中，也可以不在同一台机器上</strong>。因此，Actor 模型不但适用于并发计算，还适用于分布式计算。</p>
<h3 id="Actor-的规范化定义"><a href="#Actor-的规范化定义" class="headerlink" title="Actor 的规范化定义"></a>Actor 的规范化定义</h3><p>Actor 是一种基础的计算单元，具体来讲包括三部分能力，分别是：</p>
<ol>
<li>处理能力，处理接收到的消息。</li>
<li>存储能力，Actor 可以存储自己的内部状态，并且内部状态在不同 Actor 之间是绝对隔离的。</li>
<li>通信能力，Actor 可以和其他 Actor 之间通信。</li>
</ol>
<p>当一个 Actor 接收的一条消息之后，这个 Actor 可以做以下三件事：</p>
<ol>
<li>创建更多的 Actor；</li>
<li>发消息给其他 Actor；</li>
<li>确定如何处理下一条消息。</li>
</ol>
<h3 id="用-Actor-实现累加器"><a href="#用-Actor-实现累加器" class="headerlink" title="用 Actor 实现累加器"></a>用 Actor 实现累加器</h3><p>在下面的示例代码中，CounterActor 内部持有累计值 counter，当 CounterActor 接收到一个数值型的消息 message 时，就将累计值 counter +&#x3D; message；但如果是其他类型的消息，则打印当前累计值 counter。在 main() 方法中，我们启动了 4 个线程来执行累加操作。整个程序没有锁，也没有 CAS，但是程序是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CounterActor</span> <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span>&#123;</span><br><span class="line">    <span class="comment">//如果接收到的消息是数字类型，执行累加操作，</span></span><br><span class="line">    <span class="comment">//否则打印 counter 的值</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">      counter += ((Number) message).intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="comment">//创建 Actor 系统</span></span><br><span class="line">  <span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create(<span class="string">&quot;HelloSystem&quot;</span>);</span><br><span class="line">  <span class="comment">//4 个线程生产消息</span></span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">//创建 CounterActor</span></span><br><span class="line">  <span class="type">ActorRef</span> <span class="variable">counterActor</span> <span class="operator">=</span></span><br><span class="line">    system.actorOf(Props.create(CounterActor.class));</span><br><span class="line">  <span class="comment">//生产 4*100000 个消息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">    es.execute(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100000</span>; j++) &#123;</span><br><span class="line">        counterActor.tell(<span class="number">1</span>, ActorRef.noSender());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭线程池</span></span><br><span class="line">  es.shutdown();</span><br><span class="line">  <span class="comment">//等待 CounterActor 处理完所有消息</span></span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">//打印结果</span></span><br><span class="line">  counterActor.tell(<span class="string">&quot;&quot;</span>, ActorRef.noSender());</span><br><span class="line">  <span class="comment">//关闭 Actor 系统</span></span><br><span class="line">  system.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="软件事务内存：借鉴数据库的并发经验"><a href="#软件事务内存：借鉴数据库的并发经验" class="headerlink" title="软件事务内存：借鉴数据库的并发经验"></a>软件事务内存：借鉴数据库的并发经验</h2><p><strong>软件事务内存（Software Transactional Memory，简称 STM）</strong>。传统的数据库事务，支持 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的 ACID，STM 由于不涉及到持久化，所以只支持 ACI。</p>
<h3 id="用-STM-实现转账"><a href="#用-STM-实现转账" class="headerlink" title="用 STM 实现转账"></a>用 STM 实现转账</h3><p>并发转账可以简单地使用 synchronized 将 transfer() 方法变成同步方法，但并不能解决并发问题，因为还存在死锁问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeAccount</span> &#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> balance;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnsafeAccount</span><span class="params">(<span class="type">long</span> balance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(UnsafeAccount target, <span class="type">long</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该转账操作若使用数据库事务就会非常简单，如下面的示例代码所示。如果所有 SQL 都正常执行，则通过 commit() 方法提交事务；如果 SQL 在执行过程中有异常，则通过 rollback() 方法回滚事务。数据库保证在并发情况下不会有死锁，而且还能保证前面我们说的原子性、一致性、隔离性和持久性，也就是 ACID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//获取数据库连接</span></span><br><span class="line">  conn = DriverManager.getConnection();</span><br><span class="line">  <span class="comment">//设置手动提交事务</span></span><br><span class="line">  conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//执行转账 SQL</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//出现异常回滚事务</span></span><br><span class="line">  conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果用 STM 又该如何实现呢？Java 语言并不支持 STM，不过可以借助第三方的类库来支持，<a target="_blank" rel="noopener" href="https://github.com/pveentjer/Multiverse">Multiverse</a> 就是个不错的选择。下面的示例代码就是借助 Multiverse 实现了线程安全的转账操作，相比较上面线程不安全的 UnsafeAccount，其改动并不大，仅仅是将余额的类型从 long 变成了 TxnLong ，将转账的操作放到了 atomic(()-&gt;{}) 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> TxnLong balance;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> balance)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = StmUtils.newTxnLong(balance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account to, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">//原子化操作</span></span><br><span class="line">    atomic(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance.get() &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance.decrement(amt);</span><br><span class="line">        to.balance.increment(amt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关键的 atomic() 方法就把并发问题解决了，这个方案看上去比传统的方案的确简单了很多，那它是如何实现的呢？数据库事务发展了几十年了，目前被广泛使用的是** MVCC**（全称是 Multi-Version Concurrency Control），也就是多版本并发控制。</p>
<p>MVCC 可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。</p>
<p>为了记录数据是否发生了变化，可以给每条数据增加一个版本号，这样每次成功修改数据都会增加版本号的值。MVCC 的工作原理和乐观锁非常相似。有不少 STM 的实现方案都是基于 MVCC 的，例如知名的 Clojure STM。</p>
<p>下面我们就用最简单的代码基于 MVCC 实现一个简版的 STM，这样你会对 STM 以及 MVCC 的工作原理有更深入的认识。</p>
<h2 id="自己实现-STM"><a href="#自己实现-STM" class="headerlink" title="自己实现 STM"></a>自己实现 STM</h2><p>我们首先要做的，就是让 Java 中的对象有版本号，在下面的示例代码中，VersionedRef 这个类的作用就是将对象 value 包装成带版本号的对象。按照 MVCC 理论，数据的每一次修改都对应着一个唯一的版本号，所以不存在仅仅改变 value 或者 version 的情况，用不变性模式就可以很好地解决这个问题，所以 VersionedRef 这个类被我们设计成了不可变的。</p>
<p>所有对数据的读写操作，一定是在一个事务里面，TxnRef 这个类负责完成事务内的读写操作，读写操作委托给了接口 Txn，Txn 代表的是读写操作所在的当前事务， 内部持有的 curRef 代表的是系统中的最新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带版本号的对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">VersionedRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> T value;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">long</span> version;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VersionedRef</span><span class="params">(T value, <span class="type">long</span> version)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.version = version;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持事务的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxnRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//当前数据，带版本号</span></span><br><span class="line">  <span class="keyword">volatile</span> VersionedRef curRef;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TxnRef</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.curRef = <span class="keyword">new</span> <span class="title class_">VersionedRef</span>(value, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">(Txn txn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> txn.get(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在当前事务中设置数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value, Txn txn)</span> &#123;</span><br><span class="line">    txn.set(<span class="built_in">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STMTxn 是 Txn 最关键的一个实现类，事务内对于数据的读写，都是通过它来完成的。STMTxn 内部有两个 Map：inTxnMap，用于保存当前事务中所有读写的数据的快照；writeMap，用于保存当前事务需要写入的数据。每个事务都有一个唯一的事务 ID txnId，这个 txnId 是全局递增的。</p>
<p>STMTxn 有三个核心方法，分别是读数据的 get() 方法、写数据的 set() 方法和提交事务的 commit() 方法。其中，get() 方法将要读取数据作为快照放入 inTxnMap，同时保证每次读取的数据都是一个版本。set() 方法会将要写入的数据放入 writeMap，但如果写入的数据没被读取过，也会将其放入 inTxnMap。</p>
<p>至于 commit() 方法，我们为了简化实现，使用了互斥锁，所以事务的提交是串行的。commit() 方法的实现很简单，首先检查 inTxnMap 中的数据是否发生过变化，如果没有发生变化，那么就将 writeMap 中的数据写入（这里的写入其实就是 TxnRef 内部持有的 curRef）；如果发生过变化，那么就不能将 writeMap 中的数据写入了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Txn</span> &#123;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span>;</span><br><span class="line">  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STM 事务实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">STMTxn</span> <span class="keyword">implements</span> <span class="title class_">Txn</span> &#123;</span><br><span class="line">  <span class="comment">//事务 ID 生成器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">txnSeq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当前事务所有的相关数据</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;TxnRef, VersionedRef&gt; inTxnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//当前事务所有需要修改的数据</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;TxnRef, Object&gt; writeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//当前事务 ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> txnId;</span><br><span class="line">  <span class="comment">//构造函数，自动生成当前事务 ID</span></span><br><span class="line">  STMTxn() &#123;</span><br><span class="line">    txnId = txnSeq.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span> &#123;</span><br><span class="line">    <span class="comment">//将需要读取的数据，加入 inTxnMap</span></span><br><span class="line">    <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">      inTxnMap.put(ref, ref.curRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) inTxnMap.get(ref).value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在当前事务中修改数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span> &#123;</span><br><span class="line">    <span class="comment">//将需要修改的数据，加入 inTxnMap</span></span><br><span class="line">    <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">      inTxnMap.put(ref, ref.curRef);</span><br><span class="line">    &#125;</span><br><span class="line">    writeMap.put(ref, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (STM.commitLock) &#123;</span><br><span class="line">    <span class="comment">//是否校验通过</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//校验所有读过的数据是否发生过变化</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;TxnRef, VersionedRef&gt; entry : inTxnMap.entrySet())&#123;</span><br><span class="line">      <span class="type">VersionedRef</span> <span class="variable">curRef</span> <span class="operator">=</span> entry.getKey().curRef;</span><br><span class="line">      <span class="type">VersionedRef</span> <span class="variable">readRef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">      <span class="comment">//通过版本号来验证数据是否发生过变化</span></span><br><span class="line">      <span class="keyword">if</span> (curRef.version != readRef.version) &#123;</span><br><span class="line">        isValid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果校验通过，则所有更改生效</span></span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">      writeMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">        k.curRef = <span class="keyword">new</span> <span class="title class_">VersionedRef</span>(v, txnId);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来模拟实现 Multiverse 中的原子化操作 atomic()。atomic() 方法中使用了类似于 CAS 的操作，如果事务提交失败，那么就重新创建一个新的事务，重新执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TxnRunnable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Txn txn)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STM</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">STM</span> &#123;</span><br><span class="line">  <span class="comment">//私有化构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">STM</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//提交数据需要用到的全局锁</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">commitLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">//原子化提交方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomic</span><span class="params">(TxnRunnable action)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">committed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果没有提交成功，则一直重试</span></span><br><span class="line">    <span class="keyword">while</span> (!committed) &#123;</span><br><span class="line">      <span class="comment">//创建新的事务</span></span><br><span class="line">      <span class="type">STMTxn</span> <span class="variable">txn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">STMTxn</span>();</span><br><span class="line">      <span class="comment">//执行业务逻辑</span></span><br><span class="line">      action.run(txn);</span><br><span class="line">      <span class="comment">//提交事务</span></span><br><span class="line">      committed = txn.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>就这样，我们自己实现了 STM，并完成了线程安全的转账操作，使用方法和 Multiverse 差不多，这里就不赘述了，具体代码如下面所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> TxnRef&lt;Integer&gt; balance;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">TxnRef</span>&lt;Integer&gt;(balance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账操作</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    STM.atomic((txn)-&gt;&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> balance.getValue(txn);</span><br><span class="line">      balance.setValue(from-amt, txn);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> target.balance.getValue(txn);</span><br><span class="line">      target.balance.setValue(to+amt, txn);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程：更轻量级的线程"><a href="#协程：更轻量级的线程" class="headerlink" title="协程：更轻量级的线程"></a>协程：更轻量级的线程</h2><p><strong>协程</strong>可以理解<strong>为一种轻量级的线程</strong>。从操作系统的角度来看，线程是在内核态中调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。协程虽然也有自己的栈，但是相比线程栈要小得多，典型的线程栈大小差不多有 1M，而协程栈的大小往往只有几 K 或者几十 K。所以，无论是从时间维度还是空间维度来看，协程都比线程轻量得多。</p>
<p>支持协程的语言还是挺多的，例如 Golang、Python、Lua、Kotlin 等都支持协程。</p>
<h2 id="CSP-模型：Golang-的主力队员"><a href="#CSP-模型：Golang-的主力队员" class="headerlink" title="CSP 模型：Golang 的主力队员"></a>CSP 模型：Golang 的主力队员</h2><p>Golang 是一门号称从语言层面支持并发的编程语言，支持并发是 Golang 一个非常重要的特性。</p>
<p>Golang 支持协程，协程可以类比 Java 中的线程，解决并发问题的难点就在于线程（协程）之间的协作。那 Golang 是如何解决协作问题的呢？</p>
<p>总的来说，Golang 提供了两种不同的方案：一种方案支持协程之间以共享内存的方式通信，Golang 提供了管程和原子类来对协程进行同步控制，这个方案与 Java 语言类似；另一种方案支持协程之间以消息传递（Message-Passing）的方式通信，本质上是要避免共享，Golang 的这个方案是基于** CSP**（Communicating Sequential Processes）模型实现的。Golang 比较推荐的方案是后者。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/fea959b2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/fea959b2/" class="post-title-link" itemprop="url">《极客时间教程 - Java 并发编程实战》笔记一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-26 14:36:05" itemprop="dateCreated datePublished" datetime="2024-08-26T14:36:05+08:00">2024-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Java-并发编程实战》笔记一"><a href="#《极客时间教程-Java-并发编程实战》笔记一" class="headerlink" title="《极客时间教程 - Java 并发编程实战》笔记一"></a>《极客时间教程 - Java 并发编程实战》笔记一</h1><h2 id="学习攻略-如何才能学好并发编程？"><a href="#学习攻略-如何才能学好并发编程？" class="headerlink" title="学习攻略 如何才能学好并发编程？"></a>学习攻略 如何才能学好并发编程？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261435639.png"></p>
<h2 id="开篇词-你为什么需要学习并发编程？"><a href="#开篇词-你为什么需要学习并发编程？" class="headerlink" title="开篇词 你为什么需要学习并发编程？"></a>开篇词 你为什么需要学习并发编程？</h2><p><strong>并发编程可以总结为三个核心问题：分工、同步、互斥。</strong></p>
<ul>
<li><strong>分工</strong>指的是如何高效地拆解任务并分配给线程。</li>
<li><strong>同步</strong>指的是线程之间如何协作。</li>
<li><strong>互斥</strong>则是保证同一时刻只允许一个线程访问共享资源。</li>
</ul>
<h2 id="可见性、原子性和有序性问题：并发编程-Bug-的源头"><a href="#可见性、原子性和有序性问题：并发编程-Bug-的源头" class="headerlink" title="可见性、原子性和有序性问题：并发编程 Bug 的源头"></a>可见性、原子性和有序性问题：并发编程 Bug 的源头</h2><p>CPU、内存、I&#x2F;O 设备三者的速度存在很大差异。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ol>
<li>CPU 增加了缓存，以均衡与内存的速度差异；</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>
</ol>
<p><strong>缓存</strong>导致的可见性问题，<strong>线程切换</strong>带来的原子性问题，<strong>编译优化</strong>带来的有序性问题。</p>
<h3 id="缓存导致的可见性问题"><a href="#缓存导致的可见性问题" class="headerlink" title="缓存导致的可见性问题"></a>缓存导致的可见性问题</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p>
<p>对于<strong>单核</strong>，所有的线程都是在一个 CPU 上执行，操作同一个 CPU 的缓存；一个线程对缓存的写，对另外一个线程来说一定是可见的。</p>
<p>例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261442765.png"></p>
<p>对于<strong>多核</strong>，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。这时两个线程对于变量的操作就不具备可见性了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261444744.png"></p>
<p>【示例】计数器的并发安全问题示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add10K</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;<span class="number">1.</span></span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="comment">// 创建两个线程，执行 add() 操作</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">    <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序的目的是将 count 变量累加导 10000，两个线程执行，则应该累加到 20000，但实际结果总是会小于 20000。</p>
<h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h3><p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“<strong>时间片</strong>”。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261450096.png"></p>
<p>Java 的并发也是基于任务切换。Java 中，即使是一条语句，也可能需要执行多条 CPU 指令。<strong>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292035170.png"></p>
<h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h3><p>有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序。</p>
<p>【示例】双重检查创建单例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以为的 new 操作应该是：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ol>
<p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261457434.png"></p>
<h2 id="Java-内存模型：看-Java-如何解决可见性和有序性问题"><a href="#Java-内存模型：看-Java-如何解决可见性和有序性问题" class="headerlink" title="Java 内存模型：看 Java 如何解决可见性和有序性问题"></a>Java 内存模型：看 Java 如何解决可见性和有序性问题</h2><p>导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但这种方案性能堪忧。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六项 <strong>Happens-Before 规则</strong>。</p>
<h3 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h3><ul>
<li><strong>程序次序规则</strong> - 在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</li>
<li><strong>锁定规则</strong> - 一个 <code>unLock</code> 操作 Happens-Before 于后面对同一个锁的 <code>lock</code> 操作。</li>
<li><strong>volatile 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作 Happens-Before 于后面对这个变量的读操作。</li>
<li><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法 Happens-Before 于此线程的每个一个动作。</li>
<li><strong>线程终止规则</strong> - 线程中所有的操作都 Happens-Before 于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法是否结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生。</li>
<li><strong>对象终结规则</strong> - 一个对象的初始化完成 Happens-Before 于它的 <code>finalize()</code> 方法的开始。</li>
<li><strong>传递性</strong> - 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
</ul>
<h2 id="互斥锁（上）：解决原子性问题"><a href="#互斥锁（上）：解决原子性问题" class="headerlink" title="互斥锁（上）：解决原子性问题"></a>互斥锁（上）：解决原子性问题</h2><p>并发原子性问题的源头是<strong>线程切换</strong>。</p>
<p>解决这个问题的直接方法就是禁止线程切换。操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。这个方案对于单核场景是可行的，但不适用于多核场景。</p>
<p>举例来说，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位，如下图所示）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261524478.png"></p>
<p>在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。</p>
<p>“<strong>同一时刻只有一个线程执行</strong>”称之为<strong>互斥</strong>。如果能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p>
<h3 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h3><p>一段需要互斥执行的代码称为<strong>临界区</strong>。线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时称这个线程持有锁；否则就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292036259.png"></p>
<h3 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h3><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292036343.png"></p>
<h3 id="Java-语言提供的锁技术：synchronized"><a href="#Java-语言提供的锁技术：synchronized" class="headerlink" title="Java 语言提供的锁技术：synchronized"></a>Java 语言提供的锁技术：synchronized</h3><p>Java 中，synchronized 是一种锁的实现方式。</p>
<p>【示例】synchronized 使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()；</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">baz</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源</strong>。</p>
<h3 id="用-synchronized-解决-count-1-问题"><a href="#用-synchronized-解决-count-1-问题" class="headerlink" title="用 synchronized 解决 count+&#x3D;1 问题"></a>用 synchronized 解决 count+&#x3D;1 问题</h3><p>【示例】synchronized 实现并发安全的计数器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCalc</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261541380.png"></p>
<h3 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a>锁和受保护资源的关系</h3><p><strong>受保护资源和锁之间的关联关系是 N:1 的关系</strong>。</p>
<p>【示例】synchronized 实现并发安全的计数器错误示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCalc</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261545832.png"></p>
<p>【示例】synchronized 实现并发安全的计数器错误示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeCalc</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> <span class="title class_">Object</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> <span class="title class_">Object</span>()) &#123;</span><br><span class="line">      value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，加锁本质就是在锁对象的对象头中写入当前线程 id，但是 new object 每次在内存中都是新对象，所以加锁无效。</p>
<h2 id="互斥锁（下）：如何用一把锁保护多个资源？"><a href="#互斥锁（下）：如何用一把锁保护多个资源？" class="headerlink" title="互斥锁（下）：如何用一把锁保护多个资源？"></a>互斥锁（下）：如何用一把锁保护多个资源？</h2><h3 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h3><p><strong>用不同的锁对受保护资源进行精细化管理，能够提升性能</strong>。这种锁还有个名字，叫<strong>细粒度锁</strong>。</p>
<p>【示例】账户类 Account 有两个成员变量，分别是账户余额 balance 和账户密码 password。取款 withdraw() 和查看余额 getBalance() 操作会访问账户余额 balance，创建一个 final 对象 balLock 作为锁（类比球赛门票）；而更改密码 updatePassword() 和查看密码 getPassword() 操作会修改账户密码 password，创建一个 final 对象 pwLock 作为锁（类比电影票）。不同的资源用不同的锁保护，各自管各自的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">balLock</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">// 账户余额</span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 锁：保护账户密码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pwLock</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amt)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看余额</span></span><br><span class="line">  Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">updatePassword</span><span class="params">(String pw)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="built_in">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看密码</span></span><br><span class="line">  String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：如果账户余额用 this.balance 作为互斥锁，账户密码用 this.password 作为互斥锁，你觉得是否可以呢？</p>
<p>答：不能用可变对象做锁。</p>
</blockquote>
<h3 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h3><p>【示例】保护临界区多个资源的错误示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(</span></span><br><span class="line"><span class="params">      Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 可以保护 this 对象持有的资源，但不能保护 target 对象持有的资源。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261603806.png"></p>
<h3 id="使用锁的正确姿势"><a href="#使用锁的正确姿势" class="headerlink" title="使用锁的正确姿势"></a>使用锁的正确姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object lock；</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">// 创建 Account 时传入同一个 lock 对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处检查所有对象共享的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">        target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码思路正确，但存在一个问题：如果创建 Account 对象时，传入的 lock 不是同一个对象，就会出现锁自家门来保护他家资产的荒唐事。</p>
<p>因此，可以优化为使用 Class 对象（Account.class）作为共享的锁。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以不用担心它的唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Account.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">        target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261610209.png"></p>
<h2 id="一不小心就死锁了，怎么办？"><a href="#一不小心就死锁了，怎么办？" class="headerlink" title="一不小心就死锁了，怎么办？"></a>一不小心就死锁了，怎么办？</h2><p><strong>死锁</strong>：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>
<p>【示例】存在死锁的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261612406.png"></p>
<h3 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h3><p>只有以下这四个条件都发生时才会出现死锁：</p>
<ul>
<li><strong>互斥</strong>，共享资源 X 和 Y 只能被一个线程占用；</li>
<li><strong>占有且等待</strong>，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li><strong>不可抢占</strong>，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li><strong>循环等待</strong>，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ul>
<p><strong>也就是说只要我们破坏其中一个，就可以成功避免死锁的发生</strong>。</p>
<p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p>
<ol>
<li>对于“<strong>占用且等待</strong>”，可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“<strong>不可抢占</strong>”，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“<strong>循环等待</strong>”，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ol>
<h4 id="破坏占用且等待条件"><a href="#破坏占用且等待条件" class="headerlink" title="破坏占用且等待条件"></a>破坏占用且等待条件</h4><p>通过一个 Allocator 来管理临界区。当账户 Account 在执行转账操作的时候，首先向 Allocator 同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，需通知 Allocator 同时释放转出账户和转入账户这两个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object from, Object to)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object from, Object to)</span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="comment">// actr 应该为单例</span></span><br><span class="line">  <span class="keyword">private</span> Allocator actr;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">    <span class="keyword">while</span>(!actr.apply(<span class="built_in">this</span>, target))</span><br><span class="line">      ；</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 锁定转出账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 锁定转入账户</span></span><br><span class="line">        <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt)&#123;</span><br><span class="line">            <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      actr.free(<span class="built_in">this</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line"><span class="keyword">while</span>(!actr.apply(<span class="built_in">this</span>, target))</span><br><span class="line">  ；</span><br></pre></td></tr></table></figure>

<p>如果 apply() 操作耗时非常短，而且并发冲突量也不大时，这个方案还挺不错的。但如果 apply() 操作耗时长，或者并发冲突量大的时候，可能遥循环大量次数才能获得锁，太消耗 CPU 了。</p>
<p>在这种场景下，更好的方案应该是：如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入<strong>等待</strong>状态；当线程要求的条件（转出账本和转入账本同在文件架上）满足后，<strong>通知</strong>等待的线程重新执行。其中，使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题。</p>
<h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><p>核心是要能够主动释放它占有的资源。</p>
<p>synchronized 做不到这点，但是可以通过 Lock 来解决此类问题。</p>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>破坏这个条件，需要对资源进行排序，然后按序申请资源。</p>
<p>假设每个账户都有不同的属性 id，这个 id 可以作为排序字段，申请的时候，我们可以按照从小到大的顺序来申请。比如下面代码中，①~⑥处的代码对转出账户（this）和转入账户（target）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>        ①</span><br><span class="line">    <span class="type">Account</span> <span class="variable">right</span> <span class="operator">=</span> target;    ②</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.id &gt; target.id) &#123; ③</span><br><span class="line">      left = target;           ④</span><br><span class="line">      right = <span class="built_in">this</span>;            ⑤</span><br><span class="line">    &#125;                          ⑥</span><br><span class="line">    <span class="comment">// 锁定序号小的账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">      <span class="comment">// 锁定序号大的账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt)&#123;</span><br><span class="line">          <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用“等待-通知”机制优化循环等待"><a href="#用“等待-通知”机制优化循环等待" class="headerlink" title="用“等待-通知”机制优化循环等待"></a>用“等待-通知”机制优化循环等待</h2><h3 id="用-synchronized-实现等待-通知机制"><a href="#用-synchronized-实现等待-通知机制" class="headerlink" title="用 synchronized 实现等待-通知机制"></a>用 synchronized 实现等待-通知机制</h3><p>在 Java 中，等待-通知机制有多种实现方式，比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292037649.png"></p>
<p>wait()、notify()、notifyAll() 方法操作的等待队列是互斥锁的等待队列，所以如果 synchronized 锁定的是 this，那么对应的一定是 this.wait()、this.notify()、this.notifyAll()；如果 synchronized 锁定的是 target，那么对应的一定是 target.wait()、target.notify()、target.notifyAll() 。而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：<code>java.lang.IllegalMonitorStateException</code>。</p>
<h3 id="小试牛刀：一个更好地资源分配器"><a href="#小试牛刀：一个更好地资源分配器" class="headerlink" title="小试牛刀：一个更好地资源分配器"></a>小试牛刀：一个更好地资源分配器</h3><p>等待-通知机制中，需要考虑以下四个要素。</p>
<ol>
<li>互斥锁：可以用 this 作为互斥锁。</li>
<li>线程要求的条件：转出账户和转入账户都没有被分配过。</li>
<li>何时等待：线程要求的条件不满足就等待。</li>
<li>何时通知：当有线程释放账户时就通知。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line">    <span class="comment">// 经典写法</span></span><br><span class="line">    <span class="keyword">while</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    als.add(from);</span><br><span class="line">    als.add(to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尽量使用-notifyAll"><a href="#尽量使用-notifyAll" class="headerlink" title="尽量使用 notifyAll()"></a>尽量使用 notifyAll()</h3><p><strong>notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程</strong>。从感觉上来讲，应该是 notify() 更好一些，因为即便通知所有线程，也只有一个线程能够进入临界区。但那所谓的感觉往往都蕴藏着风险，实际上使用 notify() 也很有风险，它的风险在于可能导致某些线程永远不会被通知到。</p>
<h2 id="安全性、活跃性以及性能问题"><a href="#安全性、活跃性以及性能问题" class="headerlink" title="安全性、活跃性以及性能问题"></a>安全性、活跃性以及性能问题</h2><p>并发编程中，需要注意三类问题：<strong>安全性问题、活跃性问题和性能问题</strong>。</p>
<h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>并发安全&#x2F;线程安全的本质就是正确性，即程序按照预期执行。</p>
<p>并发安全问题的三个主要源头是：原子性、可见性、有序性。通俗的说，多线程同时读写共享变量。</p>
<p>对于非共享变量（ThreadLocal）或常量（final），不存在并发安全问题。</p>
<p>对于共享变量，在并发环境下，存在竞态条件。</p>
<ul>
<li><strong>竞态条件（Race Condition）</strong>：程序的执行结果依赖多线程执行的顺序。</li>
<li><strong>临界区（Critical Sections）</strong>：导致竞态条件发生的代码区称作临界区。</li>
</ul>
<p>对于这种情况，解决方案就是互斥（锁）。</p>
<h3 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h3><p>活跃性问题主要分为：</p>
<ul>
<li><strong>死锁</strong></li>
<li><strong>活锁</strong> - <strong>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况</strong>。解决方案：尝试等待一个随机的时间。</li>
<li><strong>饥饿</strong> - <strong>线程因无法访问所需资源而无法执行下去的情况</strong>。解决方案：<ol>
<li>保证资源充足；</li>
<li>公平地分配资源；</li>
<li>避免持有锁的线程长时间执行。</li>
</ol>
</li>
</ul>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>三个核心性能指标：</p>
<ol>
<li><strong>吞吐量</strong>：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。</li>
<li><strong>延迟</strong>：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。</li>
<li><strong>并发量</strong>：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</li>
</ol>
<p>由互斥而产生的阻塞会影响性能。要提升性能有以下思路：</p>
<ul>
<li><strong>无锁化</strong> - 相关的技术有：ThreadLocal、写入时复制 (Copy-on-write)、乐观锁、原子类、Disruptor</li>
<li><strong>减少锁持有的时间</strong> - 互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。相关的技术有：细粒度锁（ConcurrentHashMap 中的分段锁技术）；读写锁。</li>
</ul>
<h2 id="管程：并发编程的万能钥匙"><a href="#管程：并发编程的万能钥匙" class="headerlink" title="管程：并发编程的万能钥匙"></a>管程：并发编程的万能钥匙</h2><h3 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h3><p>synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。但是管程更容易使用，所以 Java 选择了管程。</p>
<p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”。</p>
<p>所谓<strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p>
<h3 id="MESA-模型"><a href="#MESA-模型" class="headerlink" title="MESA 模型"></a>MESA 模型</h3><p>Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。</p>
<p>并发领域两大核心问题，管程都是能够解决的。</p>
<p>一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；</p>
<p>一个是<strong>同步</strong>，即线程之间如何通信、协作。</p>
<p>管程是如何解决<strong>互斥</strong>问题的：</p>
<p>将共享变量及其对共享变量的操作统一封装起来。在下图中，管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq() 保证互斥性，只允许一个线程进入管程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408261940150.png"></p>
<p>管程是如何解决线程间的<strong>同步</strong>问题的：</p>
<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。管程里还引入了条件变量的概念，而且<strong>每个条件变量都对应有一个等待队列</strong>，如下图，条件变量 A 和条件变量 B 分别都有自己的等待队列。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270725745.png"></p>
<h2 id="Java-线程（上）：Java-线程的生命周期"><a href="#Java-线程（上）：Java-线程的生命周期" class="headerlink" title="Java 线程（上）：Java 线程的生命周期"></a>Java 线程（上）：Java 线程的生命周期</h2><h3 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h3><p>通用的线程生命周期：<strong>初始状态、可运行状态、运行状态、休眠状态</strong>和<strong>终止状态</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270729535.png"></p>
<h3 id="Java-中线程的生命周期"><a href="#Java-中线程的生命周期" class="headerlink" title="Java 中线程的生命周期"></a>Java 中线程的生命周期</h3><p>Java 中线程共有六种状态：</p>
<ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行 &#x2F; 运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270731084.png"></p>
<h2 id="Java-线程（中）：创建多少线程才是合适的？"><a href="#Java-线程（中）：创建多少线程才是合适的？" class="headerlink" title="Java 线程（中）：创建多少线程才是合适的？"></a>Java 线程（中）：创建多少线程才是合适的？</h2><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><p>度量性能的核心指标：</p>
<ul>
<li><strong>延迟</strong> - 延迟指的是发出请求到收到响应这个过程的时间；延迟越短，意味着程序执行得越快，性能也就越好。</li>
<li><strong>吞吐量</strong> - 吞吐量指的是在单位时间内能处理请求的数量；吞吐量越大，意味着程序能处理的请求越多，性能也就越好。</li>
</ul>
<h3 id="多线程的应用场景有哪些？"><a href="#多线程的应用场景有哪些？" class="headerlink" title="多线程的应用场景有哪些？"></a>多线程的应用场景有哪些？</h3><p><strong>降低延迟，提高吞吐量</strong>，有两个方向：一个方向是<strong>优化算法</strong>，另一个方向是<strong>将硬件的性能发挥到极致</strong>。计算机主要有哪些硬件呢？主要是两类：一个是 I&#x2F;O，一个是 CPU。简言之，<strong>在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升 I&#x2F;O 的利用率和 CPU 的利用率</strong>。</p>
<h3 id="创建多少线程合适？"><a href="#创建多少线程合适？" class="headerlink" title="创建多少线程合适？"></a>创建多少线程合适？</h3><p>创建多少线程合适，要看多线程具体的应用场景。</p>
<p>程序一般都是 CPU 计算和 I&#x2F;O 操作交叉执行的。I&#x2F;O 操作执行时间长的，称为 I&#x2F;O 密集型计算；CPU 操作执行时间长的，称为 CPU 密集型计算。</p>
<p><strong>对于 CPU 密集型的计算场景，理论上“线程的数量 &#x3D;CPU 核数”就是最合适的</strong>。不过在工程上，<strong>线程的数量一般会设置为“CPU 核数 +1”</strong>，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。</p>
<p>对于 I&#x2F;O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I&#x2F;O 操作的耗时比相关的，我们可以总结出这样一个公式：</p>
<blockquote>
<p>最佳线程数 &#x3D;CPU 核数 * [ 1 +（I&#x2F;O 耗时 &#x2F; CPU 耗时）]</p>
</blockquote>
<h2 id="Java-线程（下）：为什么局部变量是线程安全的？"><a href="#Java-线程（下）：为什么局部变量是线程安全的？" class="headerlink" title="Java 线程（下）：为什么局部变量是线程安全的？"></a>Java 线程（下）：为什么局部变量是线程安全的？</h2><h3 id="方法是如何被执行的"><a href="#方法是如何被执行的" class="headerlink" title="方法是如何被执行的"></a>方法是如何被执行的</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270751420.png">“CPU 去哪里找到调用方法的参数和返回地址？</p>
<p><strong>通过 CPU 的堆栈寄存器</strong>。CPU 支持一种栈结构，先入后出。因为这个栈是和方法调用相关的，因此经常被称为<strong>调用栈</strong>。</p>
<p>例如，有三个方法 A、B、C，他们的调用关系是 A-&gt;B-&gt;C（A 调用 B，B 调用 C），在运行时，会构建出下面这样的调用栈。每个方法在调用栈里都有自己的独立空间，称为<strong>栈帧</strong>，每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，<strong>栈帧和方法是同生共死的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270753265.png"></p>
<h3 id="局部变量存哪里？"><a href="#局部变量存哪里？" class="headerlink" title="局部变量存哪里？"></a>局部变量存哪里？</h3><p>局部变量的作用域是方法内部，也就是说当方法执行完，局部变量就没用了，局部变量应该和方法同生共死。此时你应该会想到调用栈的栈帧，调用栈的栈帧就是和方法同生共死的，所以局部变量放到调用栈里那儿是相当的合理。事实上，的确是这样的，<strong>局部变量就是放到了调用栈里</strong>。于是调用栈的结构就变成了下图这样。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270755942.png"></p>
<h3 id="调用栈与线程"><a href="#调用栈与线程" class="headerlink" title="调用栈与线程"></a>调用栈与线程</h3><p>那调用栈和线程之间是什么关系呢？</p>
<p>答案是：<strong>每个线程都有自己独立的调用栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270756092.png"></p>
<p>因为每个线程都有自己的调用栈，局部变量保存在线程各自的调用栈里面，不会共享，所以自然也就没有并发问题。再次重申一遍：没有共享，就没有伤害。</p>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做<strong>线程封闭</strong>，比较官方的解释是：<strong>仅在单线程内访问数据</strong>。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。</p>
<p>采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection</p>
<h2 id="如何用面向对象思想写好并发程序？"><a href="#如何用面向对象思想写好并发程序？" class="headerlink" title="如何用面向对象思想写好并发程序？"></a>如何用面向对象思想写好并发程序？</h2><h3 id="一、封装共享变量"><a href="#一、封装共享变量" class="headerlink" title="一、封装共享变量"></a>一、封装共享变量</h3><p><strong>将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略</strong>。</p>
<p><strong>对于这些不会发生变化的共享变量，建议你用 final 关键字来修饰</strong>。</p>
<h3 id="二、识别共享变量间的约束条件"><a href="#二、识别共享变量间的约束条件" class="headerlink" title="二、识别共享变量间的约束条件"></a>二、识别共享变量间的约束条件</h3><p>识别共享变量间的约束条件非常重要。因为<strong>这些约束条件，决定了并发访问策略</strong>。</p>
<p>共享变量之间的约束条件，反映在代码里，基本上都会有 if 语句，所以，一定要特别注意竞态条件。</p>
<h3 id="三、制定并发访问策略"><a href="#三、制定并发访问策略" class="headerlink" title="三、制定并发访问策略"></a>三、制定并发访问策略</h3><p>并发访问策略方案：</p>
<ol>
<li>避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。</li>
<li>不变模式：这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模式、CSP 模式以及函数式编程的基础都是不变模式。</li>
<li>管程及其他同步工具：Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java 并发包提供的读写锁、并发容器等同步工具会更好。</li>
</ol>
<h2 id="理论基础模块热点问题答疑"><a href="#理论基础模块热点问题答疑" class="headerlink" title="理论基础模块热点问题答疑"></a>理论基础模块热点问题答疑</h2><p>起源是一个硬件的核心矛盾：CPU 与内存、I&#x2F;O 的速度差异，系统软件（操作系统、编译器）在解决这个核心矛盾的同时，引入了可见性、原子性和有序性问题，这三个问题就是很多并发程序的 Bug 之源。</p>
<p>如何解决这三个问题呢？Java 中提供了 Java 内存模型，以应对可见性和有序性问题；提供了互斥锁，以应对原子性问题。</p>
<p>互斥锁是解决并发问题的核心工具，但它也可能会带来死锁问题。</p>
<p>管程，是 Java 并发编程技术的基础，是解决并发问题的万能钥匙。并发编程里两大核心问题——互斥和同步，都是可以由管程来解决的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408270805546.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/11933f32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/11933f32/" class="post-title-link" itemprop="url">《极客时间教程 - Java 并发编程实战》笔记二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-26 14:36:05" itemprop="dateCreated datePublished" datetime="2024-08-26T14:36:05+08:00">2024-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>33k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-Java-并发编程实战》笔记二"><a href="#《极客时间教程-Java-并发编程实战》笔记二" class="headerlink" title="《极客时间教程 - Java 并发编程实战》笔记二"></a>《极客时间教程 - Java 并发编程实战》笔记二</h1><h2 id="Lock-和-Condition（上）：隐藏在并发包中的管程"><a href="#Lock-和-Condition（上）：隐藏在并发包中的管程" class="headerlink" title="Lock 和 Condition（上）：隐藏在并发包中的管程"></a>Lock 和 Condition（上）：隐藏在并发包中的管程</h2><h3 id="再造管程的理由"><a href="#再造管程的理由" class="headerlink" title="再造管程的理由"></a>再造管程的理由</h3><p>已有 synchronized，还支持 Lock 的原因是，需要一把锁支持：</p>
<ol>
<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</li>
<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持中断的 API</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 支持超时的 API</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 支持非阻塞获取锁的 API</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><p>以 ReentrantLock 为例，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值。由 volatile 保证变量的可见性。</p>
<h3 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h3><p><strong>所谓可重入锁，指的是线程可以重复获取同一把锁</strong>。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>ReentrantLock 中实现了公平锁和非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数：默认非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据公平策略参数创建锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span>&#123;<span class="type">F</span></span><br><span class="line">    <span class="variable">sync</span> <span class="operator">=</span> fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>()</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p>
<h3 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="headerlink" title="用锁的最佳实践"></a>用锁的最佳实践</h3><ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ol>
<h2 id="Lock-和-Condition（下）：Dubbo-如何用管程实现异步转同步？"><a href="#Lock-和-Condition（下）：Dubbo-如何用管程实现异步转同步？" class="headerlink" title="Lock 和 Condition（下）：Dubbo 如何用管程实现异步转同步？"></a>Lock 和 Condition（下）：Dubbo 如何用管程实现异步转同步？</h2><p><strong>Condition 实现了管程模型里面的条件变量</strong>。</p>
<p><strong>如何利用两个条件变量快速实现阻塞队列呢？</strong></p>
<p>一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> （队列已满）&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略入队操作。..</span></span><br><span class="line">      <span class="comment">// 入队后，通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> （队列已空）&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作。..</span></span><br><span class="line">      <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 和 Condition 实现的管程，**线程等待和通知需要调用 await()、signal()、signalAll()**，它们的语义和 wait()、notify()、notifyAll() 是相同的。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步的区别：<strong>调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步</strong>。</p>
<h3 id="Dubbo-源码分析"><a href="#Dubbo-源码分析" class="headerlink" title="Dubbo 源码分析"></a>Dubbo 源码分析</h3><p>RPC 调用，<strong>在 TCP 协议层面，发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的</strong>。</p>
<p>Dubbo 调用关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboInvoker</span>&#123;</span><br><span class="line">  Result <span class="title function_">doInvoke</span><span class="params">(Invocation inv)</span>&#123;</span><br><span class="line">    <span class="comment">// 下面这行就是源码中 108 行</span></span><br><span class="line">    <span class="comment">// 为了便于展示，做了修改</span></span><br><span class="line">    <span class="keyword">return</span> currentClient</span><br><span class="line">      .request(inv, timeout)</span><br><span class="line">      .get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 RPC 返回结果之前，阻塞调用线程，让调用线程等待；当 RPC 返回结果后，唤醒调用线程，让调用线程重新执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁与条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方通过该方法等待结果</span></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">	  done.await(timeout);</span><br><span class="line">      <span class="type">long</span> cur=System.nanoTime();</span><br><span class="line">	  <span class="keyword">if</span> (isDone() ||</span><br><span class="line">          cur-start &gt; timeout)&#123;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC 结果是否已经返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC 结果返回时调用该方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReceived</span><span class="params">(Response res)</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = res;</span><br><span class="line">    <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">      done.signal();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore：如何快速实现一个限流器？"><a href="#Semaphore：如何快速实现一个限流器？" class="headerlink" title="Semaphore：如何快速实现一个限流器？"></a>Semaphore：如何快速实现一个限流器？</h2><h3 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h3><p>信号量模型还是很简单的，可以简单概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408280813940.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span>&#123;</span><br><span class="line">  <span class="comment">// 计数器</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">// 等待队列</span></span><br><span class="line">  Queue queue;</span><br><span class="line">  <span class="comment">// 初始化操作</span></span><br><span class="line">  Semaphore(<span class="type">int</span> c)&#123;</span><br><span class="line">    <span class="built_in">this</span>.count=c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.count&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 将当前线程插入等待队列</span></span><br><span class="line">      <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 移除等待队列中的某个线程 T</span></span><br><span class="line">      <span class="comment">// 唤醒线程 T</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>号量模型里面，down()、up() 这两个操作历史上最早称为 P 操作和 V 操作，所以信号量模型也被称为 PV 原语。在 Java SDK 并发包里，down() 和 up() 对应的则是 acquire() 和 release()。</p>
<h3 id="如何使用信号量"><a href="#如何使用信号量" class="headerlink" title="如何使用信号量"></a>如何使用信号量</h3><p>就像我们用互斥锁一样，只需要在进入临界区之前执行一下 down() 操作，退出临界区之前执行一下 up() 操作就可以了。下面是 Java 代码的示例，acquire() 就是信号量里的 down() 操作，release() 就是信号量里的 up() 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">s</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 用信号量保证互斥</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">  s.acquire();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    count+=<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    s.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速实现一个限流器"><a href="#快速实现一个限流器" class="headerlink" title="快速实现一个限流器"></a>快速实现一个限流器</h3><p><strong>Semaphore 可以允许多个线程访问一个临界区</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjPool</span>&lt;T, R&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">  <span class="comment">// 用信号量实现限流器</span></span><br><span class="line">  <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  ObjPool(<span class="type">int</span> size, T t)&#123;</span><br><span class="line">    pool = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;T&gt;()&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sem = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用对象池的对象，调用 func</span></span><br><span class="line">  R <span class="title function_">exec</span><span class="params">(Function&lt;T,R&gt; func)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t = pool.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> func.apply(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjPool&lt;Long, String&gt; pool =</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ObjPool</span>&lt;Long, String&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过对象池获取 t，之后执行</span></span><br><span class="line">pool.exec(t -&gt; &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t.toString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但<strong>读写锁的写操作是互斥的</strong>，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。</p>
<h3 id="快速实现一个缓存"><a href="#快速实现一个缓存" class="headerlink" title="快速实现一个缓存"></a>快速实现一个缓存</h3><p>Cache 这个工具类，我们提供了两个方法，一个是读缓存方法 get()，另一个是写缓存方法 put()。读缓存需要用到读锁，读锁的使用和前面我们介绍的 Lock 的使用是相同的，都是 try{}finally{}这个编程范式。写缓存则需要用到写锁，写锁的使用和读锁是类似的。这样看来，读写锁的使用还是非常简单的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="comment">// 读锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="comment">// 写锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">  <span class="comment">// 读缓存</span></span><br><span class="line">  V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写缓存</span></span><br><span class="line">  V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, v); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现缓存的按需加载"><a href="#实现缓存的按需加载" class="headerlink" title="实现缓存的按需加载"></a>实现缓存的按需加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//读缓存</span></span><br><span class="line">    r.lock();         ①</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      v = m.get(key); ②</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      r.unlock();     ③</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中存在，返回</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="literal">null</span>) &#123;   ④</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中不存在，查询数据库</span></span><br><span class="line">    w.lock();         ⑤</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证</span></span><br><span class="line">      <span class="comment">//其他线程可能已经查询过数据库</span></span><br><span class="line">      v = m.get(key); ⑥</span><br><span class="line">      <span class="keyword">if</span>(v == <span class="literal">null</span>)&#123;  ⑦</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        v=省略代码无数</span><br><span class="line">        m.put(key, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock：如何快速实现一个完备的缓存？"><a href="#ReadWriteLock：如何快速实现一个完备的缓存？" class="headerlink" title="ReadWriteLock：如何快速实现一个完备的缓存？"></a>ReadWriteLock：如何快速实现一个完备的缓存？</h2><h3 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读缓存</span></span><br><span class="line">r.lock();         ①</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = m.get(key); ②</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证并更新缓存</span></span><br><span class="line">      <span class="comment">//省略详细代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  r.unlock();     ③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，先是获取读锁，然后再升级为写锁，对此还有个专业的名字，叫<strong>锁的升级</strong>。可惜 ReadWriteLock 并不支持这种升级。</p>
<p>不过，虽然锁的升级是不允许的，但是锁的降级却是允许的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">  <span class="comment">// 读锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">  <span class="comment">//写锁</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// 释放读锁，因为不允许读锁的升级</span></span><br><span class="line">      r.unlock();</span><br><span class="line">      <span class="comment">// 获取写锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 再次检查状态</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放写锁前，降级为读锁</span></span><br><span class="line">        <span class="comment">// 降级是可以的</span></span><br><span class="line">        r.lock(); ①</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;use(data);&#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;r.unlock();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StampedLock：有没有比读写锁更快的锁？"><a href="#StampedLock：有没有比读写锁更快的锁？" class="headerlink" title="StampedLock：有没有比读写锁更快的锁？"></a>StampedLock：有没有比读写锁更快的锁？</h2><h3 id="StampedLock-支持的三种锁模式"><a href="#StampedLock-支持的三种锁模式" class="headerlink" title="StampedLock 支持的三种锁模式"></a>StampedLock 支持的三种锁模式</h3><p>ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取/释放悲观读锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取/释放写锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</p>
<p>在 distanceFromOrigin() 这个方法中，首先通过调用 tryOptimisticRead() 获取了一个 stamp，这里的 tryOptimisticRead() 就是我们前面提到的乐观读。之后将共享变量 x 和 y 读入方法的局部变量中，不过需要注意的是，由于 tryOptimisticRead() 是无锁的，所以共享变量 x 和 y 读入方法局部变量时，x 和 y 有可能被其他线程修改了。因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用 validate(stamp) 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">  <span class="comment">//计算到原点的距离</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 乐观读</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span></span><br><span class="line">      sl.tryOptimisticRead();</span><br><span class="line">    <span class="comment">// 读入局部变量，</span></span><br><span class="line">    <span class="comment">// 读的过程数据可能被修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> x, curY = y;</span><br><span class="line">    <span class="comment">//判断执行读操作期间，</span></span><br><span class="line">    <span class="comment">//是否存在写操作，如果存在，</span></span><br><span class="line">    <span class="comment">//则 sl.validate 返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">      <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">      stamp = sl.readLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        curX = x;</span><br><span class="line">        curY = y;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放悲观读锁</span></span><br><span class="line">        sl.unlockRead(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(</span><br><span class="line">      curX * curX + curY * curY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进一步理解乐观读"><a href="#进一步理解乐观读" class="headerlink" title="进一步理解乐观读"></a>进一步理解乐观读</h3><p>StampedLock 的乐观读和数据库的乐观锁有异曲同工之妙。</p>
<h3 id="StampedLock-使用注意事项"><a href="#StampedLock-使用注意事项" class="headerlink" title="StampedLock 使用注意事项"></a>StampedLock 使用注意事项</h3><p>对于读多写少的场景 StampedLock 性能很好，简单的应用场景基本上可以替代 ReadWriteLock，但是** StampedLock 的功能仅仅是 ReadWriteLock 的子集**，在使用的时候，还是有几个地方需要注意一下。</p>
<p>StampedLock 在命名上并没有增加 Reentrant，想必你已经猜测到 StampedLock 应该是不可重入的。事实上，的确是这样的，<strong>StampedLock 不支持重入</strong>。这个是在使用中必须要特别注意的。</p>
<p>另外，StampedLock 的悲观读锁、写锁都不支持条件变量，这个也需要你注意。</p>
<p>还有一点需要特别注意，那就是：如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span></span><br><span class="line">  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 获取写锁</span></span><br><span class="line">  lock.writeLock();</span><br><span class="line">  <span class="comment">// 永远阻塞在此处，不释放写锁</span></span><br><span class="line">  LockSupport.park();</span><br><span class="line">&#125;);</span><br><span class="line">T1.start();</span><br><span class="line"><span class="comment">// 保证 T1 获取写锁</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">  <span class="comment">//阻塞在悲观读锁</span></span><br><span class="line">  lock.readLock()</span><br><span class="line">);</span><br><span class="line">T2.start();</span><br><span class="line"><span class="comment">// 保证 T2 阻塞在读锁</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//中断线程 T2</span></span><br><span class="line"><span class="comment">//会导致线程 T2 所在 CPU 飙升</span></span><br><span class="line">T2.interrupt();</span><br><span class="line">T2.join();</span><br></pre></td></tr></table></figure>

<p>所以，**使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()**。这个规则一定要记清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>StampedLock 读模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span></span><br><span class="line">  sl.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 读入方法局部变量</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 校验 stamp</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">  <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">  stamp = sl.readLock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读入方法局部变量</span></span><br><span class="line">    .....</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放悲观读锁</span></span><br><span class="line">    sl.unlockRead(stamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方法局部变量执行业务操作</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>StampedLock 写模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 写共享变量</span></span><br><span class="line">  ......</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch-和-CyclicBarrier：如何让多线程步调一致？"><a href="#CountDownLatch-和-CyclicBarrier：如何让多线程步调一致？" class="headerlink" title="CountDownLatch 和 CyclicBarrier：如何让多线程步调一致？"></a>CountDownLatch 和 CyclicBarrier：如何让多线程步调一致？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292030531.png"></p>
<p>对账系统串行处理流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（存在未对账订单）&#123;</span><br><span class="line">  <span class="comment">// 查询未对账订单</span></span><br><span class="line">  pos = getPOrders();</span><br><span class="line">  <span class="comment">// 查询派送单</span></span><br><span class="line">  dos = getDOrders();</span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用并行优化对账系统"><a href="#利用并行优化对账系统" class="headerlink" title="利用并行优化对账系统"></a>利用并行优化对账系统</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292030390.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292030333.png"></p>
<h3 id="用-CountDownLatch-实现线程等待"><a href="#用-CountDownLatch-实现线程等待" class="headerlink" title="用 CountDownLatch 实现线程等待"></a>用 CountDownLatch 实现线程等待</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 2 个线程的线程池</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>（存在未对账订单）&#123;</span><br><span class="line">  <span class="comment">// 计数器初始化为 2</span></span><br><span class="line">  <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 查询未对账订单</span></span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 查询派送单</span></span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">  latch.await();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进一步优化性能"><a href="#进一步优化性能" class="headerlink" title="进一步优化性能"></a>进一步优化性能</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292031238.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292031656.png"></p>
<h3 id="用-CyclicBarrier-实现线程同步"><a href="#用-CyclicBarrier-实现线程同步" class="headerlink" title="用 CyclicBarrier 实现线程同步"></a>用 CyclicBarrier 实现线程同步</h3><p>CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单队列</span></span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line"><span class="comment">// 派送单队列</span></span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="comment">// 执行回调的线程池</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">  <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(p, d);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 循环查询订单库</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>（存在未对账订单）&#123;</span><br><span class="line">      <span class="comment">// 查询订单库</span></span><br><span class="line">      pos.add(getPOrders());</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T1.start();</span><br><span class="line">  <span class="comment">// 循环查询运单库</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>（存在未对账订单）&#123;</span><br><span class="line">      <span class="comment">// 查询运单库</span></span><br><span class="line">      dos.add(getDOrders());</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong>。</p>
<p><strong>CyclicBarrier 是一组线程之间互相等待</strong>。</p>
<p>CountDownLatch 的计数器是不能循环利用的，也就是说一旦计数器减到 0，再有线程调用 await()，该线程会直接通过。但 <strong>CyclicBarrier 的计数器是可以循环利用的</strong>，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。除此之外，CyclicBarrier 还可以设置回调函数，可以说是功能丰富。</p>
<h2 id="并发容器：都有哪些“坑”需要我们填？"><a href="#并发容器：都有哪些“坑”需要我们填？" class="headerlink" title="并发容器：都有哪些“坑”需要我们填？"></a>并发容器：都有哪些“坑”需要我们填？</h2><h3 id="同步容器及其注意事项"><a href="#同步容器及其注意事项" class="headerlink" title="同步容器及其注意事项"></a>同步容器及其注意事项</h3><p><strong>组合操作需要注意竞态条件问题</strong>，组合操作往往隐藏着竞态条件问题，即便每个操作都能保证原子性，也并不能保证组合操作的原子性。</p>
<p>在容器领域<strong>一个容易被忽视的“坑”是用迭代器遍历容器</strong>。因为遍历元素，进行操作，不能保证原子性。</p>
<p>基于 synchronized 这个同步关键字实现的容器被称为<strong>同步容器</strong>。Java 提供的同步容器还有 Vector、Stack 和 Hashtable。对这三个容器的遍历，同样要加锁保证互斥。</p>
<h3 id="并发容器及其注意事项"><a href="#并发容器及其注意事项" class="headerlink" title="并发容器及其注意事项"></a>并发容器及其注意事项</h3><p>Java 在 1.5 版本之前所谓的线程安全的容器，主要指的就是<strong>同步容器</strong>。不过同步容器有个最大的问题，那就是性能差，所有方法都用 synchronized 来保证互斥，串行度太高了。因此 Java 在 1.5 及之后版本提供了性能更高的容器，我们一般称为<strong>并发容器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292032669.png"></p>
<h4 id="（一）List"><a href="#（一）List" class="headerlink" title="（一）List"></a>（一）List</h4><p>List 里面只有一个实现类就是** CopyOnWriteArrayList**。CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p>
<p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，如下图所示，迭代器 Iterator 遍历的就是 array 数组。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292032762.png"></p>
<p>如果在遍历 array 的同时，还有一个写操作，例如增加元素，CopyOnWriteArrayList 是如何处理的呢？</p>
<p>CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。通过下图你可以看到，读写是可以并行的，遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292032731.png"></p>
<p>使用 CopyOnWriteArrayList 需要注意的“坑”主要有两个方面。一个是应用场景，CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。例如上面的例子中，写入的新元素并不能立刻被遍历到。另一个需要注意的是，CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p>
<h4 id="（二）Map"><a href="#（二）Map" class="headerlink" title="（二）Map"></a>（二）Map</h4><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于** ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的**。</p>
<p>使用 ConcurrentHashMap 和 ConcurrentSkipListMap 需要注意的地方是，它们的 key 和 value 都不能为空，否则会抛出<code>NullPointerException</code>这个运行时异常。下面这个表格总结了 Map 相关的实现类对于 key 和 value 的要求，你可以对比学习。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292033594.png"></p>
<p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，中文一般都翻译为“跳表”。跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p>
<h4 id="（三）Set"><a href="#（三）Set" class="headerlink" title="（三）Set"></a>（三）Set</h4><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap，它们的原理都是一样的，这里就不再赘述了。</p>
<h4 id="（四）Queue"><a href="#（四）Queue" class="headerlink" title="（四）Queue"></a>（四）Queue</h4><p>Java 并发包里面 Queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里<strong>阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识</strong>。</p>
<h2 id="原子类：无锁工具类的典范"><a href="#原子类：无锁工具类的典范" class="headerlink" title="原子类：无锁工具类的典范"></a>原子类：无锁工具类的典范</h2><p>无锁方案相对互斥锁方案，最大的好处就是<strong>性能</strong>。互斥锁方案为了保证互斥性，需要执行加锁、解锁操作，而加锁、解锁操作本身就消耗性能；同时拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大。 相比之下，无锁方案则完全没有加锁、解锁的性能消耗，同时还能保证互斥性，既解决了问题，又没有带来新的问题，可谓绝佳方案。</p>
<h3 id="无锁方案的实现原理"><a href="#无锁方案的实现原理" class="headerlink" title="无锁方案的实现原理"></a>无锁方案的实现原理</h3><p>CPU 为了解决并发问题，提供了 CAS 指令（CAS，全称是 Compare And Swap，即“比较并交换”）。CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。<strong>作为一条 CPU 指令，CAS 指令本身是能够保证原子性的</strong>。</p>
<p>使用 CAS 来解决并发问题，一般都会伴随着自旋，而所谓自旋，其实就是循环尝试。</p>
<p>CAS 存在 ABA 问题。</p>
<h3 id="看-Java-如何实现原子化的-count-1"><a href="#看-Java-如何实现原子化的-count-1" class="headerlink" title="看 Java 如何实现原子化的 count +&#x3D; 1"></a>看 Java 如何实现原子化的 count +&#x3D; 1</h3><p>AtomicLong 的 getAndIncrement() 方法会转调 unsafe.getAndAddLong() 方法。这里 this 和 valueOffset 两个参数可以唯一确定共享变量的内存地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddLong(</span><br><span class="line">    <span class="built_in">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unsafe.getAndAddLong() 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndAddLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> delta)</span>&#123;</span><br><span class="line">  <span class="type">long</span> v;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 读取内存中的值</span></span><br><span class="line">    v = getLongVolatile(o, offset);</span><br><span class="line">  &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子性地将变量更新为 x</span></span><br><span class="line"><span class="comment">//条件是内存中的值等于 expected</span></span><br><span class="line"><span class="comment">//更新成功则返回 true</span></span><br><span class="line"><span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(</span></span><br><span class="line"><span class="params">  Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">  <span class="type">long</span> expected,</span></span><br><span class="line"><span class="params">  <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="原子类概览"><a href="#原子类概览" class="headerlink" title="原子类概览"></a>原子类概览</h3><p>Java SDK 并发包里提供的原子类内容很丰富，我们可以将它们分为五个类别：<strong>原子化的基本数据类型、原子化的对象引用类型、原子化数组、原子化对象属性更新器</strong>和<strong>原子化的累加器</strong>。这五个类别提供的方法基本上是相似的，并且每个类别都有若干原子类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292033394.png"></p>
<h4 id="1-原子化的基本数据类型"><a href="#1-原子化的基本数据类型" class="headerlink" title="1. 原子化的基本数据类型"></a>1. 原子化的基本数据类型</h4><p>相关实现有 AtomicBoolean、AtomicInteger 和 AtomicLong，提供的方法主要有以下这些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getAndIncrement() <span class="comment">//原子化 i++</span></span><br><span class="line">getAndDecrement() <span class="comment">//原子化的 i--</span></span><br><span class="line">incrementAndGet() <span class="comment">//原子化的++i</span></span><br><span class="line">decrementAndGet() <span class="comment">//原子化的--i</span></span><br><span class="line"><span class="comment">//当前值+=delta，返回+=前的值</span></span><br><span class="line">getAndAdd(delta)</span><br><span class="line"><span class="comment">//当前值+=delta，返回+=后的值</span></span><br><span class="line">addAndGet(delta)</span><br><span class="line"><span class="comment">//CAS 操作，返回是否成功</span></span><br><span class="line">compareAndSet(expect, update)</span><br><span class="line"><span class="comment">//以下四个方法</span></span><br><span class="line"><span class="comment">//新值可以通过传入 func 函数来计算</span></span><br><span class="line">getAndUpdate(func)</span><br><span class="line">updateAndGet(func)</span><br><span class="line">getAndAccumulate(x,func)</span><br><span class="line">accumulateAndGet(x,func)</span><br></pre></td></tr></table></figure>

<h4 id="2-原子化的对象引用类型"><a href="#2-原子化的对象引用类型" class="headerlink" title="2. 原子化的对象引用类型"></a>2. 原子化的对象引用类型</h4><p>相关实现有 AtomicReference、AtomicStampedReference 和 AtomicMarkableReference，利用它们可以实现对象引用的原子化更新。AtomicReference 提供的方法和原子化的基本数据类型差不多。</p>
<p>AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题。解决思路就是增加一个版本号，类似于乐观锁机制。</p>
<p>AtomicStampedReference 实现的 CAS 方法就增加了版本号参数，方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params">  V expectedReference,</span></span><br><span class="line"><span class="params">  V newReference,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> newStamp)</span></span><br></pre></td></tr></table></figure>

<p>AtomicMarkableReference 的实现机制则更简单，将版本号简化成了一个 Boolean 值，方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params">  V expectedReference,</span></span><br><span class="line"><span class="params">  V newReference,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> expectedMark,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> newMark)</span></span><br></pre></td></tr></table></figure>

<h4 id="3-原子化数组"><a href="#3-原子化数组" class="headerlink" title="3. 原子化数组"></a>3. 原子化数组</h4><p>相关实现有 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray，利用这些原子类，我们可以原子化地更新数组里面的每一个元素。这些类提供的方法和原子化的基本数据类型的区别仅仅是：每个方法多了一个数组的索引参数。</p>
<h4 id="4-原子化对象属性更新器"><a href="#4-原子化对象属性更新器" class="headerlink" title="4. 原子化对象属性更新器"></a>4. 原子化对象属性更新器</h4><p>相关实现有 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater，利用它们可以原子化地更新对象的属性，这三个方法都是利用反射机制实现的，创建更新器的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="operator">&lt;</span><span class="type">U</span><span class="operator">&gt;</span></span><br><span class="line"><span class="type">AtomicXXXFieldUpdater</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">newUpdater(<span class="type">Class</span>&lt;<span class="type">U</span>&gt; tclass,</span><br><span class="line">  <span class="type">String</span> fieldName)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>对象属性必须是 volatile 类型的，只有这样才能保证可见性</strong>；如果对象属性不是 volatile 类型的，newUpdater() 方法会抛出 IllegalArgumentException 这个运行时异常。</p>
<p>newUpdater() 的方法参数只有类的信息，没有对象的引用，而更新<strong>对象</strong>的属性，一定需要对象的引用，那这个参数是在哪里传入的呢？是在原子操作的方法参数中传入的。例如 compareAndSet() 这个原子操作，相比原子化的基本数据类型多了一个对象引用 obj。原子化对象属性更新器相关的方法，相比原子化的基本数据类型仅仅是多了对象引用参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(</span></span><br><span class="line"><span class="params">  T obj,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> expect,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>

<h4 id="5-原子化的累加器"><a href="#5-原子化的累加器" class="headerlink" title="5. 原子化的累加器"></a>5. 原子化的累加器</h4><p>DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 compareAndSet() 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>无锁方案相对于互斥锁方案，优点非常多，首先性能好，其次是基本不会出现死锁问题（但可能出现饥饿和活锁问题，因为自旋会反复重试）。Java 提供的原子类大部分都实现了 compareAndSet() 方法。</p>
<p>Java 提供的原子类能够解决一些简单的原子性问题，但是所有原子类的方法都是针对一个共享变量的，如果需要解决多个变量的原子性问题，建议还是使用互斥锁方案。</p>
<h2 id="Executor-与线程池：如何创建正确的线程池？"><a href="#Executor-与线程池：如何创建正确的线程池？" class="headerlink" title="Executor 与线程池：如何创建正确的线程池？"></a>Executor 与线程池：如何创建正确的线程池？</h2><p><strong>线程是一个重量级的对象，应该避免频繁创建和销毁</strong>。</p>
<h3 id="线程池是一种生产者-消费者模式"><a href="#线程池是一种生产者-消费者模式" class="headerlink" title="线程池是一种生产者-消费者模式"></a>线程池是一种生产者-消费者模式</h3><p>业界线程池的设计，普遍采用的都是<strong>生产者-消费者模式</strong>。线程池的使用方是生产者，线程池本身是消费者。</p>
<h3 id="如何使用-Java-中的线程池"><a href="#如何使用-Java-中的线程池" class="headerlink" title="如何使用 Java 中的线程池"></a>如何使用 Java 中的线程池</h3><p>ThreadPoolExecutor 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ThreadPoolExecutor</span>(</span><br><span class="line">  <span class="type">int</span> corePoolSize,</span><br><span class="line">  <span class="type">int</span> maximumPoolSize,</span><br><span class="line">  <span class="type">long</span> keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>corePoolSize</strong>：表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留 corePoolSize 个人坚守阵地。</li>
<li><strong>maximumPoolSize</strong>：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到 maximumPoolSize 个人。当项目闲下来时，就要撤人了，最多能撤到 corePoolSize 个人。</li>
<li><strong>keepAliveTime &amp; unit</strong>：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了<code>keepAliveTime &amp; unit</code>这么久，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。</li>
<li><strong>workQueue</strong>：工作队列，和上面示例代码的工作队列同义。</li>
<li><strong>threadFactory</strong>：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。</li>
<li>handler：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过 handler 这个参数来指定。ThreadPoolExecutor 已经提供了以下 4 种策略。<ul>
<li>CallerRunsPolicy：提交任务的线程自己去执行该任务。</li>
<li>AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。</li>
<li>DiscardPolicy：直接丢弃任务，没有任何异常抛出。</li>
<li>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。</li>
</ul>
</li>
</ul>
<p>Java 在 1.6 版本还增加了 allowCoreThreadTimeOut(boolean value) 方法，它可以让所有线程都支持超时，这意味着如果项目很闲，就会将项目组的成员都撤走。</p>
<h3 id="使用线程池要注意些什么"><a href="#使用线程池要注意些什么" class="headerlink" title="使用线程池要注意些什么"></a>使用线程池要注意些什么</h3><p>不建议使用 Executors 的最重要的原因是：Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列</strong>。</p>
<p>使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会 throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制 catch 它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用</strong>。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p>
<p>使用线程池，还要注意异常处理的问题，例如通过 ThreadPoolExecutor 对象的 execute() 方法提交任务时，如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止；不过，最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理，你可以参考下面的示例代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">RuntimeException</span> x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Throwable</span> x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future：如何用多线程实现最优的“烧水泡茶”程序？"><a href="#Future：如何用多线程实现最优的“烧水泡茶”程序？" class="headerlink" title="Future：如何用多线程实现最优的“烧水泡茶”程序？"></a>Future：如何用多线程实现最优的“烧水泡茶”程序？</h2><h3 id="如何获取任务执行结果"><a href="#如何获取任务执行结果" class="headerlink" title="如何获取任务执行结果"></a>如何获取任务执行结果</h3><p>Java 通过 ThreadPoolExecutor 提供的 3 个 submit() 方法和 1 个 FutureTask 工具类来支持获得任务执行结果的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 Runnable 任务</span></span><br><span class="line">Future&lt;?&gt;</span><br><span class="line">  submit(Runnable task);</span><br><span class="line"><span class="comment">// 提交 Callable 任务</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt;</span><br><span class="line">  <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">// 提交 Runnable 任务及结果引用</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt;</span><br><span class="line">  <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br></pre></td></tr></table></figure>

<p>Future 接口有 5 个方法，我都列在下面了，它们分别是**取消任务的方法 cancel()、判断任务是否已取消的方法 isCancelled()、判断任务是否已结束的方法 isDone() <strong>以及</strong> 2 个获得任务执行结果的 get() 和 get(timeout, unit)**，其中最后一个 get(timeout, unit) 支持超时机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消任务</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"><span class="comment">// 判断任务是否已取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断任务是否已结束</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获得任务执行结果</span></span><br><span class="line">get();</span><br><span class="line"><span class="comment">// 获得任务执行结果，支持超时</span></span><br><span class="line">get(<span class="type">long</span> timeout, TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>FutureTask 实现了 Runnable 和 Future 接口，由于实现了 Runnable 接口，所以可以将 FutureTask 对象作为任务提交给 ThreadPoolExecutor 去执行，也可以直接被 Thread 执行；又因为实现了 Future 接口，所以也能用来获得任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt; <span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span></span><br><span class="line">  Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 提交 FutureTask</span></span><br><span class="line">es.submit(futureTask);</span><br><span class="line"><span class="comment">// 获取计算结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br></pre></td></tr></table></figure>

<p>FutureTask 对象直接被 Thread 执行的示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt; <span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">T1.start();</span><br><span class="line"><span class="comment">// 获取计算结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br></pre></td></tr></table></figure>

<h3 id="实现最优的“烧水泡茶”程序"><a href="#实现最优的“烧水泡茶”程序" class="headerlink" title="实现最优的“烧水泡茶”程序"></a>实现最优的“烧水泡茶”程序</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292034424.png"></p>
<p>烧水泡茶最优分工方案</p>
<p>首先，我们创建了两个 FutureTask——ft1 和 ft2，ft1 完成洗水壶、烧开水、泡茶的任务，ft2 完成洗茶壶、洗茶杯、拿茶叶的任务；这里需要注意的是 ft1 这个任务在执行泡茶任务前，需要等待 ft2 把茶叶拿来，所以 ft1 内部需要引用 ft2，并在执行泡茶之前，调用 ft2 的 get() 方法实现等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务 T2 的 FutureTask</span></span><br><span class="line">FutureTask&lt;String&gt; ft2</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">T2Task</span>());</span><br><span class="line"><span class="comment">// 创建任务 T1 的 FutureTask</span></span><br><span class="line">FutureTask&lt;String&gt; ft1</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">T1Task</span>(ft2));</span><br><span class="line"><span class="comment">// 线程 T1 执行任务 ft1</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft1);</span><br><span class="line">T1.start();</span><br><span class="line"><span class="comment">// 线程 T2 执行任务 ft2</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft2);</span><br><span class="line">T2.start();</span><br><span class="line"><span class="comment">// 等待线程 T1 执行结果</span></span><br><span class="line">System.out.println(ft1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1Task 需要执行的任务：</span></span><br><span class="line"><span class="comment">// 洗水壶、烧开水、泡茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">  FutureTask&lt;String&gt; ft2;</span><br><span class="line">  <span class="comment">// T1 任务需要 T2 任务的 FutureTask</span></span><br><span class="line">  T1Task(FutureTask&lt;String&gt; ft2)&#123;</span><br><span class="line">    <span class="built_in">this</span>.ft2 = ft2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 洗水壶。..&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 烧开水。..&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">// 获取 T2 线程的茶叶</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tf</span> <span class="operator">=</span> ft2.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 拿到茶叶：&quot;</span>+tf);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 泡茶。..&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;上茶：&quot;</span> + tf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T2Task 需要执行的任务：</span></span><br><span class="line"><span class="comment">// 洗茶壶、洗茶杯、拿茶叶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T2: 洗茶壶。..&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;T2: 洗茶杯。..&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;T2: 拿茶叶。..&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;龙井&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次执行结果：</span></span><br><span class="line">T1: 洗水壶。..</span><br><span class="line">T2: 洗茶壶。..</span><br><span class="line">T1: 烧开水。..</span><br><span class="line">T2: 洗茶杯。..</span><br><span class="line">T2: 拿茶叶。..</span><br><span class="line">T1: 拿到茶叶：龙井</span><br><span class="line">T1: 泡茶。..</span><br><span class="line">上茶：龙井</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture：异步编程没那么难"><a href="#CompletableFuture：异步编程没那么难" class="headerlink" title="CompletableFuture：异步编程没那么难"></a>CompletableFuture：异步编程没那么难</h2><p><strong>异步化</strong>，是并行方案得以实施的基础，更深入地讲其实就是：<strong>利用多线程优化性能这个核心方案得以实施的基础</strong>。</p>
<h3 id="CompletableFuture-的核心优势"><a href="#CompletableFuture-的核心优势" class="headerlink" title="CompletableFuture 的核心优势"></a>CompletableFuture 的核心优势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务 1：洗水壶 -&gt; 烧开水</span></span><br><span class="line">CompletableFuture&lt;Void&gt; f1 =</span><br><span class="line">  CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;T1: 洗水壶。..&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;T1: 烧开水。..&quot;</span>);</span><br><span class="line">  sleep(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 任务 2：洗茶壶 -&gt; 洗茶杯 -&gt; 拿茶叶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f2 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;T2: 洗茶壶。..&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;T2: 洗茶杯。..&quot;</span>);</span><br><span class="line">  sleep(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;T2: 拿茶叶。..&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot; 龙井 &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 任务 3：任务 1 和任务 2 完成后执行：泡茶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f3 =</span><br><span class="line">  f1.thenCombine(f2, (__, tf)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 拿到茶叶：&quot;</span> + tf);</span><br><span class="line">    System.out.println(<span class="string">&quot;T1: 泡茶。..&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; 上茶：&quot;</span> + tf;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 等待任务 3 执行结果</span></span><br><span class="line">System.out.println(f3.join());</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> t, TimeUnit u)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    u.sleep(t);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次执行结果：</span></span><br><span class="line">T1: 洗水壶。..</span><br><span class="line">T2: 洗茶壶。..</span><br><span class="line">T1: 烧开水。..</span><br><span class="line">T2: 洗茶杯。..</span><br><span class="line">T2: 拿茶叶。..</span><br><span class="line">T1: 拿到茶叶：龙井</span><br><span class="line">T1: 泡茶。..</span><br><span class="line">上茶：龙井</span><br></pre></td></tr></table></figure>

<h3 id="创建-CompletableFuture-对象"><a href="#创建-CompletableFuture-对象" class="headerlink" title="创建 CompletableFuture 对象"></a>创建 CompletableFuture 对象</h3><p>默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism 来设置 ForkJoinPool 线程池的线程数）。如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I&#x2F;O 操作，就会导致线程池中所有线程都阻塞在 I&#x2F;O 操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要<strong>根据不同的业务类型创建不同的线程池，以避免互相干扰</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt;</span><br><span class="line">  <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt;</span><br><span class="line">  <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="comment">//可以指定线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt;</span><br><span class="line">  <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt;</span><br><span class="line">  <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure>

<p>创建完 CompletableFuture 对象之后，会自动地异步执行 runnable.run() 方法或者 supplier.get() 方法。</p>
<h3 id="如何理解-CompletionStage-接口"><a href="#如何理解-CompletionStage-接口" class="headerlink" title="如何理解 CompletionStage 接口"></a>如何理解 CompletionStage 接口</h3><p>CompletionStage 接口可以清晰地描述任务之间的这种时序关系，例如前面提到的 <code>f3 = f1.thenCombine(f2, ()-&gt;&#123;&#125;)</code> 描述的就是一种汇聚关系。</p>
<h4 id="1-描述串行关系"><a href="#1-描述串行关系" class="headerlink" title="1. 描述串行关系"></a>1. 描述串行关系</h4><p>CompletionStage 接口里面描述串行关系，主要是 thenApply、thenAccept、thenRun 和 thenCompose 这四个系列的接口。</p>
<p>thenApply 系列函数里参数 fn 的类型是接口 Function，这个接口里与 CompletionStage 相关的方法是 <code>R apply(T t)</code>，这个方法既能接收参数也支持返回值，所以 thenApply 系列方法返回的是<code>CompletionStage&lt;R&gt;</code>。</p>
<p>而 thenAccept 系列方法里参数 consumer 的类型是接口<code>Consumer&lt;T&gt;</code>，这个接口里与 CompletionStage 相关的方法是 <code>void accept(T t)</code>，这个方法虽然支持参数，但却不支持回值，所以 thenAccept 系列方法返回的是<code>CompletionStage&lt;Void&gt;</code>。</p>
<p>thenRun 系列方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值，所以 thenRun 系列方法返回的也是<code>CompletionStage&lt;Void&gt;</code>。</p>
<p>这些方法里面 Async 代表的是异步执行 fn、consumer 或者 action。其中，需要你注意的是 thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenApply</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenApplyAsync</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(action)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(action)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCompose</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenComposeAsync</span><span class="params">(fn)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-描述-AND-汇聚关系"><a href="#2-描述-AND-汇聚关系" class="headerlink" title="2. 描述 AND 汇聚关系"></a>2. 描述 AND 汇聚关系</h4><p>CompletionStage 接口里面描述 AND 汇聚关系，主要是 thenCombine、thenAcceptBoth 和 runAfterBoth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。它们的使用你可以参考上面烧水泡茶的实现程序，这里就不赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCombine</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCombineAsync</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(other, action)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(other, action)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-描述-OR-汇聚关系"><a href="#3-描述-OR-汇聚关系" class="headerlink" title="3. 描述 OR 汇聚关系"></a>3. 描述 OR 汇聚关系</h4><p>CompletionStage 接口里面描述 OR 汇聚关系，主要是 applyToEither、acceptEither 和 runAfterEither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage <span class="title function_">applyToEither</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage <span class="title function_">applyToEitherAsync</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage <span class="title function_">acceptEither</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage <span class="title function_">acceptEitherAsync</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage <span class="title function_">runAfterEither</span><span class="params">(other, action)</span>;</span><br><span class="line">CompletionStage <span class="title function_">runAfterEitherAsync</span><span class="params">(other, action)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="CompletionService：如何批量执行异步任务？"><a href="#CompletionService：如何批量执行异步任务？" class="headerlink" title="CompletionService：如何批量执行异步任务？"></a>CompletionService：如何批量执行异步任务？</h2><p>用三个线程异步执行询价，通过三次调用 Future 的 get() 方法获取询价结果，之后将询价结果保存在数据库中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 异步向电商 S1 询价</span></span><br><span class="line">Future&lt;Integer&gt; f1 =</span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商 S2 询价</span></span><br><span class="line">Future&lt;Integer&gt; f2 =</span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商 S3 询价</span></span><br><span class="line">Future&lt;Integer&gt; f3 =</span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS3());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取电商 S1 报价并保存</span></span><br><span class="line">r=f1.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取电商 S2 报价并保存</span></span><br><span class="line">r=f2.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取电商 S3 报价并保存</span></span><br><span class="line">r=f3.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br></pre></td></tr></table></figure>

<p>如果获取电商 S1 报价的耗时很长，那么即便获取电商 S2 报价的耗时很短，也无法让保存 S2 报价的操作先执行，因为这个主线程都阻塞在了 <code>f1.get()</code> 操作上。这点小瑕疵你该如何解决呢？</p>
<p>估计你已经想到了，增加一个阻塞队列，获取到 S1、S2、S3 的报价都进入阻塞队列，然后在主线程中消费阻塞队列，这样就能保证先获取到的报价先保存到数据库了。下面的示例代码展示了如何利用阻塞队列实现先获取到的报价先保存到数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建阻塞队列</span></span><br><span class="line">BlockingQueue&lt;Integer&gt; bq =</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//电商 S1 报价异步进入阻塞队列</span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f1.get()));</span><br><span class="line"><span class="comment">//电商 S2 报价异步进入阻塞队列</span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f2.get()));</span><br><span class="line"><span class="comment">//电商 S3 报价异步进入阻塞队列</span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f3.get()));</span><br><span class="line"><span class="comment">//异步保存所有报价</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> bq.take();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用-CompletionService-实现询价系统"><a href="#利用-CompletionService-实现询价系统" class="headerlink" title="利用 CompletionService 实现询价系统"></a>利用 CompletionService 实现询价系统</h3><p><strong>如何创建 CompletionService 呢？</strong></p>
<p>CompletionService 接口的实现类是 ExecutorCompletionService，这个实现类的构造方法有两个，分别是：</p>
<ol>
<li><code>ExecutorCompletionService(Executor executor)</code>；</li>
<li><code>ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</code>。</li>
</ol>
<p>这两个构造方法都需要传入一个线程池，如果不指定 completionQueue，那么默认会使用无界的 LinkedBlockingQueue。任务执行结果的 Future 对象就是加入到 completionQueue 中。</p>
<p>下面的示例代码完整地展示了如何利用 CompletionService 来实现高性能的询价系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建 CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span></span><br><span class="line">  <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商 S1 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商 S2 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商 S3 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> cs.take().get();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompletionService-接口说明"><a href="#CompletionService-接口说明" class="headerlink" title="CompletionService 接口说明"></a>CompletionService 接口说明</h3><p>CompletionService 接口提供的方法有 5 个，这 5 个方法的方法签名如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;V&gt; task)</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Runnable task, V result)</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">take</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="利用-CompletionService-实现-Dubbo-中的-Forking-Cluster"><a href="#利用-CompletionService-实现-Dubbo-中的-Forking-Cluster" class="headerlink" title="利用 CompletionService 实现 Dubbo 中的 Forking Cluster"></a>利用 CompletionService 实现 Dubbo 中的 Forking Cluster</h3><p>Dubbo 中有一种叫做** Forking 的集群模式<strong>，这种集群模式下，支持</strong>并行地调用多个查询服务，只要有一个成功返回结果，整个服务就可以返回了**。例如你需要提供一个地址转坐标的服务，为了保证该服务的高可用和性能，你可以并行地调用 3 个地图服务商的 API，然后只要有 1 个正确返回了结果 r，那么地址转坐标这个服务就可以直接返回 r 了。这种集群模式可以容忍 2 个地图服务商服务异常，但缺点是消耗的资源偏多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">geocoder(addr) &#123;</span><br><span class="line">  <span class="comment">//并行执行以下 3 个查询服务，</span></span><br><span class="line">  r1=geocoderByS1(addr);</span><br><span class="line">  r2=geocoderByS2(addr);</span><br><span class="line">  r3=geocoderByS3(addr);</span><br><span class="line">  <span class="comment">//只要 r1,r2,r3 有一个返回</span></span><br><span class="line">  <span class="comment">//则返回</span></span><br><span class="line">  <span class="keyword">return</span> r1|r2|r3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 CompletionService 可以快速实现 Forking 这种集群模式，比如下面的示例代码就展示了具体是如何实现的。首先我们创建了一个线程池 executor 、一个 CompletionService 对象 cs 和一个<code>Future&lt;Integer&gt;</code>类型的列表 futures，每次通过调用 CompletionService 的 submit() 方法提交一个异步任务，会返回一个 Future 对象，我们把这些 Future 对象保存在列表 futures 中。通过调用 <code>cs.take().get()</code>，我们能够拿到最快返回的任务执行结果，只要我们拿到一个正确返回的结果，就可以取消所有任务并且返回最终结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建 CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs =</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 用于保存 Future 对象</span></span><br><span class="line">List&lt;Future&lt;Integer&gt;&gt; futures =</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//提交异步任务，并保存 future 到 futures</span></span><br><span class="line">futures.add(</span><br><span class="line">  cs.submit(()-&gt;geocoderByS1()));</span><br><span class="line">futures.add(</span><br><span class="line">  cs.submit(()-&gt;geocoderByS2()));</span><br><span class="line">futures.add(</span><br><span class="line">  cs.submit(()-&gt;geocoderByS3()));</span><br><span class="line"><span class="comment">// 获取最快返回的任务执行结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 只要有一个成功返回，则 break</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    r = cs.take().get();</span><br><span class="line">    <span class="comment">//简单地通过判空来检查是否成功返回</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//取消所有任务</span></span><br><span class="line">  <span class="keyword">for</span>(Future&lt;Integer&gt; f : futures)</span><br><span class="line">    f.cancel(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>当需要批量提交异步任务的时候建议你使用 CompletionService。CompletionService 将线程池 Executor 和阻塞队列 BlockingQueue 的功能融合在了一起，能够让批量异步任务的管理更简单。除此之外，CompletionService 能够让异步任务的执行结果有序化，先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如 Forking Cluster 这样的需求。</p>
<p>CompletionService 的实现类 ExecutorCompletionService，需要你自己创建线程池，虽看上去有些啰嗦，但好处是你可以让多个 ExecutorCompletionService 的线程池隔离，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</p>
<h2 id="Fork-Join：单机版的-MapReduce"><a href="#Fork-Join：单机版的-MapReduce" class="headerlink" title="Fork_Join：单机版的 MapReduce"></a>Fork_Join：单机版的 MapReduce</h2><p><strong>对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292001191.png"></p>
<p>除了简单并行、聚合、批量并行这三种任务模型，还有一种“分治”的任务模型。</p>
<p><strong>分治</strong>，顾名思义，即分而治之，是一种解决复杂问题的思维方法和模式；具体来讲，指的是<strong>把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解</strong>。理论上来讲，解决每一个问题都对应着一个任务，所以对于问题的分治，实际上就是对于任务的分治。</p>
<h3 id="分治任务模型"><a href="#分治任务模型" class="headerlink" title="分治任务模型"></a>分治任务模型</h3><p>这里你需要先深入了解一下分治任务模型，分治任务模型可分为两个阶段：一个阶段是<strong>任务分解</strong>，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；另一个阶段是<strong>结果合并</strong>，即逐层合并子任务的执行结果，直至获得最终结果。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292012846.png"></p>
<p>简版分治任务模型图</p>
<p>在这个分治任务模型里，任务和分解后的子任务具有相似性，这种相似性往往体现在任务和子任务的算法是相同的，但是计算的数据规模是不同的。具备这种相似性的问题，我们往往都采用递归算法。</p>
<h3 id="Fork-Join-的使用"><a href="#Fork-Join-的使用" class="headerlink" title="Fork&#x2F;Join 的使用"></a>Fork&#x2F;Join 的使用</h3><p>Fork&#x2F;Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的** Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并<strong>。Fork&#x2F;Join 计算框架主要包含两部分，一部分是</strong>分治任务的线程池 ForkJoinPool<strong>，另一部分是</strong>分治任务 ForkJoinTask**。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p>
<p>接下来我们就来实现一下，看看如何用 Fork&#x2F;Join 这个并行计算框架计算斐波那契数列（下面的代码源自 Java 官方示例）。首先我们需要创建一个分治任务线程池以及计算斐波那契数列的分治任务，之后通过调用分治任务线程池的 invoke() 方法来启动分治任务。由于计算斐波那契数列需要有返回值，所以 Fibonacci 继承自 RecursiveTask。分治任务 Fibonacci 需要实现 compute() 方法，这个方法里面的逻辑和普通计算斐波那契数列非常类似，区别之处在于计算 <code>Fibonacci(n - 1)</code> 使用了异步子任务，这是通过 <code>f1.fork()</code> 这条语句实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="comment">//创建分治任务线程池</span></span><br><span class="line">  <span class="type">ForkJoinPool</span> <span class="variable">fjp</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">//创建分治任务</span></span><br><span class="line">  <span class="type">Fibonacci</span> <span class="variable">fib</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="comment">//启动分治任务</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">    fjp.invoke(fib);</span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span></span><br><span class="line">    <span class="title class_">RecursiveTask</span>&lt;Integer&gt;&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">  Fibonacci(<span class="type">int</span> n)&#123;<span class="built_in">this</span>.n = n;&#125;</span><br><span class="line">  <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建子任务</span></span><br><span class="line">    f1.fork();</span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//等待子任务结果，并合并结果</span></span><br><span class="line">    <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoinPool-工作原理"><a href="#ForkJoinPool-工作原理" class="headerlink" title="ForkJoinPool 工作原理"></a>ForkJoinPool 工作原理</h2><p>ForkJoinPool 本质上也是一个生产者-消费者的实现，但是更加智能，ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p>
<p>如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“<strong>任务窃取</strong>”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。</p>
<p>ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408292016364.png"></p>
<h3 id="模拟-MapReduce-统计单词数量"><a href="#模拟-MapReduce-统计单词数量" class="headerlink" title="模拟 MapReduce 统计单词数量"></a>模拟 MapReduce 统计单词数量</h3><p>学习 MapReduce 有一个入门程序，统计一个文件里面每个单词的数量，下面我们来看看如何用 Fork&#x2F;Join 并行计算框架来实现。</p>
<p>我们可以先用二分法递归地将一个文件拆分成更小的文件，直到文件里只有一行数据，然后统计这一行数据里单词的数量，最后再逐级汇总结果，你可以对照前面的简版分治任务模型图来理解这个过程。</p>
<p>思路有了，我们马上来实现。下面的示例程序用一个字符串数组 <code>String[] fc</code> 来模拟文件内容，fc 里面的元素与文件里面的行数据一一对应。关键的代码在 <code>compute()</code> 这个方法里面，这是一个递归方法，前半部分数据 fork 一个递归任务去处理（关键代码 mr1.fork()），后半部分数据则在当前任务中递归处理（mr2.compute()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  String[] fc = &#123;<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">          <span class="string">&quot;hello me&quot;</span>,</span><br><span class="line">          <span class="string">&quot;hello fork&quot;</span>,</span><br><span class="line">          <span class="string">&quot;hello join&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fork join in world&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">//创建 ForkJoin 线程池</span></span><br><span class="line">  <span class="type">ForkJoinPool</span> <span class="variable">fjp</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//创建任务</span></span><br><span class="line">  <span class="type">MR</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(</span><br><span class="line">      fc, <span class="number">0</span>, fc.length);</span><br><span class="line">  <span class="comment">//启动任务</span></span><br><span class="line">  Map&lt;String, Long&gt; result =</span><br><span class="line">      fjp.invoke(mr);</span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  result.forEach((k, v)-&gt;</span><br><span class="line">    System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MR 模拟类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MR</span> <span class="keyword">extends</span></span><br><span class="line">  <span class="title class_">RecursiveTask</span>&lt;Map&lt;String, Long&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] fc;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> start, end;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  MR(String[] fc, <span class="type">int</span> fr, <span class="type">int</span> to)&#123;</span><br><span class="line">    <span class="built_in">this</span>.fc = fc;</span><br><span class="line">    <span class="built_in">this</span>.start = fr;</span><br><span class="line">    <span class="built_in">this</span>.end = to;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span></span><br><span class="line">  Map&lt;String, Long&gt; <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> calc(fc[start]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end)/<span class="number">2</span>;</span><br><span class="line">      <span class="type">MR</span> <span class="variable">mr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(</span><br><span class="line">          fc, start, mid);</span><br><span class="line">      mr1.fork();</span><br><span class="line">      <span class="type">MR</span> <span class="variable">mr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(</span><br><span class="line">          fc, mid, end);</span><br><span class="line">      <span class="comment">//计算子任务，并返回合并的结果</span></span><br><span class="line">      <span class="keyword">return</span> merge(mr2.compute(),</span><br><span class="line">          mr1.join());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//合并结果</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Long&gt; <span class="title function_">merge</span><span class="params">(</span></span><br><span class="line"><span class="params">      Map&lt;String, Long&gt; r1,</span></span><br><span class="line"><span class="params">      Map&lt;String, Long&gt; r2)</span> &#123;</span><br><span class="line">    Map&lt;String, Long&gt; result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    result.putAll(r1);</span><br><span class="line">    <span class="comment">//合并结果</span></span><br><span class="line">    r2.forEach((k, v) -&gt; &#123;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">c</span> <span class="operator">=</span> result.get(k);</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="literal">null</span>)</span><br><span class="line">        result.put(k, c+v);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result.put(k, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//统计单词数量</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Long&gt;</span><br><span class="line">      <span class="title function_">calc</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    Map&lt;String, Long&gt; result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//分割单词</span></span><br><span class="line">    String [] words =</span><br><span class="line">        line.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">    <span class="comment">//统计单词数量</span></span><br><span class="line">    <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">v</span> <span class="operator">=</span> result.get(w);</span><br><span class="line">      <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">        result.put(w, v+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result.put(w, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Fork&#x2F;Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork&#x2F;Join 看作单机版的 MapReduce。</p>
<p>Fork&#x2F;Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I&#x2F;O 密集型的并行流计算，那么很可能会因为一个很慢的 I&#x2F;O 计算而拖慢整个系统的性能。所以<strong>建议用不同的 ForkJoinPool 执行不同类型的计算任务</strong>。</p>
<p>如果你对 ForkJoinPool 详细的实现细节感兴趣，也可以参考 <a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">Doug Lea 的论文</a>。</p>
<h2 id="并发工具类模块热点问题答疑"><a href="#并发工具类模块热点问题答疑" class="headerlink" title="并发工具类模块热点问题答疑"></a>并发工具类模块热点问题答疑</h2><p>略</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a3e4ca88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a3e4ca88/" class="post-title-link" itemprop="url">《极客时间教程 - 深入拆解 Java 虚拟机》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-07 07:22:58" itemprop="dateCreated datePublished" datetime="2024-08-07T07:22:58+08:00">2024-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-深入拆解-Java-虚拟机》笔记"><a href="#《极客时间教程-深入拆解-Java-虚拟机》笔记" class="headerlink" title="《极客时间教程 - 深入拆解 Java 虚拟机》笔记"></a>《极客时间教程 - 深入拆解 Java 虚拟机》笔记</h1><h2 id="开篇词-为什么我们要学习-Java-虚拟机？"><a href="#开篇词-为什么我们要学习-Java-虚拟机？" class="headerlink" title="开篇词 为什么我们要学习 Java 虚拟机？"></a>开篇词 为什么我们要学习 Java 虚拟机？</h2><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/414248014bf825dd610c3095eed75377.jpg"></p>
<h2 id="Java-代码是怎么运行的？"><a href="#Java-代码是怎么运行的？" class="headerlink" title="Java 代码是怎么运行的？"></a>Java 代码是怎么运行的？</h2><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/ab5c3523af08e0bf2f689c1d6033ef77.png"></p>
<p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p>
<p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</p>
<p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。</p>
<p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/5ee351091464de78eed75438b6f9183b.png"></p>
<h2 id="Java-的基本类型"><a href="#Java-的基本类型" class="headerlink" title="Java 的基本类型"></a>Java 的基本类型</h2><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/77dfb788a8ad5877e77fc28ed2d51745.png"></p>
<h2 id="Java-虚拟机是如何加载-Java-类的"><a href="#Java-虚拟机是如何加载-Java-类的" class="headerlink" title="Java 虚拟机是如何加载 Java 类的"></a>Java 虚拟机是如何加载 Java 类的</h2><ul>
<li>加载 - 是指查找字节流，并且据此创建类的过程。</li>
<li>链接 - 是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。<ul>
<li>验证 - 确保被加载类能够满足 Java 虚拟机的约束条件。</li>
<li>准备 - 为被加载类的静态字段分配内存。</li>
<li>解析 - 将符号引用解析为直接引用。</li>
</ul>
</li>
<li>初始化 - 为标记为常量值的字段赋值，以及执行 <code>&lt;clinit&gt;</code> 方法的过程。Java 虚拟机会通过加锁来确保类的 <code>&lt;clinit&gt;</code> 方法仅被执行一次。</li>
</ul>
<h2 id="JVM-是如何执行方法调用的？（上）"><a href="#JVM-是如何执行方法调用的？（上）" class="headerlink" title="JVM 是如何执行方法调用的？（上）"></a>JVM 是如何执行方法调用的？（上）</h2><p>重载指的是方法名相同而参数类型不相同的方法之间的关系。</p>
<p>重写指的是子类中定义和父类方法名相同且参数类型相同的方法。</p>
<p>重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ol>
<li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；</li>
<li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；</li>
<li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。</li>
</ol>
<h2 id="JVM-是如何执行方法调用的？（下）"><a href="#JVM-是如何执行方法调用的？（下）" class="headerlink" title="JVM 是如何执行方法调用的？（下）"></a>JVM 是如何执行方法调用的？（下）</h2><p>虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。</p>
<p>否则，Java 虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。</p>
<p>Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。</p>
<p>在解析虚方法调用时，Java 虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。</p>
<p>Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。</p>
<p>当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。</p>
<p>否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。</p>
<h2 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h2><p>Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/17e2a3053b06b0a4383884f106e31c06.png"></p>
<h2 id="JVM-是如何实现反射的？"><a href="#JVM-是如何实现反射的？" class="headerlink" title="JVM 是如何实现反射的？"></a>JVM 是如何实现反射的？</h2><p>在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。</p>
<p>方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。</p>
<h2 id="JVM-是怎么实现-invokedynamic-的？（上）"><a href="#JVM-是怎么实现-invokedynamic-的？（上）" class="headerlink" title="JVM 是怎么实现 invokedynamic 的？（上）"></a>JVM 是怎么实现 invokedynamic 的？（上）</h2><p>invokedynamic 底层机制的基石：方法句柄。</p>
<p>方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。</p>
<p>方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。</p>
<p>方法句柄的调用和反射调用一样，都是间接调用，同样会面临无法内联的问题。</p>
<h2 id="JVM-是怎么实现-invokedynamic-的？（下）"><a href="#JVM-是怎么实现-invokedynamic-的？（下）" class="headerlink" title="JVM 是怎么实现 invokedynamic 的？（下）"></a>JVM 是怎么实现 invokedynamic 的？（下）</h2><p>invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。</p>
<p>Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。</p>
<p>对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。</p>
<p>不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。</p>
<h2 id="Java-对象的内存布局"><a href="#Java-对象的内存布局" class="headerlink" title="Java 对象的内存布局"></a>Java 对象的内存布局</h2><h3 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h3><p>在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由标记字段和类型指针所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。</p>
<p>在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。</p>
<p>Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。</p>
<h3 id="字段重排序"><a href="#字段重排序" class="headerlink" title="字段重排序"></a>字段重排序</h3><h2 id="垃圾回收（上）"><a href="#垃圾回收（上）" class="headerlink" title="垃圾回收（上）"></a>垃圾回收（上）</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p>
<p>如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>
<p>GC Roots 包括（但不限于）如下几种：</p>
<ol>
<li>Java 方法栈桢中的局部变量；</li>
<li>已加载类的静态变量；</li>
<li>JNI handles；</li>
<li>已启动且未停止的 Java 线程。</li>
</ol>
<h3 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop-the-world"></a>Stop-the-world</h3><p>传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p>
<h3 id="垃圾回收方式"><a href="#垃圾回收方式" class="headerlink" title="垃圾回收方式"></a>垃圾回收方式</h3><h4 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h4><p>标记-复制把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/4749cad235deb1542d4ca3b232ebf261.png"></p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>标记-清除即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/f225126be24826658ca5a899fcff5003.png"></p>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p>标记-整理把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/415ee8e4aef12ff076b42e41660dad39.png"></p>
<h2 id="垃圾回收（下）"><a href="#垃圾回收（下）" class="headerlink" title="垃圾回收（下）"></a>垃圾回收（下）</h2><p>Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p>
<p>可以通过参数 -XX:SurvivorRatio 来调整 Eden 区和 Survivor 区的比例。</p>
<p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%8b%86%e8%a7%a3Java%e8%99%9a%e6%8b%9f%e6%9c%ba/assets/2cc29b8de676d3747416416a3523e4e5.png"></p>
<p>当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p>
<p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p>
<p>总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型还定义了下述线程间的 happens-before 关系。</p>
<ol>
<li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li>
<li>volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li>
<li>线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。</li>
<li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。</li>
<li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li>
<li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li>
</ol>
<p>happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。</p>
<h2 id="Java-虚拟机是怎么实现-synchronized-的？"><a href="#Java-虚拟机是怎么实现-synchronized-的？" class="headerlink" title="Java 虚拟机是怎么实现 synchronized 的？"></a>Java 虚拟机是怎么实现 synchronized 的？</h2><p>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。</p>
<p>当用 synchronized 标记方法时，你会看到字节码中方法的访问标记包括 ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机需要进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机均需要进行 monitorexit 操作。</p>
<h2 id="Java-语法糖与-Java-编译器"><a href="#Java-语法糖与-Java-编译器" class="headerlink" title="Java 语法糖与 Java 编译器"></a>Java 语法糖与 Java 编译器</h2><p>Java 程序中的泛型信息会被擦除。具体来说，Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的具体类。</p>
<h2 id="即时编译（上）"><a href="#即时编译（上）" class="headerlink" title="即时编译（上）"></a>即时编译（上）</h2><p>从 Java 8 开始，Java 虚拟机默认采用分层编译的方式。它将执行分为五个层次，分为为 0 层解释执行，1 层执行没有 profiling 的 C1 代码，2 层执行部分 profiling 的 C1 代码，3 层执行全部 profiling 的 C1 代码，和 4 层执行 C2 代码。</p>
<p>通常情况下，方法会首先被解释执行，然后被 3 层的 C1 编译，最后被 4 层的 C2 编译。</p>
<p>即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。</p>
<p>OSR 是一种能够在非方法入口处进行解释执行和编译后代码之间切换的技术。OSR 编译可以用来解决单次调用方法包含热循环的性能优化问题。</p>
<h2 id="即时编译（下）"><a href="#即时编译（下）" class="headerlink" title="即时编译（下）"></a>即时编译（下）</h2><p>通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。</p>
<p>当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支 profile，以及类型相关指令的类型 profile。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profile。</p>
<p>基于分支 profile 的优化以及基于类型 profile 的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile。</p>
<h2 id="即时编译器的中间表达形式"><a href="#即时编译器的中间表达形式" class="headerlink" title="即时编译器的中间表达形式"></a>即时编译器的中间表达形式</h2><p>即时编译器将所输入的 Java 字节码转换成 SSA IR，以便更好地进行优化。</p>
<h2 id="Java-字节码（基础篇）"><a href="#Java-字节码（基础篇）" class="headerlink" title="Java 字节码（基础篇）"></a>Java 字节码（基础篇）</h2><p>Java 方法的栈桢分为操作数栈和局部变量区。通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。</p>
<p>Java 字节码可以划分为很多种类型，如加载常量指令，操作数栈专用指令，局部变量区访问指令，Java 相关指令，方法调用指令，数组相关指令，控制流指令，以及计算相关指令。</p>
<h2 id="方法内联（上）"><a href="#方法内联（上）" class="headerlink" title="方法内联（上）"></a>方法内联（上）</h2><p>方法内联是指，在编译过程中，当遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。</p>
<p>即时编译器既可以在解析过程中替换方法调用字节码，也可以在 IR 图中替换方法调用 IR 节点。这两者都需要将目标方法的参数以及返回值映射到当前方法来。</p>
<p>方法内联有许多规则。除了一些强制内联以及强制不内联的规则外，即时编译器会根据方法调用的层数、方法调用指令所在的程序路径的热度、目标方法的调用次数及大小，以及当前 IR 图的大小来决定方法调用能否被内联。</p>
<h2 id="方法内联（下）"><a href="#方法内联（下）" class="headerlink" title="方法内联（下）"></a>方法内联（下）</h2><p>完全去虚化通过类型推导或者类层次分析，将虚方法调用转换为直接调用。它的关键在于证明虚方法调用的目标方法是唯一的。</p>
<p>条件去虚化通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。它将借助 Java 虚拟机所收集的类型 Profile。</p>
<h2 id="HotSpot-虚拟机的-intrinsic"><a href="#HotSpot-虚拟机的-intrinsic" class="headerlink" title="HotSpot 虚拟机的 intrinsic"></a>HotSpot 虚拟机的 intrinsic</h2><p>HotSpot 虚拟机将对标注了<code>@HotSpotIntrinsicCandidate</code>注解的方法的调用，替换为直接使用基于特定 CPU 指令的高效实现。这些方法我们便称之为 intrinsic。</p>
<p>具体来说，intrinsic 的实现有两种。一是不大常见的桩程序，可以在解释执行或者即时编译生成的代码中使用。二是特殊的 IR 节点。即时编译器将在方法内联过程中，将对 intrinsic 的调用替换为这些特殊的 IR 节点，并最终生成指定的 CPU 指令。</p>
<p>HotSpot 虚拟机定义了三百多个 intrinsic。其中比较特殊的有<code>Unsafe</code>类的方法，基本上使用 java.util.concurrent 包便会间接使用到<code>Unsafe</code>类的 intrinsic。除此之外，<code>String</code>类和<code>Arrays</code>类中的 intrinsic 也比较特殊。即时编译器将为之生成非常高效的 SIMD 指令。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>Java 中<code>Iterable</code>对象的 foreach 循环遍历是一个语法糖，Java 编译器会将该语法糖编译为调用<code>Iterable</code>对象的<code>iterator</code>方法，并用所返回的<code>Iterator</code>对象的<code>hasNext</code>以及<code>next</code>方法，来完成遍历。</p>
<p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。</p>
<p>在 Java 虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否会逃逸。即时编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。</p>
<p>即时编译器会根据逃逸分析的结果进行优化，如锁消除以及标量替换。后者指的是将原本连续分配的对象拆散为一个个单独的字段，分布在栈上或者寄存器中。</p>
<p>部分逃逸分析是一种附带了控制流信息的逃逸分析。它将判断新建对象真正逃逸的分支，并且支持将新建操作推延至逃逸分支。</p>
<h2 id="字段访问相关优化"><a href="#字段访问相关优化" class="headerlink" title="字段访问相关优化"></a>字段访问相关优化</h2><p>即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。</p>
<p>这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。</p>
<p>即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。</p>
<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>循环无关代码外提将循环中值不变的表达式，或者循环无关检测外提至循环之前，以避免在循环中重复进行冗余计算。前者是通过 Sea-of-Nodes IR 以及节点调度来共同完成的，而后者则是通过一个独立优化 —— 循环预测来完成的。循环预测还可以外提循环有关的数组下标范围检测。</p>
<p>循环展开是一种在循环中重复多次迭代，并且相应地减少循环次数的优化方式。它是一种以空间换时间的优化方式，通过增大循环体来获取更多的优化机会。循环展开的特殊形式是完全展开，将原本的循环转换成若干个循环体的顺序执行。</p>
<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>向量化优化借助的是 CPU 的 SIMD 指令，即通过单条指令控制多组数据的运算。它被称为 CPU 指令级别的并行。</p>
<p>HotSpot 虚拟机运用向量化优化的方式有两种。第一种是使用 HotSpot intrinsic，在调用特定方法的时候替换为使用了 SIMD 指令的高效实现。Intrinsic 属于点覆盖，只有当应用程序明确需要这些 intrinsic 的语义，才能够获得由它带来的性能提升。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><h2 id="基准测试框架-JMH（上）"><a href="#基准测试框架-JMH（上）" class="headerlink" title="基准测试框架 JMH（上）"></a>基准测试框架 JMH（上）</h2><p>性能基准测试框架 JMH 是 OpenJDK 中的其中一个开源项目。它内置了许多功能，来规避由 Java 虚拟机中的即时编译器或者其他优化对性能测试造成的影响。此外，它还提供了不少策略来降低来自操作系统以及硬件系统的影响。</p>
<p>开发人员仅需将所要测试的业务逻辑通过<code>@Benchmark</code>注解，便可以让 JMH 的注解处理器自动生成真正的性能测试代码，以及相应的性能测试配置文件。</p>
<h2 id="基准测试框架-JMH（下）"><a href="#基准测试框架-JMH（下）" class="headerlink" title="基准测试框架 JMH（下）"></a>基准测试框架 JMH（下）</h2><ul>
<li><code>@Fork</code>允许开发人员指定所要 Fork 出的 Java 虚拟机的数目。</li>
<li><code>@BenchmarkMode</code>允许指定性能数据的格式。</li>
<li><code>@Warmup</code>和<code>@Measurement</code>允许配置预热迭代或者测试迭代的数目，每个迭代的时间以及每个操作包含多少次对测试方法的调用。</li>
<li><code>@State</code>允许配置测试程序的状态。测试前对程序状态的初始化以及测试后对程序状态的恢复或者校验可分别通过<code>@Setup</code>和<code>@TearDown</code>来实现。</li>
</ul>
<h2 id="Java-虚拟机的监控及诊断工具（命令行篇）"><a href="#Java-虚拟机的监控及诊断工具（命令行篇）" class="headerlink" title="Java 虚拟机的监控及诊断工具（命令行篇）"></a>Java 虚拟机的监控及诊断工具（命令行篇）</h2><ul>
<li><code>jps</code>将打印所有正在运行的 Java 进程。</li>
<li><code>jstat</code>允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li>
<li><code>jmap</code>允许用户统计目标 Java 进程的堆中存放的 Java 对象，并将它们导出成二进制文件。</li>
<li><code>jinfo</code>将打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</li>
<li><code>jstack</code>将打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li>
<li><code>jcmd</code>则是一把瑞士军刀，可以用来实现前面除了<code>jstat</code>之外所有命令的功能。</li>
</ul>
<h2 id="Java-虚拟机的监控及诊断工具（GUI-篇）"><a href="#Java-虚拟机的监控及诊断工具（GUI-篇）" class="headerlink" title="Java 虚拟机的监控及诊断工具（GUI 篇）"></a>Java 虚拟机的监控及诊断工具（GUI 篇）</h2><p>Eclipse MAT 可用于分析由<code>jmap</code>命令导出的 Java 堆快照。它包括两个相对比较重要的视图，分别为直方图和支配树。直方图展示了各个类的实例数目以及这些实例的 Shallow heap 或 Retained heap 的总和。支配树则展示了快照中每个对象所直接支配的对象。</p>
<p>Java Mission Control 是 Java 虚拟机平台上的性能监控工具。Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。</p>
<h2 id="JNI-的运行机制"><a href="#JNI-的运行机制" class="headerlink" title="JNI 的运行机制"></a>JNI 的运行机制</h2><p>Java 中的 native 方法的链接方式主要有两种。一是按照 JNI 的默认规范命名所要链接的 C 函数，并依赖于 Java 虚拟机自动链接。另一种则是在 C 代码中主动链接。</p>
<p>JNI 提供了一系列 API 来允许 C 代码使用 Java 语言特性。这些 API 不仅使用了特殊的数据结构来表示 Java 类，还拥有特殊的异常处理模式。</p>
<p>JNI 中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的 Java 对象。不同的是，局部引用在 native 方法调用返回之后便会失效。传入参数以及大部分 JNI API 函数的返回值都属于局部引用。</p>
<h2 id="JavaAgent-与字节码注入"><a href="#JavaAgent-与字节码注入" class="headerlink" title="JavaAgent 与字节码注入"></a>JavaAgent 与字节码注入</h2><h2 id="Graal：用-Java-编译-Java"><a href="#Graal：用-Java-编译-Java" class="headerlink" title="Graal：用 Java 编译 Java"></a>Graal：用 Java 编译 Java</h2><p>Graal 是一个用 Java 写就的、并能够将 Java 字节码转换成二进制码的即时编译器。它通过 JVMCI 与 Java 虚拟机交互，响应由后者发出的编译请求、完成编译并部署编译结果。</p>
<p>对 Java 程序而言，Graal 编译结果的性能略优于 OpenJDK 中的 C2；对 Scala 程序而言，它的性能优势可达到 10%（企业版甚至可以达到 20%！）。这背后离不开 Graal 所采用的激进优化方式。</p>
<h2 id="Truffle：语言实现框架"><a href="#Truffle：语言实现框架" class="headerlink" title="Truffle：语言实现框架"></a>Truffle：语言实现框架</h2><p>Truffle 是一个语言实现框架，允许语言开发者在仅实现词法解析、语法解析以及 AST 解释器的情况下，达到极佳的性能。目前 Oracle Labs 已经实现并维护了 JavaScript、Ruby、R、Python 以及可用于解析 LLVM bitcode 的 Sulong。后者将支持在 GraalVM 上运行 C&#x2F;C++ 代码。</p>
<p>Truffle 背后所依赖的技术是 Partial Evaluation 以及节点重写。Partial Evaluation 指的是将所要编译的目标程序解析生成的抽象语法树当做编译时常量，特化该 Truffle 语言的解释器，从而得到指代这段程序解释执行过程的 Java 代码。然后，我们可以借助 Graal 编译器将这段 Java 代码即时编译为机器码。</p>
<p>节点重写则是收集 AST 节点的类型，根据所收集的类型 profile 进行的特化，并在节点类型不匹配时进行去优化并重新收集、编译的一项技术。</p>
<p>Truffle 的 Polyglot 特性支持在一段代码中混用多种不同的语言。与其他 Polyglot 框架相比，它支持在不同的 Truffle 语言中复用内存中存储的同一个对象。</p>
<h2 id="SubstrateVM：AOT-编译框架"><a href="#SubstrateVM：AOT-编译框架" class="headerlink" title="SubstrateVM：AOT 编译框架"></a>SubstrateVM：AOT 编译框架</h2><p>SubstrateVM 的设计初衷是提供一个高启动性能、低内存开销，和能够无缝衔接 C 代码的 Java 运行时。它是一个独立的运行时，拥有自己的内存管理等组件。</p>
<p>SubstrateVM 要求所要 AOT 编译的目标程序是封闭的，即不能动态加载其他类库等。在进行 AOT 编译时，它会探索所有可能运行到的方法，并全部纳入编译范围之内。</p>
<p>SubstrateVM 的启动时间和内存开销都非常少，这主要得益于在 AOT 编译时便已保存了已初始化好的堆快照，并支持从程序入口直接开始运行。作为对比，HotSpot 虚拟机在执行 main 方法前需要执行一系列的初始化操作，因此启动时间和内存开销都要远大于运行在 SubstrateVM 上的程序。</p>
<p>Metropolis 项目将运用 SubstrateVM 项目，逐步地将 HotSpot 虚拟机中的 C++ 代码替换成 Java 代码，从而提升 HotSpot 虚拟机的可维护性，也加快新 Java 功能的开发效率。</p>
<h2 id="尾声丨道阻且长，努力加餐。html"><a href="#尾声丨道阻且长，努力加餐。html" class="headerlink" title="尾声丨道阻且长，努力加餐。html"></a>尾声丨道阻且长，努力加餐。html</h2><h2 id="工具篇-常用工具介绍"><a href="#工具篇-常用工具介绍" class="headerlink" title="工具篇 常用工具介绍"></a>工具篇 常用工具介绍</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"959ec09ecbedf408139d2243623af878"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
