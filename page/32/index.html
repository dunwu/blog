<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/32/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/32/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/32/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/76e764a2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/76e764a2/" class="post-title-link" itemprop="url">Java 并发面试一</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-04 13:51:00" itemprop="dateCreated datePublished" datetime="2020-06-04T13:51:00+08:00">2020-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发面试一"><a href="#Java-并发面试一" class="headerlink" title="Java 并发面试一"></a>Java 并发面试一</h1><h2 id="并发简介"><a href="#并发简介" class="headerlink" title="并发简介"></a>并发简介</h2><h3 id="【简单】并发和并行有什么区别？"><a href="#【简单】并发和并行有什么区别？" class="headerlink" title="【简单】并发和并行有什么区别？"></a>【简单】并发和并行有什么区别？</h3><blockquote>
<ul>
<li>什么是并发？</li>
<li>什么是并行？</li>
<li>并发和并行有什么区别？</li>
</ul>
</blockquote>
<p>并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是<strong>同时</strong>发生：</p>
<ul>
<li><strong>并发是指具备处理多个任务的能力，但不一定要同时</strong>。</li>
<li><strong>并行是指具备同时处理多个任务的能力</strong>。</li>
</ul>
<p>下面是我见过最生动的说明，摘自 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33515481/answer/58849148">并发与并行的区别是什么？——知乎的高票答案</a></p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<h3 id="【简单】同步和异步有什么区别？"><a href="#【简单】同步和异步有什么区别？" class="headerlink" title="【简单】同步和异步有什么区别？"></a>【简单】同步和异步有什么区别？</h3><blockquote>
<ul>
<li>什么是同步？</li>
<li>什么是异步？</li>
<li>同步和异步有什么区别？</li>
</ul>
</blockquote>
<ul>
<li><strong>同步</strong>：顺序执行，必须等待当前任务完成才能继续，会阻塞后续操作。</li>
<li><strong>异步</strong>：不等待当前任务完成，直接执行后续操作，任务完成后通过回调&#x2F;通知返回结果。</li>
</ul>
<p>比喻：</p>
<ul>
<li>同步就像是打电话：不挂电话，通话不会结束。</li>
<li>异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。</li>
</ul>
<h3 id="【简单】阻塞和非阻塞有什么区别？"><a href="#【简单】阻塞和非阻塞有什么区别？" class="headerlink" title="【简单】阻塞和非阻塞有什么区别？"></a>【简单】阻塞和非阻塞有什么区别？</h3><blockquote>
<ul>
<li>什么是阻塞？</li>
<li>阻塞和非阻塞有什么区别？</li>
</ul>
</blockquote>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：</p>
<ul>
<li><strong>阻塞</strong>：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li><strong>非阻塞</strong>：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>比喻：</p>
<ul>
<li>阻塞：排队等奶茶，不拿到不走；</li>
<li>非阻塞：点完奶茶去逛街，店员短信通知后再取。</li>
</ul>
<h3 id="【中等】进程、线程、协程、管程有什么区别？"><a href="#【中等】进程、线程、协程、管程有什么区别？" class="headerlink" title="【中等】进程、线程、协程、管程有什么区别？"></a>【中等】进程、线程、协程、管程有什么区别？</h3><p>进程、线程、协程、管程对比：</p>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>定义</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>进程</strong></td>
<td><strong>可视为一个正在运行的程序</strong></td>
<td>独立内存空间<br>切换开销大<br>进程间通信（IPC）较复杂</td>
<td>需要高隔离性的任务（如浏览器多标签）</td>
</tr>
<tr>
<td><strong>线程</strong></td>
<td><strong>CPU 调度的基本单位</strong>（属于进程）</td>
<td>共享进程内存<br>切换开销较小<br>需同步（锁）避免竞态</td>
<td>高并发任务（如Web服务器处理请求）</td>
</tr>
<tr>
<td><strong>协程</strong></td>
<td><strong>用户态轻量级线程</strong>（协作式调度）</td>
<td>无内核切换开销<br>由程序员控制切换（<code>yield</code>）<br>单线程内并发</td>
<td>I&#x2F;O密集型高并发（如爬虫、异步编程）</td>
</tr>
<tr>
<td><strong>管程</strong></td>
<td><strong>管理共享资源的同步机制</strong>（如锁、条件变量）</td>
<td>封装线程同步逻辑<br>避免手动操作锁（如Java <code>synchronized</code>）</td>
<td>多线程共享资源（如线程安全的数据结构）</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：</p>
<ul>
<li><strong>进程</strong>：隔离性强但开销大。</li>
<li><strong>线程</strong>：CPU 调度的基本单位，共享内存但需同步。</li>
<li><strong>协程</strong>：用户态线程，高效但需主动让出控制权。</li>
<li><strong>管程</strong>：同步工具，简化多线程资源共享。</li>
</ul>
<p>进程和线程的差异：</p>
<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/processes-vs-threads.jpg" alt="img"></p>
<p>JVM 在单个进程中运行，JVM 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。</p>
<h3 id="【中等】Java-线程和操作系统的线程有什么区别？"><a href="#【中等】Java-线程和操作系统的线程有什么区别？" class="headerlink" title="【中等】Java 线程和操作系统的线程有什么区别？"></a>【中等】Java 线程和操作系统的线程有什么区别？</h3><p>以下是 Java 线程与操作系统线程的区别对比表：</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>Java 线程</strong></th>
<th><strong>操作系统线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象层级</strong></td>
<td>JVM 层面的用户态抽象（现代 JVM 1:1 映射到 OS 线程）</td>
<td>内核直接管理的原生线程（内核态）</td>
</tr>
<tr>
<td><strong>调度机制</strong></td>
<td>依赖 OS 调度，但可通过协程（如虚拟线程）优化</td>
<td>完全由内核抢占式调度</td>
</tr>
<tr>
<td><strong>创建&#x2F;切换开销</strong></td>
<td>高（需系统调用），但线程池可优化</td>
<td>高（上下文切换涉及用户态-内核态切换）</td>
</tr>
<tr>
<td><strong>并发模型</strong></td>
<td>支持 1:1（默认）和 M:N（虚拟线程）</td>
<td>仅 1:1，并发数受内核限制</td>
</tr>
<tr>
<td><strong>平台依赖性</strong></td>
<td>跨平台（JVM 统一行为，底层实现因 OS 而异）</td>
<td>直接依赖 OS 和硬件特性（如线程优先级实现不同）</td>
</tr>
<tr>
<td><strong>同步机制</strong></td>
<td>高级抽象（如<code>synchronized</code>，映射为 OS 原语）</td>
<td>底层原语（如<code>pthread_mutex</code>）</td>
</tr>
<tr>
<td><strong>栈内存占用</strong></td>
<td>默认 1MB（可调），虚拟线程仅 KB 级</td>
<td>Linux 默认 8MB（不可跨线程共享）</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>通用并发编程，高并发推荐虚拟线程</td>
<td>直接系统编程，需精细控制线程行为的场景</td>
</tr>
</tbody></table>
<p><strong>补充说明</strong>：</p>
<ol>
<li><strong>现代 JVM</strong>：HotSpot 等主流 JVM 默认将 Java 线程与 OS 线程<strong>1:1 绑定</strong>，但虚拟线程（Project Loom）实现<strong>M:N 映射</strong>，显著提升并发能力。</li>
<li><strong>性能关键点</strong>：<ul>
<li>Java 线程的阻塞操作（如 I&#x2F;O）会阻塞 OS 线程，而虚拟线程通过挂起避免资源浪费。</li>
<li>OS 线程数量过多会导致内存和调度开销激增，Java 线程池或虚拟线程可缓解。</li>
</ul>
</li>
</ol>
<h3 id="【中等】单核-CPU-支持-Java-多线程吗？"><a href="#【中等】单核-CPU-支持-Java-多线程吗？" class="headerlink" title="【中等】单核 CPU 支持 Java 多线程吗？"></a>【中等】单核 CPU 支持 Java 多线程吗？</h3><p><strong>单核 CPU 可以支持 Java 多线程</strong>，但多个线程<strong>无法真正并行执行</strong>，而是通过<strong>时间片轮转（分时调度）</strong>在单个 CPU 核心上交替运行，实现<strong>并发（Concurrency）</strong>而非<strong>并行（Parallelism）</strong>。</p>
<p>这里顺带提一下 Java 使用的线程调度方式。</p>
<p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p>
<ul>
<li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I&#x2F;O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li>
<li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li>
</ul>
<p>Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。</p>
<h3 id="【简单】并发一定比串行更快吗？"><a href="#【简单】并发一定比串行更快吗？" class="headerlink" title="【简单】并发一定比串行更快吗？"></a>【简单】并发一定比串行更快吗？</h3><p><strong>并发不一定比串行更快</strong>！关键看场景：</p>
<p><strong>并发更快的情况</strong></p>
<ul>
<li>📶 <strong>I&#x2F;O 密集型</strong>：网络&#x2F;磁盘操作时，CPU 可切换做其他事</li>
<li>⚡ <strong>多核 CPU</strong>：真正并行执行计算任务</li>
</ul>
<p><strong>串行更快的情况</strong></p>
<ul>
<li>🔢 <strong>单核 CPU 计算</strong>：线程切换反而增加开销</li>
<li>🔒 <strong>高竞争场景</strong>：锁争用导致线程空等</li>
<li>🎯 <strong>简单任务</strong>：并发管理开销超过收益</li>
</ul>
<p><strong>黄金法则</strong></p>
<ul>
<li>I&#x2F;O 多用并发，计算多用多核</li>
<li>避免无脑加线程，合理控制并发度</li>
</ul>
<h3 id="【简单】什么是并发安全？有哪些线程不安全的情况？"><a href="#【简单】什么是并发安全？有哪些线程不安全的情况？" class="headerlink" title="【简单】什么是并发安全？有哪些线程不安全的情况？"></a>【简单】什么是并发安全？有哪些线程不安全的情况？</h3><p>::: info 什么是并发安全？<br>:::</p>
<p>并发最重要的问题是并发安全问题。所谓<strong>并发安全</strong>，是指保证程序的正确性，使得并发处理结果符合预期。</p>
<p>并发安全需要保证几个基本特性：</p>
<ul>
<li><strong>可见性</strong> - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code> 就是负责保证可见性的。</li>
<li><strong>原子性</strong> - 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：<code>sychronized</code>、<code>Lock</code>）实现。</li>
<li><strong>有序性</strong> - 是保证线程内串行语义，避免指令重排等。</li>
</ul>
<p>::: info 有哪些线程不安全的情况？<br>:::</p>
<ul>
<li><strong>竞态条件</strong>：多线程同时修改共享变量（如 <code>count++</code>）</li>
<li><strong>非原子操作</strong>：多步骤操作被中断（如 <code>if(x==null) x=new Object()</code>）</li>
<li><strong>可见性问题</strong>：线程 A 的修改对线程 B 不可见</li>
<li><strong>死锁</strong>：多个线程互相持有对方需要的锁</li>
<li><strong>资源泄漏</strong>：线程未释放资源（如连接、文件）</li>
</ul>
<p>::: info 线程不安全有哪些解决办法？<br>:::</p>
<ul>
<li>同步：<code>synchronized</code>、<code>Lock</code></li>
<li>原子类：<code>AtomicInteger</code></li>
<li>不可变对象：<code>final</code></li>
<li>并发容器：<code>ConcurrentHashMap</code></li>
</ul>
<blockquote>
<p>核心：减少共享数据，合理加锁</p>
</blockquote>
<h3 id="【中等】为什么会有并发安全问题？"><a href="#【中等】为什么会有并发安全问题？" class="headerlink" title="【中等】为什么会有并发安全问题？"></a>【中等】为什么会有并发安全问题？</h3><p><strong>（1）缓存导致的可见性问题</strong></p>
<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 <strong>可见性</strong>。</p>
<p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409042331169.png"></p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409042332517.png"></p>
<p><strong>（2）线程切换带来的原子性问题</strong></p>
<p>Java 的并发也是基于任务切换。Java 中，即使是一条语句，也可能需要执行多条 CPU 指令。<strong>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。</p>
<p>CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。违背直觉的是，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的<code>count += 1</code>，至少需要三条 CPU 指令。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行+1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>因此，执行 <code>count += 1</code> 不是原子操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409042334004.png"></p>
<p><strong>（3）编译优化带来的有序性问题</strong></p>
<p>有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：<code>a=6; b=7;</code> 编译器优化后可能变成 <code>b=7; a=6;</code>，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p>
<h3 id="【中等】哪些场景需要额外注意线程安全问题？"><a href="#【中等】哪些场景需要额外注意线程安全问题？" class="headerlink" title="【中等】哪些场景需要额外注意线程安全问题？"></a>【中等】哪些场景需要额外注意线程安全问题？</h3><ul>
<li><strong>访问共享变量或资源</strong> - 典型的场景有访问共享对象的属性，访问 static 静态变量，访问共享的缓存，等等。因为这些信息不仅会被一个线程访问到，还有可能被多个线程同时访问，那么就有可能在并发读写的情况下发生线程安全问题。</li>
<li><strong>依赖时序的操作</strong> - 如果我们操作的正确性是依赖时序的，而在多线程的情况下又不能保障执行的顺序和我们预想的一致，这个时候就会发生线程安全问题。</li>
<li><strong>不同数据之间存在绑定关系</strong> - 有时候，不同数据之间是成组出现的，存在着相互对应或绑定的关系，最典型的就是 IP 和端口号。有时候我们更换了 IP，往往需要同时更换端口号，如果没有把这两个操作绑定在一起，就有可能出现单独更换了 IP 或端口号的情况，而此时信息如果已经对外发布，信息获取方就有可能获取一个错误的 IP 与端口绑定情况，这时就发生了线程安全问题。</li>
<li><strong>对方没有声明自己是线程安全的</strong> - 在我们使用其他类时，如果对方没有声明自己是线程安全的，那么这种情况下对其他类进行多线程的并发操作，就有可能会发生线程安全问题。举个例子，比如说我们定义了 ArrayList，它本身并不是线程安全的，如果此时多个线程同时对 ArrayList 进行并发读&#x2F;写，那么就有可能会产生线程安全问题，造成数据出错，而这个责任并不在 ArrayList，因为它本身并不是并发安全的。</li>
</ul>
<h3 id="【困难】什么是死锁？如何发现死锁？如何避免死锁？"><a href="#【困难】什么是死锁？如何发现死锁？如何避免死锁？" class="headerlink" title="【困难】什么是死锁？如何发现死锁？如何避免死锁？"></a>【困难】什么是死锁？如何发现死锁？如何避免死锁？</h3><p>::: info 什么是死锁？<br>:::</p>
<p><strong>死锁</strong>：<strong>一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象</strong>。</p>
<p>产生死锁的四个必要条件：</p>
<ul>
<li><strong>互斥</strong>：该资源任意一个时刻只由一个线程占用。</li>
<li><strong>占有并等待</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不可抢占</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409050712813.png"></p>
<p>::: info 如何发现死锁？<br>:::</p>
<p>（1）使用 <code>jstack</code> 工具</p>
<ul>
<li><p>运行程序后，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;PID&gt;  # PID 是 Java 进程 ID</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在死锁，输出会显示 <code>Found one Java-level deadlock</code>，并列出死锁的线程和资源。</p>
</li>
</ul>
<p>（2）使用 <code>ThreadMXBean</code> 检测（代码方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="type">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads(); <span class="comment">// 检测死锁线程</span></span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发现死锁！涉及线程：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> threadId : deadlockedThreads) &#123;</span><br><span class="line">                System.out.println(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无死锁。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发现死锁！涉及线程：</span><br><span class="line">12345</span><br><span class="line">67890</span><br></pre></td></tr></table></figure>

<p>（3）使用 VisualVM 或 JConsole（可视化工具）</p>
<p>连接 Java 进程后，查看<strong>线程</strong>选项卡，死锁会被明确标记。</p>
<p>::: info 如何避免死锁？<br>:::</p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ul>
<li><strong>互斥</strong>：难以避免</li>
<li><strong>占有并等待</strong>：一次性申请所有资源</li>
<li><strong>不可抢占</strong>：超时释放锁</li>
<li><strong>循环等待</strong>：按序申请资源</li>
</ul>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
<h3 id="【中等】什么是活锁？如何避免活锁？"><a href="#【中等】什么是活锁？如何避免活锁？" class="headerlink" title="【中等】什么是活锁？如何避免活锁？"></a>【中等】什么是活锁？如何避免活锁？</h3><p>::: info 什么是活锁？<br>:::</p>
<p>活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持’this’线程。</p>
<p>想象这样一个例子：两个人在狭窄的走廊里相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任何进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409050740102.png"></p>
<p>如图所示：两个线程想要通过一个 Worker 对象访问共享公共资源的情况，但是当他们看到另一个 Worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题。</p>
<p>::: info 如何避免活锁？<br>:::</p>
<p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p>
<h3 id="【中等】什么是饥饿问题？如何避免饥饿？"><a href="#【中等】什么是饥饿问题？如何避免饥饿？" class="headerlink" title="【中等】什么是饥饿问题？如何避免饥饿？"></a>【中等】什么是饥饿问题？如何避免饥饿？</h3><p>::: info 什么是饥饿问题？<br>:::</p>
<p><strong>定义</strong>：某些线程由于<strong>长期无法获取所需资源</strong>（如 CPU 时间、锁、I&#x2F;O 等），导致<strong>任务无法执行或执行缓慢</strong>。</p>
<p><strong>与死锁&#x2F;活锁的区别</strong>：</p>
<ul>
<li><strong>死锁</strong>：所有相关线程都被阻塞，无法继续。</li>
<li><strong>活锁</strong>：线程在运行，但无法取得进展。</li>
<li><strong>饥饿</strong>：部分线程能正常运行，但某些线程长期得不到资源。</li>
</ul>
<p><strong>饥饿的常见原因</strong></p>
<table>
<thead>
<tr>
<th><strong>原因</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程优先级不合理</strong></td>
<td>高优先级线程总是抢占 CPU，低优先级线程长期得不到执行。</td>
</tr>
<tr>
<td><strong>锁竞争不公平</strong></td>
<td>某些线程总是抢不到锁（如<code>synchronized</code>是非公平锁）。</td>
</tr>
<tr>
<td><strong>资源分配不均</strong></td>
<td>线程池任务调度不合理，某些任务被长时间搁置。</td>
</tr>
<tr>
<td><strong>I&#x2F;O 或网络阻塞</strong></td>
<td>某些线程因 I&#x2F;O 操作被阻塞，而其他线程持续占用 CPU。</td>
</tr>
</tbody></table>
<p>::: info 如何避免饥饿？<br>:::</p>
<p><strong>（1）使用公平锁（Fair Lock）</strong></p>
<ul>
<li><p><strong><code>ReentrantLock</code> 支持公平策略</strong>，避免某些线程长期抢不到锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// true 表示公平锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>synchronized</code> 是非公平的</strong>，无法直接设置公平性。</p>
</li>
</ul>
<p><strong>（2）合理设置线程优先级</strong></p>
<ul>
<li><p>避免滥用高优先级，尽量让所有线程有机会执行。</p>
</li>
<li><p>Java 线程优先级（1~10，默认 5）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（3）避免长时间占用资源</strong></p>
<ul>
<li><p>减少锁的持有时间，尽量只在必要时加锁。</p>
</li>
<li><p>使用 <code>tryLock()</code> 设置超时，防止无限等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">/* 临界区 */</span> &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（4）优化线程池任务调度</strong></p>
<ul>
<li>使用 <code>newFixedThreadPool</code> 或 <code>newCachedThreadPool</code> 时，结合 <code>BlockingQueue</code> 避免任务堆积。</li>
<li>可改用 <code>ForkJoinPool</code> 进行任务拆分，提高公平性。</li>
</ul>
<p><strong>（5）监控与调整</strong></p>
<ul>
<li>使用 <strong>VisualVM、JConsole</strong> 等工具观察线程状态，发现长期阻塞的线程。</li>
<li>结合日志分析，优化资源分配策略。</li>
</ul>
<h3 id="【简单】简单介绍一下-Java-并发编程？"><a href="#【简单】简单介绍一下-Java-并发编程？" class="headerlink" title="【简单】简单介绍一下 Java 并发编程？"></a>【简单】简单介绍一下 Java 并发编程？</h3><p>并发编程可以抽象成三个核心问题：分工、同步、互斥。</p>
<ul>
<li><strong>分工</strong> - 是指如何高效地拆解任务并分配给线程。</li>
<li><strong>同步</strong> - 是指线程之间如何协作。</li>
<li><strong>互斥</strong> - 是指保证同一时刻只允许一个线程访问共享资源。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504221021138.png"></p>
<p>Java 的 <code>java.util.concurrent</code> 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：</p>
<ul>
<li><strong>原子类</strong> - 如：<code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicReference</code>、<code>AtomicStampedReference</code> 等。</li>
<li><strong>锁</strong> - 如：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li>
<li><strong>并发容器</strong> - 如：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</li>
<li><strong>阻塞队列</strong> - 如：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li>
<li><strong>非阻塞队列</strong> - 如： <code>ConcurrentLinkedQueue</code> 、<code>LinkedTransferQueue</code> 等。</li>
<li><strong>线程池</strong> - 如：<code>ThreadPoolExecutor</code>、<code>Executors</code> 等。</li>
</ul>
<p>J.U.C 包中的工具类是基于 <code>synchronized</code>、<code>volatile</code>、<code>CAS</code>、<code>ThreadLocal</code> 这样的并发核心机制打造的。所以，要想深入理解 J.U.C 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。</p>
<h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="【中等】Java-线程生命周期有哪些状态？状态之间如何切换？"><a href="#【中等】Java-线程生命周期有哪些状态？状态之间如何切换？" class="headerlink" title="【中等】Java 线程生命周期有哪些状态？状态之间如何切换？"></a>【中等】Java 线程生命周期有哪些状态？状态之间如何切换？</h3><p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408290809602.png"></p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><strong>开始（NEW）</strong> - 尚未调用 <code>start</code> 方法的线程处于此状态。此状态意味着：<strong>创建的线程尚未启动</strong>。</li>
<li><strong>可运行（RUNNABLE）</strong> - 已经调用了 <code>start</code> 方法的线程处于此状态。此状态意味着，<strong>线程已经准备好了</strong>，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。<ul>
<li>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</li>
</ul>
</li>
<li><strong>阻塞（BLOCKED）</strong> - 此状态意味着：<strong>线程处于被阻塞状态</strong>。表示线程在等待 <code>synchronized</code> 的隐式锁（Monitor lock）。<code>synchronized</code> 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 <code>synchronized</code> 隐式锁的线程释放锁，并且等待的线程获得 <code>synchronized</code> 隐式锁时，就又会从 <code>BLOCKED</code> 转换到 <code>RUNNABLE</code> 状态。</li>
<li><strong>等待（WAITING）</strong> - 此状态意味着：<strong>线程无限期等待，直到被其他线程显式地唤醒</strong>。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code>synchronized</code> 的隐式锁。而等待是主动的，通过调用 <code>Object.wait</code> 等方法进入。<ul>
<li>进入：<code>Object.wait()</code>；退出：<code>Object.notify</code> &#x2F; <code>Object.notifyAll</code></li>
<li>进入：<code>Thread.join()</code>；退出：被调用的线程执行完毕</li>
<li>进入：<code>LockSupport.park()</code>；退出：<code>LockSupport.unpark</code></li>
</ul>
</li>
<li><strong>定时等待（TIMED_WAITING）</strong> - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li>进入：<code>Thread.sleep(long)</code>；退出：时间结束</li>
<li>进入：<code>Object.wait(long)</code>；退出：时间结束 &#x2F; <code>Object.notify</code> &#x2F; <code>Object.notifyAll</code></li>
<li>进入：<code>Thread.join(long)</code>；退出：时间结束 &#x2F; 被调用的线程执行完毕</li>
<li>进入：<code>LockSupport.parkNanos(long)</code>；退出：<code>LockSupport.unpark</code></li>
<li>进入：<code>LockSupport.parkUntil(long)</code>；退出：<code>LockSupport.unpark</code></li>
</ul>
</li>
<li><strong>终止 (TERMINATED)</strong> - 线程 <code>run()</code> 方法执行结束，或者因异常退出了 <code>run()</code> 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<blockquote>
<p>👉 扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php">Java Thread Methods and Thread States</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 5 种状态及切换（透彻讲解）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答</a></li>
</ul>
</blockquote>
<h3 id="【中等】Java-中，创建线程有几种方式？"><a href="#【中等】Java-中，创建线程有几种方式？" class="headerlink" title="【中等】Java 中，创建线程有几种方式？"></a>【中等】Java 中，创建线程有几种方式？</h3><p>一般来说，创建线程有很多种方式，例如：</p>
<ul>
<li>实现 <code>Runnable</code> 接口（推荐）</li>
<li>继承 <code>Thread</code> 类（不推荐，因为不灵活，Java 不支持多继承）</li>
<li>实现 <code>Callable</code> 接口 + <code>FutureTask</code>，支持返回值</li>
<li>通过线程池（生产环境推荐）</li>
<li>使用 <code>CompletableFuture</code></li>
<li>…</li>
</ul>
<p>虽然，看似有多种多样的创建线程方式。但是，**从本质上来说，Java 就只有一种方式可以创建线程，那就是通过 <code>new Thread().start() </code> 创建。不管是哪种方式，最终还是依赖于 <code>new Thread().start()</code>**。</p>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说 Java 有三种创建线程的方式！并发编程中的惊天骗局！</a>。</p>
</blockquote>
<h3 id="【简单】可以直接调用-Thread-run-方法么？"><a href="#【简单】可以直接调用-Thread-run-方法么？" class="headerlink" title="【简单】可以直接调用 Thread.run() 方法么？"></a>【简单】可以直接调用 <code>Thread.run()</code> 方法么？</h3><p>可以直接调用 <code>Thread.run()</code> 方法，但是它的行为和普通方法一样，不会启动新线程去执行。<strong>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<ul>
<li><strong><code>run()</code> 方法是线程的执行体</strong>。</li>
<li><strong><code>start()</code> 方法负责启动线程，然后 JVM 会让这个线程去执行 <code>run()</code> 方法</strong>。</li>
</ul>
<h3 id="【简单】一个线程两次调用-Thread-start-方法会怎样？"><a href="#【简单】一个线程两次调用-Thread-start-方法会怎样？" class="headerlink" title="【简单】一个线程两次调用 Thread.start() 方法会怎样？"></a>【简单】一个线程两次调用 <code>Thread.start()</code> 方法会怎样？</h3><p>Java 的线程是不允许启动两次的，**第二次调用 <code>Thread.start()</code> 会抛出 <code>IllegalThreadStateException</code>**。</p>
<h3 id="【简单】Thread-sleep-、Thread-yield-、Thread-join-、Object-wait-有什么区别？"><a href="#【简单】Thread-sleep-、Thread-yield-、Thread-join-、Object-wait-有什么区别？" class="headerlink" title="【简单】Thread.sleep()、Thread.yield()、Thread.join()、Object.wait() 有什么区别？"></a>【简单】<code>Thread.sleep()</code>、<code>Thread.yield()</code>、<code>Thread.join()</code>、<code>Object.wait()</code> 有什么区别？</h3><table>
<thead>
<tr>
<th>方法</th>
<th>所属类</th>
<th>作用</th>
<th>是否释放锁</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Thread.sleep(long ms)</code></strong></td>
<td><code>Thread</code></td>
<td><strong>让当前线程暂停执行指定时间</strong>（不释放 CPU 资源）</td>
<td>❌ 不释放锁</td>
<td>模拟耗时操作、定时任务</td>
</tr>
<tr>
<td><strong><code>Thread.yield()</code></strong></td>
<td><code>Thread</code></td>
<td><strong>提示调度器让出 CPU，但可能立即重新竞争</strong>（不保证让出）</td>
<td>❌ 不释放锁</td>
<td>优化线程调度，减少竞争（极少使用）</td>
</tr>
<tr>
<td><strong><code>Thread.join()</code></strong></td>
<td><code>Thread</code></td>
<td><strong>等待目标线程执行完毕</strong>（阻塞当前线程）</td>
<td>❌ 不释放锁</td>
<td>线程顺序执行，如主线程等待子线程结束</td>
</tr>
<tr>
<td><strong><code>Object.wait()</code></strong></td>
<td><code>Object</code></td>
<td><strong>释放锁并进入等待，直到 <code>notify()</code>&#x2F;<code>notifyAll()</code> 唤醒</strong></td>
<td>✅ 释放锁</td>
<td>线程间通信（需在 <code>synchronized</code> 块中使用）</td>
</tr>
</tbody></table>
<p><strong>锁的释放</strong></p>
<ul>
<li><code>wait()</code> 会释放锁，其他方法不会。</li>
<li><code>sleep()</code> 和 <code>yield()</code> 仅影响线程调度，不涉及锁。</li>
</ul>
<p><strong>唤醒机制</strong></p>
<ul>
<li><code>wait()</code> 需依赖 <code>notify()</code>&#x2F;<code>notifyAll()</code> 或超时唤醒。</li>
<li><code>sleep()</code> 和 <code>join()</code> 超时后自动恢复。</li>
<li><code>yield()</code> 立刻重新参与竞争。</li>
</ul>
<p><strong>用途</strong></p>
<ul>
<li><code>sleep()</code>：固定时间暂停（如定时任务）。</li>
<li><code>yield()</code>：礼貌让出 CPU（实际开发很少用）。</li>
<li><code>join()</code>：线程依赖（如主线程等待子线程）。</li>
<li><code>wait()</code>：线程间协作（生产者-消费者模型）。</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920385.html">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></p>
</blockquote>
<h3 id="【中等】为什么-Thread-sleep-、Thread-yield-设计为静态方法？"><a href="#【中等】为什么-Thread-sleep-、Thread-yield-设计为静态方法？" class="headerlink" title="【中等】为什么 Thread.sleep()、Thread.yield() 设计为静态方法？"></a>【中等】为什么 <code>Thread.sleep()</code>、<code>Thread.yield()</code> 设计为静态方法？</h3><p><code>Thread.sleep()</code>、<code>Thread.yield()</code> 针对的是 <strong>Running</strong> 状态的线程，也就是说在非 <strong>Running</strong> 状态的线程上执行这两个方法没有意义。这就是为什么这两个方法被设计为静态的。它们只针对正在 <strong>Running</strong> 状态的线程工作，避免程序员错误的认为可以在其他非 <strong>Running</strong> 状态线程上调用。</p>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="http://www.importnew.com/14958.html">Java 线程中 yield 与 join 方法的区别</a><br>👉 扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangwanpeng/article/details/54972952">sleep()，wait()，yield() 和 join() 方法的区别</a></p>
</blockquote>
<h3 id="【中等】为什么-Object-wait-、Object-notify-和-Object-notifyAll-被定义在-Object-类里？"><a href="#【中等】为什么-Object-wait-、Object-notify-和-Object-notifyAll-被定义在-Object-类里？" class="headerlink" title="【中等】为什么 Object.wait()、Object.notify() 和 Object.notifyAll() 被定义在 Object 类里？"></a>【中等】为什么 <code>Object.wait()</code>、<code>Object.notify()</code> 和 <code>Object.notifyAll()</code> 被定义在 <code>Object</code> 类里？</h3><p><strong>因为锁是对象的，<code>wait()</code>&#x2F;<code>notify()</code> 是锁的行为，所以必须定义在 <code>Object</code> 中</strong>。</p>
<ul>
<li><p><strong>锁基于对象</strong>：Java 的锁（<code>synchronized</code>）是 <strong>对象级别</strong> 的，每个对象关联一个监视器（Monitor），<code>wait()</code>&#x2F;<code>notify()</code> 是监视器的核心操作，必须属于 <code>Object</code>。</p>
</li>
<li><p><strong>任何对象都可作为锁</strong>：不仅 <code>Thread</code> 能作为锁，<strong>所有对象</strong> 都能作为锁，因此这些方法需定义在 <code>Object</code> 以保证通用性。</p>
</li>
<li><p><strong>等待队列绑定对象</strong>：调用 <code>wait()</code> 的线程会进入 <strong>该对象的等待队列</strong>，<code>notify()</code> 唤醒的也是同一对象队列中的线程，与对象强绑定。</p>
</li>
<li><p><strong>与 <code>Thread</code> 类职责分离</strong>：<code>Thread</code> 类管理线程生命周期（如 <code>sleep()</code>、<code>join()</code>），而 <code>wait()</code>&#x2F;<code>notify()</code> 是 <strong>线程间协作机制</strong>，属于锁（对象）的行为。</p>
</li>
<li><p><strong>设计一致性与历史原因</strong>：遵循 <strong>Monitor 模式</strong>（操作系统同步原语），保持 <code>Thread</code> 简洁，避免功能混淆（如 <code>wait()</code> 和 <code>sleep()</code> 的误用）。</p>
</li>
</ul>
<h3 id="【中等】为什么-Object-wait-、Object-notify-和-Object-notifyAll-必须在-synchronized-方法-块中被调用？"><a href="#【中等】为什么-Object-wait-、Object-notify-和-Object-notifyAll-必须在-synchronized-方法-块中被调用？" class="headerlink" title="【中等】为什么 Object.wait()、Object.notify() 和 Object.notifyAll() 必须在 synchronized 方法&#x2F;块中被调用？"></a>【中等】为什么 <code>Object.wait()</code>、<code>Object.notify()</code> 和 <code>Object.notifyAll()</code> 必须在 <code>synchronized</code> 方法&#x2F;块中被调用？</h3><p>当一个线程需要调用对象的 <code>wait()</code> 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 <code>notify()</code> 方法。同样的，当一个线程需要调用对象的 <code>notify()</code> 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过 <code>synchronized</code> 来实现，所以他们只能在 <code>synchronized</code> 方法&#x2F;块中被调用。</p>
<h3 id="【中等】如何正确停止-Java-线程？"><a href="#【中等】如何正确停止-Java-线程？" class="headerlink" title="【中等】如何正确停止 Java 线程？"></a>【中等】如何正确停止 Java 线程？</h3><p><strong>对于 Java 而言，最正确的停止线程的方式是：通过 <code>Thread.interrupt</code> 和 <code>Thread.isInterrupted</code> 配合来控制线程终止</strong>。</p>
<ul>
<li><code>Thread.interrupt()</code>：设置线程的中断标志位（不会直接停止线程）。</li>
<li><code>Thread.isInterrupted()</code>：检查中断状态。</li>
</ul>
<p>【示例】正确停止线程的方式——<code>Thread.interrupt</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStopDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>(), <span class="string">&quot;MyTask&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程启动&quot;</span>);</span><br><span class="line">            <span class="comment">// 通过 Thread.interrupted 和 interrupt 配合来控制线程终止</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;count = &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程终止&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出（count 未到 10000，线程就主动结束）：</span></span><br><span class="line"><span class="comment">// MyTask 线程启动</span></span><br><span class="line"><span class="comment">// count = 0</span></span><br><span class="line"><span class="comment">// count = 1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// count = 840</span></span><br><span class="line"><span class="comment">// count = 841</span></span><br><span class="line"><span class="comment">// count = 842</span></span><br><span class="line"><span class="comment">// MyTask 线程终止</span></span><br></pre></td></tr></table></figure>

<h3 id="【中等】可以使用-Thread-stop，Thread-suspend-和-Thread-resume-停止线程吗？为什么？"><a href="#【中等】可以使用-Thread-stop，Thread-suspend-和-Thread-resume-停止线程吗？为什么？" class="headerlink" title="【中等】可以使用 Thread.stop，Thread.suspend 和 Thread.resume 停止线程吗？为什么？"></a>【中等】可以使用 <code>Thread.stop</code>，<code>Thread.suspend</code> 和 <code>Thread.resume</code> 停止线程吗？为什么？</h3><p><code>Thread.stop</code>，<code>Thread.suspend</code> 和 <code>Thread.resume</code> 方法已经被 Java 标记为 <code>@Deprecated</code>。为什么废弃呢？</p>
<ul>
<li><strong><code>Thread.stop</code> 会直接把线程停止，这样就没有给线程足够的时间来处理想要在停止前保存数据的逻辑，任务戛然而止，会导致出现数据完整性等问题</strong>。</li>
<li>而对于<code>Thread.suspend</code> 和 <code>Thread.resume</code> 而言，它们的问题在于：<strong>如果线程调用 <code>Thread.suspend</code>，它并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，这样就容易导致死锁问题</strong>。因为这把锁在线程被 <code>Thread.resume</code> 之前，是不会被释放的。假设线程 A 调用了 <code>Thread.suspend</code> 方法让线程 B 挂起，线程 B 进入休眠，而线程 B 又刚好持有一把锁，此时假设线程 A 想访问线程 B 持有的锁，但由于线程 B 并没有释放锁就进入休眠了，所以对于线程 A 而言，此时拿不到锁，也会陷入阻塞，那么线程 A 和线程 B 就都无法继续向下执行。</li>
</ul>
<p>【示例】<code>Thread.stop</code> 终止线程，导致线程任务戛然而止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStopErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程</span></span><br><span class="line">        thread.stop();</span><br><span class="line">        <span class="comment">// 确保线程终止后，才执行下面的代码</span></span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;</span><br><span class="line">        <span class="comment">// 输出两个计数器的最终状态</span></span><br><span class="line">        thread.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有两个计数器，run 方法中每次执行都会使计数器自增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】使用-volatile-标记方式停止线程正确吗？"><a href="#【中等】使用-volatile-标记方式停止线程正确吗？" class="headerlink" title="【中等】使用 volatile 标记方式停止线程正确吗？"></a>【中等】使用 <code>volatile</code> 标记方式停止线程正确吗？</h3><p>使用 <code>volatile</code> 标记方式仅适用于简单场景（无阻塞、无锁竞争）。<strong>推荐 <code>Thread.interrupt</code> 和 <code>Thread.isInterrupted</code> 方式停止线程</strong>：更通用，可处理阻塞操作，是 Java 线程停止的标准方式。</p>
<p><strong><code>volatile</code> 标记停止线程适用场景（正确使用）</strong></p>
<ul>
<li>✅ <strong>非阻塞循环</strong><ul>
<li>线程在 <code>while (!stopped)</code> 循环中运行，且 <strong>无阻塞操作</strong>（如 <code>sleep()</code>、<code>wait()</code>、I&#x2F;O）。</li>
<li><code>volatile</code> 保证标志位 (<code>stopped</code>) 的修改对所有线程 <strong>立即可见</strong>。</li>
</ul>
</li>
<li>✅ <strong>短周期任务</strong>：适用于 <strong>纯计算型任务</strong> 或 <strong>高频检查标志位</strong> 的场景。</li>
</ul>
<p><strong><code>volatile</code> 标记停止线程不适用场景（可能失效）</strong></p>
<ul>
<li>❌ <strong>线程被阻塞</strong>（如 <code>sleep()</code>、<code>wait()</code>、I&#x2F;O）：阻塞期间无法检测 <code>volatile</code> 标志位，必须等阻塞结束才能退出。</li>
<li>❌ <strong>依赖外部资源</strong>（如锁竞争、网络请求）：即使 <code>stopped=true</code>，线程可能因锁或 I&#x2F;O 阻塞无法立即退出。</li>
</ul>
<p>当我们使用 <code>volatile</code> 变量来控制线程的停止，通常是通过设置一个 <code>volatile</code> 标志位来告诉线程停止执行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!canceled) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopTask</span><span class="params">()</span> &#123;</span><br><span class="line">        canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>canceled</code> 是一个 <code>volatile</code> 变量，用来控制线程的停止。虽然这种方式在某些情况下可以工作，但它并不是一个可靠的停止线程的方式，因为<strong>在多线程环境中，其他线程修改 <code>canceled</code> 的值时，可能会出现竞态条件，导致线程无法正确停止</strong>。</p>
<h3 id="【中等】Java-线程之间如何进行通信？"><a href="#【中等】Java-线程之间如何进行通信？" class="headerlink" title="【中等】Java 线程之间如何进行通信？"></a>【中等】Java 线程之间如何进行通信？</h3><p>在 Java 中，线程间通信（Inter-Thread Communication, ITC）是指多个线程之间协调工作、共享数据或传递消息的机制。常见的线程通信方式包括以下几种：</p>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>核心机制</th>
<th>适用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>共享变量</strong></td>
<td><code>volatile</code>&#x2F;<code>synchronized</code></td>
<td>简单状态标记</td>
<td>需处理竞态条件</td>
</tr>
<tr>
<td><strong><code>wait()</code>&#x2F;<code>notify()</code></strong></td>
<td>对象监视器</td>
<td>生产者-消费者</td>
<td>需手动同步</td>
</tr>
<tr>
<td><strong><code>BlockingQueue</code></strong></td>
<td>内置锁和条件队列</td>
<td>生产者-消费者</td>
<td>无需手动同步</td>
</tr>
<tr>
<td><strong><code>CountDownLatch</code></strong></td>
<td>计数器</td>
<td>主线程等待子线程</td>
<td>一次性</td>
</tr>
<tr>
<td><strong><code>CyclicBarrier</code></strong></td>
<td>屏障</td>
<td>多线程同步</td>
<td>可重复使用</td>
</tr>
<tr>
<td><strong><code>Semaphore</code></strong></td>
<td>许可证</td>
<td>限流&#x2F;资源池</td>
<td>控制并发数</td>
</tr>
<tr>
<td><strong>管道流</strong></td>
<td>字节流</td>
<td>线程间数据传输</td>
<td>效率较低</td>
</tr>
</tbody></table>
<p><strong>推荐选择</strong>：</p>
<ul>
<li>需要高效数据交换 → <strong><code>BlockingQueue</code></strong></li>
<li>线程协作 → <strong><code>wait()</code>&#x2F;<code>notify()</code> 或 <code>CountDownLatch</code></strong></li>
<li>资源控制 → <strong><code>Semaphore</code></strong></li>
<li>避免重复造轮子，优先使用 JUC（<code>java.util.concurrent</code>）工具类！</li>
</ul>
<h3 id="【简单】高优先级的-Java-线程一定先执行吗？"><a href="#【简单】高优先级的-Java-线程一定先执行吗？" class="headerlink" title="【简单】高优先级的 Java 线程一定先执行吗？"></a>【简单】高优先级的 Java 线程一定先执行吗？</h3><p>Java 中的线程优先级的范围是 <code>[1,10]</code>，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 <code>5</code>。</p>
<p>即使设置了线程的优先级，也<strong>无法保证高优先级的线程一定先执行</strong>。这是因为 <strong>Java 线程优先级依赖于操作系统的支持</strong>，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。因此，Java 线程优先级控制并不可靠。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h3 id="【中等】什么是-Java-内存模型？"><a href="#【中等】什么是-Java-内存模型？" class="headerlink" title="【中等】什么是 Java 内存模型？"></a>【中等】什么是 Java 内存模型？</h3><p><strong>Java Memory Model (JMM)</strong> 是 Java 规范定义的一套<strong>多线程内存访问规则</strong>，用于解决并发编程中的<strong>可见性、原子性、有序性</strong>问题。目的是让 Java 程序在不同硬件和操作系统上都能正确执行并发操作。</p>
<p><strong>CPU、内存、I&#x2F;O 设备存在很大的速度差异</strong> - CPU 远快于内存，内存远快于 I&#x2F;O 设备。</p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li><strong>CPU 增加了缓存</strong>，以均衡与 CPU 内存的速度差异；</li>
<li><strong>编译程序优化指令执行次序</strong>，使得缓存能够得到更加合理地利用。</li>
<li><strong>操作系统增加了进程、线程</strong>，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 的速度差异；</li>
</ul>
<p><strong>缓存一致性</strong></p>
<p><strong>缓存</strong>导致的可见性问题，<strong>编译优化</strong>带来的有序性问题，<strong>线程切换</strong>带来的原子性问题。</p>
<p>为了解决缓存一致性问题，<strong>需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408290755550.png"></p>
<p><strong>指令重排序</strong></p>
<p>为了使缓存得到更加合理地使用，计算机在执行程序代码的时候，会对指令进行重排序。常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong>：编译器在不改变单线程语义的前提下调整语句顺序。</li>
<li><strong>指令并行重排</strong>：处理器利用指令级并行技术（ILP）调整指令执行顺序（无数据依赖时）。</li>
</ul>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。指令重排序<strong>可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</strong></p>
<p>解决方案：</p>
<ul>
<li><strong>编译器</strong>：禁止特定类型的编译器重排序。</li>
<li><strong>处理器</strong>：通过插入<strong>内存屏障（Memory Barrier&#x2F;Fence）</strong>禁止特定处理器重排序。</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng3051/article/details/52611310">全面理解 Java 内存模型</a></p>
</blockquote>
<h3 id="【困难】什么是-Happens-Before-规则？有什么用？"><a href="#【困难】什么是-Happens-Before-规则？有什么用？" class="headerlink" title="【困难】什么是 Happens-Before 规则？有什么用？"></a>【困难】什么是 Happens-Before 规则？有什么用？</h3><p>JMM 为程序中所有的操作定义了一个偏序关系，称之为 <strong><code>先行发生原则（Happens-Before）</code><strong>。</strong>Happens-Before 是 JMM 的核心规则，用于约束指令重排序和保证多线程可见性。</strong></p>
<p><strong>Happens-Before</strong> 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。</p>
<ol>
<li><strong>程序顺序规则</strong>：单线程内代码顺序执行（但不影响多线程重排序）。</li>
<li><strong><code>volatile</code> 规则</strong>：**<code>volatile</code> 写** Happens-Before <strong>后续的 <code>volatile</code> 读</strong>。<strong>volatile 保证可见性 + 禁止指令重排序</strong>。</li>
<li><strong>锁规则</strong>：<strong>解锁</strong> Happens-Before <strong>后续的加锁</strong>（如 <code>synchronized</code>、<code>ReentrantLock</code>）。</li>
<li><strong>线程启动规则</strong>：**<code>Thread.start()</code>** Happens-Before <strong>线程内的所有操作</strong>。</li>
<li><strong>线程终止规则</strong>：<strong>线程中的所有操作</strong> Happens-Before <strong><code>Thread.join()</code> 完成</strong>。</li>
<li><strong>线程中断规则</strong>：**<code>Thread.interrupt()</code>** Happens-Before <strong>被中断线程检测到中断（<code>isInterrupted()</code> 或 <code>InterruptedException</code>）</strong>。</li>
<li><strong>对象终结规则</strong>：<strong>对象的构造函数执行结束</strong> Happens-Before <strong><code>finalize()</code> 方法被调用</strong>。</li>
<li><strong>传递性</strong>：若 A → B 且 B → C，则 A → C。</li>
</ol>
<blockquote>
<p>1978 年，Lamport 在论文 <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a> （<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163428"><strong>译文</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56146800"><strong>解读</strong></a> ）中第一次提出了 Happens-Before，阐述了偏序关系（partial ordering）、逻辑时钟（Logical Clocks）概念，提出解决分布式系统中区分事件发生的时序问题的方法。Happens-Before 的语义是一种因果关系：如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的。</p>
</blockquote>
<h3 id="【困难】什么是-Java-内存屏障？有什么用？"><a href="#【困难】什么是-Java-内存屏障？有什么用？" class="headerlink" title="【困难】什么是 Java 内存屏障？有什么用？"></a>【困难】什么是 Java 内存屏障？有什么用？</h3><p>内存屏障（Memory Barrier&#x2F;Fence）是 JMM 的底层机制，通过 <strong>限制重排序</strong> 和 <strong>强制缓存同步</strong>，实现多线程程序的 <strong>可见性</strong> 和 <strong>有序性</strong>。</p>
<ul>
<li><strong>禁止特定类型的指令重排序</strong>（编译器和处理器优化可能导致乱序执行）。</li>
<li><strong>强制刷新 CPU 缓存</strong>，确保多线程间的 <strong>内存可见性</strong>。</li>
</ul>
<p>JVM 依赖底层 CPU 的内存屏障指令（如 x86 的 <code>mfence</code>&#x2F;<code>lfence</code>&#x2F;<code>sfence</code>），抽象为以下四种：</p>
<ul>
<li><strong>LoadLoad</strong>：确保 <code>Load1</code> 的读取操作在 <code>Load2</code> 及后续读取之前完成。 示例：<code>volatile</code> 读后的普通读。</li>
<li><strong>StoreStore</strong>：确保 <code>Store1</code> 的写入操作在 <code>Store2</code> 及后续写入之前对其他线程可见。示例：<code>volatile</code> 写前的普通写。</li>
<li><strong>LoadStore</strong>：确保 <code>Load1</code> 的读取操作在 <code>Store2</code> 及后续写入之前完成。</li>
<li><strong>StoreLoad</strong>：确保 <code>Store1</code> 的写入对所有线程可见后，才执行 <code>Load2</code> 的读取。 <strong>开销最大</strong>（如 <code>volatile</code> 写后的 <code>volatile</code> 读会插入此屏障）。</li>
</ul>
<p><strong>内存屏障的应用场景</strong></p>
<ul>
<li><strong><code>volatile</code> 变量</strong><ul>
<li><strong>写操作</strong>：插入 <code>StoreStore</code> + <code>StoreLoad</code> 屏障。</li>
<li><strong>读操作</strong>：插入 <code>LoadLoad</code> + <code>LoadStore</code> 屏障。</li>
</ul>
</li>
<li><strong><code>synchronized</code> 锁</strong><ul>
<li>进入临界区（加锁）和退出（解锁）时插入屏障，保证可见性和有序性。</li>
</ul>
</li>
<li><strong><code>final</code> 字段</strong><ul>
<li>构造函数中的 <code>final</code> 字段写入后插入屏障，确保正确初始化对其他线程可见。</li>
</ul>
</li>
</ul>
<p><strong>内存屏障的作用</strong></p>
<ul>
<li><strong>禁止重排序</strong>：防止编译器和 CPU 优化破坏多线程逻辑（如单例模式的 DCL 问题）。</li>
<li><strong>保证可见性</strong>：强制将工作内存的修改刷回主内存，并失效其他线程的缓存。</li>
<li><strong>保证有序性</strong>：确保临界区代码按预期顺序执行（如 <code>happens-before</code> 规则的实现基础）。</li>
</ul>
<p><strong>底层实现</strong></p>
<ul>
<li><strong>x86 CPU</strong>：<code>StoreLoad</code> 对应 <code>mfence</code> 指令，其他屏障通常无实际指令（因 x86 强内存模型已满足大部分需求）。</li>
<li><strong>ARM&#x2F;PowerPC</strong>：弱内存模型需显式插入更多屏障指令。</li>
<li><strong>JVM 的封装</strong>：通过 <code>Unsafe</code> 类提供 <code>loadFence()</code>&#x2F;<code>storeFence()</code>&#x2F;<code>fullFence()</code> 方法（如 <code>VarHandle</code> 内部使用）。</li>
</ul>
<p><strong>示例：<code>volatile</code> 的屏障插入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">    value = <span class="number">42</span>;          <span class="comment">// 普通写</span></span><br><span class="line">    <span class="comment">// StoreStore 屏障（确保 value=42 先刷入主内存）</span></span><br><span class="line">    flag = <span class="number">1</span>;            <span class="comment">// volatile 写</span></span><br><span class="line">    <span class="comment">// StoreLoad 屏障（保证写操作对所有线程可见）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;     <span class="comment">// volatile 读</span></span><br><span class="line">        <span class="comment">// LoadLoad + LoadStore 屏障</span></span><br><span class="line">        System.out.println(value); <span class="comment">// 保证读到 value=42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】volatile-有什么作用？"><a href="#【中等】volatile-有什么作用？" class="headerlink" title="【中等】volatile 有什么作用？"></a>【中等】<code>volatile</code> 有什么作用？</h3><p><code>volatile</code> 是轻量级的线程同步工具。**<code>volatile</code> 可以保证可见性和有序性，但不保证原子性**。适用于状态标志、DCL 单例等场景。</p>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>不要滥用</strong>：仅适用于简单状态同步，复杂操作仍需锁或原子类。</li>
<li><strong>不适用于复合操作</strong>：如 <code>check-then-act</code>（需 <code>synchronized</code> 或 CAS）。</li>
</ul>
<p>::: info 保证可见性</p>
<p>:::</p>
<ul>
<li><strong>强制线程每次读取 <code>volatile</code> 变量时</strong>，直接从主内存获取最新值（跳过工作内存缓存）。</li>
<li><strong>强制线程每次写入 <code>volatile</code> 变量时</strong>，立即同步到主内存，使其他线程立即可见。</li>
</ul>
<p>::: info 禁止指令重排序</p>
<p>:::</p>
<ul>
<li>通过插入 <strong>内存屏障（Memory Barrier）</strong> 禁止编译器和 CPU 对 <code>volatile</code> 变量的读写操作进行重排序。</li>
<li><strong>双重检查锁（DCL）单例模式</strong> 中必须用 <code>volatile</code> 修饰实例变量，防止对象未初始化完成就被使用。</li>
</ul>
<p>::: info 不保证原子性</p>
<p>:::</p>
<p><code>volatile</code> **不能替代 <code>synchronized</code>**，例如 <code>volatile int i++;</code> 仍存在竞态条件（需用 <code>AtomicInteger</code>）。</p>
<p>适用场景：<strong>单线程写、多线程读</strong> 的变量（如开关标志）。</p>
<p>::: info volatile 底层实现原理</p>
<p>:::</p>
<ul>
<li><strong>写操作</strong>：插入 <code>StoreStore</code> + <code>StoreLoad</code> 屏障，确保写入前所有操作完成，且结果全局可见。</li>
<li><strong>读操作</strong>：插入 <code>LoadLoad</code> + <code>LoadStore</code> 屏障，确保读取后所有操作依赖最新值。</li>
</ul>
<p>::: info volatile 应用场景</p>
<p>:::</p>
<p><strong>状态标志位</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125;  <span class="comment">// 线程 A</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">while</span> (running) &#123; ... &#125; &#125; <span class="comment">// 线程 B</span></span><br></pre></td></tr></table></figure>

<p><strong>双重检查锁（DCL）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 禁止重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发布不可变对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Map&lt;String, String&gt; config = readConfig(); <span class="comment">// 保证引用可见性</span></span><br></pre></td></tr></table></figure>

<h3 id="【中等】volatile-能完全保证并发安全吗？"><a href="#【中等】volatile-能完全保证并发安全吗？" class="headerlink" title="【中等】volatile 能完全保证并发安全吗？"></a>【中等】volatile 能完全保证并发安全吗？</h3><p>线程安全需要具备：可见性、原子性、顺序性。**<code>volatile</code> 不保证原子性，所以决定了它不能彻底地保证线程安全**。</p>
<p>我们通过下面的代码即可证明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatileAtomicityDemo</span> <span class="variable">volatileAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatileAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待 1.5 秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p>
<p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p>
<p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p>
<p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p>
<ol>
<li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code> 的值并对其进行修改（+1），再将 <code>inc</code> 的值写回内存。</li>
<li>线程 2 操作完毕后，线程 1 对 <code>inc</code> 的值进行修改（+1），再将 <code>inc</code> 的值写回内存。</li>
</ol>
<p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p>
<p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code>、<code>Lock</code> 或者 <code>AtomicInteger</code> 都可以。</p>
<p>使用 <code>synchronized</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>AtomicInteger</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>ReentrantLock</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】volatile-和-synchronized-有什么区别？volatile-能替代-synchronized-吗？"><a href="#【中等】volatile-和-synchronized-有什么区别？volatile-能替代-synchronized-吗？" class="headerlink" title="【中等】volatile 和 synchronized 有什么区别？volatile 能替代 synchronized 吗？"></a>【中等】<code>volatile</code> 和 <code>synchronized</code> 有什么区别？<code>volatile</code> 能替代 <code>synchronized</code> 吗？</h3><p><strong><code>volatile</code> 无法替代 <code>synchronized</code> ，因为 <code>volatile</code> 无法保证操作的原子性</strong>。</p>
<p><strong>volatile 和 synchronized 的特性区别</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>原子性</strong></td>
<td>❌ 不保证（如 <code>i++</code>）</td>
<td>✅ 保证</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>✅ 强制主内存读写</td>
<td>✅ 通过锁机制保证</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>✅ 禁止重排序</td>
<td>✅ 串行化执行</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>⚡ 轻量级（无锁）</td>
<td>🔒 较重（上下文切换）</td>
</tr>
</tbody></table>
<p><strong>volatile 和 synchronized 的实现区别</strong>：</p>
<ul>
<li><strong>volatile</strong>：<ul>
<li>通过 <strong>内存屏障</strong> 禁止指令重排序</li>
<li>强制 <strong>CPU 缓存失效</strong> 保证可见性</li>
<li>底层使用 <strong>LoadLoad&#x2F;StoreStore 等屏障指令</strong></li>
</ul>
</li>
<li><strong>synchronized</strong>：<ul>
<li>通过 <strong>Monitor 监视器锁</strong>（对象头 Mark Word）</li>
<li>包含 <strong>偏向锁→轻量级锁→重量级锁</strong> 的升级过程</li>
<li>保证 <strong>代码块&#x2F;方法</strong> 的排他性访问</li>
</ul>
</li>
</ul>
<h3 id="【中等】synchronized-有什么作用？"><a href="#【中等】synchronized-有什么作用？" class="headerlink" title="【中等】synchronized 有什么作用？"></a>【中等】<code>synchronized</code> 有什么作用？</h3><p><code>synchronized</code> 是 Java 最基础的线程同步机制，通过 <strong>原子性、可见性、有序性</strong> 保障线程安全，适用于需要 <strong>强一致性</strong> 的场景，但需合理控制锁粒度以避免性能问题。</p>
<p><code>synchronized</code> 有 3 种应用方式：</p>
<ul>
<li><strong>同步实例方法</strong> - 对于普通同步方法，锁是当前实例对象</li>
<li><strong>同步静态方法</strong> - 对于静态同步方法，锁是当前类的 <code>Class</code> 对象</li>
<li><strong>同步代码块</strong> - 对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409090719904.png"></p>
<h3 id="【中等】synchronized-的实现原理是什么？"><a href="#【中等】synchronized-的实现原理是什么？" class="headerlink" title="【中等】synchronized 的实现原理是什么？"></a>【中等】<code>synchronized</code> 的实现原理是什么？</h3><p><code>synchronized</code> 的底层实现涉及 <strong>Java 对象头、Monitor（监视器）、锁升级机制</strong> 等。</p>
<p><strong><code>synchronized</code> 修饰代码块时，在代码块前后植入 monitorenter 和 monitorexit 字节码指令，相当于加锁和解锁</strong>。</p>
<p><strong><code>synchronized</code> 修饰方法时，会在方法的访问标志上设置一个 <code>ACC_SYNCHRONIZED</code> 标记</strong>。线程每次访问方法，会进行检查，若设置了 <code>ACC_SYNCHRONIZED</code> 标记，执行线程将先持有 <code>Monitor</code> 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 Mointor 对象，当方法执行完成后，再释放该 Monitor 对象。</p>
<p><strong>（1）对象头与 Mark Word</strong></p>
<p>每个 Java 对象在内存中由 <strong>对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</strong> 组成。<br><code>synchronized</code> 的锁信息存储在 <strong>对象头</strong> 的 <strong>Mark Word</strong> 中，主要包括：</p>
<ul>
<li><strong>锁状态</strong>（无锁、偏向锁、轻量级锁、重量级锁）</li>
<li><strong>持有锁的线程 ID</strong></li>
<li><strong>GC 分代年龄</strong></li>
<li><strong>哈希码（HashCode）</strong></li>
</ul>
<p>Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200629191250.png" alt="img"></p>
<p><strong>（2）Monitor（监视器）</strong></p>
<p>每个 Java 对象都关联一个 <strong>Monitor（监视器）</strong>，用于实现同步机制。Monitor 的主要结构：</p>
<ul>
<li>**<code>_owner</code>**：持有锁的线程</li>
<li>**<code>_EntryList</code>**：等待获取锁的线程队列（阻塞状态）</li>
<li>**<code>_WaitSet</code>**：调用 <code>wait()</code> 后进入等待状态的线程队列</li>
</ul>
<h3 id="【困难】JDK6-对synchronized-进行了哪些优化？"><a href="#【困难】JDK6-对synchronized-进行了哪些优化？" class="headerlink" title="【困难】JDK6 对synchronized 进行了哪些优化？"></a>【困难】JDK6 对<code>synchronized</code> 进行了哪些优化？</h3><p><strong>JDK 6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平</strong>。</p>
<p>::: info 锁升级</p>
<p>:::</p>
<p>JDK 1.6 后，<code>synchronized</code> 采用 <strong>锁升级</strong> 机制优化性能，避免直接使用重量级锁带来的性能损耗。锁的状态变化如下：</p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">适用场景</th>
<th align="left">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>无锁</strong></td>
<td align="left">初始状态</td>
<td align="left">Mark Word 无锁标记</td>
</tr>
<tr>
<td align="left"><strong>偏向锁</strong></td>
<td align="left">单线程访问</td>
<td align="left">Mark Word 记录线程 ID</td>
</tr>
<tr>
<td align="left"><strong>轻量级锁</strong></td>
<td align="left">少量线程竞争</td>
<td align="left">CAS 自旋</td>
</tr>
<tr>
<td align="left"><strong>重量级锁</strong></td>
<td align="left">高并发竞争</td>
<td align="left">操作系统 Mutex 锁</td>
</tr>
</tbody></table>
<p><strong>偏向锁</strong></p>
<ul>
<li><strong>适用场景</strong>：只有一个线程访问同步块。</li>
<li><strong>实现方式</strong>：<ul>
<li>在 Mark Word 中记录 <strong>线程 ID</strong>，后续该线程进入时无需 CAS 操作。</li>
<li>如果其他线程尝试获取锁，偏向锁会 <strong>撤销</strong>（Revoke）并升级为轻量级锁。</li>
</ul>
</li>
</ul>
<p><strong>轻量级锁</strong></p>
<ul>
<li><strong>适用场景</strong>：少量线程竞争，且线程交替执行。</li>
<li><strong>实现方式</strong>：<ul>
<li>线程通过 <strong>CAS（Compare-And-Swap）</strong> 尝试获取锁。</li>
<li>如果失败，会进行 <strong>自旋（Spin）</strong>（循环尝试），避免直接进入阻塞状态。</li>
<li>如果自旋失败，升级为 <strong>重量级锁</strong>。</li>
</ul>
</li>
</ul>
<p><strong>重量级锁</strong></p>
<ul>
<li><strong>适用场景</strong>：高并发竞争。</li>
<li><strong>实现方式</strong>：<ul>
<li>依赖 <strong>操作系统 Mutex 锁</strong>（互斥量）。</li>
<li>未获取锁的线程会被 <strong>挂起（Blocked）</strong>，进入 <code>_EntryList</code> 等待唤醒。</li>
</ul>
</li>
</ul>
<p>Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200629191250.png" alt="img"></p>
<p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，<code>synchronized</code> 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</p>
<p>::: info 锁消除</p>
<p>:::</p>
<p>锁消除是指在即时编译（JIT）时，JVM 会对代码进行逃逸分析。如果发现一段代码中使用的锁对象不会逃逸到方法外部，也就是其他线程无法访问到该锁对象，那么 JVM 会认为该锁是无意义的，从而将锁的代码消除，避免不必要的锁竞争，提高程序的性能。</p>
<p><strong>锁消除实现原理</strong>：</p>
<p>（1）<strong>逃逸分析</strong>：JVM 会分析对象的作用域。如果一个对象在方法内部创建，并且不会被外部方法引用，那么这个对象就不会逃逸出该方法。</p>
<p>（2）<strong>锁消除</strong>：由于 <code>StringBuffer</code> 的 <code>append</code> 方法是 <code>synchronized</code> 方法，但 <code>sb</code> 对象不会逃逸，JVM 经过逃逸分析后，会将 <code>append</code> 方法中的锁代码消除，从而避免了锁的开销。</p>
<p>【示例】锁消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockEliminationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 StringBuffer 对象，它不会逃逸出该方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        sb.append(s3);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> concatString(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>StringBuffer</code> 对象 <code>sb</code> 只在 <code>concatString</code> 方法内部使用，不会被其他方法访问。因此，JVM 在即时编译时会进行逃逸分析，并将 <code>append</code> 方法中的锁代码消除。</p>
<p>::: info 锁粗化</p>
<p>:::</p>
<p>锁粗化是指：在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。</p>
<p>如果<strong>一系列的连续操作都对同一个对象反复加锁和解锁</strong>，频繁的加锁操作就会导致性能损耗。</p>
<h3 id="【中等】final-关键字可以保证线程的可见性吗？"><a href="#【中等】final-关键字可以保证线程的可见性吗？" class="headerlink" title="【中等】final 关键字可以保证线程的可见性吗？"></a>【中等】final 关键字可以保证线程的可见性吗？</h3><p><strong>final 本身不能直接保证线程间的可见性</strong>。</p>
<p><strong>但 final 修饰的字段在正确初始化后，对其他线程是可见的（JMM 保证）</strong>。对象构造完成时，final 字段的初始化值对所有线程立即可见。不需要额外的同步措施（如 volatile&#x2F;synchronized）。</p>
<p>final 的线程可见性仅限于<strong>初始化阶段</strong>，适用于：</p>
<ul>
<li>声明不可变常量（如 <code>final int MAX = 100</code>）</li>
<li>构造线程安全对象（如 <code>final AtomicReference</code>）</li>
</ul>
<p>如果需要<strong>持续可见性</strong>（如状态标志位），仍需使用 <code>volatile</code> 或同步机制。</p>
<p>非 final 字段对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">42</span>;  <span class="comment">// 构造后所有线程看到x=42</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;        <span class="comment">// 其他线程可能看到y=0（默认值）或10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层实现机制</strong></p>
<ul>
<li><strong>JVM 会插入内存屏障</strong>：确保 final 字段初始化后对所有线程可见。</li>
<li><strong>与 happens-before 规则关联</strong>：对象构造结束 happens-before 于其他线程看到该对象。</li>
</ul>
<p><strong>使用限制</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否线程安全</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>final 基本类型</strong></td>
<td>✔️ 安全</td>
<td>int&#x2F;long 等初始化后不可变</td>
</tr>
<tr>
<td><strong>final 引用类型</strong></td>
<td>⚠️ 部分安全</td>
<td>引用不可变，但对象内部状态可能变化</td>
</tr>
<tr>
<td><strong>非 final 字段</strong></td>
<td>❌ 不安全</td>
<td>需要额外同步</td>
</tr>
</tbody></table>
<p>危险示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// map引用不可变，但map.put()操作非线程安全！</span></span><br></pre></td></tr></table></figure>

<p><strong>最佳实践</strong></p>
<p>（1）<strong>优先用 final 修饰不可变数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>); <span class="comment">// 线程安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>需要跨线程可见的变量应使用 volatile</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>避免以下错误用法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误！final 不能保证对象内部线程安全</span></span><br><span class="line"><span class="keyword">final</span> List&lt;String&gt; unsafeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8f953f1c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8f953f1c/" class="post-title-link" itemprop="url">MySQL 优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 20:16:48" itemprop="dateCreated datePublished" datetime="2020-06-03T20:16:48+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-优化"><a href="#MySQL-优化" class="headerlink" title="MySQL 优化"></a>MySQL 优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>慢查询日志可以帮我们找到执行慢的 SQL。</p>
<p>可以通过以下命令查看慢查询日志是否开启：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>启停慢查询日志开关：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 关闭慢查询日志</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看慢查询的时间阈值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>设置慢查询的时间阈值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 自带了一个 mysqldumpslow 工具，用于统计慢查询日志（这个工具是个 Perl 脚本，需要先安装好 Perl）。</p>
<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li><code>-s</code> - 采用 order 排序的方式，排序方式可以有以下几种。分别是 c（访问次数）、t（查询时间）、l（锁定时间）、r（返回记录）、ac（平均查询次数）、al（平均锁定时间）、ar（平均返回记录数）和 at（平均查询时间）。其中 at 为默认排序方式。</li>
<li><code>-t</code> - 返回前 N 条数据 。</li>
<li><code>-g</code> - 后面可以是正则表达式，对大小写不敏感。</li>
</ul>
<p>比如想要按照查询时间排序，查看前两条 SQL 语句，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl mysqldumpslow.pl -s t -t 2 &quot;C:\ProgramData\MySQL\MySQL Server 8.0\Data\slow.log&quot;</span><br></pre></td></tr></table></figure>

<h2 id="执行计划（EXPLAIN）"><a href="#执行计划（EXPLAIN）" class="headerlink" title="执行计划（EXPLAIN）"></a>执行计划（EXPLAIN）</h2><p><strong>“执行计划”是对 SQL 查询语句在数据库中执行过程的描述</strong>。 如果要分析某条 SQL 的性能问题，通常需要先查看 SQL 的执行计划，排查每一步 SQL 执行是否存在问题。</p>
<p>很多数据库都支持执行计划，MySQL 也不例外。在 MySQL 中，用户可以通过 <code>EXPLAIN</code> 命令查看优化器针对指定 SQL 生成的逻辑执行计划。 </p>
<p>【示例】MySQL 执行计划示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line"><span class="keyword">          key</span>: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>执行计划返回结果参数说明：</p>
<ul>
<li><code>id</code> - SELECT 查询的标识符。每个 <code>SELECT</code> 都会自动分配一个唯一的标识符。</li>
<li><code>select_type</code> - <code>SELECT</code> 查询的类型。<ul>
<li><code>SIMPLE</code> - 表示此查询不包含 <code>UNION</code> 查询或子查询。</li>
<li><code>PRIMARY</code> - 表示此查询是最外层的查询。</li>
<li><code>UNION</code> - 表示此查询是 <code>UNION</code> 的第二或随后的查询。</li>
<li><code>DEPENDENT UNION</code> - <code>UNION</code> 中的第二个或后面的查询语句, 取决于外面的查询。</li>
<li><code>UNION RESULT</code> - <code>UNION</code> 的结果。</li>
<li><code>SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>。</li>
<li><code>DEPENDENT SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>, 取决于外面的查询. 即子查询依赖于外层查询的结果。</li>
</ul>
</li>
<li><code>table</code> - 查询的是哪个表，如果给表起别名了，则显示别名。</li>
<li><code>partitions</code> - 匹配的分区。</li>
<li><code>type</code> - 表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，执行效率由高到低依次为：<ul>
<li><code>system</code>&#x2F;<code>const</code> - 表中只有一行数据匹配。此时根据索引查询一次就能找到对应的数据。如果是 B+ 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。<code>const</code> 表示此时索引在第一层，只需访问一层便能得到数据。</li>
<li><code>eq_ref</code> - 使用唯一索引扫描。常见于多表连接中使用主键和唯一索引作为关联条件。</li>
<li><code>ref</code> - 非唯一索引扫描。还可见于唯一索引最左原则匹配扫描。</li>
<li><code>range</code> - 索引范围扫描。比如 <code>&lt;</code>，<code>&gt;</code>，<code>between</code> 等操作。</li>
<li><code>index</code> - 索引全表扫描。此时遍历整个索引树。</li>
<li><code>ALL</code> - 表示全表扫描。需要遍历全表来找到对应的行。</li>
</ul>
</li>
<li><code>possible_keys</code> - 此次查询中可能选用的索引。</li>
<li><code>key</code> - 此次查询中实际使用的索引。如果这一项为 <code>NULL</code>，说明没有使用索引。</li>
<li><code>ref</code> - 哪个字段或常数与 key 一起被使用。</li>
<li><code>rows</code> - 显示此查询一共扫描了多少行，这个是一个估计值。</li>
<li><code>filtered</code> - 表示此查询条件所过滤的数据的百分比。</li>
<li><code>extra</code> - 额外的信息。<ul>
<li><code>Using filesort</code> - 当查询语句中包含 <code>GROUP BY</code> 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li><code>Using temporary</code> - 使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 <code>ORDER BY</code> 和分组查询 <code>GROUP BY</code>。效率低，要避免这种问题的出现。</li>
<li><code>Using index</code> - 所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多内容请参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></p>
</blockquote>
<h2 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h2><p>在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。</p>
<p>如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> NAME <span class="operator">&gt;</span><span class="string">&#x27;name84059&#x27;</span> <span class="keyword">AND</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-01-24 05:00</span></span><br><span class="line"><span class="string">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span></span><br><span class="line"><span class="string">SET optimizer_trace=&quot;enabled=off&quot;;</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化基本思路"><a href="#SQL-优化基本思路" class="headerlink" title="SQL 优化基本思路"></a>SQL 优化基本思路</h3><p>使用 <code>EXPLAIN</code> 命令查看当前 SQL 是否使用了索引，优化后，再通过执行计划（<code>EXPLAIN</code>）来查看优化效果。</p>
<p>SQL 优化的基本思路：</p>
<ul>
<li><p><strong>只返回必要的列</strong> - 最好不要使用 <code>SELECT *</code> 语句。</p>
</li>
<li><p><strong>只返回必要的行</strong> - 使用 <code>WHERE</code> 子查询语句进行过滤查询，有时候也需要使用 <code>LIMIT</code> 语句来限制返回的数据。</p>
</li>
<li><p><strong>缓存重复查询的数据</strong> - 应该考虑在客户端使用缓存，尽量不要使用 MySQL 服务器缓存（存在较多问题和限制）。</p>
</li>
<li><p><strong>使用索引覆盖查询</strong></p>
</li>
</ul>
<h3 id="优化分页"><a href="#优化分页" class="headerlink" title="优化分页"></a>优化分页</h3><p>当需要分页操作时，通常会使用 <code>LIMIT</code> 加上偏移量的办法实现，同时加上合适的 <code>ORDER BY</code> 字句。<strong>如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作</strong>。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：<code>LIMIT 1000000 20</code> 这样的查询，MySQL 需要查询 1000020 条记录然后只返回 20 条记录，前面的 1000000  条都将被抛弃，这样的代价非常高。</p>
<p>针对分页优化，有以下两种方案</p>
<p>（1）方案 - 延迟关联</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>如果这张表非常大，那么这个查询最好改成下面的样子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>

<p>这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>（2）方案 - 书签方式</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用 <code>OFFSET</code>，比如下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原语句</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 优化语句</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h3 id="优化-JOIN"><a href="#优化-JOIN" class="headerlink" title="优化 JOIN"></a>优化 JOIN</h3><p>优化子查询</p>
<p>尽量使用 <code>JOIN</code> 语句来替代子查询。因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大。</p>
<p>小表驱动大表</p>
<p>JOIN 查询时，应该用小表驱动大表。因为 JOIN 时，MySQL 内部会先遍历驱动表，再去遍历被驱动表。</p>
<p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B ;</span><br></pre></td></tr></table></figure>

<p>适当冗余字段</p>
<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>
<p>避免 JOIN 太多表</p>
<p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p>
<p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p>
<h3 id="优化-UNION"><a href="#优化-UNION" class="headerlink" title="优化 UNION"></a>优化 UNION</h3><p>MySQL 执行 <code>UNION</code> 的策略是：先创建临时表，然后将各个查询结果填充到临时表中，最后再进行查询。很多优化策略在 <code>UNION</code> 查询中都会失效，因为它无法利用索引。</p>
<p>最好将 <code>WHERE</code>、<code>LIMIT</code> 等子句下推到 <code>UNION</code> 的各个子查询中，以便优化器可以充分利用这些条件进行优化。</p>
<p>此外，尽量使用 <code>UNION ALL</code>，避免使用 <code>UNION</code>。</p>
<p><code>UNION</code> 和 <code>UNION ALL</code> 都是将两个结果集合并为一个，<strong>两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）</strong>。</p>
<ul>
<li><code>UNION</code> 需要进行去重扫描，因此消息较低；而 <code>UNION ALL</code> 不会进行去重。</li>
<li><code>UNION</code> 会按照字段的顺序进行排序；而 <code>UNION ALL</code> 只是简单的将两个结果合并就返回。</li>
</ul>
<h3 id="优化-COUNT-查询"><a href="#优化-COUNT-查询" class="headerlink" title="优化 COUNT() 查询"></a>优化 COUNT() 查询</h3><p><code>COUNT()</code> 有两种作用：</p>
<ul>
<li>统计某个列值的数量。统计列值时，要求列值是非 <code>NULL</code> 的，它不会统计 <code>NULL</code>。</li>
<li>统计行数。</li>
</ul>
<p><strong>统计列值时，要求列值是非空的，它不会统计 NULL</strong>。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用 <code>COUNT(*)</code> 时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用 <code>COUNT(*)</code>，意义清晰，且性能更好。</p>
<p>（1）简单优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city) <span class="operator">-</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>（2）使用近似值</p>
<p>有时候某些业务场景并不需要完全精确的统计值，可以用近似值来代替，<code>EXPLAIN</code> 出来的行数就是一个不错的近似值，而且执行 <code>EXPLAIN</code> 并不需要真正地去执行查询，所以成本非常低。通常来说，执行 <code>COUNT()</code> 都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 Redis 这样的外部缓存系统。</p>
<h3 id="优化查询方式"><a href="#优化查询方式" class="headerlink" title="优化查询方式"></a>优化查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELEFT <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h4><p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>通过索引覆盖查询，可以优化排序、分组。</p>
<p>详情见 <a href="https://dunwu.github.io/waterdrop/pages/2f9875b2/">MySQL 索引</a></p>
<h2 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h2><p>良好的逻辑设计和物理设计是高性能的基石。</p>
<h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><h4 id="数据类型优化基本原则"><a href="#数据类型优化基本原则" class="headerlink" title="数据类型优化基本原则"></a>数据类型优化基本原则</h4><ul>
<li><strong>更小的通常更好</strong> - 越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。<ul>
<li>例如：整型比字符类型操作代价低，因而会使用整型来存储 IP 地址，使用 <code>DATETIME</code> 来存储时间，而不是使用字符串。</li>
</ul>
</li>
<li><strong>简单就好</strong> - 如整型比字符型操作代价低。<ul>
<li>例如：很多软件会用整型来存储 IP 地址。</li>
<li>例如：**<code>UNSIGNED</code> 表示不允许负值，大致可以使正数的上限提高一倍**。</li>
</ul>
</li>
<li><strong>尽量避免 NULL</strong> - 可为 NULL 的列会使得索引、索引统计和值比较都更复杂。</li>
</ul>
<h4 id="类型的选择"><a href="#类型的选择" class="headerlink" title="类型的选择"></a>类型的选择</h4><ul>
<li><p>整数类型通常是标识列最好的选择，因为它们很快并且可以使用 <code>AUTO_INCREMENT</code>。</p>
</li>
<li><p><code>ENUM</code> 和 <code>SET</code> 类型通常是一个糟糕的选择，应尽量避免。</p>
</li>
<li><p>应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 <code>MD5</code>、<code>SHA</code>、<code>UUID</code> 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 <code>INSERT</code> 以及一些 <code>SELECT</code> 语句变得很慢。</p>
<ul>
<li>如果存储 UUID ，应该移除 <code>-</code> 符号；更好的做法是，用 <code>UNHEX()</code> 函数转换 UUID 值为 16 字节的数字，并存储在一个 <code>BINARY(16)</code> 的列中，检索时，可以通过 <code>HEX()</code> 函数来格式化为 16 进制格式。</li>
</ul>
</li>
</ul>
<h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>应该避免的设计问题：</p>
<ul>
<li><strong>太多的列</strong> - 设计者为了图方便，将大量冗余列加入表中，实际查询中，表中很多列是用不到的。这种宽表模式设计，会造成不小的性能代价，尤其是 <code>ALTER TABLE</code> 非常耗时。</li>
<li><strong>太多的关联</strong> - 所谓的实体 - 属性 - 值（EAV）设计模式是一个常见的糟糕设计模式。MySQL 限制了每个关联操作最多只能有 61 张表，但 EAV 模式需要许多自关联。</li>
<li><strong>枚举</strong> - 尽量不要用枚举，因为添加和删除字符串（枚举选项）必须使用 <code>ALTER TABLE</code>。</li>
<li>尽量避免 <code>NULL</code></li>
</ul>
<h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p><strong>范式化目标是尽量减少冗余，而反范式化则相反</strong>。</p>
<p>范式化的优点：</p>
<ul>
<li>比反范式更节省空间</li>
<li>更新操作比反范式快</li>
<li>更少需要 <code>DISTINCT</code> 或 <code>GROUP BY</code> 语句</li>
</ul>
<p>范式化的缺点：</p>
<ul>
<li>通常需要关联查询。而关联查询代价较高，如果是分表的关联查询，代价更是高昂。</li>
</ul>
<p>在真实世界中，很少会极端地使用范式化或反范式化。实际上，应该权衡范式和反范式的利弊，混合使用。</p>
<h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><blockquote>
<p>索引优化应该是查询性能优化的最有效手段。</p>
<p>如果想详细了解索引特性请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md">MySQL 索引</a></p>
</blockquote>
<h4 id="何时使用索引"><a href="#何时使用索引" class="headerlink" title="何时使用索引"></a>何时使用索引</h4><ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li>对于中、大型表，索引非常有效。</li>
<li>对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术。</li>
<li>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。</li>
</ul>
<h4 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h4><ul>
<li><strong>索引基本原则</strong><ul>
<li>索引不是越多越好，不要为所有列都创建索引。</li>
<li>要尽量避免冗余和重复索引。</li>
<li>要考虑删除未使用的索引。</li>
<li>尽量的扩展索引，不要新建索引。</li>
<li>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引。</li>
</ul>
</li>
<li><strong>独立的列</strong> - “独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。</li>
<li><strong>前缀索引</strong> - 索引很长的字符列，可以索引开始的部分字符，这样可以大大节约索引空间。</li>
<li><strong>最左匹配原则</strong> - 将选择性高的列或基数大的列优先排在多列索引最前列。</li>
<li><strong>使用索引来排序</strong> - 索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。</li>
<li><code>=</code>、<code>IN</code> 可以乱序 - 不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</li>
<li><strong>覆盖索引</strong></li>
<li><strong>自增字段作主键</strong></li>
</ul>
<h2 id="数据模型和业务"><a href="#数据模型和业务" class="headerlink" title="数据模型和业务"></a>数据模型和业务</h2><ul>
<li>表字段比较复杂、易变动、结构难以统一的情况下，可以考虑使用 Nosql 来代替关系数据库表存储，如 ElasticSearch、MongoDB。</li>
<li>在高并发情况下的查询操作，可以使用缓存（如 Redis）代替数据库操作，提高并发性能。</li>
<li>数据量增长较快的表，需要考虑水平分表或分库，避免单表操作的性能瓶颈。</li>
<li>除此之外，我们应该通过一些优化，尽量避免比较复杂的 JOIN 查询操作，例如冗余一些字段，减少 JOIN 查询；创建一些中间表，减少 JOIN 查询。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">极客时间教程 - Java 性能调优实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d7665192aaaf">我必须得告诉大家的 MySQL 优化原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html">MySQL 官方文档之执行计划</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/79b99f86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/79b99f86/" class="post-title-link" itemprop="url">MySQL 事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 19:32:09" itemprop="dateCreated datePublished" datetime="2020-06-03T19:32:09+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>::: info 概述</p>
<p>不是所有的 MySQL 存储引擎都实现了事务处理。支持事务的存储引擎有：<code>InnoDB</code> 和 <code>NDB Cluster</code>。不支持事务的存储引擎，代表有：<code>MyISAM</code>。</p>
<p>用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。</p>
<p>:::</p>
<h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p><strong>“事务”指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242207831.png"></p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>事务相关的语句如下：</p>
<ul>
<li><code>BEGIN</code> &#x2F; <code>START TRANSACTION</code> - <strong>用于标记事务的起始点</strong>。</li>
<li><code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> - <strong>用于标记事务的起始点</strong>。</li>
<li><code>SAVEPOINT</code> - <strong>用于创建保存点</strong>。方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li><code>RELEASE SAVEPOINT</code> - 删除某个保存点。</li>
<li><code>ROLLBACK TO</code> - <strong>用于回滚到指定的保存点</strong>。如果没有设置保存点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - <strong>提交事务</strong>。</li>
<li><code>SET TRANSACTION</code> - 设置事务的隔离级别。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>两种开启事务的命令，启动时机是不同的：</p>
<ul>
<li>执行了 <code>BEGIN</code> &#x2F; <code>START TRANSACTION</code> 命令后，并不代表事务立刻启动，而是当执行了增删查操作时，才真正启动事务。</li>
<li>执行了 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 命令，会立刻启动事务。</li>
</ul>
</blockquote>
<p>事务处理示例：</p>
<p>（1）创建一张示例表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 撤销表 user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 user</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">	`username` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">	`password` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">	`email` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT <span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>（2）执行事务操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> `updateA`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> `updateA`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>（3）查询结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> email        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> root1    <span class="operator">|</span> root1    <span class="operator">|</span> xxxx<span class="variable">@163</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;AUTOCOMMIT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p><strong>“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换</strong>。</p>
<p>如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242209867.png"></p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据</strong>。</p>
<p>如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242210430.png"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致</strong>。</p>
<p>如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242211015.png"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据</strong>。</p>
<p>事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242212639.png"></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="事务隔离级别简介"><a href="#事务隔离级别简介" class="headerlink" title="事务隔离级别简介"></a>事务隔离级别简介</h3><p>为了解决以上提到的<a href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">“并发一致性问题”</a>，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p>
<p>事务隔离级别从低到高分别是：</p>
<ul>
<li><strong>“读未提交（read uncommitted）”</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</li>
<li><strong>“读已提交（read committed）” ** - 是指，</strong>事务提交后，其他事务才能看到它的修改**。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。<ul>
<li><strong>读已提交解决了脏读的问题</strong>。</li>
<li>读已提交是大多数数据库的默认事务隔离级别，如 Oracle。</li>
</ul>
</li>
<li><strong>“可重复读（repeatable read）”</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。<ul>
<li><strong>可重复读解决了不可重复读问题</strong>。</li>
<li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li>
</ul>
</li>
<li><strong>串行化（serializable ）</strong> - 是指，<strong>强制事务串行执行</strong>，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。<ul>
<li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li>
<li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li>
</ul>
</li>
</ul>
<p>事务隔离级别对并发一致性问题的解决情况：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">丢失修改</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
</tr>
</tbody></table>
<h3 id="查看和设置事务隔离级别"><a href="#查看和设置事务隔离级别" class="headerlink" title="查看和设置事务隔离级别"></a>查看和设置事务隔离级别</h3><p>可以通过 <code>SHOW VARIABLES LIKE &#39;transaction_isolation&#39;</code> 语句查看事务隔离级别。</p>
<p>【示例】查看事务隔离示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>MySQL 提供了 <code>SET TRANSACTION</code> 语句，该语句可以改变单个会话或全局的事务隔离级别。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> REPEATABLE READ <span class="operator">|</span> SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>SESSION</code> 和 <code>GLOBAL</code> 关键字用来指定修改的事务隔离级别的范围：</p>
<ul>
<li><code>SESSION</code> - 表示修改的事务隔离级别，将应用于当前会话内的所有事务。</li>
<li><code>GLOBAL</code> - 表示修改的事务隔离级别，将应用于所有会话内的所有事务（即全局修改），且当前已经存在的会话不受影响；</li>
<li>如果省略 <code>SESSION</code> 和 <code>GLOBAL</code>，表示修改的事务隔离级别，将应用于当前会话内的下一个还未开始的事务。</li>
</ul>
<p>【示例】设置事务隔离示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别为 READ UNCOMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ COMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 REPEATABLE READ</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 SERIALIZABLE</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>

<h3 id="事务隔离级别实现方式"><a href="#事务隔离级别实现方式" class="headerlink" title="事务隔离级别实现方式"></a>事务隔离级别实现方式</h3><p>MySQL 中的事务功能是在存储引擎层实现的，<strong>并非所有存储引擎都支持事务功能</strong>。InnoDB 是 MySQL 的首先事务存储引擎。</p>
<p>四种隔离级别具体是如何实现的呢？</p>
<p>以 InnoDB 的事务实现来说明：</p>
<ul>
<li>对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。<ul>
<li>“读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView</li>
<li>“可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于 ReadView 更多细节，将在 MVCC 章节中阐述。</p>
</blockquote>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>在高并发场景下，多事务同时执行，可能会出现种种并发一致性问题。最常见，也是最容易想到的解决问题思路就是：对访问的数据加锁，通过强制互斥来解决问题。但是，加锁就意味着阻塞，势必会增加响应时间，降低系统整体吞吐量。在大多数真实的业务场景中，读请求远大于写请求，由于读请求并不会修改数据，自然也不存在一致性问题，因此为占大多数的读请求加锁是一种不必要的开销。那么，我们很自然的会想到，如果只针对写操作加锁，不就能大大提升吞吐量了吗？没错，有一种名为<strong>“写时复制（Copy-On-Write，简称 COW）”</strong>的技术，正是基于这个想法而设计，并广泛应用于各种软件领域，例如：Java 中的 <code>CopyOnWriteArrayList</code> 等容器；Redis 中的 RDB 持久化过程。</p>
<p>Copy-On-Write 的核心思想是：假设有多个请求需要访问相同的数据，先为这份数据生成一个副本（也可以称为快照）。然后将读写分离，所有的读请求都直接访问原数据；所有的写请求都访问副本数据，为了实现并发一致性，写数据时需要通过加锁保证每次写操作只能由一个写请求完成。当写操作完成后，用副本数据替换原数据。</p>
<p>在 MySQL 中，也采用了 Copy-On-Write 设计思想，将读写分离。</p>
<ul>
<li>这里的“写”指的是当前读。<strong>“当前读”，顾名思义，指的是读取记录当前的数据。</strong>为了保证读取当前数据时，没有其他事务修改，因此需要对读取记录加锁。当前读的场景有下面几种：<ul>
<li><code>INSERT</code> - 插入操作</li>
<li><code>UPDATE</code> - 更新操作</li>
<li><code>DELETE</code> - 删除操作</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code> - 加共享锁（读锁）</li>
<li><code>SELECT ... FOR UPDATE</code> - 加独享锁（写锁）</li>
</ul>
</li>
<li>这里的“读”指的是快照读。<strong>“快照读”，顾名思义，指的是读取记录的某个历史快照版本</strong>。不加锁的普通 <code>SELECT</code> 都属于快照读，例如：<code>SELECT ... FROM</code>。采用快照读的前提是，事务隔离级别不是串行化级别。串行化级别下的快照读会退化成当前读。快照读的实现是基于 MVCC。</li>
</ul>
<h3 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h3><blockquote>
<p>前文提到，快照读的实现是基于 MVCC。那么，什么是 MVCC 呢？</p>
</blockquote>
<p><strong>MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”</strong>。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读&#x2F;写并发冲突，可以将其看成一种乐观锁。</p>
<p>不仅是 MySQL，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。<strong>MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式</strong>。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理"></a>MVCC 实现原理</h3><p>MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。</p>
<h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：</p>
<ul>
<li><code>DB_ROW_ID</code> - <strong>隐藏的自增 ID</strong>，如果数据表没有指定主键，InnoDB 会自动基于 <code>row_id</code> 产生一个聚簇索引。</li>
<li><code>DB_TRX_ID</code> - <strong>最近修改的事务 ID</strong>。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li><code>DB_ROLL_PTR</code> - <strong>回滚指针</strong>，指向这条记录的上一个版本。</li>
</ul>
<h4 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h4><p>MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 <code>roll_pointer</code> 把一个数据行的所有快照链接起来，构成一个<strong>版本链</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242213050.png"></p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p><strong>ReadView 就是事务进行快照读时产生的读视图（快照）</strong>。</p>
<p>ReadView 有四个重要的字段：</p>
<ul>
<li><code>m_ids</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li><code>min_trx_id</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 <code>m_ids</code> 的最小值。</li>
<li><code>max_trx_id</code> - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；</li>
<li><code>creator_trx_id</code> - 指的是创建该 ReadView 的事务的事务 ID。</li>
</ul>
<p>在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：</p>
<ul>
<li>已提交事务</li>
<li>已启动但未提交的事务</li>
<li>未启动的事务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242214504.png"></p>
<blockquote>
<p>ReadView 如何判断版本链中哪个版本可见？</p>
</blockquote>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li><code>trx_id == creator_trx_id</code> - 表示 <code>trx_id</code> 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。</li>
<li><code>trx_id &lt; min_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。</li>
<li><code>trx_id &gt;= max_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。</li>
<li><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> - 需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中<ul>
<li>如果 <code>trx_id</code> 在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。</li>
<li>如果 <code>trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务已提交，当前事务可以访问。</li>
</ul>
</li>
</ul>
<p>这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p>
<h3 id="MVCC-如何实现多种事务隔离级别"><a href="#MVCC-如何实现多种事务隔离级别" class="headerlink" title="MVCC 如何实现多种事务隔离级别"></a>MVCC 如何实现多种事务隔离级别</h3><p>对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。</p>
<ul>
<li>“读已提交”隔离级别，会在“每个语句执行前”都会重新生成一个 ReadView。</li>
<li>“可重复读”隔离级别，会在“启动事务时”生成一个 ReadView，然后整个事务期间都在复用这个 ReadView。</li>
</ul>
<p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h4 id="MVCC-实现可重复读"><a href="#MVCC-实现可重复读" class="headerlink" title="MVCC 实现可重复读"></a>MVCC 实现可重复读</h4><p><strong>可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView</strong>。这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 将 value 设为 200；</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据，value 依旧为 100；</li>
</ul>
<p>以上操作，如下图所示。T2 事务在事务过程中，是否可以看到 T1 事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242217983.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出 <code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见。</li>
</ul>
<p>综上所述，在 T2 事务中，自始至终只能看到 <code>trx_id = 100</code> 的版本记录。</p>
<h4 id="MVCC-实现读已提交"><a href="#MVCC-实现读已提交" class="headerlink" title="MVCC 实现读已提交"></a>MVCC 实现读已提交</h4><p><strong>读已提交隔离级别每次读取数据时都会创建一个 ReadView</strong>。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 将 value 设为 100；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 100；</li>
</ul>
<p>以上操作，如下图所示，T2 事务在事务过程中，是否可以看到其他事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503242218464.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出第二次查询时（T1 更新未提交），<code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见；而第三次查询时（T1 更新已提交），<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中可见；</li>
</ul>
<p>综上所述，在 T2 事务中，当 T1 事务提交前，可读取到的是 <code>trx_id = 100</code> 的版本记录；当 T1 事务提交后，可读取到的是 <code>trx_id = 101</code> 的版本记录。</p>
<h4 id="MVCC-Next-Key-Lock-解决幻读"><a href="#MVCC-Next-Key-Lock-解决幻读" class="headerlink" title="MVCC + Next-Key Lock 解决幻读"></a>MVCC + Next-Key Lock 解决幻读</h4><p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了）。针对快照读和当前读，InnoDB 的处理方式各不相同。</p>
<blockquote>
<p>快照读是如何避免幻读的？</p>
</blockquote>
<p>针对<strong>快照读</strong>（普通 <code>SELECT</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
<blockquote>
<p>当前读是如何避免幻读的？</p>
</blockquote>
<p>针对<strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 <code>SELECT ... FOR UPDATE</code> 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</p>
<blockquote>
<p>幻读被完全解决了吗？</p>
</blockquote>
<p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<p>【示例】幻读案例一</p>
<p>环境：存储引擎为 InnoDB；事务隔离级别为可重复读</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- --------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 实验说明：以下 SQL 脚本必须严格按照顺序执行，并且事务 A 和事务 B 必须在不同的 Client 中执行。</span></span><br><span class="line"><span class="comment">-- ----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （1）数据初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 test</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据初始化</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （2）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （3）事务 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （4）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果依然为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成功更新本应看不到的记录 id = 4</span></span><br><span class="line"><span class="keyword">UPDATE</span> `test` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再一次查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"><span class="comment">-- | id | value |</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"><span class="comment">-- |  4 |     0 |</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>以上示例代码的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070630072.png"></p>
<p>【示例】幻读案例二</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- --------------------------------------------------------------------- （1）数据初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 test</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据初始化</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （2）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id &gt; 2 的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- | count(*) |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- |        1 |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （3）事务 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （4）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id &gt; 2 的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- | count(*) |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- |        2 |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 <code>select ... for update</code> 这类当前读的语句</strong>，因为它会对记录加 Next-Key Lock，从而避免其他事务插入一条新记录。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 <strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong><ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>MQ 事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案分析：</p>
<ul>
<li>2PC&#x2F;3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表&#x2F;MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<blockquote>
<p>分布式事务详细说明、分析请参考：<a href="https://dunwu.github.io/waterdrop/pages/f293688d/">分布式事务基本原理</a></p>
</blockquote>
<h2 id="事务最佳实践"><a href="#事务最佳实践" class="headerlink" title="事务最佳实践"></a>事务最佳实践</h2><p>高并发场景下的事务到底该如何调优？</p>
<h3 id="尽量使用低级别事务隔离"><a href="#尽量使用低级别事务隔离" class="headerlink" title="尽量使用低级别事务隔离"></a>尽量使用低级别事务隔离</h3><p>结合业务场景，尽量使用低级别事务隔离</p>
<h3 id="避免行锁升级表锁"><a href="#避免行锁升级表锁" class="headerlink" title="避免行锁升级表锁"></a>避免行锁升级表锁</h3><p>在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。</p>
<h3 id="缩小事务范围"><a href="#缩小事务范围" class="headerlink" title="缩小事务范围"></a>缩小事务范围</h3><p>有时候，数据库并发访问量太大，会出现以下异常：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQLQueryInterruptedException: Query execution was <span class="built_in">int</span>errupted</span><br></pre></td></tr></table></figure>

<p>高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。</p>
<p>又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630112600.png" alt="img"></p>
<p>如上图中的操作，虽然都是在一个事务中，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。</p>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-transaction-model.html">MySQL 官方文档之 InnoDB 锁和事务模型</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d6ebb57d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d6ebb57d/" class="post-title-link" itemprop="url">Kafka 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 09:55:35" itemprop="dateCreated datePublished" datetime="2020-06-03T09:55:35+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-快速入门"><a href="#Kafka-快速入门" class="headerlink" title="Kafka 快速入门"></a>Kafka 快速入门</h1><h2 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h2><p><strong>Apache Kafka 是一款开源的消息引擎系统，也是一个分布式流计算平台，此外，还可以作为数据存储</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/mq/kafka/kafka-event-system.png" alt="img"></p>
<h3 id="Kafka-的功能"><a href="#Kafka-的功能" class="headerlink" title="Kafka 的功能"></a>Kafka 的功能</h3><p>Kafka 的核心功能如下：</p>
<ul>
<li><strong>消息引擎</strong> - Kafka 可以作为一个消息引擎系统。</li>
<li><strong>流处理</strong> - Kafka 可以作为一个分布式流处理平台。</li>
<li><strong>存储</strong> - Kafka 可以作为一个安全的分布式存储。</li>
</ul>
<h3 id="Kafka-的特性"><a href="#Kafka-的特性" class="headerlink" title="Kafka 的特性"></a>Kafka 的特性</h3><p>Kafka 的设计目标：</p>
<ul>
<li><strong>高性能</strong><ul>
<li><strong>分区、分段、索引</strong>：基于分区机制提供并发处理能力。分段、索引提升了数据读写的查询效率。</li>
<li><strong>顺序读写</strong>：使用顺序读写提升磁盘 IO 性能。</li>
<li><strong>零拷贝</strong>：利用零拷贝技术，提升网络 I&#x2F;O 效率。</li>
<li><strong>页缓存</strong>：利用操作系统的 PageCache 来缓存数据（典型的利用空间换时间）</li>
<li><strong>批量读写</strong>：批量读写可以有效提升网络 I&#x2F;O 效率。</li>
<li><strong>数据压缩</strong>：Kafka 支持数据压缩，可以有效提升网络 I&#x2F;O 效率。</li>
<li><strong>pull 模式</strong>：Kafka 架构基于 pull 模式，可以自主控制消费策略，提升传输效率。</li>
</ul>
</li>
<li><strong>高可用</strong><ul>
<li><strong>持久化</strong>：Kafka 所有的消息都存储在磁盘，天然支持持久化。</li>
<li><strong>副本机制</strong>：Kafka 的 Broker 集群支持副本机制，可以通过冗余，来保证其整体的可用性。</li>
<li><strong>选举 Leader</strong>：Kafka 基于 ZooKeeper 支持选举 Leader，实现了故障转移能力。</li>
</ul>
</li>
<li><strong>伸缩性</strong><ul>
<li><strong>分区</strong>：Kafka 的分区机制使得其具有良好的伸缩性。</li>
</ul>
</li>
</ul>
<h3 id="Kafka-术语"><a href="#Kafka-术语" class="headerlink" title="Kafka 术语"></a>Kafka 术语</h3><ul>
<li><strong>消息</strong>：Kafka 的数据单元被称为消息。消息由字节数组组成。</li>
<li><strong>批次</strong>：批次就是一组消息，这些消息属于同一个主题和分区。</li>
<li><strong>主题（Topic）</strong>：Kafka 消息通过主题进行分类。主题就类似数据库的表。<ul>
<li>不同主题的消息是物理隔离的；</li>
<li>同一个主题的消息保存在一个或多个 Broker 上。但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处。</li>
<li>主题有一个或多个分区。</li>
</ul>
</li>
<li><strong>分区（Partition）</strong>：分区是一个有序不变的消息序列，消息以追加的方式写入分区，然后以先入先出的顺序读取。Kafka 通过分区来实现数据冗余和伸缩性。</li>
<li><strong>消息偏移量（Offset）</strong>：表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li>
<li><strong>生产者（Producer）</strong>：生产者是向主题发布新消息的 Kafka 客户端。生产者可以将数据发布到所选择的主题中。生产者负责将记录分配到主题中的哪一个分区中。</li>
<li><strong>消费者（Consumer）</strong>：消费者是从主题订阅新消息的 Kafka 客户端。消费者通过检查消息的偏移量来区分消息是否已读。</li>
<li><strong>消费者群组（Consumer Group）</strong>：多个消费者共同构成的一个群组，同时消费多个分区以实现高并发。<ul>
<li>每个消费者属于一个特定的消费者群组（可以为每个消费者指定消费者群组，若不指定，则属于默认的群组）。</li>
<li>群组中，一个消费者可以消费多个分区。</li>
<li>群组中，每个分区只能被指定给一个消费者。</li>
</ul>
</li>
<li><strong>再均衡（Rebalance）</strong>：消费者群组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。分区再均衡是 Kafka 消费者端实现高可用的重要手段。</li>
<li><strong>Broker</strong> - 一个独立的 Kafka 服务器被称为 Broker。Broker 接受来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；消费者向 Broker 请求消息，Broker 负责返回已提交的消息。</li>
<li><strong>副本（Replica）</strong>：Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li>
</ul>
<h3 id="Kafka-发行版本"><a href="#Kafka-发行版本" class="headerlink" title="Kafka 发行版本"></a>Kafka 发行版本</h3><p>Kafka 主要有以下发行版本：</p>
<ul>
<li><strong>Apache Kafka</strong>：也称社区版 Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。</li>
<li><strong>Confluent Kafka</strong>：Confluent 公司提供的 Kafka。优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。</li>
<li><strong>CDH&#x2F;HDP Kafka</strong>：大数据云公司提供的 Kafka，内嵌 Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。</li>
</ul>
<h3 id="Kafka-重大版本"><a href="#Kafka-重大版本" class="headerlink" title="Kafka 重大版本"></a>Kafka 重大版本</h3><p>Kafka 有以下重大版本：</p>
<ul>
<li>0.7 - 只提供了最基础的消息队列功能</li>
<li>0.8<ul>
<li>正式引入了副本机制</li>
<li>至少升级到 0.8.2.2</li>
</ul>
</li>
<li>0.9<ul>
<li>增加了基础的安全认证 &#x2F; 权限功能</li>
<li>用 Java 重写了新版本消费者 API</li>
<li>引入了 Kafka Connect 组件</li>
<li>新版本 Producer API 在这个版本中算比较稳定</li>
</ul>
</li>
<li>0.10<ul>
<li>引入了 Kafka Streams，正式升级成分布式流处理平台</li>
<li>至少升级到 0.10.2.2</li>
<li>修复了一个可能导致 Producer 性能降低的 Bug</li>
</ul>
</li>
<li>0.11<ul>
<li>提供幂等性 Producer API 以及事务</li>
<li>对 Kafka 消息格式做了重构</li>
<li>至少升级到 0.11.0.3</li>
</ul>
</li>
<li>1.0 和 2.0 - Kafka Streams 的改进</li>
</ul>
<h2 id="Kafka-服务端使用入门"><a href="#Kafka-服务端使用入门" class="headerlink" title="Kafka 服务端使用入门"></a>Kafka 服务端使用入门</h2><h3 id="步骤一、获取-Kafka"><a href="#步骤一、获取-Kafka" class="headerlink" title="步骤一、获取 Kafka"></a>步骤一、获取 Kafka</h3><p>下载最新的 Kafka 版本并解压到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzf kafka_2.13-2.7.0.tgz</span><br><span class="line">$ <span class="built_in">cd</span> kafka_2.13-2.7.0</span><br></pre></td></tr></table></figure>

<h3 id="步骤二、启动-Kafka-环境"><a href="#步骤二、启动-Kafka-环境" class="headerlink" title="步骤二、启动 Kafka 环境"></a>步骤二、启动 Kafka 环境</h3><blockquote>
<p>注意：本地必须已安装 Java8</p>
</blockquote>
<p>执行以下指令，保证所有服务按照正确的顺序启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start the ZooKeeper service</span></span><br><span class="line"><span class="comment"># Note: Soon, ZooKeeper will no longer be required by Apache Kafka.</span></span><br><span class="line">$ bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>

<p>打开另一个终端会话，并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start the Kafka broker service</span></span><br><span class="line">$ bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>

<p>一旦所有服务成功启动，您就已经成功运行了一个基本的 kafka 环境。</p>
<h3 id="步骤三、创建一个-TOPIC-并存储您的事件"><a href="#步骤三、创建一个-TOPIC-并存储您的事件" class="headerlink" title="步骤三、创建一个 TOPIC 并存储您的事件"></a>步骤三、创建一个 TOPIC 并存储您的事件</h3><p>Kafka 是一个分布式事件流处理平台，它可以让您通过各种机制读、写、存储并处理事件（<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#messages"><em>events</em></a>，也被称为记录或消息）</p>
<p>示例事件包括付款交易，手机的地理位置更新，运输订单，物联网设备或医疗设备的传感器测量等等。 这些事件被组织并存储在主题中（<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#intro_concepts_and_terms"><em>topics</em></a>）。 简单来说，主题类似于文件系统中的文件夹，而事件是该文件夹中的文件。</p>
<p>因此，在您写入第一个事件之前，您必须先创建一个 Topic。执行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<p>所有的 Kafka 命令行工具都有附加可选项：不加任何参数，运行 <code>kafka-topics.sh</code> 命令会显示使用信息。例如，会显示新 Topic 的分区数等细节。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-topics.sh --describe --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line">Topic:quickstart-events  PartitionCount:1    ReplicationFactor:1 Configs:</span><br><span class="line">    Topic: quickstart-events Partition: 0    Leader: 0   Replicas: 0 Isr: 0</span><br></pre></td></tr></table></figure>

<h3 id="步骤四、向-Topic-写入-Event"><a href="#步骤四、向-Topic-写入-Event" class="headerlink" title="步骤四、向 Topic 写入 Event"></a>步骤四、向 Topic 写入 Event</h3><p>Kafka 客户端和 Kafka Broker 的通信是通过网络读写 Event。一旦收到信息，Broker 会将其以您需要的时间（甚至永久化）、容错化的方式存储。</p>
<p>执行 <code>kafka-console-producer.sh</code> 命令将 Event 写入 Topic。默认，您输入的任意行会作为独立 Event 写入 Topic：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line">This is my first event</span><br><span class="line">This is my second event</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以通过 <code>Ctrl-C</code> 在任何时候中断 <code>kafka-console-producer.sh</code></p>
</blockquote>
<h3 id="步骤五、读-Event"><a href="#步骤五、读-Event" class="headerlink" title="步骤五、读 Event"></a>步骤五、读 Event</h3><p>执行 kafka-console-consumer.sh 以读取写入 Topic 中的 Event</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092</span><br><span class="line">This is my first event</span><br><span class="line">This is my second event</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您可以通过 <code>Ctrl-C</code> 在任何时候中断 <code>kafka-console-consumer.sh</code></p>
</blockquote>
<p>由于 Event 被持久化存储在 Kafka 中，因此您可以根据需要任意多次地读取它们。 您可以通过打开另一个终端会话并再次重新运行上一个命令来轻松地验证这一点。</p>
<h3 id="步骤六、通过-KAFKA-CONNECT-将数据作为事件流导入-导出"><a href="#步骤六、通过-KAFKA-CONNECT-将数据作为事件流导入-导出" class="headerlink" title="步骤六、通过 KAFKA CONNECT 将数据作为事件流导入&#x2F;导出"></a>步骤六、通过 KAFKA CONNECT 将数据作为事件流导入&#x2F;导出</h3><p>您可能有大量数据，存储在传统的关系数据库或消息队列系统中，并且有许多使用这些系统的应用程序。 通过 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#connect">Kafka Connect</a>，您可以将来自外部系统的数据持续地导入到 Kafka 中，反之亦然。 因此，将已有系统与 Kafka 集成非常容易。为了使此过程更加容易，有数百种此类连接器可供使用。</p>
<p>需要了解有关如何将数据导入和导出 Kafka 的更多信息，可以参考：<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#connect">Kafka Connect section</a> 章节。</p>
<h3 id="步骤七、使用-Kafka-Streams-处理事件"><a href="#步骤七、使用-Kafka-Streams-处理事件" class="headerlink" title="步骤七、使用 Kafka Streams 处理事件"></a>步骤七、使用 Kafka Streams 处理事件</h3><p>一旦将数据作为 Event 存储在 Kafka 中，就可以使用 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/streams">Kafka Streams</a> 的 Java &#x2F; Scala 客户端。它允许您实现关键任务的实时应用程序和微服务，其中输入（和&#x2F;或）输出数据存储在 Kafka Topic 中。</p>
<p>Kafka Streams 结合了 Kafka 客户端编写和部署标准 Java 和 Scala 应用程序的简便性，以及 Kafka 服务器集群技术的优势，使这些应用程序具有高度的可伸缩性、弹性、容错性和分布式。该库支持一次性处理，有状态的操作，以及聚合、窗口化化操作、join、基于事件时间的处理等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;String, String&gt; textLines = builder.stream(<span class="string">&quot;quickstart-events&quot;</span>);</span><br><span class="line"></span><br><span class="line">KTable&lt;String, Long&gt; wordCounts = textLines</span><br><span class="line">            .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">            .groupBy((keyIgnored, word) -&gt; word)</span><br><span class="line">            .count();</span><br><span class="line"></span><br><span class="line">wordCounts.toStream().to(<span class="string">&quot;output-topic&quot;</span>), Produced.with(Serdes.String(), Serdes.Long()));</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://kafka.apache.org/25/documentation/streams/quickstart">Kafka Streams demo</a> 和 <a target="_blank" rel="noopener" href="https://kafka.apache.org/25/documentation/streams/tutorial">app development tutorial</a> 展示了如何从头到尾的编码并运行一个流式应用。</p>
<h3 id="步骤八、终止-Kafka-环境"><a href="#步骤八、终止-Kafka-环境" class="headerlink" title="步骤八、终止 Kafka 环境"></a>步骤八、终止 Kafka 环境</h3><ol>
<li>如果尚未停止，请使用 <code>Ctrl-C</code> 停止生产者和消费者客户端。</li>
<li>使用 <code>Ctrl-C</code> 停止 Kafka 代理。</li>
<li>最后，使用 <code>Ctrl-C</code> 停止 ZooKeeper 服务器。</li>
</ol>
<p>如果您还想删除本地 Kafka 环境的所有数据，包括您在此过程中创建的所有事件，请执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf /tmp/kafka-logs /tmp/zookeeper</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-Java-客户端使用入门"><a href="#Kafka-Java-客户端使用入门" class="headerlink" title="Kafka Java 客户端使用入门"></a>Kafka Java 客户端使用入门</h2><h3 id="引入-maven-依赖"><a href="#引入-maven-依赖" class="headerlink" title="引入 maven 依赖"></a>引入 maven 依赖</h3><p>Stream API 的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他 API 的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Kafka-核心-API"><a href="#Kafka-核心-API" class="headerlink" title="Kafka 核心 API"></a>Kafka 核心 API</h3><p>Kafka 有 5 个核心 API</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#producerapi">Producer API</a> - 允许一个应用程序发布一串流式数据到一个或者多个 Kafka Topic。</li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#consumerapi">Consumer API</a> - 允许一个应用程序订阅一个或多个 Kafka Topic，并且对发布给他们的流式数据进行处理。</li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/streams">Streams API</a> - 允许一个应用程序作为一个流处理器，消费一个或者多个 Kafka Topic 产生的输入流，然后生产一个输出流到一个或多个 Kafka Topic 中去，在输入输出流中进行有效的转换。</li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#connect">Connector API</a> - 允许构建并运行可重用的生产者或者消费者，将 Kafka Topic 连接到已存在的应用程序或数据库。例如，连接到一个关系型数据库，捕捉表的所有变更内容。</li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#adminapi">Admin API</a> - 支持管理和检查 Topic，Broker，ACL 和其他 Kafka 对象。</li>
</ul>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><h4 id="发送并忽略返回"><a href="#发送并忽略返回" class="headerlink" title="发送并忽略返回"></a>发送并忽略返回</h4><p>代码如下，直接通过 <code>send</code> 方法来发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Precision Products&quot;</span>, <span class="string">&quot;France&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h4><p>代码如下，与“发送并忘记”的方式区别在于多了一个 <code>get</code> 方法，会一直阻塞等待 <code>Broker</code> 返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Precision Products&quot;</span>, <span class="string">&quot;France&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record).get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><p>代码如下，异步方式相对于“发送并忽略返回”的方式的不同在于：在异步返回时可以执行一些操作，如记录错误或者成功日志。</p>
<p>首先，定义一个 callback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，使用这个 callback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Biomedical Materials&quot;</span>, <span class="string">&quot;USA&quot;</span>);</span><br><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">DemoProducerCallback</span>());</span><br></pre></td></tr></table></figure>

<h4 id="发送消息示例"><a href="#发送消息示例" class="headerlink" title="发送消息示例"></a>发送消息示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kafka 生产者生产消息示例 生产者配置参考：https://kafka.apache.org/documentation/#producerconfigs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;localhost:9092&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 指定生产者的配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, HOST);</span><br><span class="line">        properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="number">0</span>);</span><br><span class="line">        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">        properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用配置初始化 Kafka 生产者</span></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 使用 send 方法发送异步消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Message &quot;</span> + i;</span><br><span class="line">                producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;HelloWorld&quot;</span>, msg));</span><br><span class="line">                System.out.println(<span class="string">&quot;Sent:&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 关闭生产者</span></span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费消息流程"><a href="#消费消息流程" class="headerlink" title="消费消息流程"></a>消费消息流程</h3><h4 id="消费流程"><a href="#消费流程" class="headerlink" title="消费流程"></a>消费流程</h4><p>具体步骤如下：</p>
<ol>
<li>创建消费者。</li>
<li>订阅主题。除了订阅主题方式外还有使用指定分组的模式，但是常用方式都是订阅主题方式</li>
<li>轮询消息。通过 poll 方法轮询。</li>
<li>关闭消费者。在不用消费者之后，会执行 close 操作。close 操作会关闭 socket，并触发当前消费者群组的再均衡。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> buildCustomer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置主题</span></span><br><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.接受消息</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;customer Message---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s\n&quot;</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.关闭消息</span></span><br><span class="line">        consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建消费者的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Consumer <span class="title function_">buildCustomer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">// bootstrap.servers是Kafka集群的IP地址。多个时,使用逗号隔开</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    <span class="comment">// 消费者群组</span></span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;session.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span></span><br><span class="line">            &lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费消息方式"><a href="#消费消息方式" class="headerlink" title="消费消息方式"></a>消费消息方式</h4><p>分为订阅主题和指定分组两种方式：</p>
<ul>
<li>消费者分组模式。通过订阅主题方式时，消费者必须加入到消费者群组中，即消费者必须有一个自己的分组；</li>
<li>独立消费者模式。这种模式就是消费者是独立的不属于任何消费者分组，自己指定消费那些 <code>Partition</code>。</li>
</ul>
<p>（1）订阅主题方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br></pre></td></tr></table></figure>

<p>（2）独立消费者模式</p>
<p>通过 consumer 的 <code>assign(Collection&lt;TopicPartition&gt; partitions)</code> 方法来为消费者指定分区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessageForIndependentConsumer</span><span class="params">(String topic)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建KafkaCustomer</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> buildCustomer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定分区</span></span><br><span class="line">    <span class="comment">// 2.1获取可用分区</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitionInfoList = buildCustomer().partitionsFor(topic);</span><br><span class="line">    <span class="comment">// 2.2指定分区,这里是指定了所有分区,也可以指定个别的分区</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> != partitionInfoList)&#123;</span><br><span class="line">        List&lt;TopicPartition&gt; partitions = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span>(PartitionInfo partitionInfo : partitionInfoList)&#123;</span><br><span class="line">            partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partitionInfo.topic(),partitionInfo.partition()));</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.assign(partitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接受消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;consume Message---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print the offset,key and value for the consumer records.</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s\n&quot;</span>,</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步提交</span></span><br><span class="line">            consumer.commitAsync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1">Thorough Introduction to Apache Kafka</a></li>
<li><a target="_blank" rel="noopener" href="http://www.heartthinkdo.com/?p=2006#233">Kafka(03) Kafka 介绍</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/233a08bf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/233a08bf/" class="post-title-link" itemprop="url">Kafka 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 09:55:35" itemprop="dateCreated datePublished" datetime="2020-06-03T09:55:35+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-运维"><a href="#Kafka-运维" class="headerlink" title="Kafka 运维"></a>Kafka 运维</h1><blockquote>
<p>环境要求：</p>
<ul>
<li>JDK8</li>
<li>ZooKeeper</li>
</ul>
</blockquote>
<h2 id="Kafka-单点部署"><a href="#Kafka-单点部署" class="headerlink" title="Kafka 单点部署"></a>Kafka 单点部署</h2><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>进入官方下载地址：<a target="_blank" rel="noopener" href="http://kafka.apache.org/downloads%EF%BC%8C%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC%E3%80%82">http://kafka.apache.org/downloads，选择合适版本。</a></p>
<p>解压到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf kafka_2.11-1.1.0.tgz</span><br><span class="line">cd kafka_2.11-1.1.0</span><br></pre></td></tr></table></figure>

<p>现在您已经在您的机器上下载了最新版本的 Kafka。</p>
<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>由于 Kafka 依赖于 ZooKeeper，所以运行前需要先启动 ZooKeeper</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zookeeper-server-start.sh config/zookeeper.properties</span></span><br><span class="line">[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后，启动 Kafka</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties</span></span><br><span class="line">[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)</span><br><span class="line">[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="停止服务器"><a href="#停止服务器" class="headerlink" title="停止服务器"></a>停止服务器</h3><p>执行所有操作后，可以使用以下命令停止服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-stop.sh config/server.properties</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-集群部署"><a href="#Kafka-集群部署" class="headerlink" title="Kafka 集群部署"></a>Kafka 集群部署</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>复制配置为多份（Windows 使用 copy 命令代理）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp config/server.properties config/server-1.properties</span><br><span class="line">cp config/server.properties config/server-2.properties</span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config/server-1.properties</span>:<span class="string"></span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9093</span></span><br><span class="line"><span class="attr">log.dir</span>=<span class="string">/tmp/kafka-logs-1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config/server-2.properties</span>:<span class="string"></span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9094</span></span><br><span class="line"><span class="attr">log.dir</span>=<span class="string">/tmp/kafka-logs-2</span></span><br></pre></td></tr></table></figure>

<p>其中，broker.id 这个参数必须是唯一的。</p>
<p>端口故意配置的不一致，是为了可以在一台机器启动多个应用节点。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>根据这两份配置启动三个服务器节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties &amp;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-start.sh config/server-1.properties &amp;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-start.sh config/server-2.properties &amp;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>创建一个新的 Topic 使用 三个备份：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>

<p>查看主题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span></span><br><span class="line">Topic:my-replicated-topic   PartitionCount:1    ReplicationFactor:3 Configs:</span><br><span class="line">    Topic: my-replicated-topic  Partition: 0    Leader: 1   Replicas: 1,2,0 Isr: 1,2,0</span><br></pre></td></tr></table></figure>

<ul>
<li>leader - 负责指定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。</li>
<li>replicas - 是复制此分区日志的节点列表，无论它们是否为领导者，或者即使它们当前处于活动状态。</li>
<li>isr - 是“同步”复制品的集合。这是副本列表的子集，该列表当前处于活跃状态并且已经被领导者捕获。</li>
</ul>
<h2 id="Kafka-命令"><a href="#Kafka-命令" class="headerlink" title="Kafka 命令"></a>Kafka 命令</h2><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3><h4 id="创建-Topic"><a href="#创建-Topic" class="headerlink" title="创建 Topic"></a>创建 Topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic my-topic</span><br></pre></td></tr></table></figure>

<h4 id="查看-Topic-列表"><a href="#查看-Topic-列表" class="headerlink" title="查看 Topic 列表"></a>查看 Topic 列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<h4 id="添加-Partition"><a href="#添加-Partition" class="headerlink" title="添加 Partition"></a>添加 Partition</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --zookeeper localhost:2181 --alter --topic my-topic --partitions 16</span><br></pre></td></tr></table></figure>

<h4 id="删除-Topic"><a href="#删除-Topic" class="headerlink" title="删除 Topic"></a>删除 Topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --zookeeper localhost:2181 --delete --topic my-topic</span><br></pre></td></tr></table></figure>

<h4 id="查看-Topic-详细信息"><a href="#查看-Topic-详细信息" class="headerlink" title="查看 Topic 详细信息"></a>查看 Topic 详细信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --zookeeper localhost:2181/kafka-cluster --describe</span><br></pre></td></tr></table></figure>

<h4 id="查看备份分区"><a href="#查看备份分区" class="headerlink" title="查看备份分区"></a>查看备份分区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --zookeeper localhost:2181/kafka-cluster --describe --under-replicated-partitions</span><br></pre></td></tr></table></figure>

<h3 id="生产者（Producers）"><a href="#生产者（Producers）" class="headerlink" title="生产者（Producers）"></a>生产者（Producers）</h3><h4 id="通过控制台输入生产消息"><a href="#通过控制台输入生产消息" class="headerlink" title="通过控制台输入生产消息"></a>通过控制台输入生产消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic my-topic</span><br></pre></td></tr></table></figure>

<h4 id="通过文件输入生产消息"><a href="#通过文件输入生产消息" class="headerlink" title="通过文件输入生产消息"></a>通过文件输入生产消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test &lt; messages.txt</span><br></pre></td></tr></table></figure>

<h4 id="通过控制台输入-Avro-生产消息"><a href="#通过控制台输入-Avro-生产消息" class="headerlink" title="通过控制台输入 Avro 生产消息"></a>通过控制台输入 Avro 生产消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-avro-console-producer --broker-list localhost:9092 --topic my.Topic --property value.schema=&#x27;&#123;&quot;type&quot;:&quot;record&quot;,&quot;name&quot;:&quot;myrecord&quot;,&quot;fields&quot;:[&#123;&quot;name&quot;:&quot;f1&quot;,&quot;type&quot;:&quot;string&quot;&#125;]&#125;&#x27; --property schema.registry.url=http://localhost:8081</span><br></pre></td></tr></table></figure>

<p>然后，可以选择输入部分 json key：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;f1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="生成消息性能测试"><a href="#生成消息性能测试" class="headerlink" title="生成消息性能测试"></a>生成消息性能测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-producer-perf-test --topic position-reports --throughput 10000 --record-size 300 --num-records 20000 --producer-props bootstrap.servers=&quot;localhost:9092&quot;</span><br></pre></td></tr></table></figure>

<h3 id="消费者（Consumers）"><a href="#消费者（Consumers）" class="headerlink" title="消费者（Consumers）"></a>消费者（Consumers）</h3><h4 id="消费所有未消费的消息"><a href="#消费所有未消费的消息" class="headerlink" title="消费所有未消费的消息"></a>消费所有未消费的消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic --from-beginning</span><br></pre></td></tr></table></figure>

<h4 id="消费一条消息"><a href="#消费一条消息" class="headerlink" title="消费一条消息"></a>消费一条消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic  --max-messages 1</span><br></pre></td></tr></table></figure>

<h4 id="从指定的-offset-消费一条消息"><a href="#从指定的-offset-消费一条消息" class="headerlink" title="从指定的 offset 消费一条消息"></a>从指定的 offset 消费一条消息</h4><p>从指定的 offset <code>__consumer_offsets</code> 消费一条消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic __consumer_offsets --formatter &#x27;kafka.coordinator.GroupMetadataManager$OffsetsMessageFormatter&#x27; --max-messages 1</span><br></pre></td></tr></table></figure>

<h4 id="从指定-Group-消费消息"><a href="#从指定-Group-消费消息" class="headerlink" title="从指定 Group 消费消息"></a>从指定 Group 消费消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --topic my-topic --new-consumer --bootstrap-server localhost:9092 --consumer-property group.id=my-group</span><br></pre></td></tr></table></figure>

<h4 id="消费-avro-消息"><a href="#消费-avro-消息" class="headerlink" title="消费 avro 消息"></a>消费 avro 消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-avro-console-consumer --topic position-reports --new-consumer --bootstrap-server localhost:9092 --from-beginning --property schema.registry.url=localhost:8081 --max-messages 10</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-avro-console-consumer --topic position-reports --new-consumer --bootstrap-server localhost:9092 --from-beginning --property schema.registry.url=localhost:8081</span><br></pre></td></tr></table></figure>

<h4 id="查看消费者-Group-列表"><a href="#查看消费者-Group-列表" class="headerlink" title="查看消费者 Group 列表"></a>查看消费者 Group 列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-consumer-groups --new-consumer --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h4 id="查看消费者-Group-详细信息"><a href="#查看消费者-Group-详细信息" class="headerlink" title="查看消费者 Group 详细信息"></a>查看消费者 Group 详细信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-consumer-groups --bootstrap-server localhost:9092 --describe --group testgroup</span><br></pre></td></tr></table></figure>

<h3 id="配置（Config）"><a href="#配置（Config）" class="headerlink" title="配置（Config）"></a>配置（Config）</h3><h4 id="设置-Topic-的保留时间"><a href="#设置-Topic-的保留时间" class="headerlink" title="设置 Topic 的保留时间"></a>设置 Topic 的保留时间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-configs --zookeeper localhost:2181 --alter --entity-type topics --entity-name my-topic --add-config retention.ms=3600000</span><br></pre></td></tr></table></figure>

<h4 id="查看-Topic-的所有配置"><a href="#查看-Topic-的所有配置" class="headerlink" title="查看 Topic 的所有配置"></a>查看 Topic 的所有配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-configs --zookeeper localhost:2181 --describe --entity-type topics --entity-name my-topic</span><br></pre></td></tr></table></figure>

<h4 id="修改-Topic-的配置"><a href="#修改-Topic-的配置" class="headerlink" title="修改 Topic 的配置"></a>修改 Topic 的配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-configs --zookeeper localhost:2181 --alter --entity-type topics --entity-name my-topic --delete-config retention.ms</span><br></pre></td></tr></table></figure>

<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><h4 id="查看指定-Topic-的-ACL"><a href="#查看指定-Topic-的-ACL" class="headerlink" title="查看指定 Topic 的 ACL"></a>查看指定 Topic 的 ACL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-acls --authorizer-properties zookeeper.connect=localhost:2181 --list --topic topicA</span><br></pre></td></tr></table></figure>

<h4 id="添加-ACL"><a href="#添加-ACL" class="headerlink" title="添加 ACL"></a>添加 ACL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-acls --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:Bob --consumer --topic topicA --group groupA</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-acls --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:Bob --producer --topic topicA</span><br></pre></td></tr></table></figure>

<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper-shell localhost:2182 ls /</span><br></pre></td></tr></table></figure>

<h2 id="Kafka-工具"><a href="#Kafka-工具" class="headerlink" title="Kafka 工具"></a>Kafka 工具</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/yahoo/kafka-manager">kafka-manager</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/quantifind/KafkaOffsetMonitor">KafkaOffsetMonitor</a></strong></li>
</ul>
<h2 id="Kafka-核心配置"><a href="#Kafka-核心配置" class="headerlink" title="Kafka 核心配置"></a>Kafka 核心配置</h2><h3 id="Broker-级别配置"><a href="#Broker-级别配置" class="headerlink" title="Broker 级别配置"></a>Broker 级别配置</h3><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p>首先 Broker 是需要配置存储信息的，即 Broker 使用哪些磁盘。那么针对存储信息的重要参数有以下这么几个：</p>
<ul>
<li><code>log.dirs</code>：指定了 Broker 需要使用的若干个文件目录路径。这个参数是没有默认值的，必须由使用者亲自指定。</li>
<li><code>log.dir</code>：注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。</li>
</ul>
<p><code>log.dirs</code> 具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径，比如<code>/home/kafka1,/home/kafka2,/home/kafka3</code>这样。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。这样做有两个好处：</p>
<ul>
<li>提升读写性能：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量。</li>
<li>能够实现故障转移：即 Failover。这是 Kafka 1.1 版本新引入的强大功能。要知道在以前，只要 Kafka Broker 使用的任何一块磁盘挂掉了，整个 Broker 进程都会关闭。但是自 1.1 开始，这种情况被修正了，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且 Broker 还能正常工作。</li>
</ul>
<h4 id="zookeeper-配置"><a href="#zookeeper-配置" class="headerlink" title="zookeeper 配置"></a>zookeeper 配置</h4><p>Kafka 与 ZooKeeper 相关的最重要的参数当属 <code>zookeeper.connect</code>。这也是一个 CSV 格式的参数，比如我可以指定它的值为<code>zk1:2181,zk2:2181,zk3:2181</code>。2181 是 ZooKeeper 的默认端口。</p>
<p>现在问题来了，如果我让多个 Kafka 集群使用同一套 ZooKeeper 集群，那么这个参数应该怎么设置呢？这时候 chroot 就派上用场了。这个 chroot 是 ZooKeeper 的概念，类似于别名。</p>
<p>如果你有两套 Kafka 集群，假设分别叫它们 kafka1 和 kafka2，那么两套集群的<code>zookeeper.connect</code>参数可以这样指定：<code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code>。切记 chroot 只需要写一次，而且是加到最后的。我经常碰到有人这样指定：<code>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</code>，这样的格式是不对的。</p>
<h4 id="Broker-连接配置"><a href="#Broker-连接配置" class="headerlink" title="Broker 连接配置"></a>Broker 连接配置</h4><ul>
<li><code>listeners</code>：告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。</li>
<li><code>advertised.listeners</code>：和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</li>
<li><code>host.name/port</code>：列出这两个参数就是想说你把它们忘掉吧，压根不要为它们指定值，毕竟都是过期的参数了。</li>
</ul>
<p>我们具体说说监听器的概念，从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为<code>&lt;协议名称，主机名，端口号&gt;</code>。这里的协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；也可能是你自己定义的协议名字，比如<code>CONTROLLER: //localhost:9092</code>。</p>
<p><strong>最好全部使用主机名，即 Broker 端和 Client 端应用配置中全部填写主机名。</strong></p>
<h4 id="Topic-管理"><a href="#Topic-管理" class="headerlink" title="Topic 管理"></a>Topic 管理</h4><ul>
<li><code>auto.create.topics.enable</code>：是否允许自动创建 Topic。一般设为 false，由运维把控创建 Topic。</li>
<li><code>unclean.leader.election.enable</code>：是否允许 Unclean Leader 选举。</li>
<li><code>auto.leader.rebalance.enable</code>：是否允许定期进行 Leader 选举。</li>
</ul>
<p>第二个参数<code>unclean.leader.election.enable</code>是关闭 Unclean Leader 选举的。何谓 Unclean？还记得 Kafka 有多个副本这件事吗？每个分区都有多个副本来提供高可用。在这些副本中只能有一个副本对外提供服务，即所谓的 Leader 副本。</p>
<p>那么问题来了，这些副本都有资格竞争 Leader 吗？显然不是，只有保存数据比较多的那些副本才有资格竞选，那些落后进度太多的副本没资格做这件事。</p>
<p>好了，现在出现这种情况了：假设那些保存数据比较多的副本都挂了怎么办？我们还要不要进行 Leader 选举了？此时这个参数就派上用场了。</p>
<p>如果设置成 false，那么就坚持之前的原则，坚决不能让那些落后太多的副本竞选 Leader。这样做的后果是这个分区就不可用了，因为没有 Leader 了。反之如果是 true，那么 Kafka 允许你从那些“跑得慢”的副本中选一个出来当 Leader。这样做的后果是数据有可能就丢失了，因为这些副本保存的数据本来就不全，当了 Leader 之后它本人就变得膨胀了，认为自己的数据才是权威的。</p>
<p>这个参数在最新版的 Kafka 中默认就是 false，本来不需要我特意提的，但是比较搞笑的是社区对这个参数的默认值来来回回改了好几版了，鉴于我不知道你用的是哪个版本的 Kafka，所以建议你还是显式地把它设置成 false 吧。</p>
<p>第三个参数<code>auto.leader.rebalance.enable</code>的影响貌似没什么人提，但其实对生产环境影响非常大。设置它的值为 true 表示允许 Kafka 定期地对一些 Topic 分区进行 Leader 重选举，当然这个重选举不是无脑进行的，它要满足一定的条件才会发生。严格来说它与上一个参数中 Leader 选举的最大不同在于，它不是选 Leader，而是换 Leader！比如 Leader A 一直表现得很好，但若<code>auto.leader.rebalance.enable=true</code>，那么有可能一段时间后 Leader A 就要被强行卸任换成 Leader B。</p>
<p>你要知道换一次 Leader 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 Leader 本质上没有任何性能收益，因此我建议你在生产环境中把这个参数设置成 false。</p>
<h4 id="数据留存"><a href="#数据留存" class="headerlink" title="数据留存"></a>数据留存</h4><ul>
<li><code>log.retention.&#123;hour|minutes|ms&#125;</code>：都是控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hour 最低。通常情况下我们还是设置 hour 级别的多一些，比如<code>log.retention.hour=168</code>表示默认保存 7 天的数据，自动删除 7 天前的数据。很多公司把 Kafka 当做存储来使用，那么这个值就要相应地调大。</li>
<li><code>log.retention.bytes</code>：这是指定 Broker 为消息保存的总磁盘容量大小。这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以，至少在容量方面 Broker 绝对为你开绿灯，不会做任何阻拦。这个参数真正发挥作用的场景其实是在云上构建多租户的 Kafka 集群：设想你要做一个云上的 Kafka 服务，每个租户只能使用 100GB 的磁盘空间，为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。</li>
<li><code>message.max.bytes</code>：控制 Broker 能够接收的最大消息大小。默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，因此在线上环境中设置一个比较大的值还是比较保险的做法。毕竟它只是一个标尺而已，仅仅衡量 Broker 能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。</li>
</ul>
<h3 id="Topic-级别配置"><a href="#Topic-级别配置" class="headerlink" title="Topic 级别配置"></a>Topic 级别配置</h3><ul>
<li><code>retention.ms</code>：规定了该 Topic 消息被保存的时长。默认是 7 天，即该 Topic 只保存最近 7 天的消息。一旦设置了这个值，它会覆盖掉 Broker 端的全局参数值。</li>
<li><code>retention.bytes</code>：规定了要为该 Topic 预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的 Kafka 集群中会有用武之地。当前默认值是 -1，表示可以无限使用磁盘空间。</li>
</ul>
<h3 id="操作系统参数"><a href="#操作系统参数" class="headerlink" title="操作系统参数"></a>操作系统参数</h3><ul>
<li>文件描述符限制</li>
<li>文件系统类型</li>
<li>Swappiness</li>
<li>提交时间</li>
</ul>
<p>文件描述符系统资源并不像我们想象的那样昂贵，你不用太担心调大此值会有什么不利的影响。通常情况下将它设置成一个超大的值是合理的做法，比如<code>ulimit -n 1000000</code>。其实设置这个参数一点都不重要，但不设置的话后果很严重，比如你会经常看到“Too many open files”的错误。</p>
<p>其次是文件系统类型的选择。这里所说的文件系统指的是如 ext3、ext4 或 XFS 这样的日志型文件系统。根据官网的测试报告，XFS 的性能要强于 ext4，所以生产环境最好还是使用 XFS。对了，最近有个 Kafka 使用 ZFS 的<a target="_blank" rel="noopener" href="https://www.confluent.io/kafka-summit-sf18/kafka-on-zfs">数据报告</a>，貌似性能更加强劲，有条件的话不妨一试。</p>
<p>第三是 swap 的调优。网上很多文章都提到设置其为 0，将 swap 完全禁掉以防止 Kafka 进程使用 swap 空间。我个人反倒觉得还是不要设置成 0 比较好，我们可以设置成一个较小的值。为什么呢？因为一旦设置成 0，当物理内存耗尽时，操作系统会触发 OOM killer 这个组件，它会随机挑选一个进程然后 kill 掉，即根本不给用户任何的预警。但如果设置成一个比较小的值，当开始使用 swap 空间时，你至少能够观测到 Broker 性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间。基于这个考虑，我个人建议将 swappniess 配置成一个接近 0 但不为 0 的值，比如 1。</p>
<p>最后是提交时间或者说是 Flush 落盘时间。向 Kafka 发送数据并不是真要等数据被写入磁盘才会认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据 LRU 算法会定期将页缓存上的“脏”数据落盘到物理磁盘上。这个定期就是由提交时间来确定的，默认是 5 秒。一般情况下我们会认为这个时间太频繁了，可以适当地增加提交间隔来降低物理磁盘的写操作。当然你可能会有这样的疑问：如果在页缓存中的数据在写入到磁盘前机器宕机了，那岂不是数据就丢失了。的确，这种情况数据确实就丢失了，但鉴于 Kafka 在软件层面已经提供了多副本的冗余机制，因此这里稍微拉大提交间隔去换取性能还是一个合理的做法。</p>
<h2 id="Kafka-集群规划"><a href="#Kafka-集群规划" class="headerlink" title="Kafka 集群规划"></a>Kafka 集群规划</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>部署生产环境的 Kafka，强烈建议操作系统选用 Linux。</p>
<p><strong>在 Linux 部署 Kafka 能够享受到零拷贝技术所带来的快速数据传输特性。</strong></p>
<p><strong>Windows 平台上部署 Kafka 只适合于个人测试或用于功能验证，千万不要应用于生产环境。</strong></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>Kafka 集群部署选择普通的机械磁盘还是固态硬盘？前者成本低且容量大，但易损坏；后者性能优势大，不过单价高。</p>
<p>结论是：<strong>使用普通机械硬盘即可</strong>。</p>
<p>Kafka 采用顺序读写操作，一定程度上规避了机械磁盘最大的劣势，即随机读写操作慢。从这一点上来说，使用 SSD 似乎并没有太大的性能优势，毕竟从性价比上来说，机械磁盘物美价廉，而它因易损坏而造成的可靠性差等缺陷，又由 Kafka 在软件层面提供机制来保证，故使用普通机械磁盘是很划算的。</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>大部分公司使用普通的以太网络，千兆网络（1Gbps）应该是网络的标准配置。</p>
<p>通常情况下你只能假设 Kafka 会用到 70% 的带宽资源，因为总要为其他应用或进程留一些资源。此外，通常要再额外预留出 2&#x2F;3 的资源，因为不能让带宽资源总是保持在峰值。</p>
<p>基于以上原因，一个 Kafka 集群数量的大致推算公式如下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kafka 机器数 <span class="operator">=</span> 单位时间需要处理的总数据量 / 单机所占用带宽</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27665114/">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lensesio/kafka-cheat-sheet">kafka-cheat-sheet</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/01378ae5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/01378ae5/" class="post-title-link" itemprop="url">ZooKeeper原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 22:28:54" itemprop="dateCreated datePublished" datetime="2020-06-02T22:28:54+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/ZooKeeper/" itemprop="url" rel="index"><span itemprop="name">ZooKeeper</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ZooKeeper-原理"><a href="#ZooKeeper-原理" class="headerlink" title="ZooKeeper 原理"></a>ZooKeeper 原理</h1><blockquote>
<p>ZooKeeper 是 Apache 的顶级项目。<strong>ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面，ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议</strong>。</p>
<p>ZooKeeper 主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储。但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来<strong>维护和监控存储数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理</strong>。</p>
<p>很多大名鼎鼎的框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等。</p>
<p>ZooKeeper 官方支持 Java 和 C 的 Client API。ZooKeeper 社区为大多数语言（.NET，python 等）提供非官方 API。</p>
</blockquote>
<h2 id="ZooKeeper-简介"><a href="#ZooKeeper-简介" class="headerlink" title="ZooKeeper 简介"></a>ZooKeeper 简介</h2><h3 id="ZooKeeper-是什么"><a href="#ZooKeeper-是什么" class="headerlink" title="ZooKeeper 是什么"></a>ZooKeeper 是什么</h3><p>ZooKeeper 是 Apache 的顶级项目。<strong>ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面，ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议</strong>。</p>
<p>ZooKeeper 主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储。但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来<strong>维护和监控存储数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理</strong>。</p>
<p>很多大名鼎鼎的框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等。</p>
<h3 id="ZooKeeper-的特性"><a href="#ZooKeeper-的特性" class="headerlink" title="ZooKeeper 的特性"></a>ZooKeeper 的特性</h3><p>ZooKeeper 具有以下特性：</p>
<ul>
<li><strong>顺序一致性</strong>：所有客户端看到的服务端数据模型都是一致的；从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 ZooKeeper 中。具体的实现可见：<a href="#%E5%8E%9F%E5%AD%90%E5%B9%BF%E6%92%AD">原子广播</a></li>
<li><strong>原子性</strong> - 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。 实现方式可见：<a href="#%E4%BA%8B%E5%8A%A1">事务</a></li>
<li><strong>单一视图</strong> - 无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。</li>
<li><strong>高性能</strong> - ZooKeeper 将<strong>数据全量存储在内存中</strong>，所以其性能很高。需要注意的是：由于 <strong>ZooKeeper 的所有更新和删除都是基于事务的</strong>，因此 ZooKeeper 在读多写少的应用场景中有性能表现较好，<strong>如果写操作频繁，性能会大大下滑</strong>。</li>
<li><strong>高可用</strong> - ZooKeeper 的高可用是基于副本机制实现的，此外 ZooKeeper 支持故障恢复，可见：<a href="#%E9%80%89%E4%B8%BE-Leader">选举 Leader</a></li>
</ul>
<h3 id="ZooKeeper-的应用场景"><a href="#ZooKeeper-的应用场景" class="headerlink" title="ZooKeeper 的应用场景"></a>ZooKeeper 的应用场景</h3><ul>
<li>配置管理<ul>
<li>集群节点可以通过中心源获取启动配置</li>
<li>更简单的部署</li>
</ul>
</li>
<li>分布式集群管理<ul>
<li>节点加入&#x2F;离开</li>
<li>节点的实时状态</li>
</ul>
</li>
<li>命名服务，如：DNS</li>
<li>分布式同步：如锁、栅栏、队列</li>
<li>分布式系统的选主</li>
<li>中心化和高可靠的数据注册</li>
</ul>
<h3 id="ZooKeeper-的设计目标"><a href="#ZooKeeper-的设计目标" class="headerlink" title="ZooKeeper 的设计目标"></a>ZooKeeper 的设计目标</h3><ul>
<li>简单的数据模型：ZooKeeper 的数据模型是一个树形结构的文件系统，树中的节点被称为 **<code>znode</code>**。</li>
<li>可以构建集群：ZooKeeper 支持集群模式，可以通过伸缩性，来控制集群的吞吐量。需要注意的是：由于 ZooKeeper 采用一主多从架构，所以其写性能是有上限的，比较适合于读多写少的场景。</li>
<li>顺序访问：对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增 ID，这个 ID 反映了所有事务请求的先后顺序。</li>
<li>高性能、高可用：ZooKeeper 将数据存全量储在内存中以保持高性能，并通过服务集群来实现高可用，由于 Zookeeper 的所有更新和删除都是基于事务的，所以其在读多写少的应用场景中有着很高的性能表现。</li>
</ul>
<h2 id="ZooKeeper-核心概念"><a href="#ZooKeeper-核心概念" class="headerlink" title="ZooKeeper 核心概念"></a>ZooKeeper 核心概念</h2><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>Zookeeper 服务是一个基于主从复制的高可用集群，集群中每个节点都存储了一份数据副本（内存中）。</p>
<p>客户端只会连接一个 ZooKeeper 服务器节点，并维持 TCP 连接。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>ZooKeeper 的数据模型是一个树形结构的文件系统</strong>。</p>
<p>树中的节点被称为 <strong><code>znode</code><strong>，其中根节点为 <code>/</code>，每个节点上都会保存自己的数据和节点信息。znode 可以用于存储数据，并且有一个与之相关联的 ACL（详情可见 <a href="#ACL">ACL</a>）。ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 znode 存储数据的</strong>大小被限制在 1MB 以内</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240730789.png"></p>
<p><strong>ZooKeeper 的数据访问具有原子性</strong>。其读写操作都是要么全部成功，要么全部失败。</p>
<p>znode 通过路径被引用。<strong>znode 节点路径必须是绝对路径</strong>。</p>
<p>znode 有两种类型：</p>
<ul>
<li><strong>临时的（ <code>EPHEMERAL</code> ）</strong> - 户端会话结束时，ZooKeeper 就会删除临时的 znode。不允许有子节点。</li>
<li><strong>持久的（<code>PERSISTENT</code> ）</strong> - 除非客户端主动执行删除操作，否则 ZooKeeper 不会删除持久的 znode。</li>
</ul>
<h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3><p>znode 上有一个<strong>顺序标志（ <code>SEQUENTIAL</code> ）</strong>。如果在创建 znode 时，设置了<strong>顺序标志（ <code>SEQUENTIAL</code> ）</strong>，那么 ZooKeeper 会使用计数器为 znode 添加一个单调递增的数值，即 <code>zxid</code>。ZooKeeper 正是利用 zxid 实现了严格的顺序访问控制能力。</p>
<p>每个 znode 节点在存储数据的同时，都会维护一个叫做 <code>Stat</code> 的数据结构，里面存储了关于该节点的全部状态信息。如下：</p>
<table>
<thead>
<tr>
<th><strong>状态属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>czxid</td>
<td>数据节点创建时的事务 ID</td>
</tr>
<tr>
<td>ctime</td>
<td>数据节点创建时的时间</td>
</tr>
<tr>
<td>mzxid</td>
<td>数据节点最后一次更新时的事务 ID</td>
</tr>
<tr>
<td><code>mtime</code></td>
<td>数据节点最后一次更新时的时间</td>
</tr>
<tr>
<td>pzxid</td>
<td>数据节点的子节点最后一次被修改时的事务 ID</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点的更改次数</td>
</tr>
<tr>
<td>version</td>
<td>节点数据的更改次数</td>
</tr>
<tr>
<td>aversion</td>
<td>节点的 ACL 的更改次数</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据内容的长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>数据节点当前的子节点个数</td>
</tr>
</tbody></table>
<h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>Zookeeper 集群是一个基于主从复制的高可用集群，集群中每个节点都存储了一份数据副本（内存中）。此外，每个服务器节点承担如下三种角色中的一种：</p>
<ul>
<li><strong>Leader</strong> - 它负责 <strong>发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器</strong>。一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader。</li>
<li><strong>Follower</strong> - 它会<strong>响应 Leader 的心跳。Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，并且负责在 Leader 处理写请求时对请求进行投票</strong>。一个 Zookeeper 集群可能同时存在多个 Follower。</li>
<li><strong>Observer</strong> - 角色与 Follower 类似，但是无投票权。</li>
</ul>
<p>客户端可以从任意 ZooKeeper 服务器节点读取数据，但只能通过 Leader 服务写数据并需要半数以上 Follower 的 ACK，才算写入成功。记住这个重要的知识点，下文会详细讲述。</p>
<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p><strong>ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制</strong>。</p>
<p>每个 znode 创建时都会带有一个 ACL 列表，用于决定谁可以对它执行何种操作。</p>
<p>ACL 依赖于 ZooKeeper 的客户端认证机制。ZooKeeper 提供了以下几种认证方式：</p>
<ul>
<li><strong>digest</strong> - 用户名和密码 来识别客户端</li>
<li><strong>sasl</strong> - 通过 kerberos 来识别客户端</li>
<li><strong>ip</strong> - 通过 IP 来识别客户端</li>
</ul>
<p>ZooKeeper 定义了如下五种权限：</p>
<ul>
<li><strong>CREATE</strong> - 允许创建子节点；</li>
<li><strong>READ</strong> - 允许从节点获取数据并列出其子节点；</li>
<li><strong>WRITE</strong> - 允许为节点设置数据；</li>
<li><strong>DELETE</strong> - 允许删除子节点；</li>
<li><strong>ADMIN</strong> - 允许为节点设置权限。</li>
</ul>
<h2 id="ZooKeeper-工作原理"><a href="#ZooKeeper-工作原理" class="headerlink" title="ZooKeeper 工作原理"></a>ZooKeeper 工作原理</h2><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p><strong>Leader&#x2F;Follower&#x2F;Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可</strong>。</p>
<p>由于处理读请求不需要服务器之间的交互，<strong>Follower&#x2F;Observer 越多，整体系统的读请求吞吐量越大</strong>，也即读性能越好。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240730119.png"></p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>所有的写请求实际上都要交给 Leader 处理。Leader 将写请求以事务形式发给所有 Follower 并等待 ACK，一旦收到半数以上 Follower 的 ACK，即认为写操作成功。</p>
<h4 id="写-Leader"><a href="#写-Leader" class="headerlink" title="写 Leader"></a>写 Leader</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240731595.png"></p>
<p>由上图可见，通过 Leader 进行写操作，主要分为五步：</p>
<ol>
<li>客户端向 Leader 发起写请求</li>
<li>Leader 将写请求以事务 Proposal 的形式发给所有 Follower 并等待 ACK</li>
<li>Follower 收到 Leader 的事务 Proposal 后返回 ACK</li>
<li>Leader 得到过半数的 ACK（Leader 对自己默认有一个 ACK）后向所有的 Follower 和 Observer 发送 Commmit</li>
<li>Leader 将处理结果返回给客户端</li>
</ol>
<blockquote>
<p>注意</p>
<ul>
<li>Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权。</li>
<li>Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK。上图中有 4 个 Follower，只需其中两个返回 ACK 即可，因为 $$(2+1) &#x2F; (4+1) &gt; 1&#x2F;2$$ 。</li>
<li>Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据。</li>
</ul>
</blockquote>
<h4 id="写-Follower-Observer"><a href="#写-Follower-Observer" class="headerlink" title="写 Follower&#x2F;Observer"></a>写 Follower&#x2F;Observer</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240731844.png"></p>
<ul>
<li>Follower&#x2F;Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理。</li>
<li>除了多了一步请求转发，其它流程与直接写 Leader 无任何区别。</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力。</p>
<p><strong>为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（zxid）来标识事务</strong>。</p>
<p><strong>Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO(先进先出) 的策略进行消息发送</strong>。Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应。<strong>当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交</strong>，之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交。</p>
<p>所有的提议（**<code>proposal</code>**）都在被提出的时候加上了 zxid。zxid 是一个 64 位的数字，它的高 32 位是 <strong><code>epoch</code></strong> 用来标识 Leader 关系是否改变，每次一个 Leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。</p>
<p>详细过程如下：</p>
<ol>
<li>Leader 等待 Server 连接；</li>
<li>Follower 连接 Leader，将最大的 zxid 发送给 Leader；</li>
<li>Leader 根据 Follower 的 zxid 确定同步点；</li>
<li>完成同步后通知 follower 已经成为 uptodate 状态；</li>
<li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li>
</ol>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p><strong>ZooKeeper 允许客户端监听它关心的 znode，当 znode 状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端</strong>。</p>
<p>客户端和服务端保持连接一般有两种形式：</p>
<ul>
<li><strong>客户端向服务端不断轮询</strong></li>
<li><strong>服务端向客户端推送状态</strong></li>
</ul>
<p>Zookeeper 的选择是服务端主动推送状态，也就是观察机制（ <code>Watch</code> ）。</p>
<p>ZooKeeper 的观察机制允许用户在指定节点上针对感兴趣的事件注册监听，当事件发生时，监听器会被触发，并将事件信息推送到客户端。</p>
<ul>
<li>监听器实时触发</li>
<li>监听器总是有序的</li>
<li>创建新的 znode 数据前，客户端就能收到监听事件。</li>
</ul>
<p>客户端使用 <code>getData</code> 等接口获取 znode 状态时传入了一个用于处理节点变更的回调，那么服务端就会主动向客户端推送节点的变更：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure>

<p>从这个方法中传入的 <code>Watcher</code> 对象实现了相应的 <code>process</code> 方法，每次对应节点出现了状态的改变，<code>WatchManager</code> 都会通过以下的方式调用传入 <code>Watcher</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> &#123;</span><br><span class="line">    <span class="type">WatchedEvent</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(type, KeeperState.SyncConnected, path);</span><br><span class="line">    Set&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">        w.process(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zookeeper 中的所有数据其实都是由一个名为 <code>DataTree</code> 的数据结构管理的，所有的读写数据的请求最终都会改变这颗树的内容，在发出读请求时可能会传入 <code>Watcher</code> 注册一个回调函数，而写请求就可能会触发相应的回调，由 <code>WatchManager</code> 通知客户端数据的变化。</p>
<p>通知机制的实现其实还是比较简单的，通过读请求设置 <code>Watcher</code> 监听事件，写请求在触发事件时就能将通知发送给指定的客户端。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>ZooKeeper 客户端通过 TCP 长连接连接到 ZooKeeper 服务集群</strong>。<strong>会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态</strong>。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知。</p>
<p>每个 ZooKeeper 客户端配置中都配置了 ZooKeeper 服务器集群列表。启动时，客户端会遍历列表去尝试建立连接。如果失败，它会尝试连接下一个服务器，依次类推。</p>
<p>一旦一台客户端与一台服务器建立连接，这台服务器会为这个客户端创建一个新的会话。<strong>每个会话都会有一个超时时间，若服务器在超时时间内没有收到任何请求，则相应会话被视为过期</strong>。一旦会话过期，就无法再重新打开，且任何与该会话相关的临时 znode 都会被删除。</p>
<p>通常来说，会话应该长期存在，而这需要由客户端来保证。客户端可以通过心跳方式（ping）来保持会话不过期。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240732938.png"></p>
<p>ZooKeeper 的会话具有四个属性：</p>
<ul>
<li><code>sessionID</code> - 会话 ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper 都会为其分配一个全局唯一的 sessionID。</li>
<li><code>TimeOut</code> - 会话超时时间，客户端在构造 Zookeeper 实例时，会配置 sessionTimeout 参数用于指定会话的超时时间，Zookeeper 客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。</li>
<li><code>TickTime</code> - 下次会话超时时间点，为了便于 Zookeeper 对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper 会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上 TimeOut。</li>
<li><code>isClosing</code> - 标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的 isClosing 标记为”已关闭”，这样就能确保不再处理来自该会话的心情求了。</li>
</ul>
<p>Zookeeper 的会话管理主要是通过 <code>SessionTracker</code> 来负责，其采用了<strong>分桶策略</strong>（将类似的会话放在同一区块中进行管理）进行管理，以便 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</p>
<h2 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h2><blockquote>
<p>ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。**<em>ZAB 协议不是 Paxos 算法</em>**，只是比较类似，二者在操作上并不相同。Multi-Paxos 实现的是一系列值的共识，不关心最终达成共识的值是什么，不关心各值的顺序。而 ZooKeeper 需要确保操作的顺序性。</p>
<p>ZAB 协议是 Zookeeper 专门设计的一种<strong>支持崩溃恢复的原子广播协议</strong>。</p>
<p>ZAB 协议是 ZooKeeper 的数据一致性和高可用解决方案。</p>
</blockquote>
<p>ZAB 协议定义了两个可以<strong>无限循环</strong>的流程：</p>
<ul>
<li><strong><code>选举 Leader</code></strong> - 用于故障恢复，从而保证高可用。</li>
<li><strong><code>原子广播</code></strong> - 用于主从同步，从而保证数据一致性。</li>
</ul>
<h3 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h3><blockquote>
<p><strong>ZooKeeper 的故障恢复</strong></p>
<p>ZooKeeper 集群采用一主（称为 Leader）多从（称为 Follower）模式，主从节点通过副本机制保证数据一致。</p>
<ul>
<li><strong>如果 Follower 节点挂了</strong> - ZooKeeper 集群中的每个节点都会单独在内存中维护自身的状态，并且各节点之间都保持着通讯，<strong>只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务</strong>。</li>
<li><strong>如果 Leader 节点挂了</strong> - 如果 Leader 节点挂了，系统就不能正常工作了。此时，需要通过 ZAB 协议的选举 Leader 机制来进行故障恢复。</li>
</ul>
<p>ZAB 协议的选举 Leader 机制简单来说，就是：基于过半选举机制产生新的 Leader，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出选举 Leader 模式，进入原子广播模式。</p>
</blockquote>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li><strong>myid</strong> - 每个 Zookeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含整个 Zookeeper 集群唯一的 ID（整数）。</li>
<li><strong>zxid</strong> - 类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal ID。为了保证顺序性，该 zxid 必须单调递增。因此 Zookeeper 使用一个 64 位的数来表示，高 32 位是 Leader 的 epoch，从 1 开始，每次选出新的 Leader，epoch 加一。低 32 位为该 epoch 内的序号，每次 epoch 变化，都将低 32 位的序号重置。这样保证了 zxid 的全局递增性。</li>
</ul>
<h4 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h4><ul>
<li><strong><em>LOOKING</em></strong> - 不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举</li>
<li><strong><em>FOLLOWING</em></strong> - 跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁</li>
<li><strong><em>LEADING</em></strong> - 领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳</li>
<li><strong><em>OBSERVING</em></strong> - 观察者状态。表明当前服务器角色是 Observer，与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票</li>
</ul>
<h4 id="选票数据结构"><a href="#选票数据结构" class="headerlink" title="选票数据结构"></a>选票数据结构</h4><p>每个服务器在进行领导选举时，会发送如下关键信息</p>
<ul>
<li><strong><em>logicClock</em></strong> - 每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票</li>
<li><strong><em>state</em></strong> - 当前服务器的状态</li>
<li><strong><em>self_id</em></strong> - 当前服务器的 myid</li>
<li><strong><em>self_zxid</em></strong> - 当前服务器上所保存的数据的最大 zxid</li>
<li><strong><em>vote_id</em></strong> - 被推举的服务器的 myid</li>
<li><strong><em>vote_zxid</em></strong> - 被推举的服务器上所保存的数据的最大 zxid</li>
</ul>
<h4 id="投票流程"><a href="#投票流程" class="headerlink" title="投票流程"></a>投票流程</h4><p>（1）<strong>自增选举轮次</strong> - Zookeeper 规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的 logicClock 进行自增操作。</p>
<p>（2）<strong>初始化选票</strong> - 每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器 2 投票给服务器 3，服务器 3 投票给服务器 1，则服务器 1 的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。</p>
<p>（3）<strong>发送初始化选票</strong> - 每个服务器最开始都是通过广播把票投给自己。</p>
<p>（4）<strong>接收外部投票</strong> - 服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。</p>
<p>（5）<strong>判断选举轮次</strong> - 收到外部投票后，首先会根据投票信息中所包含的 logicClock 来进行不同处理</p>
<ul>
<li>外部投票的 logicClock 大于自己的 logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的 logicClock 更新为收到的 logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。</li>
<li>外部投票的 logicClock 小于自己的 logicClock。当前服务器直接忽略该投票，继续处理下一个投票。</li>
<li>外部投票的 logickClock 与自己的相等。当时进行选票 PK。</li>
</ul>
<p>（6）<strong>选票 PK</strong> - 选票 PK 是基于<code>(self_id, self_zxid)</code> 与 <code>(vote_id, vote_zxid)</code> 的对比</p>
<ul>
<li>外部投票的 logicClock 大于自己的 logicClock，则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock</li>
<li>若 logicClock 一致，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖</li>
<li>若二者 vote_zxid 一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱</li>
</ul>
<p>（7）<strong>统计选票</strong> - 如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p>
<p>（8）<strong>更新服务器状态</strong> - 投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING</p>
<p>通过以上流程分析，我们不难看出：要使 Leader 获得多数 Server 的支持，则 <strong>ZooKeeper 集群节点数必须是奇数。且存活的节点数目不得少于 <code>N + 1</code></strong> 。</p>
<p>每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p>
<h3 id="原子广播（Atomic-Broadcast）"><a href="#原子广播（Atomic-Broadcast）" class="headerlink" title="原子广播（Atomic Broadcast）"></a>原子广播（Atomic Broadcast）</h3><p><strong>ZooKeeper 通过副本机制来实现高可用</strong>。</p>
<p>那么，ZooKeeper 是如何实现副本机制的呢？答案是：ZAB 协议的原子广播。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240735474.png"></p>
<p>ZAB 协议的原子广播要求：</p>
<p>**<em>所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应</em>**。这有些类似数据库中的两阶段提交协议。</p>
<p>在整个消息的广播过程中，Leader 服务器会每个事务请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。</p>
<blockquote>
<p>ZAB 是通过“一切以领导者为准”的强领导者模型和严格按照顺序提交日志，来实现操作的顺序性的，这一点和 Raft 是一样的。</p>
</blockquote>
<h2 id="ZooKeeper-应用"><a href="#ZooKeeper-应用" class="headerlink" title="ZooKeeper 应用"></a>ZooKeeper 应用</h2><blockquote>
<p><strong>ZooKeeper 可以用于发布&#x2F;订阅、负载均衡、命令服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能</strong> 。</p>
</blockquote>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>在分布式系统中，通常需要一个全局唯一的名字，如生成全局唯一的订单号等，ZooKeeper 可以通过顺序节点的特性来生成全局唯一 ID，从而可以对分布式系统提供命名服务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240736223.png"></p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>利用 ZooKeeper 的观察机制，可以将其作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>可以通过 ZooKeeper 的临时节点和 Watcher 机制来实现分布式排它锁。</p>
<p>举例来说，有一个分布式系统，有三个节点 A、B、C，试图通过 ZooKeeper 获取分布式锁。</p>
<p>（1）访问 <code>/lock</code> （这个目录路径由程序自己决定），创建 <strong>带序列号的临时节点（EPHEMERAL）</strong> 。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240738997.png"></p>
<p>（2）每个节点尝试获取锁时，拿到 <code>/locks</code>节点下的所有子节点（<code>id_0000</code>,<code>id_0001</code>,<code>id_0002</code>），<strong>判断自己创建的节点是不是序列号最小的</strong></p>
<ul>
<li>如果序列号是最小的，则成功获取到锁。<ul>
<li>释放锁：执行完操作后，把创建的节点给删掉。</li>
</ul>
</li>
<li>如果不是，则监听比自己要小 1 的节点变化。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240738641.png"></p>
<p>（3）释放锁，即删除自己创建的节点。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240739623.png"></p>
<p>图中，NodeA 删除自己创建的节点 <code>id_0000</code>，NodeB 监听到变化，发现自己的节点已经是最小节点，即可获取到锁。</p>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>ZooKeeper 还能解决大多数分布式系统中的问题：</p>
<ul>
<li>如可以通过创建临时节点来建立心跳检测机制。如果分布式系统的某个服务节点宕机了，则其持有的会话会超时，此时该临时节点会被删除，相应的监听事件就会被触发。</li>
<li>分布式系统的每个服务节点还可以将自己的节点状态写入临时节点，从而完成状态报告或节点工作进度汇报。</li>
<li>通过数据的订阅和发布功能，ZooKeeper 还能对分布式系统进行模块的解耦和任务的调度。</li>
<li>通过监听机制，还能对分布式系统的服务节点进行动态上下线，从而实现服务的动态扩容。</li>
</ul>
<h3 id="选举-Leader-节点"><a href="#选举-Leader-节点" class="headerlink" title="选举 Leader 节点"></a>选举 Leader 节点</h3><p>分布式系统一个重要的模式就是主从模式 (Master&#x2F;Salves)，ZooKeeper 可以用于该模式下的 Matser 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 ZooKeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Master 节点。</p>
<h3 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h3><p>ZooKeeper 可以处理两种类型的队列：</p>
<ol>
<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li>
<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。</li>
</ol>
<p>同步队列用 ZooKeeper 实现的实现思路如下：</p>
<p>创建一个父目录 <code>/synchronizing</code>，每个成员都监控标志（Set Watch）位目录 <code>/synchronizing/start</code> 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 <code>/synchronizing/member_i</code> 的临时目录节点，然后每个成员获取 <code>/synchronizing</code> 目录的所有目录节点，也就是 <code>member_i</code>。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 <code>/synchronizing/start</code> 的出现，如果已经相等就创建 <code>/synchronizing/start</code>。</p>
<h2 id="ZooKeeper-的缺点"><a href="#ZooKeeper-的缺点" class="headerlink" title="ZooKeeper 的缺点"></a>ZooKeeper 的缺点</h2><h3 id="ZooKeeper-不是为高可用性设计的"><a href="#ZooKeeper-不是为高可用性设计的" class="headerlink" title="ZooKeeper 不是为高可用性设计的"></a>ZooKeeper 不是为高可用性设计的</h3><p>生产环境中常常需要通过多机房部署来容灾。出于成本考虑，一般多机房都是同时提供服务的，即一个机房撑不住所有流量。<strong>ZooKeeper 集群只能有一个 Leader</strong>，一旦机房之间连接出现故障，那么只有 Leader 所在的机房可以正常工作，其他机房只能停摆。于是所有流量集中到 Leader 所在的机房，由于处理不过来而导致崩溃。</p>
<p>即使是在同一个机房里面，由于网段的不同，在调整机房交换机的时候偶尔也会发生网段隔离的情况。实际上机房每个月基本上都会发生短暂的网络隔离之类的子网段调整。在那个时刻 ZooKeeper 将处于不可用状态。如果业务系统重度依赖 ZooKeeper（比如用 Dubbo 作为 RPC，且使用 ZooKeeper 作为注册中心），则系统的可用性将非常脆弱。</p>
<p>由于 ZooKeeper 对于网络隔离的极度敏感，导致 ZooKeeper 对于网络的任何风吹草动都会做出激烈反应。这使得 ZooKeeper 的<strong>不可用</strong>时间比较多。我们不能让 ZooKeeper 的<strong>不可用</strong>，变成系统的<strong>不可用</strong>。</p>
<h3 id="ZooKeeper-的选举过程速度很慢"><a href="#ZooKeeper-的选举过程速度很慢" class="headerlink" title="ZooKeeper 的选举过程速度很慢"></a>ZooKeeper 的选举过程速度很慢</h3><p>互联网环境中，网络不稳定几乎是必然的，而 ZooKeeper 网络隔离非常敏感。一旦出现网络隔离，zookeeper 就要发起选举流程。</p>
<p>ZooKeeper 的选举流程通常耗时 30 到 120 秒，期间 ZooKeeper 由于没有 Leader，都是不可用的。</p>
<p>对于网络里面偶尔出现的，比如半秒一秒的网络隔离，ZooKeeper 会由于选举过程，而把不可用时间放大几十倍。</p>
<h3 id="ZooKeeper-的性能是有限的"><a href="#ZooKeeper-的性能是有限的" class="headerlink" title="ZooKeeper 的性能是有限的"></a>ZooKeeper 的性能是有限的</h3><p>典型的 ZooKeeper 的 TPS 大概是一万多，无法支撑每天动辄几十亿次的调用。因此，每次请求都去 ZooKeeper 获取业务系统信息是不可能的。</p>
<p>为此，ZooKeeper 的 client 必须自己缓存业务系统的信息。这就导致 ZooKeeper 提供的<strong>强一致性</strong>实际上是做不到的。如果我们需要强一致性，还需要其他机制来进行保障：比如用自动化脚本把业务系统的 old master 给 kill 掉，但是这可能会引发很多其他问题。</p>
<h3 id="ZooKeeper-无法进行有效的权限控制"><a href="#ZooKeeper-无法进行有效的权限控制" class="headerlink" title="ZooKeeper 无法进行有效的权限控制"></a>ZooKeeper 无法进行有效的权限控制</h3><p>ZooKeeper 的权限控制非常弱。在大型的复杂系统里面，使用 ZooKeeper 必须自己再额外的开发一套权限控制系统，通过那套权限控制系统再访问 ZooKeeper。</p>
<p>额外的权限控制系统不但增加了系统复杂性和维护成本，而且降低了系统的总体性能。</p>
<h3 id="即使有了-ZooKeeper-也很难避免业务系统的数据不一致"><a href="#即使有了-ZooKeeper-也很难避免业务系统的数据不一致" class="headerlink" title="即使有了 ZooKeeper 也很难避免业务系统的数据不一致"></a>即使有了 ZooKeeper 也很难避免业务系统的数据不一致</h3><p>由于 ZooKeeper 的性能限制，我们无法让每次系统内部调用都走 ZooKeeper，因此总有某些时刻，业务系统会存在两份数据（业务系统 client 那边缓存的业务系统信息是定时从 ZooKeeper 更新的，因此会有更新不同步的问题）。</p>
<p>如果要保持数据的强一致性，唯一的方法是“先 kill 掉当前 Leader，再在 ZooKeeper 上更新 Leader 信息”。是否要 kill 掉当前 Leader 这个问题上，程序是无法完全自动决定的（因为网络隔离的时候 ZooKeeper 已经不可用了，自动脚本没有全局信息，不管怎么做都可能是错的，什么都不做也可能是错的。当网络故障的时候，只有运维人员才有全局信息，程序是无法得知其他机房的情况的）。因此系统无法自动的保障数据一致性，必须要人工介入。而人工介入的典型时间是半个小时以上，我们不能让系统这么长时间不可用。因此我们必须在某个方向上进行妥协，最常见的妥协方式是放弃<strong>强一致性</strong>，而接受<strong>最终一致性</strong>。</p>
<p>如果我们需要人工介入才能保证<em>可靠的强一致性</em>，那么 ZooKeeper 的价值就大打折扣。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">ZooKeeper 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">ZooKeeper 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper">ZooKeeper Github</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27115351/">《Hadoop 权威指南（第四版）》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11622772.html">《从 Paxos 到 Zookeeper 分布式一致性原理与实践》</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html">分布式服务框架 ZooKeeper – 管理分布式环境中的数据</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixzh/p/5869212.html">ZooKeeper 的功能以及工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/ZooKeeper%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.md">ZooKeeper 简介及核心概念</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/zookeeper-chubby">详解分布式协调服务 ZooKeeper</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jasongj.com/zookeeper/fastleaderelection/">深入浅出 Zookeeper（一） Zookeeper 架构及 FastLeaderElection 机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper">Introduction to Apache ZooKeeper</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwwsq/article/details/7644445">Zookeeper 的优缺点</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f261d4e3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f261d4e3/" class="post-title-link" itemprop="url">ZooKeeper 原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 22:28:54" itemprop="dateCreated datePublished" datetime="2020-06-02T22:28:54+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/ZooKeeper/" itemprop="url" rel="index"><span itemprop="name">ZooKeeper</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ZooKeeper-面试"><a href="#ZooKeeper-面试" class="headerlink" title="ZooKeeper 面试"></a>ZooKeeper 面试</h1><h2 id="ZooKeeper-简介"><a href="#ZooKeeper-简介" class="headerlink" title="ZooKeeper 简介"></a>ZooKeeper 简介</h2><h3 id="【基础】什么是-ZooKeeper？"><a href="#【基础】什么是-ZooKeeper？" class="headerlink" title="【基础】什么是 ZooKeeper？"></a>【基础】什么是 ZooKeeper？</h3><p>:::details 要点</p>
<p>Zookeeper 是一个开源的分布式协调服务，目前由 Apache 进行维护。Zookeeper 可以用于实现分布式系统中常见的发布&#x2F;订阅、负载均衡、命令服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>Zookeeper 具有以下特性：</p>
<ul>
<li><strong>顺序一致性</strong>：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</li>
<li><strong>原子性</strong>：所有事务请求的处理结果在整个集群中所有机器上都是一致的；不存在部分机器应用了该事务，而另一部分没有应用的情况；</li>
<li><strong>单一视图</strong>：所有客户端看到的服务端数据模型都是一致的；</li>
<li><strong>可靠性</strong>：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</li>
<li><strong>实时性</strong>：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据。</li>
</ul>
<p>:::</p>
<h3 id="【基础】ZooKeeper-中有哪些应用场景？"><a href="#【基础】ZooKeeper-中有哪些应用场景？" class="headerlink" title="【基础】ZooKeeper 中有哪些应用场景？"></a>【基础】ZooKeeper 中有哪些应用场景？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 可以用于发布&#x2F;订阅、负载均衡、命令服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能</strong> 。</p>
<h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>通过 Zookeeper 进行数据的发布与订阅其实可以说是它提供的最基本功能，它能够允许多个客户端同时订阅某一个节点的变更并在变更发生时执行我们预先设置好的回调函数，在运行时改变服务的配置和行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZooKeeper</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">3000</span>, <span class="literal">null</span>);</span><br><span class="line">zk.getData(<span class="string">&quot;/config&quot;</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">        System.out.println(watchedEvent.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">null</span>);</span><br><span class="line">zk.setData(<span class="string">&quot;/config&quot;</span>, <span class="string">&quot;draven&quot;</span>.getBytes(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatchedEvent state:SyncConnected type:NodeDataChanged path:/config</span></span><br></pre></td></tr></table></figure>

<p>发布与订阅是 Zookeeper 提供的一个最基本的功能，它的使用非常的简单，我们可以在 <code>getData</code> 中传入实现 <code>process</code> 方法的 <code>Watcher</code> 对象，在每次改变节点的状态时，<code>process</code> 方法都会被调用，在这个方法中就可以对变更进行响应动态修改一些行为。</p>
<p><img src="https://img.draveness.me/2018-09-22-zookeeper-pubsub.png" alt="zookeeper-pubsub"></p>
<p>通过 Zookeeper 这个中枢，每一个客户端对节点状态的改变都能够推送给节点的订阅者，在发布订阅模型中，Zookeeper 的每一个节点都可以被理解成一个主题，每一个客户端都可以向这个主题推送详细，同时也可以订阅这个主题中的消息；只是 Zookeeper 引入了文件系统的父子层级的概念将发布订阅功能实现得更加复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">    None(-<span class="number">1</span>),</span><br><span class="line">    NodeCreated(<span class="number">1</span>),</span><br><span class="line">    NodeDeleted(<span class="number">2</span>),</span><br><span class="line">    NodeDataChanged(<span class="number">3</span>),</span><br><span class="line">    NodeChildrenChanged(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们订阅了一个节点的变更信息，那么该节点的子节点出现数量变更时就会调用 <code>process</code> 方法通知观察者，这也意味着更复杂的实现，同时和专门做发布订阅的中间件相比也没有性能优势，在海量推送的应用场景下，消息队列更能胜任，而 Zookeeper 更适合做一些类似服务配置的动态下发的工作。</p>
<h4 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h4><p>在分布式系统中，通常需要一个全局唯一的名字，如生成全局唯一的订单号等，ZooKeeper 可以通过顺序节点的特性来生成全局唯一 ID，从而可以对分布式系统提供命名服务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240736223.png"></p>
<h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>利用 ZooKeeper 的观察机制，可以将其作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>可以通过 ZooKeeper 的临时节点和 Watcher 机制来实现分布式排它锁。</p>
<p>举例来说，有一个分布式系统，有三个节点 A、B、C，试图通过 ZooKeeper 获取分布式锁。</p>
<p>（1）访问 <code>/lock</code> （这个目录路径由程序自己决定），创建 <strong>带序列号的临时节点（EPHEMERAL）</strong> 。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240738997.png"></p>
<p>（2）每个节点尝试获取锁时，拿到 <code>/locks</code>节点下的所有子节点（<code>id_0000</code>,<code>id_0001</code>,<code>id_0002</code>），<strong>判断自己创建的节点是不是序列号最小的</strong></p>
<ul>
<li>如果序列号是最小的，则成功获取到锁。<ul>
<li>释放锁：执行完操作后，把创建的节点给删掉。</li>
</ul>
</li>
<li>如果不是，则监听比自己要小 1 的节点变化。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240738641.png"></p>
<p>（3）释放锁，即删除自己创建的节点。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240739623.png"></p>
<p>图中，NodeA 删除自己创建的节点 <code>id_0000</code>，NodeB 监听到变化，发现自己的节点已经是最小节点，即可获取到锁。</p>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>ZooKeeper 还能解决大多数分布式系统中的协调问题：</p>
<ul>
<li><strong>可以通过创建临时节点来建立心跳检测机制</strong>。如果分布式系统的某个服务节点宕机了，则其持有的会话会超时，此时该临时节点会被删除，相应的监听事件就会被触发。</li>
<li><strong>分布式系统的每个服务节点还可以将自己的节点状态写入临时节点，从而完成状态报告或节点工作进度汇报</strong>。</li>
<li><strong>通过数据的订阅和发布功能，ZooKeeper 还能对分布式系统进行模块的解耦和任务的调度</strong>。</li>
<li><strong>通过监听机制，还能对分布式系统的服务节点进行动态上下线</strong>，从而实现服务的动态扩容。</li>
</ul>
<h4 id="选举-Leader-节点"><a href="#选举-Leader-节点" class="headerlink" title="选举 Leader 节点"></a>选举 Leader 节点</h4><p>分布式系统一个重要的模式就是主从模式 (Leader&#x2F;Followers)，ZooKeeper 可以用于该模式下的 Leader 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 ZooKeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Leader 节点。</p>
<h4 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h4><p>ZooKeeper 可以处理两种类型的队列：</p>
<ol>
<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li>
<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。</li>
</ol>
<p>同步队列用 ZooKeeper 实现的实现思路如下：</p>
<p>创建一个父目录 <code>/synchronizing</code>，每个成员都监控标志（Set Watch）位目录 <code>/synchronizing/start</code> 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 <code>/synchronizing/member_i</code> 的临时目录节点，然后每个成员获取 <code>/synchronizing</code> 目录的所有目录节点，也就是 <code>member_i</code>。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 <code>/synchronizing/start</code> 的出现，如果已经相等就创建 <code>/synchronizing/start</code>。</p>
<p>:::</p>
<h2 id="ZooKeeper-存储"><a href="#ZooKeeper-存储" class="headerlink" title="ZooKeeper 存储"></a>ZooKeeper 存储</h2><h3 id="【基础】ZooKeeper-如何存储数据？"><a href="#【基础】ZooKeeper-如何存储数据？" class="headerlink" title="【基础】ZooKeeper 如何存储数据？"></a>【基础】ZooKeeper 如何存储数据？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 采用类似于文件系统的层级结构存储数据</strong>。</p>
<p>树中的节点被称为 <strong><code>znode</code><strong>，其中根节点为 <code>/</code>，每个节点上都会保存自己的数据和节点信息。znode 可以用于存储数据，并且有一个与之相关联的 ACL（详情可见 <a href="#ACL">ACL</a>）。ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 znode 存储数据的</strong>大小被限制在 1MB 以内</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240730789.png"></p>
<p><strong>ZooKeeper 的数据访问具有原子性</strong>。其读写操作都是要么全部成功，要么全部失败。</p>
<p>znode 通过路径被引用。<strong>znode 节点路径必须是绝对路径</strong>。</p>
<p>:::</p>
<h3 id="【基础】ZooKeeper-有几种节点类型？"><a href="#【基础】ZooKeeper-有几种节点类型？" class="headerlink" title="【基础】ZooKeeper 有几种节点类型？"></a>【基础】ZooKeeper 有几种节点类型？</h3><p>:::details 要点</p>
<p>znode 其实有 <code>PERSISTENT</code>、<code>PERSISTENT_SEQUENTIAL</code>、<code>EPHEMERAL</code> 和 <code>EPHEMERAL_SEQUENTIAL</code> 四种类型，它们是临时与持久、顺序与非顺序两个不同的方向组合成的四种类型。</p>
<p>临时节点是客户端在连接 Zookeeper 时才会保持存在的节点，一旦客户端和服务端之间的连接中断，当前连接持有的所有节点都会被删除，而持久的节点不会随着会话连接的中断而删除，它们需要被客户端主动删除；Zookeeper 中另一种节点的特性就是顺序和非顺序，如果我们使用 Zookeeper 创建了顺序的节点，那么所有节点就会在名字的末尾附加一个序列号，序列号是一个由父节点维护的单调递增计数器。</p>
<p>:::</p>
<h2 id="ZooKeeper-架构"><a href="#ZooKeeper-架构" class="headerlink" title="ZooKeeper 架构"></a>ZooKeeper 架构</h2><h3 id="【中级】ZooKeeper-的设计目标是什么？"><a href="#【中级】ZooKeeper-的设计目标是什么？" class="headerlink" title="【中级】ZooKeeper 的设计目标是什么？"></a>【中级】ZooKeeper 的设计目标是什么？</h3><p>:::details 要点</p>
<p>Zookeeper 致力于为那些高吞吐的大型分布式系统提供一个高性能、高可用、且具有严格顺序访问控制能力的分布式协调服务。它具有以下四个目标：</p>
<p>目标一：简单的数据模型</p>
<p>Zookeeper 通过树形结构来存储数据，它由一系列被称为 znode 的数据节点组成，类似于常见的文件系统。不过和常见的文件系统不同，Zookeeper 将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9290aabdd522e9ea5d14d9ea4c3618614daad590ae3d31dc9583c2d4f12f10d9/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f7a6f6f6b65657065722d7a6b6e616d6573706163652e6a7067"><img src="https://camo.githubusercontent.com/9290aabdd522e9ea5d14d9ea4c3618614daad590ae3d31dc9583c2d4f12f10d9/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f7a6f6f6b65657065722d7a6b6e616d6573706163652e6a7067" alt="img"></a></p>
<p>目标二：构建集群</p>
<p>可以由一组 Zookeeper 服务构成 Zookeeper 集群，集群中每台机器都会单独在内存中维护自身的状态，并且每台机器之间都保持着通讯，只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bd11318040d88613c00aa65c4a1cab6232eadb6d34f398c8a0ae2796207dffdb/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f7a6f6f6b65657065722d7a6b736572766963652e6a7067"><img src="https://camo.githubusercontent.com/bd11318040d88613c00aa65c4a1cab6232eadb6d34f398c8a0ae2796207dffdb/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f7a6f6f6b65657065722d7a6b736572766963652e6a7067" alt="img"></a></p>
<p>目标三：顺序访问</p>
<p>对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增 ID，这个 ID 反映了所有事务请求的先后顺序。</p>
<p>目标四：高性能高可用</p>
<p>ZooKeeper 将数据存全量储在内存中以保持高性能，并通过服务集群来实现高可用，由于 Zookeeper 的所有更新和删除都是基于事务的，所以其在读多写少的应用场景中有着很高的性能表现。</p>
<p>:::</p>
<h3 id="【中级】ZooKeeper-集群有几种角色？"><a href="#【中级】ZooKeeper-集群有几种角色？" class="headerlink" title="【中级】ZooKeeper 集群有几种角色？"></a>【中级】ZooKeeper 集群有几种角色？</h3><p>:::details 要点</p>
<p>Zookeeper 集群是一个基于主从复制的高可用集群，集群中每个节点都存储了一份数据副本（内存中）。此外，每个服务器节点承担如下三种角色中的一种：</p>
<ul>
<li><strong>Leader</strong> - 它负责 <strong>发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器</strong>。一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader。</li>
<li><strong>Follower</strong> - 它会<strong>响应 Leader 的心跳。Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，并且负责在 Leader 处理写请求时对请求进行投票</strong>。一个 Zookeeper 集群可能同时存在多个 Follower。</li>
<li><strong>Observer</strong> - 角色与 Follower 类似，但是无投票权。</li>
</ul>
<p>客户端可以从任意 ZooKeeper 服务器节点读取数据，但只能通过 Leader 服务写数据并需要半数以上 Follower 的 ACK，才算写入成功。记住这个重要的知识点，下文会详细讲述。</p>
<p>:::</p>
<h3 id="【中级】ZooKeeper-的权限控制如何设计的？"><a href="#【中级】ZooKeeper-的权限控制如何设计的？" class="headerlink" title="【中级】ZooKeeper 的权限控制如何设计的？"></a>【中级】ZooKeeper 的权限控制如何设计的？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制</strong>。</p>
<p>每个 znode 创建时都会带有一个 ACL 列表，用于决定谁可以对它执行何种操作。</p>
<p>ACL 依赖于 ZooKeeper 的客户端认证机制。ZooKeeper 提供了以下几种认证方式：</p>
<ul>
<li><strong>digest</strong> - 用户名和密码 来识别客户端</li>
<li><strong>sasl</strong> - 通过 kerberos 来识别客户端</li>
<li><strong>ip</strong> - 通过 IP 来识别客户端</li>
</ul>
<p>ZooKeeper 定义了如下五种权限：</p>
<ul>
<li><strong>CREATE</strong> - 允许创建子节点；</li>
<li><strong>READ</strong> - 允许从节点获取数据并列出其子节点；</li>
<li><strong>WRITE</strong> - 允许为节点设置数据；</li>
<li><strong>DELETE</strong> - 允许删除子节点；</li>
<li><strong>ADMIN</strong> - 允许为节点设置权限。</li>
</ul>
<p>:::</p>
<h3 id="【高级】ZooKeeper-的架构有什么缺点？"><a href="#【高级】ZooKeeper-的架构有什么缺点？" class="headerlink" title="【高级】ZooKeeper 的架构有什么缺点？"></a>【高级】ZooKeeper 的架构有什么缺点？</h3><p>:::details 要点</p>
<h4 id="ZooKeeper-不是为高可用性设计的"><a href="#ZooKeeper-不是为高可用性设计的" class="headerlink" title="ZooKeeper 不是为高可用性设计的"></a>ZooKeeper 不是为高可用性设计的</h4><p>生产环境中常常需要通过多机房部署来容灾。出于成本考虑，一般多机房都是同时提供服务的，即一个机房撑不住所有流量。<strong>ZooKeeper 集群只能有一个 Leader</strong>，一旦机房之间连接出现故障，那么只有 Leader 所在的机房可以正常工作，其他机房只能停摆。于是所有流量集中到 Leader 所在的机房，由于处理不过来而导致崩溃。</p>
<p>即使是在同一个机房里面，由于网段的不同，在调整机房交换机的时候偶尔也会发生网段隔离的情况。实际上机房每个月基本上都会发生短暂的网络隔离之类的子网段调整。在那个时刻 ZooKeeper 将处于不可用状态。如果业务系统重度依赖 ZooKeeper（比如用 Dubbo 作为 RPC，且使用 ZooKeeper 作为注册中心），则系统的可用性将非常脆弱。</p>
<p>由于 ZooKeeper 对于网络隔离的极度敏感，导致 ZooKeeper 对于网络的任何风吹草动都会做出激烈反应。这使得 ZooKeeper 的<strong>不可用</strong>时间比较多。我们不能让 ZooKeeper 的<strong>不可用</strong>，变成系统的<strong>不可用</strong>。</p>
<h4 id="ZooKeeper-的选举过程速度很慢"><a href="#ZooKeeper-的选举过程速度很慢" class="headerlink" title="ZooKeeper 的选举过程速度很慢"></a>ZooKeeper 的选举过程速度很慢</h4><p>互联网环境中，网络不稳定几乎是必然的，而 ZooKeeper 网络隔离非常敏感。一旦出现网络隔离，zookeeper 就要发起选举流程。</p>
<p><strong>ZooKeeper 的选举流程通常耗时 30 到 120 秒，期间 ZooKeeper 由于没有 Leader，都是不可用的</strong>。</p>
<p>对于网络里面偶尔出现的，比如半秒一秒的网络隔离，ZooKeeper 会由于选举过程，而把不可用时间放大几十倍。</p>
<h4 id="ZooKeeper-的性能是有限的"><a href="#ZooKeeper-的性能是有限的" class="headerlink" title="ZooKeeper 的性能是有限的"></a>ZooKeeper 的性能是有限的</h4><p><strong>典型的 ZooKeeper 的 TPS 大概是一万多，无法支撑每天动辄几十亿次的调用</strong>。因此，每次请求都去 ZooKeeper 获取业务系统信息是不可能的。</p>
<p>为此，ZooKeeper 的 client 必须自己缓存业务系统的信息。这就导致 ZooKeeper 提供的<strong>强一致性</strong>实际上是做不到的。如果我们需要强一致性，还需要其他机制来进行保障：比如用自动化脚本把业务系统的 old master 给 kill 掉，但是这可能会引发很多其他问题。</p>
<h4 id="ZooKeeper-无法进行有效的权限控制"><a href="#ZooKeeper-无法进行有效的权限控制" class="headerlink" title="ZooKeeper 无法进行有效的权限控制"></a>ZooKeeper 无法进行有效的权限控制</h4><p><strong>ZooKeeper 的权限控制非常弱</strong>。在大型的复杂系统里面，使用 ZooKeeper 必须自己再额外的开发一套权限控制系统，通过那套权限控制系统再访问 ZooKeeper。</p>
<p>额外的权限控制系统不但增加了系统复杂性和维护成本，而且降低了系统的总体性能。</p>
<h4 id="即使有了-ZooKeeper-也很难避免业务系统的数据不一致"><a href="#即使有了-ZooKeeper-也很难避免业务系统的数据不一致" class="headerlink" title="即使有了 ZooKeeper 也很难避免业务系统的数据不一致"></a>即使有了 ZooKeeper 也很难避免业务系统的数据不一致</h4><p>由于 ZooKeeper 的性能限制，我们无法让每次系统内部调用都走 ZooKeeper，因此总有某些时刻，业务系统会存在两份数据（业务系统 client 那边缓存的业务系统信息是定时从 ZooKeeper 更新的，因此会有更新不同步的问题）。</p>
<p>如果要保持数据的强一致性，唯一的方法是“先 kill 掉当前 Leader，再在 ZooKeeper 上更新 Leader 信息”。是否要 kill 掉当前 Leader 这个问题上，程序是无法完全自动决定的（因为网络隔离的时候 ZooKeeper 已经不可用了，自动脚本没有全局信息，不管怎么做都可能是错的，什么都不做也可能是错的。当网络故障的时候，只有运维人员才有全局信息，程序是无法得知其他机房的情况的）。因此系统无法自动的保障数据一致性，必须要人工介入。而人工介入的典型时间是半个小时以上，我们不能让系统这么长时间不可用。因此我们必须在某个方向上进行妥协，最常见的妥协方式是放弃<strong>强一致性</strong>，而接受<strong>最终一致性</strong>。</p>
<p>如果我们需要人工介入才能保证<em>可靠的强一致性</em>，那么 ZooKeeper 的价值就大打折扣。</p>
<p>:::</p>
<h2 id="ZooKeeper-工作流"><a href="#ZooKeeper-工作流" class="headerlink" title="ZooKeeper 工作流"></a>ZooKeeper 工作流</h2><h3 id="【中级】ZooKeeper-读操作工作流程是怎样的？"><a href="#【中级】ZooKeeper-读操作工作流程是怎样的？" class="headerlink" title="【中级】ZooKeeper 读操作工作流程是怎样的？"></a>【中级】ZooKeeper 读操作工作流程是怎样的？</h3><p>:::details 要点</p>
<p><strong>Leader&#x2F;Follower&#x2F;Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可</strong>。</p>
<p>由于处理读请求不需要服务器之间的交互，<strong>Follower&#x2F;Observer 越多，整体系统的读请求吞吐量越大</strong>，也即读性能越好。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240730119.png"></p>
<p>:::</p>
<h3 id="【中级】ZooKeeper-写操作工作流程是怎样的？"><a href="#【中级】ZooKeeper-写操作工作流程是怎样的？" class="headerlink" title="【中级】ZooKeeper 写操作工作流程是怎样的？"></a>【中级】ZooKeeper 写操作工作流程是怎样的？</h3><p>:::details 要点</p>
<p>所有的写请求实际上都要交给 Leader 处理。Leader 将写请求以事务形式发给所有 Follower 并等待 ACK，一旦收到半数以上 Follower 的 ACK，即认为写操作成功。</p>
<h4 id="写-Leader"><a href="#写-Leader" class="headerlink" title="写 Leader"></a>写 Leader</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240731595.png"></p>
<p>由上图可见，通过 Leader 进行写操作，主要分为五步：</p>
<ol>
<li>客户端向 Leader 发起写请求</li>
<li>Leader 将写请求以事务 Proposal 的形式发给所有 Follower 并等待 ACK</li>
<li>Follower 收到 Leader 的事务 Proposal 后返回 ACK</li>
<li>Leader 得到过半数的 ACK（Leader 对自己默认有一个 ACK）后向所有的 Follower 和 Observer 发送 Commmit</li>
<li>Leader 将处理结果返回给客户端</li>
</ol>
<blockquote>
<p>注意</p>
<ul>
<li>Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权。</li>
<li>Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK。上图中有 4 个 Follower，只需其中两个返回 ACK 即可，因为 $$(2+1) &#x2F; (4+1) &gt; 1&#x2F;2$$ 。</li>
<li>Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据。</li>
</ul>
</blockquote>
<h4 id="写-Follower-Observer"><a href="#写-Follower-Observer" class="headerlink" title="写 Follower&#x2F;Observer"></a>写 Follower&#x2F;Observer</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240731844.png"></p>
<ul>
<li>Follower&#x2F;Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理。</li>
<li>除了多了一步请求转发，其它流程与直接写 Leader 无任何区别。</li>
</ul>
<p>:::</p>
<h3 id="【中级】ZooKeeper-事务机制是怎样的？"><a href="#【中级】ZooKeeper-事务机制是怎样的？" class="headerlink" title="【中级】ZooKeeper 事务机制是怎样的？"></a>【中级】ZooKeeper 事务机制是怎样的？</h3><p>:::details 要点</p>
<p>对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力。</p>
<p><strong>为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（zxid）来标识事务</strong>。</p>
<p><strong>Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO（先进先出） 的策略进行消息发送</strong>。Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应。<strong>当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交</strong>，之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交。</p>
<p>所有的提议（**<code>proposal</code>**）都在被提出的时候加上了 zxid。zxid 是一个 64 位的数字，它的高 32 位是 <strong><code>epoch</code></strong> 用来标识 Leader 关系是否改变，每次一个 Leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。</p>
<p>详细过程如下：</p>
<ol>
<li>Leader 等待 Server 连接；</li>
<li>Follower 连接 Leader，将最大的 zxid 发送给 Leader；</li>
<li>Leader 根据 Follower 的 zxid 确定同步点；</li>
<li>完成同步后通知 follower 已经成为 uptodate 状态；</li>
<li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li>
</ol>
<p>:::</p>
<h3 id="【中级】ZooKeeper-监听机制是怎样的？"><a href="#【中级】ZooKeeper-监听机制是怎样的？" class="headerlink" title="【中级】ZooKeeper 监听机制是怎样的？"></a>【中级】ZooKeeper 监听机制是怎样的？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 允许客户端监听它关心的 znode，当 znode 状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端</strong>。</p>
<p>需要注意的是：<strong>ZooKeeper 的监听通知是一次性的</strong>。无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p>
<p>客户端和服务端保持连接一般有两种形式：</p>
<ul>
<li>客户端向服务端不断轮询</li>
<li>服务端向客户端推送状态</li>
</ul>
<p><strong>Zookeeper 的选择是服务端主动推送状态，也就是观察机制（ <code>Watch</code> ）</strong>。</p>
<p>ZooKeeper 的观察机制允许用户在指定节点上针对感兴趣的事件注册监听，当事件发生时，监听器会被触发，并将事件信息推送到客户端。</p>
<ul>
<li>监听器实时触发</li>
<li>监听器总是有序的</li>
<li>创建新的 znode 数据前，客户端就能收到监听事件。</li>
</ul>
<p>客户端使用 <code>getData</code> 等接口获取 znode 状态时传入了一个用于处理节点变更的回调，那么服务端就会主动向客户端推送节点的变更：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure>

<p>从这个方法中传入的 <code>Watcher</code> 对象实现了相应的 <code>process</code> 方法，每次对应节点出现了状态的改变，<code>WatchManager</code> 都会通过以下的方式调用传入 <code>Watcher</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> &#123;</span><br><span class="line">    <span class="type">WatchedEvent</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(type, KeeperState.SyncConnected, path);</span><br><span class="line">    Set&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">        w.process(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zookeeper 中的所有数据其实都是由一个名为 <code>DataTree</code> 的数据结构管理的，所有的读写数据的请求最终都会改变这颗树的内容，在发出读请求时可能会传入 <code>Watcher</code> 注册一个回调函数，而写请求就可能会触发相应的回调，由 <code>WatchManager</code> 通知客户端数据的变化。</p>
<p>通知机制的实现其实还是比较简单的，通过读请求设置 <code>Watcher</code> 监听事件，写请求在触发事件时就能将通知发送给指定的客户端。</p>
<p>:::</p>
<h3 id="【中级】ZooKeeper-会话机制是怎样的？"><a href="#【中级】ZooKeeper-会话机制是怎样的？" class="headerlink" title="【中级】ZooKeeper 会话机制是怎样的？"></a>【中级】ZooKeeper 会话机制是怎样的？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 客户端通过 TCP 长连接连接到 ZooKeeper 服务集群</strong>。<strong>会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态</strong>。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知。</p>
<p>每个 ZooKeeper 客户端配置中都配置了 ZooKeeper 服务器集群列表。启动时，客户端会遍历列表去尝试建立连接。如果失败，它会尝试连接下一个服务器，依次类推。</p>
<p>一旦一台客户端与一台服务器建立连接，这台服务器会为这个客户端创建一个新的会话。<strong>每个会话都会有一个超时时间，若服务器在超时时间内没有收到任何请求，则相应会话被视为过期</strong>。一旦会话过期，就无法再重新打开，且任何与该会话相关的临时 znode 都会被删除。</p>
<p>通常来说，会话应该长期存在，而这需要由客户端来保证。客户端可以通过心跳方式（ping）来保持会话不过期。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240732938.png"></p>
<p>ZooKeeper 的会话具有四个属性：</p>
<ul>
<li><code>sessionID</code> - 会话 ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper 都会为其分配一个全局唯一的 sessionID。</li>
<li><code>TimeOut</code> - 会话超时时间，客户端在构造 Zookeeper 实例时，会配置 sessionTimeout 参数用于指定会话的超时时间，Zookeeper 客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。</li>
<li><code>TickTime</code> - 下次会话超时时间点，为了便于 Zookeeper 对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper 会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上 TimeOut。</li>
<li><code>isClosing</code> - 标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的 isClosing 标记为”已关闭”，这样就能确保不再处理来自该会话的心情求了。</li>
</ul>
<p>Zookeeper 的会话管理主要是通过 <code>SessionTracker</code> 来负责，其采用了<strong>分桶策略</strong>（将类似的会话放在同一区块中进行管理）进行管理，以便 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</p>
<p>:::</p>
<h2 id="Zab-协议"><a href="#Zab-协议" class="headerlink" title="Zab 协议"></a>Zab 协议</h2><h3 id="【中级】什么是-Zab-协议？"><a href="#【中级】什么是-Zab-协议？" class="headerlink" title="【中级】什么是 Zab 协议？"></a>【中级】什么是 Zab 协议？</h3><p>:::details 要点</p>
<p>ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。**<em>ZAB 协议不是 Paxos 算法</em>**，只是比较类似，二者在操作上并不相同。Multi-Paxos 实现的是一系列值的共识，不关心最终达成共识的值是什么，不关心各值的顺序。而 ZooKeeper 需要确保操作的顺序性。</p>
<p>ZAB 协议是 Zookeeper 专门设计的一种<strong>支持故障恢复的原子广播协议</strong>。ZAB 协议是 ZooKeeper 的数据一致性和高可用解决方案。</p>
<p>ZAB 协议定义了两个可以<strong>无限循环</strong>的流程：</p>
<ul>
<li><strong><code>选举 Leader</code></strong> - 用于故障恢复，从而保证高可用。</li>
<li><strong><code>原子广播</code></strong> - 用于主从同步，从而保证数据一致性。</li>
</ul>
<p>:::</p>
<h3 id="【高级】Zab-协议中故障恢复的流程是怎样的？"><a href="#【高级】Zab-协议中故障恢复的流程是怎样的？" class="headerlink" title="【高级】Zab 协议中故障恢复的流程是怎样的？"></a>【高级】Zab 协议中故障恢复的流程是怎样的？</h3><p>:::details 要点</p>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p><strong>ZooKeeper 集群采用一主多从模式，主从节点通过副本机制保证数据一致</strong>。</p>
<ul>
<li><strong>如果 Follower 节点挂了</strong> - ZooKeeper 集群中的每个节点都会单独在内存中维护自身的状态，并且各节点之间都保持着通讯，<strong>只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务</strong>。</li>
<li><strong>如果 Leader 节点挂了</strong> - 如果 Leader 节点挂了，系统就不能正常工作了。此时，需要通过 ZAB 协议的选举 Leader 机制来进行故障恢复。</li>
</ul>
<p>ZAB 协议的选举 Leader 机制简单来说，就是：<strong>基于过半选举机制产生新的 Leader</strong>，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出选举 Leader 模式，进入原子广播模式。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li><strong>myid</strong> - 每个 Zookeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，<strong>该文件包含整个 Zookeeper 集群唯一的 ID（整数）</strong>。</li>
<li><strong>zxid</strong> - 类似于 RDBMS 中的事务 ID，<strong>用于标识一次更新操作的 Proposal ID</strong>。为了保证顺序性，该 zxid 必须单调递增。因此 Zookeeper 使用一个 64 位的数来表示，高 32 位是 Leader 的 epoch，从 1 开始，每次选出新的 Leader，epoch 加一。低 32 位为该 epoch 内的序号，每次 epoch 变化，都将低 32 位的序号重置。这样保证了 zxid 的全局递增性。</li>
</ul>
<h4 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h4><ul>
<li><strong><em>LOOKING</em></strong> - 不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举</li>
<li><strong><em>FOLLOWING</em></strong> - 跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁</li>
<li><strong><em>LEADING</em></strong> - 领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳</li>
<li><strong><em>OBSERVING</em></strong> - 观察者状态。表明当前服务器角色是 Observer，与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票</li>
</ul>
<h4 id="选票数据结构"><a href="#选票数据结构" class="headerlink" title="选票数据结构"></a>选票数据结构</h4><p>每个服务器在进行领导选举时，会发送如下关键信息</p>
<ul>
<li><strong><em>logicClock</em></strong> - 每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票</li>
<li><strong><em>state</em></strong> - 当前服务器的状态</li>
<li><strong><em>self_id</em></strong> - 当前服务器的 myid</li>
<li><strong><em>self_zxid</em></strong> - 当前服务器上所保存的数据的最大 zxid</li>
<li><strong><em>vote_id</em></strong> - 被推举的服务器的 myid</li>
<li><strong><em>vote_zxid</em></strong> - 被推举的服务器上所保存的数据的最大 zxid</li>
</ul>
<h4 id="投票流程"><a href="#投票流程" class="headerlink" title="投票流程"></a>投票流程</h4><p>（1）<strong>自增选举轮次</strong> - Zookeeper 规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的 logicClock 进行自增操作。</p>
<p>（2）<strong>初始化选票</strong> - 每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器 2 投票给服务器 3，服务器 3 投票给服务器 1，则服务器 1 的投票箱为 (2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。</p>
<p>（3）<strong>发送初始化选票</strong> - 每个服务器最开始都是通过广播把票投给自己。</p>
<p>（4）<strong>接收外部投票</strong> - 服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。</p>
<p>（5）<strong>判断选举轮次</strong> - 收到外部投票后，首先会根据投票信息中所包含的 logicClock 来进行不同处理</p>
<ul>
<li>外部投票的 logicClock 大于自己的 logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的 logicClock 更新为收到的 logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。</li>
<li>外部投票的 logicClock 小于自己的 logicClock。当前服务器直接忽略该投票，继续处理下一个投票。</li>
<li>外部投票的 logickClock 与自己的相等。当时进行选票 PK。</li>
</ul>
<p>（6）<strong>选票 PK</strong> - 选票 PK 是基于<code>(self_id, self_zxid)</code> 与 <code>(vote_id, vote_zxid)</code> 的对比</p>
<ul>
<li>外部投票的 logicClock 大于自己的 logicClock，则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock</li>
<li>若 logicClock 一致，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在 (self_myid, self_zxid) 相同的选票，则直接覆盖</li>
<li>若二者 vote_zxid 一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱</li>
</ul>
<p>（7）<strong>统计选票</strong> - 如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p>
<p>（8）<strong>更新服务器状态</strong> - 投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING</p>
<p>通过以上流程分析，我们不难看出：要使 Leader 获得多数 Server 的支持，则 <strong>ZooKeeper 集群节点数必须是奇数。且存活的节点数目不得少于 <code>N + 1</code></strong> 。</p>
<p>每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p>
<p>:::</p>
<h3 id="【高级】Zab-协议中原子广播的流程是怎样的？"><a href="#【高级】Zab-协议中原子广播的流程是怎样的？" class="headerlink" title="【高级】Zab 协议中原子广播的流程是怎样的？"></a>【高级】Zab 协议中原子广播的流程是怎样的？</h3><p>:::details 要点</p>
<p><strong>ZooKeeper 通过副本机制来实现高可用</strong>。</p>
<p>那么，ZooKeeper 是如何实现副本机制的呢？答案是：ZAB 协议的原子广播。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412240735474.png"></p>
<p>ZAB 协议的原子广播要求：</p>
<p>**<em>所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应</em>**。这有些类似数据库中的两阶段提交协议。</p>
<p>在整个消息的广播过程中，Leader 服务器会每个事务请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。</p>
<blockquote>
<p>ZAB 是通过“一切以领导者为准”的强领导者模型和严格按照顺序提交日志，来实现操作的顺序性的，这一点和 Raft 是一样的。</p>
</blockquote>
<p>:::</p>
<h3 id="【中级】Zab-和-Paxos-有什么区别？"><a href="#【中级】Zab-和-Paxos-有什么区别？" class="headerlink" title="【中级】Zab 和 Paxos 有什么区别？"></a>【中级】Zab 和 Paxos 有什么区别？</h3><p>:::details 要点</p>
<p>Zab 和 Paxos 协议在实现上其实有非常多的相似点，例如：</p>
<ul>
<li>主节点会向所有的从节点发出提案；</li>
<li>主节点在接收到一组从节点中一半以上节点的确认后，才会认为当前提案被提交了；</li>
<li>Zab 协议中的每一个提案都包含一个 epoch 值，与 Paxos 中的 Ballot 非常相似；</li>
</ul>
<p>因为它们有一些相同的特点，所以有的观点会认为 Zab 是 Paxos 的一个简化版本，但是 Zab 和 Paxos 在设计理念上就有着比较大的不同，两者的主要区别就在于 Zab 主要是为构建高可用的主备系统设计的，而 Paxos 能够帮助工程师搭建具有一致性的状态机系统。</p>
<p>作为一个一致性状态机系统，它能够保证集群中任意一个状态机副本都按照客户端的请求执行了相同顺序的请求，即使来自客户端请求是异步的并且不同客户端的接收同一个请求的顺序不同，集群中的这些副本就是会使用 Paxos 或者它的变种对提案达成一致；在集群运行的过程中，如果主节点出现了错误导致宕机，其他的节点会重新开始进行选举并处理未提交的请求。</p>
<p>但是在类似 Zookeeper 的高可用主备系统中，所有的副本都需要对增量的状态更新顺序达成一致，这些状态更新的变量都是由主节点创建并发送给其他的从节点的，每一个从节点都会严格按照顺序逐一的执行主节点生成的状态更新请求，如果 Zookeeper 集群中的主节点发生了宕机，新的主节点也必须严格按照顺序对请求进行恢复。</p>
<p>总的来说，使用状态更新节点数据的主备系统相比根据客户端请求改变状态的状态机系统对于请求的执行顺序有着更严格的要求。</p>
<blockquote>
<p>这一节对于 Zab 和 Paxos 区别的介绍大都来自于 <a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos">Zab vs. Paxos</a> ，有兴趣的读者可以阅读相关的内容。</p>
</blockquote>
<p>:::</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">ZooKeeper 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27115351/">《Hadoop 权威指南（第四版）》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11622772.html">《从 Paxos 到 Zookeeper 分布式一致性原理与实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/zookeeper-chubby">详解分布式协调服务 ZooKeeper</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/5b98b2ad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/5b98b2ad/" class="post-title-link" itemprop="url">ZooKeeper运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 22:28:38" itemprop="dateCreated datePublished" datetime="2020-06-02T22:28:38+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/ZooKeeper/" itemprop="url" rel="index"><span itemprop="name">ZooKeeper</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ZooKeeper-运维指南"><a href="#ZooKeeper-运维指南" class="headerlink" title="ZooKeeper 运维指南"></a>ZooKeeper 运维指南</h1><h2 id="单点服务部署"><a href="#单点服务部署" class="headerlink" title="单点服务部署"></a>单点服务部署</h2><p>在安装 ZooKeeper 之前，请确保你的系统是在以下任一操作系统上运行：</p>
<ul>
<li><strong>任意 Linux OS</strong> - 支持开发和部署。适合演示应用程序。</li>
<li><strong>Windows OS</strong> - 仅支持开发。</li>
<li><strong>Mac OS</strong> - 仅支持开发。</li>
</ul>
<p>安装步骤如下：</p>
<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>进入官方下载地址：<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/releases.html#download">http://zookeeper.apache.org/releases.html#download</a> ，选择合适版本。</p>
<p>解压到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf zookeeper-3.4.6.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zookeeper-3.4.6</span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>执行 <code>vim /etc/profile</code>，添加环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/app/zookeeper-3.4.14</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>再执行 <code>source /etc/profile</code> ， 使得配置的环境变量生效。</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>你必须创建 <code>conf/zoo.cfg</code> 文件，否则启动时会提示你没有此文件。</p>
<p>初次尝试，不妨直接使用 Kafka 提供的模板配置文件 <code>conf/zoo_sample.cfg</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> conf/zoo_sample.cfg conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改后完整配置如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial</span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between</span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just</span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/usr/local/zookeeper/data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">/usr/local/zookeeper/log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the</span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>

<p>配置参数说明：</p>
<ul>
<li><strong>tickTime</strong>：用于计算的基础时间单元。比如 session 超时：N*tickTime；</li>
<li><strong>initLimit</strong>：用于集群，允许从节点连接并同步到 master 节点的初始化连接时间，以 tickTime 的倍数来表示；</li>
<li><strong>syncLimit</strong>：用于集群， master 主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）；</li>
<li><strong>dataDir</strong>：数据存储位置；</li>
<li><strong>dataLogDir</strong>：日志目录；</li>
<li><strong>clientPort</strong>：用于客户端连接的端口，默认 2181</li>
</ul>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>执行此命令后，你将收到以下响应</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JMX enabled by default</span><br><span class="line">Using config: /Users/../zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><p>可以使用以下命令停止 zookeeper 服务器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>

<h2 id="集群服务部署"><a href="#集群服务部署" class="headerlink" title="集群服务部署"></a>集群服务部署</h2><p>分布式系统节点数一般都要求是奇数，且最少为 3 个节点，Zookeeper 也不例外。</p>
<p>这里，规划一个含 3 个节点的最小 ZooKeeper 集群，主机名分别为 hadoop001，hadoop002，hadoop003 。</p>
<h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改配置文件 <code>zoo.cfg</code>，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/usr/local/zookeeper-cluster/data/</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">/usr/local/zookeeper-cluster/log/</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># server.1 这个1是服务器的标识，可以是任意有效数字，标识这是第几个服务器节点，这个标识要写到dataDir目录下面myid文件里</span></span><br><span class="line"><span class="comment"># 指名集群间通讯端口和选举端口</span></span><br><span class="line"><span class="attr">server.1</span>=<span class="string">hadoop001:2287:3387</span></span><br><span class="line"><span class="attr">server.2</span>=<span class="string">hadoop002:2287:3387</span></span><br><span class="line"><span class="attr">server.3</span>=<span class="string">hadoop003:2287:3387</span></span><br></pre></td></tr></table></figure>

<h3 id="标识节点"><a href="#标识节点" class="headerlink" title="标识节点"></a>标识节点</h3><p>分别在三台主机的 <code>dataDir</code> 目录下新建 <code>myid</code> 文件,并写入对应的节点标识。Zookeeper 集群通过 <code>myid</code> 文件识别集群节点，并通过上文配置的节点通信端口和选举端口来进行节点通信，选举出 Leader 节点。</p>
<p>创建存储目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三台主机均执行该命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -vp  /usr/local/zookeeper-cluster/data/</span><br></pre></td></tr></table></figure>

<p>创建并写入节点标识到 <code>myid</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hadoop001主机</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /usr/local/zookeeper-cluster/data/myid</span><br><span class="line"><span class="comment"># hadoop002主机</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt; /usr/local/zookeeper-cluster/data/myid</span><br><span class="line"><span class="comment"># hadoop003主机</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3&quot;</span> &gt; /usr/local/zookeeper-cluster/data/myid</span><br></pre></td></tr></table></figure>

<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>分别在三台主机上，执行如下命令启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/app/zookeeper-cluster/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><p>启动后使用 <code>zkServer.sh status</code> 查看集群各个节点状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/zookeeper/zookeeper_installation.html">Zookeeper 安装</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/zookeeper-bs-command.html">Zookeeper 客户端基础命令使用</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1180ebb0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1180ebb0/" class="post-title-link" itemprop="url">HBase 命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 22:28:18" itemprop="dateCreated datePublished" datetime="2020-06-02T22:28:18+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-命令"><a href="#HBase-命令" class="headerlink" title="HBase 命令"></a>HBase 命令</h1><blockquote>
<p>进入 HBase Shell 控制台：<code>./bin/hbase shell</code></p>
<p>如果有 kerberos 认证，需要事先使用相应的 keytab 进行一下认证（使用 kinit 命令），认证成功之后再使用 hbase shell 进入可以使用 whoami 命令可查看当前用户.</p>
</blockquote>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li>获取帮助信息：<code>help</code></li>
<li>获取命令的详细帮助信息：<code>help &#39;status&#39;</code></li>
<li>查看服务器状态：<code>status</code></li>
<li>查看版本信息：<code>version</code></li>
<li>查看当前登录用户：<code>whoami</code></li>
</ul>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>【语法】<code>create &#39;表名称&#39;,&#39;列族名称 1&#39;,&#39;列族名称 2&#39;,&#39;列名称 N&#39;</code></p>
<p>【示例】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一张名为 <span class="built_in">test</span> 的表，columnFamliy1、columnFamliy2 是 table1 表的列族。</span></span><br><span class="line">create &#x27;test&#x27;,&#x27;columnFamliy1&#x27;,&#x27;columnFamliy2&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="启用、禁用表"><a href="#启用、禁用表" class="headerlink" title="启用、禁用表"></a>启用、禁用表</h3><ul>
<li>启用表：<code>enable &#39;test&#39;</code></li>
<li>禁用表：<code>disable &#39;test&#39;</code></li>
<li>检查表是否被启用：<code>is_enabled &#39;test&#39;</code></li>
<li>检查表是否被禁用：<code>is_disabled &#39;test&#39;</code></li>
</ul>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>注意：删除表前需要先禁用表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable &#x27;test&#x27;</span><br><span class="line">drop &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="添加列族"><a href="#添加列族" class="headerlink" title="添加列族"></a>添加列族</h4><p><strong>命令格式</strong>： alter ‘表名’, ‘列族名’</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &#x27;test&#x27;, &#x27;teacherInfo&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="删除列族"><a href="#删除列族" class="headerlink" title="删除列族"></a>删除列族</h4><p><strong>命令格式</strong>：alter ‘表名’, {NAME &#x3D;&gt; ‘列族名’, METHOD &#x3D;&gt; ‘delete’}</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &#x27;test&#x27;, &#123;NAME =&gt; &#x27;teacherInfo&#x27;, METHOD =&gt; &#x27;delete&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改列族存储版本的限制"><a href="#更改列族存储版本的限制" class="headerlink" title="更改列族存储版本的限制"></a>更改列族存储版本的限制</h4><p>默认情况下，列族只存储一个版本的数据，如果需要存储多个版本的数据，则需要修改列族的属性。修改后可通过 <code>desc</code> 命令查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &#x27;test&#x27;,&#123;NAME=&gt;&#x27;columnFamliy1&#x27;,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ul>
<li>查看所有表：<code>list</code></li>
<li>查看表的详细信息：<code>describe &#39;test&#39;</code></li>
<li>检查表是否存在：<code>exists &#39;test&#39;</code></li>
</ul>
<h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p><strong>命令格式</strong>：<code>put &#39;表名&#39;, &#39;行键&#39;,&#39;列族:列&#39;,&#39;值&#39;</code></p>
<p><strong>注意：如果新增数据的行键值、列族名、列名与原有数据完全相同，则相当于更新操作</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy1:a&#x27;, &#x27;valueA&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy1:b&#x27;, &#x27;valueB&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy1:c&#x27;, &#x27;valueC&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey2&#x27;, &#x27;columnFamliy1:a&#x27;, &#x27;valueA&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey2&#x27;, &#x27;columnFamliy1:b&#x27;, &#x27;valueB&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey2&#x27;, &#x27;columnFamliy1:c&#x27;, &#x27;valueC&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey3&#x27;, &#x27;columnFamliy1:a&#x27;, &#x27;valueA&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey3&#x27;, &#x27;columnFamliy1:b&#x27;, &#x27;valueB&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey3&#x27;, &#x27;columnFamliy1:c&#x27;, &#x27;valueC&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy2:a&#x27;, &#x27;valueA&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy2:b&#x27;, &#x27;valueB&#x27;</span><br><span class="line">put &#x27;test&#x27;, &#x27;rowkey1&#x27;, &#x27;columnFamliy2:c&#x27;, &#x27;valueC&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="获取指定行、列族、列"><a href="#获取指定行、列族、列" class="headerlink" title="获取指定行、列族、列"></a>获取指定行、列族、列</h3><ul>
<li>获取指定行中所有列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;</code></li>
<li>获取指定行中指定列族下所有列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;,&#39;columnFamliy1&#39;</code></li>
<li>获取指定行中指定列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;,&#39;columnFamliy1:a&#39;</code></li>
</ul>
<h3 id="删除指定行、列"><a href="#删除指定行、列" class="headerlink" title="删除指定行、列"></a>删除指定行、列</h3><ul>
<li>删除指定行：<code>delete &#39;test&#39;,&#39;rowkey2&#39;</code></li>
<li>删除指定行中指定列的数据：<code>delete &#39;test&#39;,&#39;rowkey2&#39;,&#39;columnFamliy1:a&#39;</code></li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>hbase 中访问数据有两种基本的方式：</p>
<ul>
<li>按指定 rowkey 获取数据：<code>get</code> 方法；</li>
<li>按指定条件获取数据：<code>scan</code> 方法。</li>
</ul>
<p><code>scan</code> 可以设置 begin 和 end 参数来访问一个范围内所有的数据。get 本质上就是 begin 和 end 相等的一种特殊的 scan。</p>
<h3 id="get-查询"><a href="#get-查询" class="headerlink" title="get 查询"></a>get 查询</h3><ul>
<li>获取指定行中所有列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;</code></li>
<li>获取指定行中指定列族下所有列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;,&#39;columnFamliy1&#39;</code></li>
<li>获取指定行中指定列的数据信息：<code>get &#39;test&#39;,&#39;rowkey2&#39;,&#39;columnFamliy1:a&#39;</code></li>
</ul>
<h3 id="scan-查询"><a href="#scan-查询" class="headerlink" title="scan 查询"></a>scan 查询</h3><h4 id="查询整表数据"><a href="#查询整表数据" class="headerlink" title="查询整表数据"></a>查询整表数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="查询指定列簇的数据"><a href="#查询指定列簇的数据" class="headerlink" title="查询指定列簇的数据"></a>查询指定列簇的数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, &#123;COLUMN=&gt;&#x27;columnFamliy1&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定列的数据</span></span><br><span class="line">scan &#x27;test&#x27;, &#123;COLUMNS=&gt; &#x27;columnFamliy1:a&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>除了列 <code>（COLUMNS）</code> 修饰词外，HBase 还支持 <code>Limit</code>（限制查询结果行数），<code>STARTROW</code>（<code>ROWKEY</code> 起始行，会先根据这个 <code>key</code> 定位到 <code>region</code>，再向后扫描）、<code>STOPROW</code>(结束行)、<code>TIMERANGE</code>（限定时间戳范围）、<code>VERSIONS</code>（版本数）、和 <code>FILTER</code>（按条件过滤行）等。</p>
<p>如下代表从 <code>rowkey2</code> 这个 <code>rowkey</code> 开始，查找下两个行的最新 3 个版本的 name 列的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, &#123;COLUMNS=&gt; &#x27;columnFamliy1:a&#x27;,STARTROW =&gt; &#x27;rowkey2&#x27;,STOPROW =&gt; &#x27;rowkey3&#x27;,LIMIT=&gt;2, VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h4><p>Filter 可以设定一系列条件来进行过滤。如我们要查询值等于 24 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;binary:24&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p>值包含 valueA 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;substring:valueA&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p>列名中的前缀为 b 的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;b&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p>FILTER 中支持多个过滤条件通过括号、AND 和 OR 进行组合：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列名中的前缀为 b 且列值中包含1998的数据</span></span><br><span class="line">scan &#x27;test&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;b&#x27;) AND ValueFilter ValueFilter(=,&#x27;substring:A&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p><code>PrefixFilter</code> 用于对 Rowkey 的前缀进行判断：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;test&#x27;, FILTER=&gt;&quot;PrefixFilter(&#x27;wr&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/Hbase_Shell.md">Hbase 常用 Shell 命令</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/4ce6aef0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/4ce6aef0/" class="post-title-link" itemprop="url">Zipkin 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-23 22:56:45" itemprop="dateCreated datePublished" datetime="2020-03-23T22:56:45+08:00">2020-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E8%BD%AF%E4%BB%B6/%E7%9B%91%E6%8E%A7%E8%AF%8A%E6%96%AD/" itemprop="url" rel="index"><span itemprop="name">监控诊断</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Zipkin-快速入门"><a href="#Zipkin-快速入门" class="headerlink" title="Zipkin 快速入门"></a>Zipkin 快速入门</h1><p><strong>Zipkin 是一个基于 Java 开发的、开源的、分布式实时数据跟踪系统（Distributed Tracking System）</strong>。它采集有助于解决服务架构中延迟问题的实时数据。</p>
<p>Zipkin 主要功能是聚集来自各个异构系统的实时监控数据。分布式跟踪系统还有其他比较成熟的实现，例如：Naver 的 Pinpoint、Apache 的 HTrace、阿里的鹰眼 Tracing、京东的 Hydra、新浪的 Watchman，美团点评的 CAT，skywalking 等。</p>
<p>Zipkin 基于 Google Dapper 的论文设计而来，由 Twitter 公司开发贡献。</p>
<h2 id="一、Zipkin-简介"><a href="#一、Zipkin-简介" class="headerlink" title="一、Zipkin 简介"></a>一、Zipkin 简介</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>如果日志文件中有跟踪 ID，则可以直接跳至该跟踪 ID。 否则，您可以基于属性进行查询，例如服务，操作名称，标签和持续时间。 将为您总结一些有趣的数据，例如在服务中花费的时间百分比以及操作是否失败。</p>
<p>Zipkin UI 还提供了一个依赖关系图，该关系图显示了每个应用程序中跟踪了多少个请求。这对于识别聚合行为（包括错误路径或对不赞成使用的服务的调用）很有帮助。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211161706.png" alt="Zipkin UI"></p>
<h3 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h3><p>Zipkin 官方支持 C#、Go、Java、JavaScript、Ruby、Scala、PHP 语言。</p>
<p>除此以外，社区还贡献了多种其他语言的支持，详情可以参考官方文档：<a target="_blank" rel="noopener" href="https://zipkin.io/pages/tracers_instrumentation.html">Tracers and Instrumentation</a></p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Zipkin 服务器捆绑了用于采集和存储数据的扩展。</p>
<p>默认情况下，数据可以通过 <code>Http</code>，<code>Kafka</code> 、<code>RabbitMQ</code> 或 RPC 传输。</p>
<p>并存储在内存中或 <code>MySQL</code>、<code>Cassandra</code> 或 <code>Elasticsearch</code> 中。</p>
<p>数据以 json 形式存储，可以参考：<a target="_blank" rel="noopener" href="https://zipkin.io/zipkin-api/#/default/post_spans">Zipkin 官方的 Swagger API</a></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211162055.png" alt="Zipkin Swagger API"></p>
<h2 id="二、Zipkin-安装"><a href="#二、Zipkin-安装" class="headerlink" title="二、Zipkin 安装"></a>二、Zipkin 安装</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 启动方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9411:9411 openzipkin/zipkin</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><blockquote>
<p>注意：必须运行在 JDK8+ 环境</p>
</blockquote>
<p>Java 启动方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://zipkin.io/quickstart.sh | bash -s</span><br><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure>

<h3 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h3><p>适用于需要订制化的场景。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get the latest <span class="built_in">source</span></span></span><br><span class="line">git clone https://github.com/openzipkin/zipkin</span><br><span class="line">cd zipkin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Build the server and also make its dependencies</span></span><br><span class="line">./mvnw -DskipTests --also-make -pl zipkin-server clean install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the server</span></span><br><span class="line">java -jar ./zipkin-server/target/zipkin-server-*exec.jar</span><br></pre></td></tr></table></figure>

<h2 id="三、Zipkin-架构"><a href="#三、Zipkin-架构" class="headerlink" title="三、Zipkin 架构"></a>三、Zipkin 架构</h2><p>ZipKin 可以分为两部分，</p>
<ul>
<li>一部分是 Zipkin server，用来作为数据的采集存储、数据分析与展示；</li>
<li>另一部分是 Zipkin client 是 Zipkin 基于不同的语言及框架封装的一些列客户端工具，这些工具完成了追踪数据的生成与上报功能。</li>
</ul>
<p>架构如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200211155836.png" alt="Zipkin 架构"></p>
<h3 id="Zipkin-Server"><a href="#Zipkin-Server" class="headerlink" title="Zipkin Server"></a>Zipkin Server</h3><p>Zipkin Server 主要包括四个模块：</p>
<ul>
<li><strong>Collector</strong> - 负责采集客户端传输的数据。</li>
<li><strong>Storage</strong> - 负责存储采集的数据。当前支持 Memory，MySQL，Cassandra，ElasticSearch 等，默认存储在内存中。</li>
<li><strong>API（Query）</strong> - 负责查询 Storage 中存储的数据。提供简单的 JSON API 获取数据，主要提供给 web UI 使用。</li>
<li><strong>UI</strong> - 提供简单的 web 界面。</li>
</ul>
<p>Instrumented Client 和 Instrumented Server，是指分布式架构中使用了 Trace 工具的两个应用，Client 会调用 Server 提供的服务，两者都会向 Zipkin 上报 Trace 相关信息。在 Client 和 Server 通过 Transport 上报 Trace 信息后，由 Zipkin 的 Collector 模块接收，并由 Storage 模块将数据存储在对应的存储介质中，然后 Zipkin 提供 API 供 UI 界面查询 Trace 跟踪信息。Non-Instrumented Server，指的是未使用 Trace 工具的 Server，显然它不会上报 Trace 信息。</p>
<h3 id="Zipkin-Client"><a href="#Zipkin-Client" class="headerlink" title="Zipkin Client"></a>Zipkin Client</h3><ul>
<li><strong>Tracer</strong> - <code>Tracer</code> 存在于你的应用中，它负责采集关于已发生操作的实时元数据。它们通常会检测库，因此对于用户是透明的。例如，已检测的 Web 服务器记录它何时接收到请求，以及何时发送响应。收集的跟踪数据称为跨度（Span）。</li>
<li><strong>Instrumentation</strong> - Instrumentation 保证了生产环境的安全性和很少的开销。因此，它们仅在内部传播 ID，以告知接收方正在进行追踪。完成的 Span 将通过外部通信告知 Zipkin，类似于应用程序异步报告指标的方式。例如，当跟踪某个操作并且需要发出 http 请求时，会添加一些 header 来传播 ID。header 不用于发送详细信息，例如操作名称。</li>
<li><strong>Reporter</strong> - 能够将数据发送到 Zipkin 的检测应用程序中的组件，被称为 Reporter。Reporter 有多种传输方式，可以将跟踪数据发送到 Zipkin 采集器，后者将跟踪数据持久化保存到存储中。稍后，API 会查询存储以向 UI 提供渲染数据。</li>
</ul>
<p>以下是 Zipkin 的一个示例工作流：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐</span><br><span class="line">│ User Code   │ │ Trace Instrumentation │  │ Http Client │  │ Zipkin Collector │</span><br><span class="line">└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘</span><br><span class="line">       │                 │                         │                 │</span><br><span class="line">           ┌─────────┐</span><br><span class="line">       │ ──┤GET /foo ├─▶ │ ────┐                   │                 │</span><br><span class="line">           └─────────┘         │ record tags</span><br><span class="line">       │                 │ ◀───┘                   │                 │</span><br><span class="line">                           ────┐</span><br><span class="line">       │                 │     │ add trace headers │                 │</span><br><span class="line">                           ◀───┘</span><br><span class="line">       │                 │ ────┐                   │                 │</span><br><span class="line">                               │ record timestamp</span><br><span class="line">       │                 │ ◀───┘                   │                 │</span><br><span class="line">                             ┌─────────────────┐</span><br><span class="line">       │                 │ ──┤GET /foo         ├─▶ │                 │</span><br><span class="line">                             │X-B3-TraceId: aa │     ────┐</span><br><span class="line">       │                 │   │X-B3-SpanId: 6b  │   │     │           │</span><br><span class="line">                             └─────────────────┘         │ invoke</span><br><span class="line">       │                 │                         │     │ request   │</span><br><span class="line">                                                         │</span><br><span class="line">       │                 │                         │     │           │</span><br><span class="line">                                 ┌────────┐          ◀───┘</span><br><span class="line">       │                 │ ◀─────┤200 OK  ├─────── │                 │</span><br><span class="line">                           ────┐ └────────┘</span><br><span class="line">       │                 │     │ record duration   │                 │</span><br><span class="line">            ┌────────┐     ◀───┘</span><br><span class="line">       │ ◀──┤200 OK  ├── │                         │                 │</span><br><span class="line">            └────────┘       ┌────────────────────────────────┐</span><br><span class="line">       │                 │ ──┤ asynchronously report span     ├────▶ │</span><br><span class="line">                             │                                │</span><br><span class="line">                             │&#123;                               │</span><br><span class="line">                             │  &quot;traceId&quot;: &quot;aa&quot;,              │</span><br><span class="line">                             │  &quot;id&quot;: &quot;6b&quot;,                   │</span><br><span class="line">                             │  &quot;name&quot;: &quot;get&quot;,                │</span><br><span class="line">                             │  &quot;timestamp&quot;: 1483945573944000,│</span><br><span class="line">                             │  &quot;duration&quot;: 386000,           │</span><br><span class="line">                             │  &quot;annotations&quot;: [              │</span><br><span class="line">                             │--snip--                        │</span><br><span class="line">                             └────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>Instrumented client 和 server 是分别使用了 ZipKin Client 的服务，Zipkin Client 会根据配置将追踪数据发送到 Zipkin Server 中进行数据存储、分析和展示。</p>
<h2 id="四、Zipkin-客户端"><a href="#四、Zipkin-客户端" class="headerlink" title="四、Zipkin 客户端"></a>四、Zipkin 客户端</h2><p><a target="_blank" rel="noopener" href="https://github.com/openzipkin/brave">Brave</a> 是 Java 版的 zipkin 客户端。</p>
<p>一般不会手动编写 Trace 相关的代码，Brave 提供可一些开箱即用的库，帮助我们追踪一些特定的请求。比如：dubbo、grpc、servlet、mysql、httpClient、kafka、springMVC 等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zipkin.io/">Zipkin 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/openzipkin/zipkin">Zipkin Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/openzipkin/brave">brave</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/31/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/31/">31</a><span class="page-number current">32</span><a class="page-number" href="/blog/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/33/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"0e895f603c687335c079d4795a6ef624"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
