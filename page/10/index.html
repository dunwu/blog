<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/10/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/10/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/57b73dc7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/57b73dc7/" class="post-title-link" itemprop="url">Spring MVC 之过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-14 17:44:09" itemprop="dateCreated datePublished" datetime="2023-02-14T17:44:09+08:00">2023-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/SpringWeb/" itemprop="url" rel="index"><span itemprop="name">SpringWeb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-MVC-之过滤器"><a href="#Spring-MVC-之过滤器" class="headerlink" title="Spring MVC 之过滤器"></a>Spring MVC 之过滤器</h1><p><code>spring-web</code> 模块提供了一些有用的 Filter：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-http-put">Form Data</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-forwarded-headers">Forwarded Headers</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-shallow-etag">Shallow ETag</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-cors">CORS</a></li>
</ul>
<h2 id="表单内容过滤器"><a href="#表单内容过滤器" class="headerlink" title="表单内容过滤器"></a>表单内容过滤器</h2><p>浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据，但非浏览器客户端也可以使用 HTTP PUT、PATCH 和 DELETE。 Servlet API 需要 <code>ServletRequest.getParameter*()</code> 系列方法来支持仅对 HTTP POST 的表单字段访问。</p>
<p><code>spring-web</code> 模块提供了 <code>FormContentFilter</code> 来拦截内容类型为 <code>applicationx-www-form-urlencoded</code> 的 HTTP PUT、PATCH、DELETE 请求，从请求体中读取表单数据，并包装 <code>ServletRequest</code> 通过 <code>ServletRequest.getParameter()</code> 系列方法使表单数据可用。</p>
<h2 id="转发过滤器"><a href="#转发过滤器" class="headerlink" title="转发过滤器"></a>转发过滤器</h2><p>当请求通过代理（如负载均衡器）时，主机、端口和方案可能会发生变化，这使得从客户端角度创建指向正确主机、端口和方案的链接成为一项挑战。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> 定义了 <code>Forwarded</code> HTTP 头，代理可以使用它来提供有关原始请求的信息。还有其他非标准头，包括 <code>X-Forwarded-Host</code>、<code>X-Forwarded-Port</code>、<code>X-Forwarded-Proto</code>、<code>X-Forwarded-Ssl</code> 和 <code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderFilter</code> 是一个 Servlet 过滤器，它修改请求以便 a) 根据 <code>Forwarded</code> 头更改主机、端口和 scheme；b) 删除这些头以消除进一步的影响。该过滤器依赖于包装请求，因此它必须排在其他过滤器之前，例如 <code>RequestContextFilter</code>，它应该与修改后的请求一起使用，而不是原始请求。</p>
<p><code>Forwarded</code> 头有安全考量，因为应用程序无法知道头是由代理按预期添加的，还是由恶意客户端添加的。这就是为什么应将信任边界处的代理配置为删除来自外部的不受信任的 <code>Forwarded</code> 头。还可以使用 <code>removeOnly=true</code> 配置 <code>ForwardedHeaderFilter</code>，在这种情况下它会删除但不使用头。</p>
<p>为了支持<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">异步请求</a>和错误分派，此过滤器应使用 <code>DispatcherType.ASYNC</code> 和 <code>DispatcherType.ERROR</code> 进行映射。如果使用 Spring Framework 的 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>（参见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-container-config">Servlet Config</a>），所有过滤器都会自动为所有调度类型注册。但是，如果通过 <code>web.xml</code> 或在 Spring Boot 中通过 <code>FilterRegistrationBean</code> 注册过滤器，请确保除了 <code>DispatcherType.REQUEST</code> 之外还包括 <code>DispatcherType.ASYNC</code> 和 <code>DispatcherType.ERROR</code>。</p>
<h2 id="ETag-过滤器"><a href="#ETag-过滤器" class="headerlink" title="ETag 过滤器"></a>ETag 过滤器</h2><p><code>ShallowEtagHeaderFilter</code> 过滤器通过缓存写入响应的内容并从中计算 MD5 哈希来创建“浅”ETag。下次客户端发送时，它会做同样的事情，但它还会将计算值与 <code>If-None-Match</code> 请求标头进行比较，如果两者相等，则返回 304 (NOT_MODIFIED)。</p>
<p>此策略节省网络带宽但不节省 CPU，因为必须为每个请求计算完整响应。前面描述的控制器级别的其他策略可以避免计算。</p>
<p>此过滤器有一个 <code>writeWeakETag</code> 参数，该参数将过滤器配置为写入类似于以下内容的弱 ETag：<code>W&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code>（如 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232 Section 2.3</a> 中所定义）。</p>
<p>为了支持<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">异步请求</a>，这个过滤器必须用 <code>DispatcherType.ASYNC</code> 映射，这样过滤器才能延迟并成功生成一个 ETag 到最后最后一次异步调度。如果使用 Spring Framework 的 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>，所有过滤器都会自动为所有调度类型注册。但是，如果通过 <code>web.xml</code> 或在 Spring Boot 中通过 <code>FilterRegistrationBean</code> 注册过滤器，请确保包含 <code>DispatcherType.ASYNC</code>。</p>
<h2 id="跨域过滤器"><a href="#跨域过滤器" class="headerlink" title="跨域过滤器"></a>跨域过滤器</h2><p>Spring MVC 通过控制器上的注解为 CORS 配置提供细粒度支持。但是，当与 Spring Security 一起使用时，建议依赖内置的 <code>CorsFilter</code>，它必须在 Spring Security 的过滤器链之前订阅。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html">Spring Framework 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html">Spring Framework 官方文档之 Web</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1782720c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1782720c/" class="post-title-link" itemprop="url">Spring MVC 之 DispatcherServlet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-13 09:57:52" itemprop="dateCreated datePublished" datetime="2023-02-13T09:57:52+08:00">2023-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/SpringWeb/" itemprop="url" rel="index"><span itemprop="name">SpringWeb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-MVC-之-DispatcherServlet"><a href="#Spring-MVC-之-DispatcherServlet" class="headerlink" title="Spring MVC 之 DispatcherServlet"></a>Spring MVC 之 DispatcherServlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>DispatcherServlet</code> 是 Spring MVC 框架的核心组件，负责将<strong>客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果</strong>。</p>
<h3 id="DispatcherServlet-工作原理"><a href="#DispatcherServlet-工作原理" class="headerlink" title="DispatcherServlet 工作原理"></a>DispatcherServlet 工作原理</h3><h4 id="DispatcherServlet-工作流程"><a href="#DispatcherServlet-工作流程" class="headerlink" title="DispatcherServlet 工作流程"></a>DispatcherServlet 工作流程</h4><p><code>DispatcherServlet</code> 的工作流程大致如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png" alt="img"></p>
<ol>
<li><strong>接收 Http 请求</strong>：当客户端发送 HTTP 请求时，<code>DispatcherServlet</code> 接收该请求并将其传递给 Spring MVC 框架。</li>
<li>**选择 <code>Handler</code>**：<code>DispatcherServlet</code> 会根据请求的 URL 找到对应的处理器映射器 <code>HandlerMapping</code>，该映射器会根据配置文件中的 URL 映射规则找到合适的处理器 <code>Handler</code>。<ul>
<li><strong>绑定属性</strong>：<code>DispatcherServlet</code> 会根据程序的 web 初始化策略关联各种 <code>Resolver</code>，如：<code>LocaleResolver</code>、<code>ThemeResolver</code> 等。</li>
<li><code>DispatcherServlet</code> 根据 <code>&lt;servlet-name&gt;-servlet.xml</code> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 <code>Handler</code> 对象以及 <code>Handler</code> 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。<ul>
<li>将请求映射到处理程序以及用于预处理和后处理的拦截器列表。映射基于一些标准，其细节因 <code>HandlerMapping</code> 实现而异。</li>
<li>两个主要的 <code>HandlerMapping</code> 实现是 <code>RequestMappingHandlerMapping</code>（支持 <code>@RequestMapping</code> 注释方法）和 <code>SimpleUrlHandlerMapping</code>（维护 URI 路径模式到处理程序的显式注册）。</li>
</ul>
</li>
</ul>
</li>
<li>**选择 <code>HandlerAdapter</code>**： <code>DispatcherServlet</code> 根据获得的 <code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。<ul>
<li><code>HandlerAdapter</code> 帮助 <code>DispatcherServlet</code> 调用映射到请求的 <code>Handler</code>，而不管实际调用 <code>Handler</code> 的方式如何。例如，调用带注解的控制器需要解析注解。<code>HandlerAdapter</code> 的主要目的是保护 <code>DispatcherServlet</code> 免受此类细节的影响。</li>
</ul>
</li>
<li><strong><code>Handler</code> 处理请求</strong>：<code>DispatcherServlet</code> 提取 <code>Request</code> 中的模型数据，填充 <code>Handler</code> 入参，由 <code>HandlerAdapter</code> 负责调用 <code>Handler</code>（<code>Controller</code>)。 在填充 <code>Handler</code> 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul>
<li><code>HttpMessageConverter</code>： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如 <code>String</code> 转换成 <code>Integer</code>、<code>Double </code>等。</li>
<li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 <code>BindingResult</code> 或 <code>Error</code> 中。</li>
</ul>
</li>
<li><strong>返回 <code>ModelAndView</code> 对象</strong>：<code>Handler</code> 处理完请求后，会返回一个 <code>ModelAndView</code> 对象，其中包含了处理结果（<code>Model</code>）和视图（<code>View</code>）信息。</li>
<li>**选择 <code>ViewResolver</code> 渲染 <code>ModelAndView</code>**：根据返回的 <code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>，并将 <code>ModelAndView</code> 传递给 <code>ViewResolver</code> 进行渲染，最后将渲染后的结果返回给客户端。</li>
</ol>
<h4 id="DispatcherServlet-源码解读"><a href="#DispatcherServlet-源码解读" class="headerlink" title="DispatcherServlet 源码解读"></a>DispatcherServlet 源码解读</h4><p>前面介绍了 <code>DispatcherServlet</code> 的工作流程，下面通过核心源码解读，来加深对 <code>DispatcherServlet</code> 工作原理的理解</p>
<p>（1）<code>onRefresh</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">	initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化此 servlet 使用的策略对象</span></span><br><span class="line"><span class="comment"> * 可以在子类中重写以初始化更多策略对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">	initMultipartResolver(context);</span><br><span class="line">	initLocaleResolver(context);</span><br><span class="line">	initThemeResolver(context);</span><br><span class="line">	initHandlerMappings(context);</span><br><span class="line">	initHandlerAdapters(context);</span><br><span class="line">	initHandlerExceptionResolvers(context);</span><br><span class="line">	initRequestToViewNameTranslator(context);</span><br><span class="line">	initViewResolvers(context);</span><br><span class="line">	initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<code>doService</code> 方法</p>
<p><code>DispatcherServlet</code> 的核心方法 <code>doService</code> 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	logRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在包含的情况下保留请求属性的快照，以便能够在包含后恢复原始属性</span></span><br><span class="line">	Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">		attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">		<span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">				attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置请求属性（绑定各种 Resolver），使框架对象可用于处理程序和视图对象</span></span><br><span class="line">	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">		<span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">			request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">		request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">RequestPath</span> <span class="variable">previousRequestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">		previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">		ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 请求分发</span></span><br><span class="line">		doDispatch(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// 恢复原始属性快照，以防包含</span></span><br><span class="line">			<span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">				restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;</span><br><span class="line">			ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<code>doDispatch</code> 方法</p>
<p><code>doService</code> 中的核心方法是 <code>doDispatch</code>，负责分发请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 检查是否为multipart请求，如果是，则解析参数</span></span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 确定适配当前请求的 Handler</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 确定适配当前请求的 HandlerAdapter</span></span><br><span class="line">         <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果 Handler 支持，则处理 last-modified 头</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 请求的前置处理</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 调用实际的 Handler 处理请求并返回 ModelAndView（有可能为 null）</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">         <span class="comment">// 请求的后置处理</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 处理响应结果</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="comment">// 替代 postHandle 和 afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 清理 multipart 请求所使用的资源</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下文层次结构"><a href="#上下文层次结构" class="headerlink" title="上下文层次结构"></a>上下文层次结构</h4><p><code>DispatcherServlet</code> 需要一个 <code>WebApplicationContext</code>（<code>ApplicationContext</code> 的扩展类）用于它自己的配置。<code>WebApplicationContext</code> 有一个指向 <code>ServletContext</code> 和与之关联的 <code>Servlet</code> 的链接。它还绑定到 <code>ServletContext</code>，以便应用程序可以在 <code>RequestContextUtils</code> 上使用静态方法来查找 <code>WebApplicationContext</code>。</p>
<p>对于多数应用程序来说，拥有一个 <code>WebApplicationContext</code> 单例就足够。也可以有一个上下文层次结构，其中有一个根 <code>WebApplicationContext</code> 在多个 <code>DispatcherServlet</code>（或其他 <code>Servlet</code>）实例之间共享，每个实例都有自己的子 <code>WebApplicationContext</code> 配置。</p>
<p>根 <code>WebApplicationContext</code> 通常包含基础结构 bean，例如需要跨多个 Servlet 实例共享的数据存储和业务服务。这些 bean 是有效继承的，并且可以在特定 <code>Servlet</code> 的子 <code>WebApplicationContext</code> 中被覆盖（即重新声明），它通常包含指定 <code>Servlet</code> 的本地 bean。下图显示了这种关系：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230213103223.png"></p>
<p>【示例】配置 <code>WebApplicationContext</code> 层次结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/app1/*&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】<code>web.xml</code> 方式配置 <code>WebApplicationContext</code> 层次结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>DispatcherServlet</code> 与其他 Servlet 一样，需要使用 Java 配置或在 <code>web.xml</code> 中根据 Servlet 规范进行声明和映射。也就是说，<code>DispatcherServlet</code> 使用 Spring 配置来发现请求映射、视图解析、异常处理等所需的委托组件。</p>
<p>可以通过将 Servlet 初始化参数（<code>init-param</code> 元素）添加到 <code>web.xml</code> 文件中的 Servlet 声明来自定义各个 <code>DispatcherServlet</code> 实例。下表列出了支持的参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>contextClass</code></td>
<td align="left">实现 <code>ConfigurableWebApplicationContext</code> 的类，将由此 Servlet 实例化和本地配置。默认情况下，使用 <code>XmlWebApplicationContext</code>。</td>
</tr>
<tr>
<td align="left"><code>contextConfigLocation</code></td>
<td align="left">传递给上下文实例（由 <code>contextClass</code> 指定）以指示可以在何处找到上下文的字符串。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。在具有两次定义的 bean 的多个上下文位置的情况下，最新的位置优先。</td>
</tr>
<tr>
<td align="left"><code>namespace</code></td>
<td align="left"><code>WebApplicationContext</code> 的命名空间。默认为 <code>[servlet-name]-servlet</code>。</td>
</tr>
<tr>
<td align="left"><code>throwExceptionIfNoHandlerFound</code></td>
<td align="left">当找不到请求的处理程序时是否抛出 <code>NoHandlerFoundException</code>。然后可以使用 <code>HandlerExceptionResolver</code>（例如，通过使用 <code>@ExceptionHandler</code> 控制器方法）捕获异常并像其他任何方法一样处理。默认情况下，它设置为 <code>false</code>，在这种情况下，<code>DispatcherServlet</code> 设置响应状态为 404 (NOT_FOUND) 而不会引发异常。请注意，如果 [默认 servlet 处理](<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc">https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc</a> -default-servlet-handler) 也被配置，未解决的请求总是转发到默认的 servlet 并且永远不会引发 404。</td>
</tr>
</tbody></table>
<p>应用程序可以声明处理请求所需的特殊 Bean 类型中列出的基础结构 bean。<code>DispatcherServlet</code> 检查每个特殊 bean 的 <code>WebApplicationContext</code>。如果没有匹配的 bean 类型，它将回退到 <code>DispatcherServlet.properties</code> 中列出的默认类型。</p>
<p>在大多数情况下，MVC 配置是最好的起点。它以 Java 或 XML 声明所需的 bean，并提供更高级别的配置回调 API 来对其进行自定义。</p>
<blockquote>
<p>注意：Spring Boot 依赖于 MVC Java 配置来配置 Spring MVC，并提供了许多额外的方便选项。</p>
</blockquote>
<p>在 Servlet 环境中，您可以选择以编程方式配置 Servlet 容器作为替代方案或与 web.xml 文件结合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebApplicationInitializer</code> 是 Spring MVC 提供的接口，可确保检测到自定义的实现并自动用于初始化任何 Servlet 3 容器。名为 <code>AbstractDispatcherServletInitializer</code> 的 <code>WebApplicationInitializer</code> 的抽象基类实现通过覆盖方法来指定 servlet 映射和 <code>DispatcherServlet</code> 配置的位置，使得注册 <code>DispatcherServlet</code> 变得更加容易。</p>
<p>对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用基于 XML 的 Spring 配置，则应直接从 AbstractDispatcherServletInitializer 扩展，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">cxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractDispatcherServletInitializer</code> 还提供了一种方便的方法来添加 Filter 实例并将它们自动映射到 <code>DispatcherServlet</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>(), <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个过滤器都根据其具体类型添加一个默认名称，并自动映射到 <code>DispatcherServlet</code>。</p>
<p><code>AbstractDispatcherServletInitializer</code> 的 <code>isAsyncSupported</code> 保护方法提供了一个单独的位置来启用 <code>DispatcherServlet</code> 和映射到它的所有过滤器的异步支持。默认情况下，此标志设置为 true。</p>
<p>最后，如果需要进一步自定义 <code>DispatcherServlet</code> 本身，可以重写 <code>createDispatcherServlet</code> 方法。</p>
<p>【示例】Java 方式注册并初始化 <code>DispatcherServlet</code>，它由 Servlet 容器自动检测（请参阅 Servlet Config）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load Spring web application configuration</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and register the DispatcherServlet</span></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context);</span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;app&quot;</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/app/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】web.xml 方式注册并初始化 <code>DispatcherServlet</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>Servlet API 将完整的请求路径公开为 <code>requestURI</code>，并将其进一步细分为 <code>contextPath</code>、<code>servletPath</code> 和 <code>pathInfo</code>，它们的值因 Servlet 的映射方式而异。从这些输入中，Spring MVC 需要确定用于映射处理程序的查找路径，如果适用，它应该排除 <code>contextPath</code> 和任何 <code>servletMapping</code> 前缀。</p>
<p><code>servletPath</code> 和 <code>pathInfo</code> 已解码，这使得它们无法直接与完整的 <code>requestURI</code> 进行比较以派生 <code>lookupPath</code>，因此有必要对 <code>requestURI</code> 进行解码。然而，这引入了它自己的问题，因为路径可能包含编码的保留字符，例如 <code>&quot;/&quot;</code> 或 <code>&quot;;&quot;</code> 这反过来又会在解码后改变路径的结构，这也可能导致安全问题。此外，Servlet 容器可能会在不同程度上规范化 <code>servletPath</code>，这使得进一步无法对 <code>requestURI</code> 执行 <code>startsWith</code> 比较。</p>
<p>这就是为什么最好避免依赖基于前缀的 <code>servletPath</code> 映射类型附带的 <code>servletPath</code>。如果 <code>DispatcherServlet</code> 被映射为带有 <code>&quot;/&quot;</code> 的默认 Servlet，或者没有带 <code>&quot;/*&quot;</code> 的前缀，并且 Servlet 容器是 4.0+，则 Spring MVC 能够检测 Servlet 映射类型，并避免使用 <code>servletPath</code> 和 <code>pathInfo</code>。在 3.1 Servlet 容器上，假设相同的 Servlet 映射类型，可以通过在 MVC 配置中通过路径匹配提供一个带有 <code>alwaysUseFullPath=true</code> 的 <code>UrlPathHelper</code> 来实现等效。</p>
<p>幸运的是，默认的 Servlet 映射 <code>&quot;/&quot;</code> 是一个不错的选择。但是，仍然存在一个问题，即需要对 <code>requestURI</code> 进行解码才能与控制器映射进行比较。这也是不可取的，因为可能会解码改变路径结构的保留字。如果不需要这样的字符，那么您可以拒绝它们（如 Spring Security HTTP 防火墙），或者您可以使用 <code>urlDecode=false</code> 配置 <code>UrlPathHelper</code>，但控制器映射需要与编码路径匹配，这可能并不总是有效。此外，有时 <code>DispatcherServlet</code> 需要与另一个 Servlet 共享 URL 空间，并且可能需要通过前缀进行映射。</p>
<p>在使用 <code>PathPatternParser</code> 和解析模式时解决了上述问题，作为使用 <code>AntPathMatcher</code> 进行字符串路径匹配的替代方法。<code>PathPatternParser</code> 从 5.3 版本开始就可以在 Spring MVC 中使用，并且从 6.0 版本开始默认启用。与需要解码查找路径或编码控制器映射的 <code>AntPathMatcher</code> 不同，解析的 <code>PathPattern</code> 与称为 <code>RequestPath</code> 的路径的解析表示匹配，一次一个路径段。这允许单独解码和清理路径段值，而没有改变路径结构的风险。解析的 <code>PathPattern</code> 也支持使用 <code>servletPath</code> 前缀映射，只要使用 Servlet 路径映射并且前缀保持简单，即它没有编码字符。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>所有 <code>HandlerMapping</code> 实现都支持处理拦截器，当想要将特定功能应用于某些请求时，这些拦截器很有用——例如，检查主体。拦截器必须使用 <code>org.springframework.web.servlet</code> 包中的三个方法实现 <code>HandlerInterceptor</code>，这三个方法应该提供足够的灵活性来进行各种预处理和后处理：</p>
<ul>
<li><code>preHandle(..)</code>：在实际 handler 之前执行</li>
<li><code>postHandle(..)</code>：handler 之后执行</li>
<li><code>afterCompletion(..)</code>：完成请求后执行</li>
</ul>
<p><code>preHandle(..)</code> 方法返回一个布尔值。可以使用此方法中断或继续执行链的处理。当此方法返回 true 时，处理程序执行链将继续。当它返回 false 时，<code>DispatcherServlet</code> 假定拦截器本身已经处理请求（并且，例如，呈现适当的视图）并且不会继续执行其他拦截器和执行链中的实际处理程序。</p>
<p>有关如何配置拦截器的示例，请参阅 MVC 配置部分中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-interceptors">拦截器</a>。还可以通过在各个 <code>HandlerMapping</code> 实现上使用 setter 来直接注册它们。</p>
<p><code>postHandle</code> 方法对于 <code>@ResponseBody</code> 和 <code>ResponseEntity</code> 的方法不太有用，它们的响应是在 <code>HandlerAdapter</code> 中和 <code>postHandle</code> 之前编写和提交的。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于此类场景，您可以实现 <code>ResponseBodyAdvice</code> 并将其声明为 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Controller Advice</a> bean 或直接在 <code>RequestMappingHandlerAdapter</code> 上进行配置。</p>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>DispatcherServlet 会加载多种解析器来处理请求，比较常见的有以下几个：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a> - 解决异常的策略，可能将它们映射到处理程序、HTML 错误视图或其他目标。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver"><code>ViewResolver</code></a> - 将从处理程序返回的基于字符串的逻辑视图名称解析为用于呈现响应的实际视图。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver"><code>LocaleResolver</code></a>, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone">LocaleContextResolver</a> - 解析用户正在使用的本地化设置，可能还有他们的时区，以便能够提供国际化的视图。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver"><code>ThemeResolver</code></a> - 解析 Web 应用程序可以使用的主题——例如，提供个性化布局。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart"><code>MultipartResolver</code></a> - 通过一些 multipart 解析库的帮助解析 multipart 请求（例如，通过浏览器上传文件）。</li>
</ul>
<h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><p>在 <code>WebApplicationContext</code> 中声明的 <code>HandlerExceptionResolver</code> 用于解决请求处理期间抛出的异常。这些异常解析器允许自定义逻辑来解决异常。</p>
<p>对于 HTTP 缓存支持，处理程序可以使用 <code>WebRequest</code> 的 <code>checkNotModified</code> 方法，以及用于控制器的 HTTP 缓存中所述的带注释控制器的更多选项。</p>
<p>如果在请求映射期间发生异常或从请求处理程序（例如 <code>@Controller</code>）抛出异常，则 <code>DispatcherServlet</code> 委托 <code>HandlerExceptionResolver</code> 链来解决异常并提供替代处理，这通常是错误响应。</p>
<p>下表列出了可用的 <code>HandlerExceptionResolver</code> 实现：</p>
<table>
<thead>
<tr>
<th align="left"><code>HandlerExceptionResolver</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SimpleMappingExceptionResolver</code></td>
<td align="left">异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></td>
<td align="left">解决由 Spring MVC 引发的异常并将它们映射到 HTTP 状态代码。</td>
</tr>
<tr>
<td align="left"><code>ResponseStatusExceptionResolver</code></td>
<td align="left">使用 <code>@ResponseStatus</code> 注解解决异常，并根据注解中的值将它们映射到 HTTP 状态代码。</td>
</tr>
<tr>
<td align="left"><code>ExceptionHandlerExceptionResolver</code></td>
<td align="left">通过在 <code>@Controller</code> 或 <code>@ControllerAdvice</code> 类中调用 <code>@ExceptionHandler</code> 方法来解决异常。</td>
</tr>
</tbody></table>
<h4 id="解析器链"><a href="#解析器链" class="headerlink" title="解析器链"></a>解析器链</h4><p>您可以通过在 Spring 配置中声明多个 <code>HandlerExceptionResolver</code> bean 并根据需要设置它们的顺序属性来构成异常解析器链。order 属性越高，异常解析器的位置就越靠后。</p>
<p><code>HandlerExceptionResolver</code> 的约定使它可以返回以下内容：</p>
<ul>
<li><p>指向错误视图的 <code>ModelAndView</code>。</p>
</li>
<li><p>如果异常是在解析器中处理的，则为空的 <code>ModelAndView</code>。</p>
</li>
<li><p>如果异常仍未解决，则为 null，供后续解析器尝试，如果异常仍然存在，则允许向上冒泡到 Servlet 容器。</p>
</li>
</ul>
<p>MVC Config 自动为默认的 Spring MVC 异常、<code>@ResponseStatus</code> 注释的异常和对 <code>@ExceptionHandler</code> 方法的支持声明内置解析器。您可以自定义该列表或替换它。</p>
<h4 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h4><p>如果异常仍未被任何 <code>HandlerExceptionResolver</code> 处理并因此继续传播，或者如果响应状态设置为错误状态（即 4xx、5xx），Servlet 容器可以在 HTML 中呈现默认错误页面。要自定义容器的默认错误页面，您可以在 <code>web.xml</code> 中声明一个错误页面映射。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，当出现异常或响应具有错误状态时，Servlet 容器会在容器内将 ERROR 分派到配置的 URL（例如，<code>/error</code>）。然后由 <code>DispatcherServlet</code> 处理，可能将其映射到 <code>@Controller</code>，后者可以返回带有模型的错误视图名称或呈现 JSON 响应，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, request.getAttribute(<span class="string">&quot;jakarta.servlet.error.status_code&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;reason&quot;</span>, request.getAttribute(<span class="string">&quot;jakarta.servlet.error.message&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：Servlet API 不提供在 Java 中创建错误页面映射的方法。但是，您可以同时使用 <code>WebApplicationInitializer</code> 和最小的 <code>web.xml</code>。</p>
</blockquote>
<h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><p>Spring MVC 定义了 <code>ViewResolver</code> 和 <code>View</code> 接口，让用户可以在浏览器中渲染模型，而无需限定于特定的视图技术。<code>ViewResolver</code> 提供视图名称和实际视图之间的映射。<code>View</code> 解决了在移交给特定视图技术之前准备数据的问题。</p>
<p>下表提供了有关 ViewResolver 一些子类：</p>
<table>
<thead>
<tr>
<th align="left">ViewResolver</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AbstractCachingViewResolver</code></td>
<td align="left"><code>AbstractCachingViewResolver</code> 的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。您可以通过将 <code>cache</code> 属性设置为 <code>false</code> 来关闭缓存。此外，如果您必须在运行时刷新某个视图（例如，修改 FreeMarker 模板时），您可以使用 removeFromCache(String viewName, Locale loc) 方法。</td>
</tr>
<tr>
<td align="left"><code>UrlBasedViewResolver</code></td>
<td align="left"><code>ViewResolver</code> 接口的简单实现，无需显式映射定义即可将逻辑视图名称直接解析为 URL。如果您的逻辑名称以直接的方式匹配您的视图资源的名称，而不需要任意映射，那么这是合适的。</td>
</tr>
<tr>
<td align="left"><code>InternalResourceViewResolver</code></td>
<td align="left"><code>UrlBasedViewResolver</code> 的子类，支持 <code>InternalResourceView</code>（实际上是 Servlet 和 JSP）以及 <code>JstlView</code> 和 <code>TilesView</code> 等子类。可以使用 <code>setViewClass(..)</code> 为该解析器生成的所有视图指定视图类。</td>
</tr>
<tr>
<td align="left"><code>FreeMarkerViewResolver</code></td>
<td align="left"><code>UrlBasedViewResolver</code> 的子类，支持 <code>FreeMarkerView</code> 和它们的自定义子类。</td>
</tr>
<tr>
<td align="left"><code>ContentNegotiatingViewResolver</code></td>
<td align="left"><code>ViewResolver</code> 接口的实现，该接口根据请求文件名或 <code>Accept</code> 标头解析视图。</td>
</tr>
<tr>
<td align="left"><code>BeanNameViewResolver</code></td>
<td align="left">将视图名称解释为当前应用程序上下文中的 bean 名称的 ViewResolver 接口的实现。这是一个非常灵活的变体，允许根据不同的视图名称混合和匹配不同的视图类型。每个这样的“视图”都可以定义为一个 bean，例如 在 XML 或配置类中。</td>
</tr>
</tbody></table>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p>可以通过声明多个解析器来构成视图解析器链，如果需要，还可以通过设置 order 属性来指定顺序。顺序属性越高，视图解析器在链中的位置就越靠后。</p>
<p><code>ViewResolver</code> 的约定指定它可以返回 null 以指示找不到视图。但是，对于 JSP 和 <code>InternalResourceViewResolver</code>，确定 JSP 是否存在的唯一方法是通过 <code>RequestDispatcher</code> 执行分派。因此，您必须始终将 <code>InternalResourceViewResolver</code> 配置为在视图解析器的整体顺序中排在最后。</p>
<p>配置视图解析就像将 <code>ViewResolver</code> 添加到 Spring 配置中一样简单。MVC Config 为视图解析器和添加无逻辑视图控制器提供了专用的配置 API，这对于没有控制器逻辑的 HTML 模板渲染很有用。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>视图名称中的特殊前缀 <code>redirect:</code> 可以实现一个重定向。<code>UrlBasedViewResolver</code>（及其子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向 URL。</p>
<p>最终效果与控制器返回 <code>RedirectView</code> 相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如 <code>redirect:/myapp/some/resource</code>）相对于当前 Servlet 上下文重定向，而名称（例如 <code>redirect:https://myhost.com/some/arbitrary/path</code>）重定向到绝对 URL。</p>
<p>请注意，如果使用 <code>@ResponseStatus</code> 注解标记控制器方法，则注解值优先于 <code>RedirectView</code> 设置的响应状态。</p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>视图名称中的特殊前缀 <code>forward:</code> 可以实现一个转发。这将创建一个 <code>InternalResourceView</code>，它执行 <code>RequestDispatcher.forward()</code>。因此，此前缀对 <code>InternalResourceViewResolver</code> 和 <code>InternalResourceView</code>（对于 JSP）没有用，但如果您使用另一种视图技术但仍想强制转发由 Servlet&#x2F;JSP 引擎处理的资源，它可能会有所帮助。</p>
<h4 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h4><p><code>ContentNegotiatingViewResolver</code> 本身不解析视图，而是委托给其他视图解析器并选择类似于客户端请求的表示的视图。可以从 <code>Accept</code> 头或查询参数（例如，<code>&quot;/path?format=pdf&quot;</code>）确定表示形式。</p>
<p><code>ContentNegotiatingViewResolver</code> 通过将请求媒体类型与其每个 <code>ViewResolver</code> 关联的 <code>View</code> 支持的媒体类型（也称为 <code>Content-Type</code>）进行比较，来选择合适的 <code>View</code> 来处理请求。列表中第一个具有兼容 <code>Content-Type</code> 的视图将处理结果返回给客户端。如果 <code>ViewResolver</code> 链无法提供兼容的视图，则会查阅通过 <code>DefaultViews</code> 属性指定的视图列表。后一个选项适用于单例视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。<code>Accept</code> 标头可以包含通配符（例如 <code>text/*</code>），在这种情况下，<code>Content-Type</code> 为 <code>text/xml</code> 的 View 是兼容的匹配项。</p>
<h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><p>大部分的 Spring 架构都支持国际化，就像 Spring web MVC 框架所做的那样。<code>DispatcherServlet</code> 允许您使用客户端的语言环境自动解析消息。这是通过 <code>LocaleResolver</code> 对象完成的。</p>
<p>当收到请求时，<code>DispatcherServlet</code> 会寻找语言环境解析器，如果找到，它会尝试使用它来设置 Locale 环境。通过使用 <code>RequestContext.getLocale()</code> 方法，您始终可以检索由 Locale 解析器解析的语言环境。</p>
<p>除了自动识别 Locale 环境之外，您还可以为 handle 映射附加拦截器，在特定情况下更改 Locale 环境设置（例如，基于请求中的参数）。</p>
<p>Locale 解析器和拦截器在 <code>org.springframework.web.servlet.i18n</code> 包中定义，并以正常方式在您的应用程序上下文中配置。Spring 中有以下 Locale 解析器可供选择。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone">Time Zone</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-acceptheader">Header Resolver</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-cookie">Cookie Resolver</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-session">Session Resolver</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-interceptor">Locale Interceptor</a></li>
</ul>
<h4 id="LocaleResolver-1"><a href="#LocaleResolver-1" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>除了获取客户端的区域设置外，了解其时区通常也很有用。<code>LocaleContextResolver</code> 接口提供了 <code>LocaleResolver</code> 的扩展，让解析器提供更丰富的 <code>LocaleContext</code>，其中可能包括时区信息。</p>
<p>如果可用，可以使用 <code>RequestContext.getTimeZone()</code> 方法获取用户的 <code>TimeZone</code>。在 Spring 的 <code>ConversionService</code> 中注册的任何日期&#x2F;时间 <code>Converter</code> 和 <code>Formatter</code> 对象会自动使用时区信息。</p>
<h4 id="标头解析器"><a href="#标头解析器" class="headerlink" title="标头解析器"></a>标头解析器</h4><p>此 Locale 解析器检查客户端（例如网络浏览器）发送的请求中的 <code>accept-language</code> 头。通常，此头字段包含客户端操作系统的区域信息。请注意，此解析器不支持时区信息。</p>
<h4 id="CookieLocaleResolver"><a href="#CookieLocaleResolver" class="headerlink" title="CookieLocaleResolver"></a>CookieLocaleResolver</h4><p>This locale resolver inspects a <code>Cookie</code> that might exist on the client to see if a <code>Locale</code> or <code>TimeZone</code> is specified. If so, it uses the specified details. By using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. The following example defines a <code>CookieLocaleResolver</code>:</p>
<p>此 Locale 解析器检查客户端上是否存在 <code>Cookie</code>，以查看是否指定了 <code>Locale</code> 或 <code>TimeZone</code>。如果是，它会使用指定的详细信息。通过使用此 Locale 解析器的属性，可以指定 cookie 的名称以及最长期限。以下示例定义了 <code>CookieLocaleResolver</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cookieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clientlanguage&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cookieMaxAge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下表描述了 <code>CookieLocaleResolver</code> 的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cookieName</code></td>
<td align="left">类名 + LOCALE</td>
<td align="left">cookie 名</td>
</tr>
<tr>
<td align="left"><code>cookieMaxAge</code></td>
<td align="left">Servlet container default</td>
<td align="left">cookie 在客户端上保留的最长时间。如果指定了“-1”，则不会保留 cookie。它仅在客户端关闭浏览器之前可用。</td>
</tr>
<tr>
<td align="left"><code>cookiePath</code></td>
<td align="left">&#x2F;</td>
<td align="left">将 cookie 的可见性限制在您网站的特定部分。当指定 <code>cookiePath</code> 时，cookie 仅对该路径及其下方的路径可见。</td>
</tr>
</tbody></table>
<h4 id="SessionLocaleResolver"><a href="#SessionLocaleResolver" class="headerlink" title="SessionLocaleResolver"></a>SessionLocaleResolver</h4><p><code>SessionLocaleResolver</code> 允许您从可能与用户请求相关联的会话中检索 <code>Locale</code> 和 <code>TimeZone</code>。与 <code>CookieLocaleResolver</code> 相比，此策略将本地选择的 locale 设置存储在 Servlet 容器的 <code>HttpSession</code> 中。因此，这些设置对于每个会话都是临时的，因此会在每个会话结束时丢失。</p>
<p>注意，这与外部会话管理机制（例如 Spring Session 项目）没有直接关系。此 <code>SessionLocaleResolver</code> 根据当前 <code>HttpServletRequest</code> 评估和修改相应的 <code>HttpSession</code> 属性。</p>
<h4 id="LocaleChangeInterceptor"><a href="#LocaleChangeInterceptor" class="headerlink" title="LocaleChangeInterceptor"></a>LocaleChangeInterceptor</h4><p>可以通过将 <code>LocaleChangeInterceptor</code> 添加到一个 <code>HandlerMapping</code> 定义来启用区域设置更改。它检测请求中的参数并相应地更改 Locale 环境，在调度程序的应用程序上下文中调用 <code>LocaleResolver</code> 上的 <code>setLocale</code> 方法。下面的示例显示调用所有包含名为 <code>siteLanguage</code> 的参数的 <code>*.view</code> 资源，以更改语言环境。因此，例如，对 URL <code>https://www.sf.net/home.view?siteLanguage=nl</code> 的请求将站点语言更改为荷兰语。以下示例显示了如何拦截语言环境：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeChangeInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;paramName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;siteLanguage&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;urlMapping&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;localeChangeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/**/*.view=someController<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><p>您可以应用 Spring Web MVC 框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。</p>
<p>要在 Web 应用程序中使用主题，必须设置 <code>org.springframework.ui.context.ThemeSource</code> 接口的实现。<code>WebApplicationContext</code> 接口扩展了 <code>ThemeSource</code> 但将其职责委托给了专门的实现。默认情况下，委托是 <code>org.springframework.ui.context.support.ResourceBundleThemeSource</code> ，它从类的根路径加载属性文件。要使用自定义的 <code>ThemeSource</code> 实现或配置 <code>ResourceBundleThemeSource</code> 的基本名称前缀，您可以在应用程序上下文中使用保留名称 <code>themeSource</code> 注册一个 bean。Web 应用程序上下文自动检测具有该名称的 bean 并使用它。</p>
<p>当使用 <code>ResourceBundleThemeSource</code> 时，主题是在一个简单的属性文件中定义的。属性文件列出了构成主题的资源，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">styleSheet</span>=<span class="string">/themes/cool/style.css</span></span><br><span class="line"><span class="attr">background</span>=<span class="string">/themes/cool/img/coolBg.jpg</span></span><br></pre></td></tr></table></figure>

<p>属性的键是从视图代码中引用主题元素的名称。对于 JSP，通常使用 <code>spring:theme</code> 自定义标签来执行此操作，它与 <code>spring:message</code> 标签非常相似。以下 JSP 片段使用前面示例中定义的主题来自定义外观：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;spring:theme code=&#x27;styleSheet&#x27;/&gt;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background=&lt;spring:theme code=&#x27;background&#x27;/&gt;&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下， <code>ResourceBundleThemeSource</code> 使用空的基本名称前缀。因此，属性文件是从类路径的根加载的。因此，可以将 <code>cool.properties</code> 主题定义放在类路径根目录中（例如，在 <code>/WEB-INF/classes</code> 中）。<code>ResourceBundleThemeSource</code> 使用标准的 Java 资源包加载机制，允许主题完全国际化。例如，我们可以有一个 <code>/WEB-INF/classes/cool_nl.properties</code>，它引用一个带有荷兰语文本的特殊背景图像。</p>
<p>定义主题后，可以决定使用哪个要使用的主题。<code>DispatcherServlet</code> 查找名为 <code>themeResolver</code> 的 bean 以找出要使用的 <code>ThemeResolver</code> 实现。主题解析器的工作方式与 <code>LocaleResolver</code> 大致相同。它检测用于特定请求的主题，也可以更改请求的主题。下表描述了 Spring 提供的主题解析器：</p>
<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FixedThemeResolver</code></td>
<td align="left">选择一个固定的主题，使用 <code>defaultThemeName</code> 属性设置。</td>
</tr>
<tr>
<td align="left"><code>SessionThemeResolver</code></td>
<td align="left">主题在用户的 HTTP 会话中维护。 它只需要为每个会话设置一次，但不会在会话之间持续存在。</td>
</tr>
<tr>
<td align="left"><code>CookieThemeResolver</code></td>
<td align="left">所选主题存储在客户端的 cookie 中。</td>
</tr>
</tbody></table>
<p>Spring 还提供了一个 <code>ThemeChangeInterceptor</code>，它允许使用一个简单的请求参数在每个请求上更改主题。</p>
<h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><p><code>org.springframework.web.multipart</code> 包中的 <code>MultipartResolver</code> 是一种解析 multipart 请求（包括文件上传）的策略。 有一个基于容器的 <code>StandardServletMultipartResolver</code> 实现，用于 Servlet 多部分请求解析。 请注意，从具有新 Servlet 5.0+ 基线的 Spring Framework 6.0 开始，基于 Apache Commons FileUpload 的过时的 <code>CommonsMultipartResolver</code> 不再可用。</p>
<p>要启用 multipart 处理，需要在 <code>DispatcherServlet</code> Spring 配置中声明一个名为 <code>multipartResolver</code> 的 <code>MultipartResolver</code>。 <code>DispatcherServlet</code> 检测到它并将其应用于传入请求。 当接收到内容类型为 <code>multipart/form-data</code> 的 POST 时，解析器解析将当前 <code>HttpServletRequest</code> 包装为 <code>MultipartHttpServletRequest</code> 的内容，以提供对已解析文件的访问以及将部分作为请求参数公开。</p>
<p>Servlet 多部分解析需要通过 Servlet 容器配置启用。 为此：</p>
<ul>
<li><p>在 Java 中，在 Servlet 注册上设置一个 <code>MultipartConfigElement</code>。</p>
</li>
<li><p>在 <code>web.xml</code> 中，将 <code>&lt;multipart-config&gt;</code> 部分添加到 servlet 声明。</p>
</li>
</ul>
<p>以下示例显示如何在 Servlet 注册上设置 <code>MultipartConfigElement</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span></span><br><span class="line">        registration.setMultipartConfig(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(<span class="string">&quot;/tmp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 Servlet multipart 配置好，就可以添加一个名为 <code>multipartResolver</code> 的 <code>StandardServletMultipartResolver</code> 类型的 bean。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html">Spring Framework 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html">Spring Framework 官方文档之 Web</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e317d658/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e317d658/" class="post-title-link" itemprop="url">《极客时间教程 - 机器学习 40 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-09 21:08:48" itemprop="dateCreated datePublished" datetime="2023-02-09T21:08:48+08:00">2023-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">人工智能</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>964</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-机器学习-40-讲》笔记"><a href="#《极客时间教程-机器学习-40-讲》笔记" class="headerlink" title="《极客时间教程 - 机器学习 40 讲》笔记"></a>《极客时间教程 - 机器学习 40 讲》笔记</h1><h2 id="开篇词-打通修炼机器学习的任督二脉"><a href="#开篇词-打通修炼机器学习的任督二脉" class="headerlink" title="开篇词 | 打通修炼机器学习的任督二脉"></a>开篇词 | 打通修炼机器学习的任督二脉</h2><p>“机器学习”分为 3 个模块</p>
<ul>
<li><strong>机器学习概观</strong>：介绍机器学习中超脱于具体模型和方法之上的一些共性问题</li>
<li><strong>统计学习（频率学派）</strong>：利用不同的模型去拟合数据背后的规律；用拟合出的规律去推断和预测未知的结果</li>
<li><strong>符号学习（贝叶斯学派）</strong>：即概率图模型，它计算的是变量间的相关关系，每个遍历的先验分布和大量复杂的积分技巧。</li>
</ul>
<h2 id="01-丨频率视角下的机器学习"><a href="#01-丨频率视角下的机器学习" class="headerlink" title="01 丨频率视角下的机器学习"></a>01 丨频率视角下的机器学习</h2><p>频率学派认为概率是随机事件发生频率的极限值；</p>
<p>频率学派执行参数估计时，视参数为确定取值，视数据为随机变量；</p>
<p>频率学派主要使用最大似然估计法，让数据在给定参数下的似然概率最大化；</p>
<p>频率学派对应机器学习中的统计学习，以经验风险最小化作为模型选择的准则。</p>
<h2 id="02-贝叶斯视角下的机器学习"><a href="#02-贝叶斯视角下的机器学习" class="headerlink" title="02 | 贝叶斯视角下的机器学习"></a>02 | 贝叶斯视角下的机器学习</h2><p>贝叶斯学派认为概率是事件的可信程度或主体对事件的信任程度；</p>
<p>贝叶斯学派执行参数估计时，视参数为随机变量，视数据为确定取值；</p>
<p>贝叶斯学派主要使用最大后验概率法，让参数在先验信息和给定数据下的后验概率最大化；</p>
<p>贝叶斯学派对应机器学习中的概率图模型，可以在模型预测和选择中提供更加完整的信息。</p>
<h2 id="03-丨学什么与怎么学"><a href="#03-丨学什么与怎么学" class="headerlink" title="03 丨学什么与怎么学"></a>03 丨学什么与怎么学</h2><p>什么样的问题才能通过机器学习来解决呢？</p>
<p>首先，问题不能是完全随机的，需要具备一定的模式；</p>
<p>其次，问题本身不能通过纯计算的方法解决；</p>
<p>再次，有大量的数据可供使用。</p>
<p>机器学习的任务，就是使用数据计算出与目标函数最接近的假设，或者说拟合出最精确的模型 。</p>
<p>输入特征类型</p>
<ul>
<li>具体特征（concrete feature）</li>
<li>原始特征（raw feature）</li>
<li>抽象特征（abstract feature）</li>
</ul>
<p>机器学习方法类型</p>
<ul>
<li>分类算法（classification）</li>
<li>回归算法（regression）</li>
<li>标注算法（tagging）</li>
</ul>
<p>如果训练数据中的每组输入都有其对应的输出结果，这类学习任务就是<strong>监督学习（supervised learning）</strong>，对没有输出的数据进行学习则是<strong>无监督学习（unsupervised learning）</strong>。监督学习具有更好的预测精度，无监督学习则可以发现数据中隐含的结构特性，起到的也是分类的作用，只不过没有给每个类别赋予标签而已。无监督学习可以用于对数据进行聚类或者密度估计，也可以完成异常检测这类监督学习中的预处理操作。直观地看，监督学习适用于预测任务，无监督学习适用于描述任务。</p>
<h2 id="04-丨计算学习理论"><a href="#04-丨计算学习理论" class="headerlink" title="04 丨计算学习理论"></a>04 丨计算学习理论</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f40d72cf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f40d72cf/" class="post-title-link" itemprop="url">Spring Data 综合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-08 09:10:35" itemprop="dateCreated datePublished" datetime="2023-02-08T09:10:35+08:00">2023-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Data-综合"><a href="#Spring-Data-综合" class="headerlink" title="Spring Data 综合"></a>Spring Data 综合</h1><p>Spring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Repository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。<code>CrudRepository</code> 和 <code>ListCrudRepository</code> 接口为被管理的实体类提供复杂的 CRUD 功能。<code>ListCrudRepository</code> 提供等效方法，但它们返回 <code>List</code>，而 <code>CrudRepository</code> 方法返回 <code>Iterable</code>。</p>
<p><code>CrudRepository</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID primaryKey)</span>;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID primaryKey)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Data 项目也提供了一些特定持久化技术的抽象接口，如：JpaRepository 或 MongoRepository。这些接口扩展了 CrudRepository 并暴露了一些持久化技术的底层功能。</p>
</blockquote>
<p>除了 <code>CrudRepository</code> 之外，还有一个 <code>PagingAndSortingRepository</code> 接口，它添加了额外的方法来简化对实体的分页访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt;  &#123;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">  Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】要按页面大小 20 访问 User 的第二页，可以执行如下操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>除了查询方法之外，计数和删除时的查询也是可用的。</p>
<p>【示例】根据姓氏计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">countByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】根据姓氏删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">deleteByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line"></span><br><span class="line">  List&lt;User&gt; <span class="title function_">removeByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><p>使用 Spring Data 对数据库进行查询有以下四步：</p>
<ol>
<li><p>声明一个扩展 <code>Repository</code> 或其子接口的接口，并指定泛型类型（实体类和 ID 类型），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口中声明查询方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances.java-config">JavaConfig</a> 或 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances">XML 配置</a>为这些接口创建代理实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注入 <code>Repository</code> 实例并使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    <span class="built_in">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">&quot;Matthews&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="定义-Repository"><a href="#定义-Repository" class="headerlink" title="定义 Repository"></a>定义 Repository</h2><p>首先需要定义一个 Repository 接口，该接口必须扩展 Repository 并且指定泛型类型（实体类和 ID 类型）。如果想为该实体暴露 CRUD 方法，可以扩展 CrudRepository 接口。</p>
<h3 id="微调-Repository-定义"><a href="#微调-Repository-定义" class="headerlink" title="微调 Repository 定义"></a>微调 Repository 定义</h3><p>Spring Data 提供了很多种 Repository 以应对不同的需求场景。</p>
<p><code>CrudRepository</code> 提供了 CRUD 功能。</p>
<p><code>ListCrudRepository</code> 和 <code>CrudRepository</code> 类似，但对于那些返回多个实体的方法，它返回一个 <code>List</code> 而不是 <code>Iterable</code>，这样使用可能更方便。</p>
<p>如果使用响应式框架，可以使用 <code>ReactiveCrudRepository</code> 或 <code>RxJava3CrudRepository</code>。</p>
<p><code>CoroutineCrudRepository</code> 支持 Kotlin 的协程特性。</p>
<p><code>PagingAndSortingRepository</code> 提供了分页、排序功能。</p>
<p>如果不想扩展 Spring Data 接口，还可以使用 <code>@RepositoryDefinition</code> 注释您的 <code>Repository</code> 接口。 扩展一个 CRUD Repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 CRUD Repository 复制到自定义的 Repository 中。 这样做时，可以更改方法的返回类型。 如果可能，Spring Data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 <code>Iterable&lt;T&gt;</code>、<code>List&lt;T&gt;</code>、<code>Collection&lt;T&gt;</code> 或 <code>VAVR</code> 列表。</p>
<p>自定义基础 <code>Repository</code> 接口，必须用 <code>@NoRepositoryBean</code> 标记。 这可以防止 Spring Data 尝试直接创建它的实例并失败，因为它无法确定该 Repository 的实体，因为它仍然包含一个通用类型变量。</p>
<p>以下示例显示了如何有选择地暴露 CRUD 方法（在本例中为 findById 和 save）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">  &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">  User <span class="title function_">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个-Spring-数据模块"><a href="#使用多个-Spring-数据模块" class="headerlink" title="使用多个 Spring 数据模块"></a>使用多个 Spring 数据模块</h3><p>有时，程序中需要使用多个 Spring Data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 Repository 工厂时，Spring Data 进入严格的配置模式。</p>
<p>如果定义的 Repository 扩展了特定模块中的 Repository，则它是特定 Spring Data 模块的有效候选者。</p>
<p>如果实体类使用了特定模块的类型注解，则它是特定 Spring Data 模块的有效候选者。 Spring Data 模块接受第三方注解（例如 JPA 的 <code>@Entity</code>）或提供自己的注解（例如用于 Spring Data MongoDB 和 Spring Data Elasticsearch 的 <code>@Document</code>）。</p>
<p>以下示例显示了一个使用模块特定接口（在本例中为 JPA）的 Repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>MyRepository 和 UserRepository 扩展了 JpaRepository。它们是 Spring Data JPA 模块的有效候选者。</p>
<p>以下示例显示了一个使用通用接口的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>AmbiguousRepository 和 AmbiguousUserRepository 仅扩展了 Repository 和 CrudRepository。 虽然这在使用唯一的 Spring Data 模块时很好，但是存在多个模块时，无法区分这些 Repository 应该绑定到哪个特定的 Spring Data。</p>
<p>以下示例显示了一个使用带注解的实体类的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>PersonRepository 引用 Person，它使用 JPA @Entity 注解进行标记，因此这个 Repository 显然属于 Spring Data JPA。 UserRepository 引用 User，它使用 Spring Data MongoDB 的 @Document 注解进行标记。</p>
<p>以下错误示例显示了一个使用带有混合注解的实体类的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>此示例中的实体类同时使用了 JPA 和 Spring Data MongoDB 的注解。示例中定义了两个 Repository：JpaPersonRepository 和 MongoDBPersonRepository。 一个用于 JPA，另一个用于 MongoDB。 Spring Data 不再能够区分 Repository，这会导致未定义的行为。</p>
<p>区分 Repository 的最后一种方法是确定 Repository 扫描 package 的范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h2><p>Repository 代理有两种方法可以从方法名称派生特定于存储的查询：</p>
<ul>
<li>通过直接从方法名称派生查询。</li>
<li>通过使用手动定义的查询。</li>
</ul>
<p>可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。</p>
<h3 id="查询策略"><a href="#查询策略" class="headerlink" title="查询策略"></a>查询策略</h3><p>以下策略可用于Repository 基础结构来解析查询。 对于 Java 配置，您可以使用 EnableJpaRepositories 注释的 queryLookupStrategy 属性。 特定数据存储可能不支持某些策略。</p>
<ul>
<li><code>CREATE</code> 尝试从查询方法名称构造特定存储的查询。</li>
<li><code>USE_DECLARED_QUERY</code> 尝试查找已声明的查询，如果找不到则抛出异常。</li>
<li><code>CREATE_IF_NOT_FOUND</code> （默认）结合了 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>。</li>
</ul>
<h3 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h3><p>Spring Data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析查询方法名称分为主语和谓语。第一部分 (find…By, exists…By) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 <code>find</code>（或其他引入关键字）和 <code>By</code> 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 <code>Distinct</code> 在要创建的查询上设置不同的标志或 <code>Top</code>&#x2F;<code>First</code> 限制查询结果。</p>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.subject">Spring Data 支持的查询主语关键词</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.predicate">Spring Data 支持的查询谓语关键词</a></p>
</blockquote>
<h2 id="创建-Repository-实例"><a href="#创建-Repository-实例" class="headerlink" title="创建 Repository 实例"></a>创建 Repository 实例</h2><h2 id="自定义-Repository-实现"><a href="#自定义-Repository-实现" class="headerlink" title="自定义 Repository 实现"></a>自定义 Repository 实现</h2><h2 id="Spring-Data-扩展"><a href="#Spring-Data-扩展" class="headerlink" title="Spring Data 扩展"></a>Spring Data 扩展</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis">Redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/">Spring Data 官方示例</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6bb64355/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6bb64355/" class="post-title-link" itemprop="url">Spring 访问 Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 20:54:42" itemprop="dateCreated datePublished" datetime="2023-01-31T20:54:42+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-访问-Redis"><a href="#Spring-访问-Redis" class="headerlink" title="Spring 访问 Redis"></a>Spring 访问 Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。</p>
<p>在 Spring 中，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a> 项目对访问 <a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> 进行了 API 封装，提供了便捷的访问方式。 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot">spring-boot</a> 项目中的子模块 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis">spring-boot-starter-data-redis</a> 基于 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a> 项目，做了二次封装，大大简化了 Redis 的相关配置。</p>
<h2 id="Spring-Boot-快速入门"><a href="#Spring-Boot-快速入门" class="headerlink" title="Spring Boot 快速入门"></a>Spring Boot 快速入门</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 pom.xml 中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span> = <span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span> =<span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4142994984277644695L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义-CRUD-接口"><a href="#定义-CRUD-接口" class="headerlink" title="定义 CRUD 接口"></a>定义 CRUD 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">batchSetUsers</span><span class="params">(Map&lt;String, User&gt; users)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-CRUD-接口实现"><a href="#创建-CRUD-接口实现" class="headerlink" title="创建 CRUD 接口实现"></a>创建 CRUD 接口实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_KEY</span> <span class="operator">=</span> <span class="string">&quot;spring:tutorial:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSetUsers</span><span class="params">(Map&lt;String, User&gt; users)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(DEFAULT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());</span><br><span class="line">        <span class="keyword">return</span> BeanUtil.toBean(obj, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-Application"><a href="#创建-Application" class="headerlink" title="创建 Application"></a>创建 Application</h3><p>创建 Application，实例化一个 <code>RedisTemplate</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQuickstartApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        <span class="comment">// objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),</span></span><br><span class="line">        <span class="comment">//     ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisQuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = &#123; RedisQuickstartApplication.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQuickstartTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">        Map&lt;String, User&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(i, RandomUtil.randomChineseName(),</span><br><span class="line">                RandomUtil.randomInt(<span class="number">1</span>, <span class="number">100</span>),</span><br><span class="line">                RandomUtil.randomEnum(Location.class).name(),</span><br><span class="line">                RandomUtil.randomEmail());</span><br><span class="line">            map.put(String.valueOf(i), user);</span><br><span class="line">        &#125;</span><br><span class="line">        userService.batchSetUsers(map);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">        Assertions.assertThat(count).isEqualTo(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> RandomUtil.randomLong(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(id);</span><br><span class="line">            log.info(<span class="string">&quot;user-&#123;&#125;: &#123;&#125;&quot;</span>, id, user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h2><p>更多 Spring 访问 Redis 示例请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/redis">Redis 示例源码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis">Redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/">Spring Data 官方示例</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/be2542d9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/be2542d9/" class="post-title-link" itemprop="url">Spring EL 表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-12 20:26:46" itemprop="dateCreated datePublished" datetime="2023-01-12T20:26:46+08:00">2023-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>60</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-EL-表达式"><a href="#Spring-EL-表达式" class="headerlink" title="Spring EL 表达式"></a>Spring EL 表达式</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/bc233194/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/bc233194/" class="post-title-link" itemprop="url">Spring 应用上下文生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-23 09:58:09" itemprop="dateCreated datePublished" datetime="2022-12-23T09:58:09+08:00">2022-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-应用上下文生命周期"><a href="#Spring-应用上下文生命周期" class="headerlink" title="Spring 应用上下文生命周期"></a>Spring 应用上下文生命周期</h1><h2 id="Spring-应用上下文启动准备阶段"><a href="#Spring-应用上下文启动准备阶段" class="headerlink" title="Spring 应用上下文启动准备阶段"></a>Spring 应用上下文启动准备阶段</h2><p>AbstractApplicationContext#prepareRefresh() 方法</p>
<ul>
<li>启动时间 - startupDate</li>
<li>状态标识 - closed(false)、active(true)</li>
<li>初始化 PropertySources - initPropertySources()</li>
<li>检验 Environment 中必须属性</li>
<li>初始化事件监听器集合</li>
<li>初始化早期 Spring 事件集合</li>
</ul>
<h2 id="BeanFactory-创建阶段"><a href="#BeanFactory-创建阶段" class="headerlink" title="BeanFactory 创建阶段"></a>BeanFactory 创建阶段</h2><p>AbstractApplicationContext#obtainFreshBeanFactory() 方法</p>
<ul>
<li>刷新 Spring 应用上下文底层 BeanFactory - refreshBeanFactory()<ul>
<li>销毁或关闭 BeanFactory，如果已存在的话</li>
<li>创建 BeanFactory - createBeanFactory()</li>
<li>设置 BeanFactory Id</li>
<li>设置“是否允许 BeanDefinition 重复定义” - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>设置“是否允许循环引用（依赖）” - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>加载 BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory) 方法</li>
<li>关联新建 BeanFactory 到 Spring 应用上下文</li>
</ul>
</li>
<li>返回 Spring 应用上下文底层 BeanFactory - getBeanFactory()</li>
</ul>
<h2 id="BeanFactory-准备阶段"><a href="#BeanFactory-准备阶段" class="headerlink" title="BeanFactory 准备阶段"></a>BeanFactory 准备阶段</h2><p>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>关联 ClassLoader</li>
<li>设置 Bean 表达式处理器</li>
<li>添加 PropertyEditorRegistrar 实现 - ResourceEditorRegistrar</li>
<li>添加 Aware 回调接口 BeanPostProcessor 实现 - ApplicationContextAwareProcessor</li>
<li>忽略 Aware 回调接口作为依赖注入接口</li>
<li>注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext</li>
<li>注册 ApplicationListenerDetector 对象</li>
<li>注册 LoadTimeWeaverAwareProcessor 对象</li>
<li>注册单例对象 - Environment、Java System Properties 以及 OS 环境变量</li>
</ul>
<h2 id="BeanFactory-后置处理阶段"><a href="#BeanFactory-后置处理阶段" class="headerlink" title="BeanFactory 后置处理阶段"></a>BeanFactory 后置处理阶段</h2><ul>
<li>AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法<ul>
<li>由子类覆盖该方法</li>
</ul>
</li>
<li>AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory 方法<ul>
<li>调用 BeanFactoryPostProcessor 或 BeanDefinitionRegistry 后置处理方法</li>
<li>注册 LoadTimeWeaverAwareProcessor 对象</li>
</ul>
</li>
</ul>
<h2 id="BeanFactory-注册-BeanPostProcessor-阶段"><a href="#BeanFactory-注册-BeanPostProcessor-阶段" class="headerlink" title="BeanFactory 注册 BeanPostProcessor 阶段"></a>BeanFactory 注册 BeanPostProcessor 阶段</h2><p>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>注册 PriorityOrdered 类型的 BeanPostProcessor Beans</li>
<li>注册 Ordered 类型的 BeanPostProcessor Beans</li>
<li>注册普通 BeanPostProcessor Beans</li>
<li>注册 MergedBeanDefinitionPostProcessor Beans</li>
<li>注册 ApplicationListenerDetector 对象</li>
</ul>
<h2 id="初始化內建-Bean：MessageSource"><a href="#初始化內建-Bean：MessageSource" class="headerlink" title="初始化內建 Bean：MessageSource"></a>初始化內建 Bean：MessageSource</h2><p>AbstractApplicationContext#initMessageSource() 方法</p>
<h2 id="初始化內建-Bean：Spring-事件广播器"><a href="#初始化內建-Bean：Spring-事件广播器" class="headerlink" title="初始化內建 Bean：Spring 事件广播器"></a>初始化內建 Bean：Spring 事件广播器</h2><p>AbstractApplicationContext#initApplicationEventMulticaster() 方法</p>
<h2 id="Spring-应用上下文刷新阶段"><a href="#Spring-应用上下文刷新阶段" class="headerlink" title="Spring 应用上下文刷新阶段"></a>Spring 应用上下文刷新阶段</h2><p>AbstractApplicationContext#onRefresh() 方法</p>
<p>子类覆盖该方法</p>
<ul>
<li>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()</li>
<li>org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()</li>
<li>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh()</li>
<li>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh()</li>
<li>org.springframework.web.context.support.StaticWebApplicationContext#onRefresh()</li>
</ul>
<h2 id="Spring-事件监听器注册阶段"><a href="#Spring-事件监听器注册阶段" class="headerlink" title="Spring 事件监听器注册阶段"></a>Spring 事件监听器注册阶段</h2><p>AbstractApplicationContext#registerListeners() 方法</p>
<ul>
<li>添加当前应用上下文所关联的 ApplicationListener 对象（集合）</li>
<li>添加 BeanFactory 所注册 ApplicationListener Beans</li>
<li>广播早期 Spring 事件</li>
</ul>
<h2 id="BeanFactory-初始化完成阶段"><a href="#BeanFactory-初始化完成阶段" class="headerlink" title="BeanFactory 初始化完成阶段"></a>BeanFactory 初始化完成阶段</h2><p>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>BeanFactory 关联 ConversionService Bean，如果存在</li>
<li>添加 StringValueResolver 对象</li>
<li>依赖查找 LoadTimeWeaverAware Bean</li>
<li>BeanFactory 临时 ClassLoader 置为 null</li>
<li>BeanFactory 冻结配置</li>
<li>BeanFactory 初始化非延迟单例 Beans</li>
</ul>
<h2 id="Spring-应用上下刷新完成阶段"><a href="#Spring-应用上下刷新完成阶段" class="headerlink" title="Spring 应用上下刷新完成阶段"></a>Spring 应用上下刷新完成阶段</h2><p>AbstractApplicationContext#finishRefresh() 方法</p>
<ul>
<li>清除 ResourceLoader 缓存 - clearResourceCaches() @since 5.0</li>
<li>初始化 LifecycleProcessor 对象 - initLifecycleProcessor()</li>
<li>调用 LifecycleProcessor#onRefresh() 方法</li>
<li>发布 Spring 应用上下文已刷新事件 - ContextRefreshedEvent</li>
<li>向 MBeanServer 托管 Live Beans</li>
</ul>
<h2 id="Spring-应用上下文启动阶段"><a href="#Spring-应用上下文启动阶段" class="headerlink" title="Spring 应用上下文启动阶段"></a>Spring 应用上下文启动阶段</h2><p>AbstractApplicationContext#start() 方法</p>
<ul>
<li>启动 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>启动 Lifecycle Beans</li>
</ul>
</li>
<li>发布 Spring 应用上下文已启动事件 - ContextStartedEvent</li>
</ul>
<h2 id="Spring-应用上下文停止阶段"><a href="#Spring-应用上下文停止阶段" class="headerlink" title="Spring 应用上下文停止阶段"></a>Spring 应用上下文停止阶段</h2><p>AbstractApplicationContext#stop() 方法</p>
<ul>
<li>停止 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>停止 Lifecycle Beans</li>
</ul>
</li>
<li>发布 Spring 应用上下文已停止事件 - ContextStoppedEvent</li>
</ul>
<h2 id="Spring-应用上下文关闭阶段"><a href="#Spring-应用上下文关闭阶段" class="headerlink" title="Spring 应用上下文关闭阶段"></a>Spring 应用上下文关闭阶段</h2><p>AbstractApplicationContext#close() 方法</p>
<ul>
<li>状态标识：active(false)、closed(true)</li>
<li>Live Beans JMX 撤销托管<ul>
<li>LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)</li>
</ul>
</li>
<li>发布 Spring 应用上下文已关闭事件 - ContextClosedEvent</li>
<li>关闭 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>停止 Lifecycle Beans</li>
</ul>
</li>
<li>销毁 Spring Beans</li>
<li>关闭 BeanFactory</li>
<li>回调 onClose()</li>
<li>注册 Shutdown Hook 线程（如果曾注册）</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Spring 应用上下文生命周期有哪些阶段</strong>？</p>
<ul>
<li>刷新阶段 - ConfigurableApplicationContext#refresh()</li>
<li>启动阶段 - ConfigurableApplicationContext#start()</li>
<li>停止阶段 - ConfigurableApplicationContext#stop()</li>
<li>关闭阶段 - ConfigurableApplicationContext#close()</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/1e6fd6fc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/1e6fd6fc/" class="post-title-link" itemprop="url">Spring Environment 抽象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-23 09:27:44" itemprop="dateCreated datePublished" datetime="2022-12-23T09:27:44+08:00">2022-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Environment-抽象"><a href="#Spring-Environment-抽象" class="headerlink" title="Spring Environment 抽象"></a>Spring Environment 抽象</h1><h2 id="理解-Spring-Environment-抽象"><a href="#理解-Spring-Environment-抽象" class="headerlink" title="理解 Spring Environment 抽象"></a>理解 Spring Environment 抽象</h2><p>统一的 Spring 配置属性管理</p>
<p>Spring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）</p>
<p>条件化 Spring Bean 装配管理</p>
<p>通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean</p>
<h2 id="Spring-Environment-接口使用场景"><a href="#Spring-Environment-接口使用场景" class="headerlink" title="Spring Environment 接口使用场景"></a>Spring Environment 接口使用场景</h2><ul>
<li>⽤于属性占位符处理</li>
<li>用于转换 Spring 配置属性类型</li>
<li>用于存储 Spring 配置属性源（PropertySource）</li>
<li>用于 Profiles 状态的维护</li>
</ul>
<h2 id="Environment-占位符处理"><a href="#Environment-占位符处理" class="headerlink" title="Environment 占位符处理"></a>Environment 占位符处理</h2><p>Spring 3.1 前占位符处理</p>
<ul>
<li>组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</li>
<li>接口：org.springframework.util.StringValueResolver</li>
</ul>
<p>Spring 3.1 + 占位符处理</p>
<ul>
<li>组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer</li>
<li>接口：org.springframework.beans.factory.config.EmbeddedValueResolver</li>
</ul>
<h2 id="理解条件配置-Spring-Profiles"><a href="#理解条件配置-Spring-Profiles" class="headerlink" title="理解条件配置 Spring Profiles"></a>理解条件配置 Spring Profiles</h2><p>Spring 3.1 条件配置</p>
<ul>
<li>API：org.springframework.core.env.ConfigurableEnvironment</li>
<li>修改：addActiveProfile(String)、setActiveProfiles(String…) 和 setDefaultProfiles(String…)</li>
<li>获取：getActiveProfiles() 和 getDefaultProfiles()</li>
<li>匹配：#acceptsProfiles(String…) 和 acceptsProfiles(Profiles)</li>
<li>注解：@org.springframework.context.annotation.Profile</li>
</ul>
<h2 id="Spring-4-重构-Profile"><a href="#Spring-4-重构-Profile" class="headerlink" title="Spring 4 重构 @Profile"></a>Spring 4 重构 @Profile</h2><p>基于 Spring 4 org.springframework.context.annotation.Condition 接口实现</p>
<p>org.springframework.context.annotation.ProfileCondition</p>
<h2 id="依赖注入-Environment"><a href="#依赖注入-Environment" class="headerlink" title="依赖注入 Environment"></a>依赖注入 Environment</h2><p>直接依赖注入</p>
<ul>
<li>通过 EnvironmentAware 接口回调</li>
<li>通过 @Autowired 注入 Environment</li>
</ul>
<p>间接依赖注入</p>
<ul>
<li>通过 ApplicationContextAware 接口回调</li>
<li>通过 @Autowired 注入 ApplicationContext</li>
</ul>
<h2 id="依赖查找-Environment"><a href="#依赖查找-Environment" class="headerlink" title="依赖查找 Environment"></a>依赖查找 Environment</h2><p>直接依赖查找</p>
<ul>
<li>通过 org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME</li>
</ul>
<p>间接依赖查找</p>
<ul>
<li>通过 org.springframework.context.ConfigurableApplicationContext#getEnvironment</li>
</ul>
<h2 id="依赖注入-Value"><a href="#依赖注入-Value" class="headerlink" title="依赖注入 @Value"></a>依赖注入 @Value</h2><p>通过注入 @Value</p>
<p>实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</p>
<h2 id="Spring-类型转换在-Environment-中的运用"><a href="#Spring-类型转换在-Environment-中的运用" class="headerlink" title="Spring 类型转换在 Environment 中的运用"></a>Spring 类型转换在 Environment 中的运用</h2><p>Environment 底层实现</p>
<ul>
<li>底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver</li>
<li>核心方法 - convertValueIfNecessary(Object,Class)</li>
<li>底层服务 - org.springframework.core.convert.ConversionService</li>
<li>默认实现 - org.springframework.core.convert.support.DefaultConversionService</li>
</ul>
<h2 id="Spring-类型转换在-Value-中的运用"><a href="#Spring-类型转换在-Value-中的运用" class="headerlink" title="Spring 类型转换在 @Value 中的运用"></a>Spring 类型转换在 @Value 中的运用</h2><p>@Value 底层实现</p>
<ul>
<li>底层实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor<ul>
<li>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</li>
</ul>
</li>
<li>底层服务 - org.springframework.beans.TypeConverter<ul>
<li>默认实现 - org.springframework.beans.TypeConverterDelegate<ul>
<li>java.beans.PropertyEditor</li>
<li>org.springframework.core.convert.ConversionService</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Spring-配置属性源-PropertySource"><a href="#Spring-配置属性源-PropertySource" class="headerlink" title="Spring 配置属性源 PropertySource"></a>Spring 配置属性源 PropertySource</h2><ul>
<li>API<ul>
<li>单配置属性源 - org.springframework.core.env.PropertySource</li>
<li>多配置属性源 - org.springframework.core.env.PropertySources</li>
</ul>
</li>
<li>注解<ul>
<li>单配置属性源 - @org.springframework.context.annotation.PropertySource</li>
<li>多配置属性源 - @org.springframework.context.annotation.PropertySources</li>
</ul>
</li>
<li>关联<ul>
<li>存储对象 - org.springframework.core.env.MutablePropertySources</li>
<li>关联方法 - org.springframework.core.env.ConfigurableEnvironment#getPropertySources()</li>
</ul>
</li>
</ul>
<h2 id="Spring-內建的配置属性源"><a href="#Spring-內建的配置属性源" class="headerlink" title="Spring 內建的配置属性源"></a>Spring 內建的配置属性源</h2><p>內建 PropertySource</p>
<table>
<thead>
<tr>
<th>PropertySource 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>org.springframework.core.env.CommandLinePropertySource</td>
<td>命令行配置属性源</td>
</tr>
<tr>
<td>org.springframework.jndi.JndiPropertySource</td>
<td>JDNI 配置属性源</td>
</tr>
<tr>
<td>org.springframework.core.env.PropertiesPropertySource</td>
<td>Properties 配置属性源</td>
</tr>
<tr>
<td>org.springframework.web.context.support.ServletConfigPropertySource</td>
<td>Servlet 配置属性源</td>
</tr>
<tr>
<td>org.springframework.web.context.support.ServletContextPropertySource</td>
<td>ServletContext 配置属性源</td>
</tr>
<tr>
<td>org.springframework.core.env.SystemEnvironmentPropertySource</td>
<td>环境变量配置属性源</td>
</tr>
</tbody></table>
<h2 id="基于注解扩展-Spring-配置属性源"><a href="#基于注解扩展-Spring-配置属性源" class="headerlink" title="基于注解扩展 Spring 配置属性源"></a>基于注解扩展 Spring 配置属性源</h2><p>@org.springframework.context.annotation.PropertySource 实现原理</p>
<ul>
<li>入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass<ul>
<li>org.springframework.context.annotation.ConfigurationClassParser#processPropertySource</li>
</ul>
</li>
<li>4.3 新增语义<ul>
<li>配置属性字符编码 - encoding</li>
<li>org.springframework.core.io.support.PropertySourceFactory</li>
</ul>
</li>
<li>适配对象 - org.springframework.core.env.CompositePropertySource</li>
</ul>
<h2 id="基于-API-扩展-Spring-配置属性源"><a href="#基于-API-扩展-Spring-配置属性源" class="headerlink" title="基于 API 扩展 Spring 配置属性源"></a>基于 API 扩展 Spring 配置属性源</h2><ul>
<li>Spring 应用上下文启动前装配 PropertySource</li>
<li>Spring 应用上下文启动后装配 PropertySource</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>简单介绍 Spring Environment 接口？</p>
<ul>
<li>核心接口 - org.springframework.core.env.Environment</li>
<li>父接口 - org.springframework.core.env.PropertyResolver</li>
<li>可配置接口 - org.springframework.core.env.ConfigurableEnvironment</li>
<li>职责：<ul>
<li>管理 Spring 配置属性源</li>
<li>管理 Profiles</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/26e4a88e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/26e4a88e/" class="post-title-link" itemprop="url">Spring 注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-23 09:08:15" itemprop="dateCreated datePublished" datetime="2022-12-23T09:08:15+08:00">2022-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h1><h2 id="Spring-注解驱动编程发展历程"><a href="#Spring-注解驱动编程发展历程" class="headerlink" title="Spring 注解驱动编程发展历程"></a>Spring 注解驱动编程发展历程</h2><ul>
<li>注解驱动启蒙时代：Spring Framework 1.x</li>
<li>注解驱动过渡时代：Spring Framework 2.x</li>
<li>注解驱动黄金时代：Spring Framework 3.x</li>
<li>注解驱动完善时代：Spring Framework 4.x</li>
<li>注解驱动当下时代：Spring Framework 5.x</li>
</ul>
<h2 id="Spring-核心注解场景分类"><a href="#Spring-核心注解场景分类" class="headerlink" title="Spring 核心注解场景分类"></a>Spring 核心注解场景分类</h2><p>Spring 模式注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td>数据仓储模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Component</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web 控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody></table>
<p>装配注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@ImportResource</td>
<td>替换 XML 元素 <code>&lt;import&gt;</code></td>
<td>2.5</td>
</tr>
<tr>
<td>@Import</td>
<td>导入 Configuration 类</td>
<td>2.5</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>扫描指定 package 下标注 Spring 模式注解的类</td>
<td>3.1</td>
</tr>
</tbody></table>
<p>依赖注入注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>Bean 依赖注入，支持多种依赖查找方式</td>
<td>2.5</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>细粒度的 @Autowired 依赖查找</td>
<td>2.5</td>
</tr>
</tbody></table>
<h2 id="Spring-注解编程模型"><a href="#Spring-注解编程模型" class="headerlink" title="Spring 注解编程模型"></a>Spring 注解编程模型</h2><ul>
<li>元注解（Meta-Annotations）</li>
<li>Spring 模式注解（Stereotype Annotations）</li>
<li>Spring 组合注解（Composed Annotations）</li>
<li>Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）</li>
</ul>
<h2 id="Spring-元注解（Meta-Annotations）"><a href="#Spring-元注解（Meta-Annotations）" class="headerlink" title="Spring 元注解（Meta-Annotations）"></a>Spring 元注解（Meta-Annotations）</h2><ul>
<li>java.lang.annotation.Documented</li>
<li>java.lang.annotation.Inherited</li>
<li>java.lang.annotation.Repeatable</li>
</ul>
<h2 id="Spring-模式注解（Stereotype-Annotations）"><a href="#Spring-模式注解（Stereotype-Annotations）" class="headerlink" title="Spring 模式注解（Stereotype Annotations）"></a>Spring 模式注解（Stereotype Annotations）</h2><p>理解 @Component “派⽣性”：元标注 @Component 的注解在 XML 元素 <a href="context:component-scan">context:component-scan</a> 或注解 @ComponentScan 扫描中“派生”了 @Component 的特性，并且从 Spring Framework 4.0 开始支持多层次“派⽣性”。</p>
<p>举例说明：</p>
<ul>
<li>@Repository</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Configuration</li>
<li>@SpringBootConfiguration（Spring Boot）</li>
</ul>
<p>@Component “派⽣性”原理</p>
<ul>
<li>核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner</li>
<li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider</li>
<li>资源处理 - org.springframework.core.io.support.ResourcePatternResolver</li>
<li>资源-类元信息</li>
<li>org.springframework.core.type.classreading.MetadataReaderFactory</li>
<li>类元信息 - org.springframework.core.type.ClassMetadata</li>
<li>ASM 实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
<li>注解元信息 - org.springframework.core.type.AnnotationMetadata</li>
<li>ASM 实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
</ul>
<h2 id="Spring-组合注解（Composed-Annotations）"><a href="#Spring-组合注解（Composed-Annotations）" class="headerlink" title="Spring 组合注解（Composed Annotations）"></a>Spring 组合注解（Composed Annotations）</h2><p>Spring 组合注解（Composed Annotations）中的元注允许是 Spring 模式注解（Stereotype Annotation）与其他 Spring 功能性注解的任意组合。</p>
<h2 id="Spring-注解属性别名（Attribute-Aliases）"><a href="#Spring-注解属性别名（Attribute-Aliases）" class="headerlink" title="Spring 注解属性别名（Attribute Aliases）"></a>Spring 注解属性别名（Attribute Aliases）</h2><h2 id="Spring-注解属性覆盖（Attribute-Overrides）"><a href="#Spring-注解属性覆盖（Attribute-Overrides）" class="headerlink" title="Spring 注解属性覆盖（Attribute Overrides）"></a>Spring 注解属性覆盖（Attribute Overrides）</h2><h2 id="Spring-Enable-模块驱动"><a href="#Spring-Enable-模块驱动" class="headerlink" title="Spring @Enable 模块驱动"></a>Spring @Enable 模块驱动</h2><p>@Enable 模块驱动</p>
<p>@Enable 模块驱动是以 @Enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 Web MVC 模块、AspectJ 代理模块、Caching（缓存）模块、JMX（Java 管理扩展）模块、Async（异步处理）模块等。</p>
<p>举例说明</p>
<ul>
<li>@EnableWebMvc</li>
<li>@EnableTransactionManagement</li>
<li>@EnableCaching</li>
<li>@EnableMBeanExport</li>
<li>@EnableAsync</li>
</ul>
<p>@Enable 模块驱动编程模式</p>
<ul>
<li>驱动注解：@EnableXXX</li>
<li>导入注解：@Import 具体实现</li>
<li>具体实现</li>
<li>基于 Configuration Class</li>
<li>基于 ImportSelector 接口实现</li>
<li>基于 ImportBeanDefinitionRegistrar 接口实现</li>
</ul>
<h2 id="Spring-条件注解"><a href="#Spring-条件注解" class="headerlink" title="Spring 条件注解"></a>Spring 条件注解</h2><p>基于配置条件注解 - @org.springframework.context.annotation.Profile</p>
<ul>
<li>关联对象 - org.springframework.core.env.Environment 中的 Profiles</li>
<li>实现变化：从 Spring 4.0 开始，@Profile 基于 @Conditional 实现</li>
</ul>
<p>基于编程条件注解 - @org.springframework.context.annotation.Conditional</p>
<ul>
<li>关联对象 - org.springframework.context.annotation.Condition 具体实现</li>
</ul>
<p>@Conditional 实现原理</p>
<ul>
<li>上下文对象 - org.springframework.context.annotation.ConditionContext</li>
<li>条件判断 - org.springframework.context.annotation.ConditionEvaluator</li>
<li>配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase</li>
<li>判断入口<ul>
<li>org.springframework.context.annotation.ConfigurationClassPostProcessor</li>
<li>org.springframework.context.annotation.ConfigurationClassParser</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/41814824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/41814824/" class="post-title-link" itemprop="url">Spring 事件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-22 20:31:02" itemprop="dateCreated datePublished" datetime="2022-12-22T20:31:02+08:00">2022-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-事件"><a href="#Spring-事件" class="headerlink" title="Spring 事件"></a>Spring 事件</h1><h2 id="Java-事件-监听器编程模型"><a href="#Java-事件-监听器编程模型" class="headerlink" title="Java 事件&#x2F;监听器编程模型"></a>Java 事件&#x2F;监听器编程模型</h2><p>设计模式 - 观察者模式扩展</p>
<ul>
<li>可观者对象（消息发送者） - java.util.Observable</li>
<li>观察者 - java.util.Observer</li>
</ul>
<p>标准化接口</p>
<ul>
<li>事件对象 - java.util.EventObject</li>
<li>事件监听器 - java.util.EventListener</li>
</ul>
<h2 id="面向接口的事件-监听器设计模式"><a href="#面向接口的事件-监听器设计模式" class="headerlink" title="面向接口的事件&#x2F;监听器设计模式"></a>面向接口的事件&#x2F;监听器设计模式</h2><p>事件&#x2F;监听器场景举例</p>
<table>
<thead>
<tr>
<th>Java 技术规范</th>
<th>事件接口</th>
<th>监听器接口</th>
</tr>
</thead>
<tbody><tr>
<td>JavaBeans</td>
<td>java.beans.PropertyChangeEvent</td>
<td>java.beans.PropertyChangeListener</td>
</tr>
<tr>
<td>Java AWT</td>
<td>java.awt.event.MouseEvent</td>
<td>java.awt.event.MouseListener</td>
</tr>
<tr>
<td>Java Swing</td>
<td>javax.swing.event.MenuEvent</td>
<td>javax.swing.event.MenuListener</td>
</tr>
<tr>
<td>Java Preference</td>
<td>java.util.prefs.PreferenceChangeEvent</td>
<td>java.util.prefs.PreferenceChangeListener</td>
</tr>
</tbody></table>
<h2 id="面向注解的事件-监听器设计模式"><a href="#面向注解的事件-监听器设计模式" class="headerlink" title="面向注解的事件&#x2F;监听器设计模式"></a>面向注解的事件&#x2F;监听器设计模式</h2><p>事件&#x2F;监听器注解场景举例</p>
<table>
<thead>
<tr>
<th>Java 技术规范</th>
<th>事件注解</th>
<th>监听器注解</th>
</tr>
</thead>
<tbody><tr>
<td>Servlet 3.0+</td>
<td></td>
<td>@javax.servlet.annotation.WebListener</td>
</tr>
<tr>
<td>JPA 1.0+</td>
<td>@javax.persistence.PostPersist</td>
<td></td>
</tr>
<tr>
<td>Java Common</td>
<td>@PostConstruct</td>
<td></td>
</tr>
<tr>
<td>EJB 3.0+</td>
<td>@javax.ejb.PrePassivate</td>
<td></td>
</tr>
<tr>
<td>JSF 2.0+</td>
<td>@javax.faces.event.ListenerFor</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Spring-标准事件-ApplicationEvent"><a href="#Spring-标准事件-ApplicationEvent" class="headerlink" title="Spring 标准事件 - ApplicationEvent"></a>Spring 标准事件 - ApplicationEvent</h2><p>Java 标准事件 <code>java.util.EventObject</code> 扩展</p>
<ul>
<li>扩展特性：事件发生事件戳</li>
<li>Spring 应用上下文 ApplicationEvent 扩展 - <code>ApplicationContextEvent</code></li>
<li>Spring 应用上下文（ApplicationContext）作为事件源</li>
</ul>
<p>具体实现：</p>
<ul>
<li><code>org.springframework.context.event.ContextClosedEvent</code></li>
<li><code>org.springframework.context.event.ContextRefreshedEvent</code></li>
<li><code>org.springframework.context.event.ContextStartedEvent</code></li>
<li><code>org.springframework.context.event.ContextStoppedEvent</code></li>
</ul>
<h2 id="基于接口的-Spring-事件监听器"><a href="#基于接口的-Spring-事件监听器" class="headerlink" title="基于接口的 Spring 事件监听器"></a>基于接口的 Spring 事件监听器</h2><p>Java 标准事件监听器 <code>java.util.EventListener</code> 扩展</p>
<ul>
<li>扩展接口 - <code>org.springframework.context.ApplicationListener</code></li>
<li>设计特点：单一类型事件处理</li>
<li>处理方法：<code>onApplicationEvent(ApplicationEvent)</code></li>
<li>事件类型：<code>org.springframework.context.ApplicationEvent</code></li>
</ul>
<h2 id="基于注解的-Spring-事件监听器"><a href="#基于注解的-Spring-事件监听器" class="headerlink" title="基于注解的 Spring 事件监听器"></a>基于注解的 Spring 事件监听器</h2><p>Spring 注解 - <code>@org.springframework.context.event.EventListener</code></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>设计特点</td>
<td>支持多 <code>ApplicationEvent</code> 类型，无需接口约束</td>
</tr>
<tr>
<td>注解目标</td>
<td>方法</td>
</tr>
<tr>
<td>是否支持异步执行</td>
<td>支持</td>
</tr>
<tr>
<td>是否支持泛型类型事件</td>
<td>支持</td>
</tr>
<tr>
<td>是指支持顺序控制</td>
<td>支持，配合 <code>@Order</code> 注解控制</td>
</tr>
</tbody></table>
<h2 id="注册-Spring-ApplicationListener"><a href="#注册-Spring-ApplicationListener" class="headerlink" title="注册 Spring ApplicationListener"></a>注册 Spring ApplicationListener</h2><ul>
<li>方法一：ApplicationListener 作为 Spring Bean 注册</li>
<li>方法二：通过 ConfigurableApplicationContext API 注册</li>
</ul>
<h2 id="Spring-事件发布器"><a href="#Spring-事件发布器" class="headerlink" title="Spring 事件发布器"></a>Spring 事件发布器</h2><ul>
<li>方法一：通过 ApplicationEventPublisher 发布 Spring 事件<ul>
<li>获取 ApplicationEventPublisher<ul>
<li>依赖注入</li>
</ul>
</li>
</ul>
</li>
<li>方法二：通过 ApplicationEventMulticaster 发布 Spring 事件<ul>
<li>获取 ApplicationEventMulticaster<ul>
<li>依赖注入</li>
<li>依赖查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Spring-层次性上下文事件传播"><a href="#Spring-层次性上下文事件传播" class="headerlink" title="Spring 层次性上下文事件传播"></a>Spring 层次性上下文事件传播</h2><ul>
<li>发生说明</li>
<li>当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 ApplicationContext 发起 Spring 事件可能会传递到其 Parent ApplicationContext（直到 Root）的过程</li>
<li>如何避免</li>
<li>定位 Spring 事件源（ApplicationContext）进行过滤处理</li>
</ul>
<h2 id="Spring-内建事件"><a href="#Spring-内建事件" class="headerlink" title="Spring 内建事件"></a>Spring 内建事件</h2><p>ApplicationContextEvent 派生事件</p>
<ul>
<li>ContextRefreshedEvent ：Spring 应用上下文就绪事件</li>
<li>ContextStartedEvent ：Spring 应用上下文启动事件</li>
<li>ContextStoppedEvent ：Spring 应用上下文停止事件</li>
<li>ContextClosedEvent ：Spring 应用上下文关闭事件</li>
</ul>
<h2 id="Spring-4-2-Payload-事件"><a href="#Spring-4-2-Payload-事件" class="headerlink" title="Spring 4.2 Payload 事件"></a>Spring 4.2 Payload 事件</h2><p>Spring Payload 事件 - org.springframework.context.PayloadApplicationEvent</p>
<ul>
<li>使用场景：简化 Spring 事件发送，关注事件源主体</li>
<li>发送方法：ApplicationEventPublisher#publishEvent(java.lang.Object)</li>
</ul>
<h2 id="自定义-Spring-事件"><a href="#自定义-Spring-事件" class="headerlink" title="自定义 Spring 事件"></a>自定义 Spring 事件</h2><ul>
<li>扩展 org.springframework.context.ApplicationEvent</li>
<li>实现 org.springframework.context.ApplicationListener</li>
<li>注册 org.springframework.context.ApplicationListener</li>
</ul>
<h2 id="依赖注入-ApplicationEventPublisher"><a href="#依赖注入-ApplicationEventPublisher" class="headerlink" title="依赖注入 ApplicationEventPublisher"></a>依赖注入 ApplicationEventPublisher</h2><ul>
<li>通过 ApplicationEventPublisherAware 回调接口</li>
<li>通过 @Autowired ApplicationEventPublisher</li>
</ul>
<h2 id="依赖查找-ApplicationEventMulticaster"><a href="#依赖查找-ApplicationEventMulticaster" class="headerlink" title="依赖查找 ApplicationEventMulticaster"></a>依赖查找 ApplicationEventMulticaster</h2><p>查找条件</p>
<ul>
<li>Bean 名称：”applicationEventMulticaster”</li>
<li>Bean 类型：org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<h2 id="ApplicationEventPublisher-底层实现"><a href="#ApplicationEventPublisher-底层实现" class="headerlink" title="ApplicationEventPublisher 底层实现"></a>ApplicationEventPublisher 底层实现</h2><ul>
<li>接口：org.springframework.context.event.ApplicationEventMulticaster</li>
<li>抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster</li>
<li>实现类：org.springframework.context.event.SimpleApplicationEventMulticaster</li>
</ul>
<h2 id="同步和异步-Spring-事件广播"><a href="#同步和异步-Spring-事件广播" class="headerlink" title="同步和异步 Spring 事件广播"></a>同步和异步 Spring 事件广播</h2><p>基于实现类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code></p>
<ul>
<li>模式切换：<code>setTaskExecutor(java.util.concurrent.Executor)</code> 方法<ul>
<li>默认模式：同步</li>
<li>异步模式：如 <code>java.util.concurrent.ThreadPoolExecutor</code></li>
</ul>
</li>
<li>设计缺陷：非基于接口契约编程</li>
</ul>
<p>基于注解 - <code>@org.springframework.context.event.EventListener</code></p>
<ul>
<li>模式切换<ul>
<li>默认模式：同步</li>
<li>异步模式：标注 <code>@org.springframework.scheduling.annotation.Async</code></li>
</ul>
</li>
<li>实现限制：无法直接实现同步&#x2F;异步动态切换</li>
</ul>
<h2 id="Spring-4-1-事件异常处理"><a href="#Spring-4-1-事件异常处理" class="headerlink" title="Spring 4.1 事件异常处理"></a>Spring 4.1 事件异常处理</h2><p>Spring 3.0 错误处理接口 - org.springframework.util.ErrorHandler</p>
<p>使用场景</p>
<ul>
<li>Spring 事件（Events）<ul>
<li>SimpleApplicationEventMulticaster Spring 4.1 开始支持</li>
</ul>
</li>
<li>Spring 本地调度（Scheduling）<ul>
<li>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</li>
<li>org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler</li>
</ul>
</li>
</ul>
<h2 id="Spring-事件-监听器实现原理"><a href="#Spring-事件-监听器实现原理" class="headerlink" title="Spring 事件&#x2F;监听器实现原理"></a>Spring 事件&#x2F;监听器实现原理</h2><p>核心类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code></p>
<ul>
<li>设计模式：观察者模式扩展<ul>
<li>被观察者 - org.springframework.context.ApplicationListener<ul>
<li>API 添加</li>
<li>依赖查找</li>
</ul>
</li>
<li>通知对象 - org.springframework.context.ApplicationEvent</li>
</ul>
</li>
<li>执行模式：同步&#x2F;异步</li>
<li>异常处理：org.springframework.util.ErrorHandler</li>
<li>泛型处理：org.springframework.core.ResolvableType</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Spring Boot 事件</strong></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationStartingEvent</td>
<td>当 Spring Boot 应用已启动时</td>
</tr>
<tr>
<td>ApplicationStartedEvent</td>
<td>当 Spring Boot 应用已启动时</td>
</tr>
<tr>
<td>ApplicationEnvironmentPreparedEvent</td>
<td>当 Spring Boot Environment 实例已准备时</td>
</tr>
<tr>
<td>ApplicationPreparedEvent</td>
<td>当 Spring Boot 应用预备时</td>
</tr>
<tr>
<td>ApplicationReadyEvent</td>
<td>当 Spring Boot 应用完全可用时</td>
</tr>
<tr>
<td>ApplicationFailedEvent</td>
<td>当 Spring Boot 应用启动失败时</td>
</tr>
</tbody></table>
<p><strong>Spring Cloud 事件</strong></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody><tr>
<td>EnvironmentChangeEvent</td>
<td>当 Environment 示例配置属性发生变化时</td>
</tr>
<tr>
<td>HeartbeatEvent</td>
<td>当 DiscoveryClient 客户端发送心跳时</td>
</tr>
<tr>
<td>InstancePreRegisteredEvent</td>
<td>当服务实例注册前</td>
</tr>
<tr>
<td>InstanceRegisteredEvent</td>
<td>当服务实例注册后</td>
</tr>
<tr>
<td>RefreshEvent</td>
<td>当 RefreshEndpoint 被调用时</td>
</tr>
<tr>
<td>RefreshScopeRefreshedEvent</td>
<td>当 Refresh Scope Bean 刷新后</td>
</tr>
</tbody></table>
<p><strong>Spring 事件核心接口&#x2F;组件</strong>？</p>
<ul>
<li>Spring 事件 - org.springframework.context.ApplicationEvent</li>
<li>Spring 事件监听器 - org.springframework.context.ApplicationListener</li>
<li>Spring 事件发布器 - org.springframework.context.ApplicationEventPublisher</li>
<li>Spring 事件广播器 - org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<p><strong>Spring 同步和异步事件处理的使用场景</strong>？</p>
<ul>
<li>Spring 同步事件 - 绝大多数 Spring 使用场景，如 ContextRefreshedEvent</li>
<li>Spring 异步事件 - 主要 @EventListener 与 @Async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 SimpleApplicationEventMulticaster 中关联的 taskExecutor 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/blog/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"3e12be03eb928797f3b6da53c7ca74f6"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
