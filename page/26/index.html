<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/26/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/26/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/26/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/76234dab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/76234dab/" class="post-title-link" itemprop="url">MongoDB 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-21 21:22:57" itemprop="dateCreated datePublished" datetime="2020-09-21T21:22:57+08:00">2020-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-索引"><a href="#MongoDB-索引" class="headerlink" title="MongoDB 索引"></a>MongoDB 索引</h1><p>::: info 概述</p>
<p>索引通常能够极大的提高查询的效率。如果<strong>没有索引</strong>，MongoDB 在读取数据时<strong>必须扫描 collection 中的每个 document</strong> 并选取那些符合查询条件的记录。这种扫描全集合的查询是非常低效的，特别是在处理大量的数据时。查询可能要花费几十秒甚至几分钟，这种性能开销是不可接受的。索引可提高查询性能，但<strong>添加索引会影响写入操作的性能</strong>。对于写入读取率高的集合，由于每次插入操作都必须同时更新所有索引，因此会带来较高的索引成本。</p>
<p>本文介绍了 MongoDB 的基本索引操作、索引类型，和设置索引的策略。掌握了 MongoDB 索引的要点，有助于提高访问 MongoDB 数据的效率。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/76234dab/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9770eefe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9770eefe/" class="post-title-link" itemprop="url">MongoDB 聚合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-21 21:22:57" itemprop="dateCreated datePublished" datetime="2020-09-21T21:22:57+08:00">2020-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h1><p>::: info 概述</p>
<p>聚合操作处理多个文档并返回计算结果。可以使用聚合操作来：</p>
<ul>
<li>将多个文档中的值组合在一起。</li>
<li>对分组数据执行操作，返回单一结果。</li>
<li>分析一段时间内的数据变化。</li>
</ul>
<p>在 MongoDB 中，支持以下聚合方式：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/aggregation/#std-label-aggregation-pipeline-intro">聚合管道</a>，这是执行聚合的首选方法。</li>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/aggregation/#std-label-single-purpose-agg-methods">单一目的聚合方法</a>，这些方法很简单，但缺乏聚合管道的功能。</li>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/core/Map-Reduce/">Map-Reduce</a>，从 MongoDB 5.0 开始，<a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/core/Map-Reduce/#std-label-Map-Reduce">Map-Reduce</a> 已被弃用。聚合管道提供的性能和可用性比 Map-Reduce 更优越。</li>
</ul>
<p>本文将逐一介绍这三种聚合方式的要点和使用方法。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/9770eefe/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a9eba9b9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a9eba9b9/" class="post-title-link" itemprop="url">MongoDB 事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-20 23:12:17" itemprop="dateCreated datePublished" datetime="2020-09-20T23:12:17+08:00">2020-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-事务"><a href="#MongoDB-事务" class="headerlink" title="MongoDB 事务"></a>MongoDB 事务</h1><p>::: info 概述</p>
<p>通俗的说，<strong>事务将多个读、写操作捆绑在一起成为一个逻辑操作单元</strong>。<strong>事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）</strong>。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于任何原因），应用层的错误处理就变得简单很多。</p>
<p>大多数 NoSQL 只能部分支持事务，甚至完全不支持事务。但是，MongoDB 支持 ACID 事务，这是它的一大优势。</p>
<p>本文主要介绍了 MongoDB 对于事务的支持力度，以及如何应用事务。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/a9eba9b9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ea60b1cc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ea60b1cc/" class="post-title-link" itemprop="url">MongoDB 分片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-20 23:12:17" itemprop="dateCreated datePublished" datetime="2020-09-20T23:12:17+08:00">2020-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h1><p>::: info 概述</p>
<p>分区通常是这样定义的，即每一条数据（或者每条记录，每行或每个文档）只属于某个特定分区。实际上，每个分区都可以视为一个完整的小型数据库，虽然数据库可能存在一些跨分区的操作。</p>
<p>在不同系统中，分区有着不同的称呼，例如它对应于 MongoDB, Elasticsearch 和 SolrCloud 中的 shard, HBase 的 region, Bigtable 中的 tablet, Cassandra 和 Riak 中的 vnode ，以及 Couch base 中的 vBucket。</p>
<p>数据量如果太大，单台机器进行存储和处理就会成为瓶颈，因此需要引入数据分区机制。分区的目地是通过多台机器均匀分布数据和查询负载，避免出现热点。这需要选择合适的数据分区方案，在节点添加或删除时重新动态平衡分区。</p>
<p>分区通常与复制结合使用，即每个分区在多个节点都存有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。一个节点上可能存储了多个分区。每个分区都有自己的主副本，例如被分配给某节点，而从副本则分配在其他一些节点。一个节点可能既是某些分区的主副本，同时又是其他分区的从副本。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/ea60b1cc/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/cd111ced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/cd111ced/" class="post-title-link" itemprop="url">MongoDB 复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-20 23:12:17" itemprop="dateCreated datePublished" datetime="2020-09-20T23:12:17+08:00">2020-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-复制"><a href="#MongoDB-复制" class="headerlink" title="MongoDB 复制"></a>MongoDB 复制</h1><p>::: info 概述</p>
<p><strong>复制主要指通过网络在多台机器上保存相同数据的副本</strong>。</p>
<p>复制数据，可能出于各种各样的原因：</p>
<ul>
<li><strong>提高可用性</strong> - 当部分组件出现位障，系统依然可以继续工作，系统依然可以继续工作。</li>
<li><strong>降低访问延迟</strong> - 使数据在地理位置上更接近用户。</li>
<li><strong>提高读吞吐量</strong> - 扩展至多台机器以同时提供数据访问服务。</li>
</ul>
<p>综上可知，复制是所有分布式系统的核心特性，是高可用的重要保证。</p>
<p>MongoDB 本身是一个分布式数据库，自然也需要具备复制的能力。MongoDB 复制采用了经典的主从架构。<strong>所有的写入操作都发送到主节点</strong>，由主节点负责将数据更改事件发送到从节点，每个从节点都可以接收读请求。</p>
<p>本文将逐一阐述 MongoDB 复制的各个要点，以及如何基于复制来保证 MongoDB 的高可用。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/cd111ced/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/60921fba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/60921fba/" class="post-title-link" itemprop="url">MySQL 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-12 10:43:53" itemprop="dateCreated datePublished" datetime="2020-09-12T10:43:53+08:00">2020-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-面试"><a href="#MySQL-面试" class="headerlink" title="MySQL 面试"></a>MySQL 面试</h1><h2 id="关系数据库综合"><a href="#关系数据库综合" class="headerlink" title="关系数据库综合"></a>关系数据库综合</h2><h3 id="【简单】什么是范式？什么是反范式？"><a href="#【简单】什么是范式？什么是反范式？" class="headerlink" title="【简单】什么是范式？什么是反范式？"></a>【简单】什么是范式？什么是反范式？</h3><p>数据库规范化，又称“<strong>范式</strong>”，是数据库设计的指导理论。<strong>范式的目标是：使数据库结构更合理，消除存储异常，使数据冗余尽量小，增进数据的一致性</strong>。</p>
<p>根据约束程度从低到高有：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）等等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410022024207.png"></p>
<ul>
<li>1NF 要求<strong>所有属性都不可再分解</strong>。</li>
<li>2NF 要求<strong>不存在部分依赖</strong>。</li>
<li>3NF 要求<strong>不存在传递依赖</strong>。</li>
</ul>
<p>反范式，顾名思义，与范式的目标正好相反。<strong>范式</strong>的目标是<strong>消除冗余</strong>；<strong>反范式</strong>的目标是<strong>冗余以提高查询效率</strong>。</p>
<p>范式并非越严格越好，现代数据库设计，一般最多满足 3NF。范式越高意味着表的划分更细，一个数据库中需要的表也就越多，用户不得不将原本相关联的数据分摊到多个表中。当用户同时需要这些数据时只能通过关联表的形式将数据重新合并在一起。同时把多个表联接在一起的花费是巨大的，尤其是当需要连接的两张或者多张表数据非常庞大的时候，表连接操作几乎是一个噩梦，这严重地降低了系统运行性能。因此，<strong>有时为了提高查询效率，有必要适当的冗余数据，以达到空间换时间的目的——这就是“反范式”</strong>。</p>
<h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 (1NF)"></a>第一范式 (1NF)</h4><p>1NF 要求<strong>所有属性都不可再分解</strong>。</p>
<h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 (2NF)"></a>第二范式 (2NF)</h4><p>2NF 要求记录有唯一标识，即实体的唯一性，即<strong>不存在部分依赖</strong>。</p>
<p>假设有一张 student 表，结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line">student（学号、课程号、姓名、学分、成绩）</span><br></pre></td></tr></table></figure>

<p>举例来说，现有一张 student 表，具有学号、课程号、姓名、学分等字段。从中可以看出，表中包含了学生信息和课程信息。由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖学号，所以不符合 2NF。</p>
<p>不符合 2NF 可能会存在的问题：</p>
<ul>
<li><strong>数据冗余</strong> - 每条记录都含有相同信息。</li>
<li><strong>删除异常</strong> - 删除所有学生成绩，就把课程信息全删除了。</li>
<li><strong>插入异常</strong> - 学生未选课，无法记录进数据库。</li>
<li><strong>更新异常</strong> - 调整课程学分，所有行都调整。</li>
</ul>
<p>根据 2NF 可以拆分如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line">student（学号、姓名）</span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line">course（课程号、学分）</span><br><span class="line"><span class="comment">-- 学生课程关系表</span></span><br><span class="line">student_course（学号、课程号、成绩）</span><br></pre></td></tr></table></figure>

<h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 (3NF)"></a>第三范式 (3NF)</h4><p><strong>如果一个关系属于第二范式</strong>，并且在<strong>两个（或多个）非主键属性之间不存在函数依赖</strong>（非主键属性之间的函数依赖也称为传递依赖），那么这个关系属于第三范式。</p>
<p>3NF 是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即<strong>不存在传递依赖</strong>。</p>
<p>假设有一张 student 表，结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line">student（学号、姓名、年龄、班级号、班主任）</span><br></pre></td></tr></table></figure>

<p>上表属于第二范式，因为主键由单个属性组成（学号）。</p>
<p>因为存在<strong>依赖传递</strong>：（学号） → （学生）→（所在班级） → （班主任） 。</p>
<p><strong>可能会存在问题：</strong></p>
<ul>
<li>数据冗余 - 有重复值；</li>
<li>更新异常 - 有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li>
</ul>
<p>可以基于 3NF 拆解：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student（学号、姓名、年龄、所在班级号）</span><br><span class="line">class（班级号、班主任）</span><br></pre></td></tr></table></figure>

<h3 id="【简单】为什么不推荐使用存储过程？"><a href="#【简单】为什么不推荐使用存储过程？" class="headerlink" title="【简单】为什么不推荐使用存储过程？"></a>【简单】为什么不推荐使用存储过程？</h3><p>存储过程的优点：</p>
<ul>
<li><strong>执行效率高</strong>：一次编译多次使用。</li>
<li><strong>安全性强</strong>：在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li>
<li><strong>可复用</strong>：将代码封装，可以提高代码复用。</li>
<li><strong>性能好</strong><ul>
<li>由于是预先编译，因此具有很高的性能。</li>
<li>一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率。</li>
</ul>
</li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>可移植性差</strong>：存储过程不能跨数据库移植。由于不同数据库的存储过程语法几乎都不一样，十分难以维护（不通用）。</li>
<li><strong>调试困难</strong>：只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</li>
<li><strong>版本管理困难</strong>：比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li><strong>不适合高并发的场景</strong>：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li>
</ul>
<blockquote>
<p>_综上，存储过程的优缺点都非常突出，是否使用一定要慎重，需要根据具体应用场景来权衡_。</p>
</blockquote>
<h2 id="MySQL-CRUD"><a href="#MySQL-CRUD" class="headerlink" title="MySQL CRUD"></a>MySQL CRUD</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35167240/">《SQL 必知必会》</a> - SQL 的基本概念和语法【入门】</li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3354490/">《MySQL 必知必会》</a> - MySQL 的基本概念和语法【入门】</li>
</ul>
</blockquote>
<h3 id="【中等】如何避免重复插入数据？"><a href="#【中等】如何避免重复插入数据？" class="headerlink" title="【中等】如何避免重复插入数据？"></a>【中等】如何避免重复插入数据？</h3><p>在 mysql 中，当存在主键冲突或唯一键冲突的情况下，根据插入策略不同，一般有以下三种避免方法：</p>
<ul>
<li><code>INSERT IGNORE INTO</code>：若无则插入，若有则忽略</li>
<li><code>REPLACE INTO</code>：若无则插入，若有则先删除后插入</li>
<li><code>INSERT INTO ... ON DUPLICATE KEY UPDATE</code>：若无则插入，若有则更新</li>
</ul>
<p>下面结合示例来说明三种方式的效果。</p>
<p>下面是示例的初始化准备：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name`(`name`)</span><br><span class="line">) <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;刘备&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;关羽&#x27;</span>, <span class="number">28</span>);</span><br></pre></td></tr></table></figure>

<p>::: tabs#避免重复插入数据</p>
<p>@tab INSERT IGNORE INTO</p>
<p><code>INSERT IGNORE INTO</code> 会根据主键或者唯一键判断，忽略数据库中已经存在的数据：</p>
<ul>
<li>若数据库没有该条数据，就插入为新的数据，跟普通的 <code>INSERT INTO</code> 一样</li>
<li>若数据库有该条数据，就忽略这条插入语句，不执行插入操作</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> <span class="keyword">user</span> (name, age)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;关羽&#x27;</span>, <span class="number">29</span>), (<span class="string">&#x27;张飞&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终数据</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 关羽   <span class="operator">|</span>   <span class="number">28</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 张飞   <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br></pre></td></tr></table></figure>

<p>@tab REPLACE INTO</p>
<p><code>REPLACE INTO</code> 会根据主键或者唯一键判断：</p>
<ul>
<li>若表中已存在该数据，则先删除此行数据，然后插入新的数据，相当于 <code>delete + insert</code></li>
<li>若表中不存在该数据，则直接插入新数据，跟普通的 <code>insert into</code> 一样</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> <span class="keyword">user</span>(id, name, age)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>,  <span class="string">&#x27;关羽&#x27;</span>, <span class="number">29</span>), (<span class="number">4</span>,  <span class="string">&#x27;赵云&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终数据</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 关羽   <span class="operator">|</span>   <span class="number">29</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 张飞   <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 赵云   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br></pre></td></tr></table></figure>

<p>@tab INSERT … ON DUPLICATE KEY UPDATE</p>
<p><code>INSERT ... ON DUPLICATE KEY UPDATE</code> 会根据主键或者唯一键判断：</p>
<ul>
<li>若数据库已有该数据，则直接更新原数据，相当于 UPDATE</li>
<li>若数据库没有该数据，则插入为新的数据，相当于 INSERT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">user</span>(id, name, age)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;关羽&#x27;</span>, <span class="number">27</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name<span class="operator">=</span><span class="keyword">values</span>(name), age<span class="operator">=</span><span class="keyword">values</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终数据</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 关羽   <span class="operator">|</span>   <span class="number">27</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 张飞   <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 赵云   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="【简单】EXISTS-和-IN-有什么区别？"><a href="#【简单】EXISTS-和-IN-有什么区别？" class="headerlink" title="【简单】EXISTS 和 IN 有什么区别？"></a>【简单】EXISTS 和 IN 有什么区别？</h3><p>EXISTS 和 IN 区别如下：</p>
<ul>
<li><strong>功能</strong><ul>
<li><code>EXISTS</code> 用于判断子查询的结果集是否为空。</li>
<li><code>IN</code> 用于判断某个值是否在指定的集合中。</li>
</ul>
</li>
<li><strong>性能</strong><ul>
<li><strong><code>EXISTS</code> 先外后内</strong> - 先对外表进行循环查询，再将查询结果放入 <code>EXISTS</code> 的子查询中进行条件比较，一旦找到匹配记录，则终止内表子查询。</li>
<li><strong><code>IN</code> 先内后外</strong> - 先查询内表，将内表的查询结果作为条件，提供给外表查询语句进行比较。</li>
</ul>
</li>
<li><strong>应用</strong><ul>
<li>如果查询的两个表大小相当，那么 <code>EXISTS</code> 和 <code>IN</code> 差别不大。</li>
<li><code>EXISTS</code> 适合外表小而内表大的场景。</li>
<li><code>IN</code> 适合外表大而内表小的场景。</li>
</ul>
</li>
</ul>
<p>EXISTS 和 IN 的对比示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc<span class="operator">=</span>A.cc)</span><br></pre></td></tr></table></figure>

<p>当 A 小于 B 时，用 <code>EXISTS</code>。因为 <code>EXISTS</code> 的实现，相当于外表循环，实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>当 B 小于 A 时用 <code>IN</code>，因为实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">        if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>哪个表小就用哪个表来驱动，A 表小就用 <code>EXISTS</code>，B 表小就用 <code>IN</code>；如果两个表大小相当，则使用 <code>EXISTS</code> 和 <code>IN</code> 的区别不大。</p>
<h3 id="【简单】UNION-和-UNION-ALL-有什么区别？"><a href="#【简单】UNION-和-UNION-ALL-有什么区别？" class="headerlink" title="【简单】UNION 和 UNION ALL 有什么区别？"></a>【简单】UNION 和 UNION ALL 有什么区别？</h3><p><code>UNION</code> 和 <code>UNION ALL</code> 都是将两个结果集合并为一个，<strong>两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）</strong>。</p>
<ul>
<li><code>UNION</code> 需要进行去重扫描，因此效率较低；而 <code>UNION ALL</code> 不会进行去重。</li>
<li><code>UNION</code> 会按照字段的顺序进行排序；而 <code>UNION ALL</code> 只是简单的将两个结果合并就返回。</li>
</ul>
<h3 id="【简单】JOIN-有哪些类型？"><a href="#【简单】JOIN-有哪些类型？" class="headerlink" title="【简单】JOIN 有哪些类型？"></a>【简单】JOIN 有哪些类型？</h3><p>**在 SELECT, UPDATE 和 DELETE 语句中，“连接”可以用于联合多表查询。连接使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>**。</p>
<p><strong>连接可以替换子查询，并且一般比子查询的效率更快</strong>。</p>
<p><code>JOIN</code> 有以下类型：</p>
<ul>
<li>内连接 - 内连接又称等值连接，用于获取两个表中字段匹配关系的记录，<strong>使用 <code>INNER JOIN</code> 关键字</strong>。在没有条件语句的情况下<strong>返回笛卡尔积</strong>。<ul>
<li>笛卡尔积 - <strong>“笛卡尔积”也称为交叉连接（<code>CROSS JOIN</code>），它的作用就是可以把任意表进行连接，即使这两张表不相关</strong>。</li>
<li>自连接（&#x3D;） - <strong>“自连接（&#x3D;）”可以看成内连接的一种，只是连接的表是自身而已</strong>。</li>
<li>自然连接（NATURAL JOIN） - <strong>“自然连接”会自动连接所有同名列</strong>。自然连接使用 <code>NATURAL JOIN</code> 关键字。</li>
</ul>
</li>
<li>外连接<ul>
<li>左连接（LEFT JOIN） - <strong>“左外连接”会获取左表所有记录，即使右表没有对应匹配的记录</strong>。左外连接使用 <code>LEFT JOIN</code> 关键字。</li>
<li>右连接（RIGHT JOIN） - <strong>“右外连接”会获取右表所有记录，即使左表没有对应匹配的记录</strong>。右外连接使用 <code>RIGHT JOIN</code> 关键字。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/sql-join.png" alt="SQL JOIN"></p>
<h3 id="【中等】为什么不推荐多表-JOIN？"><a href="#【中等】为什么不推荐多表-JOIN？" class="headerlink" title="【中等】为什么不推荐多表 JOIN？"></a>【中等】为什么不推荐多表 JOIN？</h3><blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/eiffelzero/p/18608160">https://www.cnblogs.com/eiffelzero/p/18608160</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27605355/">《阿里巴巴 Java 开发手册》</a> 中强制要求超过三个表禁止 join。这是为什么呢？</p>
<p>主要原因如下：</p>
<ul>
<li><strong>性能问题</strong><ul>
<li><strong>查询效率低</strong>：当涉及多个表进行 <strong>JOIN</strong> 操作时，MySQL 需要执行多次扫描，尤其是在没有合适索引支持的情况下，性能可能会大幅下降。每增加一个表的 <strong>JOIN</strong>，查询的复杂度呈指数增长。</li>
<li><strong>临时表的创建</strong>：MySQL 在执行复杂的多表 <strong>JOIN</strong> 时，通常会创建临时表来存储中间结果。如果数据量很大，临时表可能会溢出到磁盘，导致磁盘 I&#x2F;O 操作增加，从而显著影响查询性能。</li>
</ul>
</li>
<li><strong>索引的作用有限</strong><ul>
<li>在多表 <strong>JOIN</strong> 的操作中，虽然每个表可以使用索引加速查询，但是当涉及到多个表的连接时，MySQL 必须在这些表之间执行 <strong>JOIN</strong> 操作，这时索引的效果会大大降低。特别是在没有合适索引的情况下，<strong>JOIN</strong> 查询会导致全表扫描，极大地降低了查询效率。</li>
</ul>
</li>
<li><strong>数据冗余</strong><ul>
<li>在多表 <strong>JOIN</strong> 时，如果一个表中的一行数据与另一个表中的多行数据进行匹配，结果会产生数据冗余。例如，假设有两个表：<code>A</code> 和 <code>B</code>，<code>A</code> 中有 10 条记录，<code>B</code> 中有 5 条记录。如果在 <code>A</code> 和 <code>B</code> 上做 <strong>JOIN</strong> 操作，且匹配条件满足 2 条记录，那么最终的结果会有 20 条记录（10 * 2）。这会导致数据量急剧增加，浪费存储空间。</li>
</ul>
</li>
<li><strong>可读性和可维护性</strong><ul>
<li>多表 <strong>JOIN</strong> 的 SQL 查询通常比较复杂，尤其是当涉及多个表、多个连接条件以及嵌套查询时，查询语句的可读性会下降，增加了维护的难度。</li>
<li>复杂的查询可能让开发者和运维人员难以理解和优化，从而增加了错误的风险。</li>
</ul>
</li>
<li><strong>可能引发死锁</strong><ul>
<li>在进行多个表 <strong>JOIN</strong> 操作时，如果涉及到多张表的锁定，可能会导致死锁。特别是在高并发的环境下，频繁执行 <strong>JOIN</strong> 操作容易导致多个事务之间相互等待，最终导致死锁问题。</li>
</ul>
</li>
<li><strong>优化器的作用有限</strong><ul>
<li>MySQL 的优化器对多表 <strong>JOIN</strong> 的优化能力相对有限，尤其在处理非常复杂的查询时，可能无法有效选择最优的执行计划，从而导致性能瓶颈。</li>
<li>虽然 MySQL 使用了 <strong>查询缓存</strong> 和 <strong>索引优化</strong>，但对于多表 <strong>JOIN</strong> 的优化仍然受到很多限制，导致性能不如预期。</li>
</ul>
</li>
</ul>
<h3 id="【中等】DROP、DELETE-和-TRUNCATE-有什么区别？"><a href="#【中等】DROP、DELETE-和-TRUNCATE-有什么区别？" class="headerlink" title="【中等】DROP、DELETE 和 TRUNCATE 有什么区别？"></a>【中等】DROP、DELETE 和 TRUNCATE 有什么区别？</h3><ul>
<li><code>DROP</code> 删除数据表，包括数据和结构。在 InnoDB 中，表数据存于 <code>.ibd</code> 文件；表结构元数据存于 .frm 文件。DROP 本质上是就是直接删除 <code>.ibd</code> 和 <code>.frm</code> 文件。</li>
<li><code>DELETE</code> 删除数据，但保留表结构。执行 DELETE 后，空间大小不会立刻变化。这是因为，DLETE 操作实际上只是标记，被写入 biglog、redo log 和 undo log。</li>
<li><code>TRUNCATE</code> 会删除全部表数据，且不会记录日志，因此无法回滚。<code>TRUNCATE</code> 执行后，自增主键重新从 1 开始。</li>
</ul>
<h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/data-types.html">MySQL 官方文档之数据类型</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal">MySQL 如何选择 float, double, decimal</a></li>
</ul>
</blockquote>
<h3 id="【简单】CHAR-和-VARCHAR-的区别是什么？"><a href="#【简单】CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="【简单】CHAR 和 VARCHAR 的区别是什么？"></a>【简单】CHAR 和 VARCHAR 的区别是什么？</h3><p><code>CHAR</code> 和 <code>VARCHAR</code> 的主要区别在于：<strong>CHAR 是定长字符串，VARCHAR 是变长字符串。</strong></p>
<ul>
<li><strong>长度限制</strong><ul>
<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>
</ul>
</li>
<li><strong>占用空间</strong><ul>
<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；</li>
<li><code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。<ul>
<li>字符长度超过 255，使用 2 个字节</li>
<li>字符长度未超过 255，使用 1 个字节</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用</strong></li>
<li><strong><code>CHAR</code> 适合存储长度较短或长度固定的字符串</strong>。例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码；</li>
<li><strong><code>VARCHAR</code> 适合存储长度不确定的字符串</strong>。例如用户昵称、文章标题等。</li>
</ul>
<p><code>BINARY</code> 和 <code>VARBINARY</code> 类似于 <code>CHAR</code> 和 <code>VARCHAR</code>，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<h3 id="【简单】金额数据用什么类型存储？"><a href="#【简单】金额数据用什么类型存储？" class="headerlink" title="【简单】金额数据用什么类型存储？"></a>【简单】金额数据用什么类型存储？</h3><p>MySQL 中有 3 种类型可以表示浮点数，分别是 <code>FLOAT</code>、<code>DOUBLE</code> 和 <code>DECIMAL</code>。</p>
<p><strong>采用 <code>FLOAT</code> 和 <code>DOUBLE</code> 类型会丢失精度</strong>。数据的精确度取决于分配给每种数据类型的存储长度。由于计算机只能存储二进制，所以浮点型数据在存储的时候，必须转化成二进制。</p>
<ul>
<li>单精度类型 <code>FLOAT</code> 存储空间为 4 字节，即 32 位。</li>
<li>双精度类型 <code>DOUBLE</code> 存储空间为 8 字节，即 64 位。</li>
</ul>
<p>如果存储的数据转为二进制后，超过存储的位数，数据就被截断，因此存在丢失精度的可能。</p>
<p>更重要的是，从 MySQL 8.0.17 版本开始，当创建表用到类型 Float 或 Double 时，会抛出下面的警告：MySQL 提醒用户不该用上述浮点类型，甚至提醒将在之后版本中废弃浮点类型。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Specifying number <span class="keyword">of</span> digits <span class="keyword">for</span> floating <span class="type">point</span> data <span class="keyword">types</span> <span class="keyword">is</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future <span class="keyword">release</span></span><br></pre></td></tr></table></figure>

<p>【示例】丢失精度案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">  `<span class="keyword">value</span>` <span class="type">FLOAT</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> test <span class="keyword">value</span> (<span class="number">131072.32</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">131072.31</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>说明：示例中，使用 FLOAT 类型，明明保留了两位小数。但是写入的数据却从 <code>131072.32</code> 变成了 <code>131072.31</code> 。</p>
<p><code>DECIMAL</code> 类型是 MySQL 官方唯一指定能精确存储的类型。因此，对于不允许丢失精度的场景（如金额数据），可以使用 <code>DECIMAL</code> 类型。</p>
<p>然而，在海量并发的互联网业务中使用，金额字段的设计并不推荐使用 <code>DECIMAL</code> 类型，而更推荐使用 <code>BIGINT</code> 整型类型。这里会用到一个巧思：将资金类型的数据用分为单位存储，而不是用元为单位存储。如 1 元在数据库中用整型类型 100 存储。</p>
<p>为什么更推荐用 <code>BIGINT</code> 存储金钱数据？因为 <code>DECIMAL</code> 是个变长字段，若要定义金额字段，则定义为 <code>DECIMAL(8,2)</code> 是远远不够的。这样只能表示存储最大值为 999999.99，百万级的资金存储。用户的金额至少要存储百亿的字段，而统计局的 GDP 金额字段则可能达到数十万亿级别。用类型 <code>DECIMAL</code> 定义，不好统一。另外重要的是，类型 <code>DECIMAL</code> 是通过二进制实现的一种编码方式，计算效率远不如整型来的高效。因此，推荐使用 <code>BIGINT</code> 来存储金额相关的字段。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal">MySQL 如何选择 float, double, decimal</a></p>
</blockquote>
<h3 id="【简单】如何存储-emoji-😃？"><a href="#【简单】如何存储-emoji-😃？" class="headerlink" title="【简单】如何存储 emoji 😃？"></a>【简单】如何存储 emoji 😃？</h3><p>在表结构设计中，除了将列定义为 <code>CHAR</code> 和 <code>VARCHAR</code> 用以存储字符以外，还需要额外定义字符对应的字符集，因为每种字符在不同字符集编码下，对应着不同的二进制值。常见的字符集有 <code>gbk</code>、<code>utf8</code>，通常推荐把默认字符集设置为 <code>utf8</code>。</p>
<p>随着移动互联网的飞速发展，**推荐把 MySQL 的默认字符集设置为 <code>utf8mb4</code>**，否则，某些 emoji 表情字符无法在 UTF8 字符集下存储。</p>
<p>【示例】设置表的字符集为 <code>utf8mb4</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> test CHARSET utf8mb4;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：上述修改只是将表的字符集修改为 <code>utf8mb4</code>，下次新增列时，若不显式地指定字符集，新列的字符集会变更为 <code>utf8mb4</code>，<strong>但对于已经存在的列，其默认字符集并不做修改</strong>。</p>
</blockquote>
<p>【示例】设置表的默认字符集为 <code>utf8mb4</code></p>
<p>正确设置 <code>utf8mb4</code> 字符集方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> test <span class="keyword">CONVERT</span> <span class="keyword">TO</span> CHARSET utf8mb4;</span><br></pre></td></tr></table></figure>

<h3 id="【简单】时间数据选择-DATETIME-还是-TIMESTAMP？"><a href="#【简单】时间数据选择-DATETIME-还是-TIMESTAMP？" class="headerlink" title="【简单】时间数据选择 DATETIME 还是 TIMESTAMP？"></a>【简单】时间数据选择 DATETIME 还是 TIMESTAMP？</h3><p>表结构设计时，对时间字段的存储，通常会有 3 种选择：<code>DATETIME</code>、<code>TIMESTAMP</code>、<code>INT</code>。</p>
<p><code>DATETIME</code>、<code>TIMESTAMP</code>、<code>INT</code> 数据表示范围：</p>
<ul>
<li><code>DATETIME</code> 占用 8 个字节，可表示范围为：<code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code></li>
<li><code>TIMESTAMP</code> 占用 4 个字节，可表示范围为：<code>&#39;1970-01-01 00:00:01.000000&#39; UTC</code> 到 <code>&#39;2038-01-09 03:14:07.999999&#39; UTC</code>。表示从 <code>1970-01-01 00:00:00</code> 到现在的毫秒数。</li>
<li><code>INT</code> 类型就是直接存储 ‘1970-01-01 00:00:00’ 到现在的毫秒数，本质和 <code>TIMESTAMP</code> 一样，因此用 <code>INT</code> 不如直接使用 <code>TIMESTAMP</code>。</li>
</ul>
<p>此外，<code>TIMESTAMP</code> 还存在潜在的性能问题。虽然从毫秒数转换到类型 <code>TIMESTAMP</code> 本身需要的 CPU 指令并不多，这并不会带来直接的性能问题。但是如果使用默认的操作系统时区，则每次通过时区计算时间时，要调用操作系统底层系统函数 <code>__tz_convert()</code>，而这个函数需要额外的加锁操作，以确保这时操作系统时区没有修改。所以，当大规模并发访问时，由于热点资源竞争，会产生两个问题。</p>
<ul>
<li><strong>性能不如 DATETIME：</strong> <code>DATETIME</code> 不存在时区转化问题。</li>
<li><strong>性能抖动：</strong> 海量并发时，存在性能抖动问题。</li>
</ul>
<p>为了优化 TIMESTAMP 的使用，强烈建议使用显式的时区，而不是操作系统时区。比如在配置文件中显示地设置时区，而不要使用系统时区</p>
<p>综上，由于 <code>TIMESTAMP</code> 存在时间上限和潜在性能问题，所以推荐使用 <code>DATETIME</code> 类型来存储时间字段。</p>
<h2 id="MySQL-存储"><a href="#MySQL-存储" class="headerlink" title="MySQL 存储"></a>MySQL 存储</h2><blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html">MySQL 官方文档之 InnoDB 存储引擎</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/storage-engines.html">MySQL 官方文档之可选的存储引擎</a></li>
</ul>
</blockquote>
<h3 id="【中等】MySQL-支持哪些存储引擎？"><a href="#【中等】MySQL-支持哪些存储引擎？" class="headerlink" title="【中等】MySQL 支持哪些存储引擎？"></a>【中等】MySQL 支持哪些存储引擎？</h3><p><strong>存储引擎层负责数据的存储和提取</strong>。MySQL 的存储引擎采用了插拔式架构，可以根据需要替换。</p>
<p>MySQL 内置了以下存储引擎：</p>
<ul>
<li><strong>InnoDB</strong> - InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。<ul>
<li>优点：支持<strong>事务</strong>，支持<strong>行级锁</strong>，支持<strong>外键约束</strong>等，<strong>并发性能不错</strong>且支持<strong>自动故障恢复</strong>。</li>
</ul>
</li>
<li><strong>MyISAM</strong> - MyISAM 是 MySQL 5.5 版本以前的默认存储引擎。<ul>
<li>优点：速度快，占用资源少。</li>
<li>缺点：不支持事务，不支持行级锁，不支持外键约束，也不支持自动故障恢复功能。</li>
</ul>
</li>
<li><strong>Memory</strong> - 使用系统内存作为存储介质，以便得到更快的响应速度。不过，如果 mysqld 进程崩溃，则会导致所有的数据丢失。因此，Memory 引擎常用于临时表。</li>
<li><strong>NDB</strong> - 也被称为 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li><strong>Archive</strong> - Archive 存储引擎有很好的压缩机制，非常适合用于归档数据。<ul>
<li>Archive 存储引擎只支持 <code>INSERT</code> 和 <code>SELECT</code> 操作。</li>
<li>Archive 存储引擎采用 zlib 算法压缩数据，压缩比可达到 1: 10。</li>
</ul>
</li>
<li><strong>CSV</strong> - 可以将 CSV 文件作为 MySQL 的表来处理，但这种表不支持索引。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503210712752.png"></p>
<h3 id="【中等】InnoDB-和-MyISAM-有哪些差异？"><a href="#【中等】InnoDB-和-MyISAM-有哪些差异？" class="headerlink" title="【中等】InnoDB 和 MyISAM 有哪些差异？"></a>【中等】InnoDB 和 MyISAM 有哪些差异？</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持四种事务隔离级别</td>
</tr>
<tr>
<td>锁粒度</td>
<td>支持表级锁</td>
<td>支持表级锁、行级锁</td>
</tr>
<tr>
<td>索引</td>
<td>采用 B+ 树索引（非聚簇索引）</td>
<td>采用 B+ 树索引（聚簇索引）</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>计数器</td>
<td>维护了计数器，<code>SELECT COUNT(*)</code> 效率为 <code>O(1)</code></td>
<td>没有维护计数器，需要全表扫描</td>
</tr>
<tr>
<td>自动故障恢复</td>
<td>不支持</td>
<td>支持（依赖于 redo log）</td>
</tr>
</tbody></table>
<h3 id="【中等】如何选择-MySQL-存储引擎？"><a href="#【中等】如何选择-MySQL-存储引擎？" class="headerlink" title="【中等】如何选择 MySQL 存储引擎？"></a>【中等】如何选择 MySQL 存储引擎？</h3><ul>
<li>大多数情况下，使用默认的 InnoDB 就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li>
<li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li>
<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中。MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li>
<li>如果存储归档数据，可以使用 ARCHIVE 引擎。</li>
</ul>
<p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p>
<h3 id="【中等】MySQL-有哪些物理存储文件？"><a href="#【中等】MySQL-有哪些物理存储文件？" class="headerlink" title="【中等】MySQL 有哪些物理存储文件？"></a>【中等】MySQL 有哪些物理存储文件？</h3><p>MySQL 不同存储引擎的物理存储文件是不一样的。</p>
<p>InnoDB 的物理文件结构为：</p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<ul>
<li>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件</li>
<li>共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070640589.png"></p>
<p>MyISAM 的物理文件结构为：</p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据。</li>
<li><code>.MYI</code> (<code>MYIndex</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。</li>
</ul>
<h3 id="【中等】什么是-Buffer-Pool？"><a href="#【中等】什么是-Buffer-Pool？" class="headerlink" title="【中等】什么是 Buffer Pool？"></a>【中等】什么是 Buffer Pool？</h3><p>Buffer Pool（缓冲池）是 MySQL InnoDB 存储引擎的核心组件之一，它是数据库系统中的内存缓存区域，主要<strong>用于缓存表和索引的数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641009.png"></p>
<p><strong>主要作用</strong>：</p>
<ol>
<li><strong>减少磁盘 I&#x2F;O</strong>：将频繁访问的数据页缓存在内存中，避免每次查询都要从磁盘读取</li>
<li><strong>提高查询性能</strong>：内存访问速度远快于磁盘访问</li>
<li><strong>写缓冲</strong>：对数据的修改先在内存中进行，再通过后台线程定期刷新到磁盘</li>
</ol>
<p><strong>工作原理</strong>：</p>
<ul>
<li>Buffer Pool 以页 (page) 为单位存储数据，默认每页 16KB</li>
<li>使用 LRU （最近最少使用）算法管理内存页</li>
<li>包含”年轻代”和”老年代”两个区域，防止全表扫描污染缓存</li>
</ul>
<h3 id="【中等】什么是-Change-Buffer？"><a href="#【中等】什么是-Change-Buffer？" class="headerlink" title="【中等】什么是 Change Buffer？"></a>【中等】什么是 Change Buffer？</h3><p>Change Buffer 是 InnoDB 存储引擎中的一种关键优化机制，主要<strong>用于提高非唯一二级索引的写操作性能</strong>。</p>
<p>Change Buffer 是一种特殊的内存数据结构，用于缓存对<strong>非唯一二级索引页</strong>的修改操作（INSERT、UPDATE、DELETE），当这些索引页不在缓冲池 (Buffer Pool) 中时，避免立即从磁盘读取索引页。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li><p><strong>写操作发生时</strong>：当修改非唯一二级索引的数据时，InnoDB 会检查目标索引页是否在 Buffer Pool 中。</p>
</li>
<li><p>如果在：直接修改</p>
<ul>
<li>如果不在：将修改操作记录到 Change Buffer</li>
</ul>
</li>
<li><p><strong>后续读取时</strong>：当需要读取该索引页时，InnoDB 会将 Change Buffer 中的修改与从磁盘读取的原始页合并。</p>
</li>
<li><p><strong>后台合并</strong>：有专门的线程定期将 Change Buffer 中的变更合并到磁盘上的索引页。</p>
</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li><strong>减少磁盘 I&#x2F;O</strong>：避免为写入操作立即读取索引页</li>
<li><strong>提高吞吐量</strong>：多个变更可以合并执行</li>
<li><strong>减少随机 I&#x2F;O</strong>：将随机写入转为顺序写入</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>适用于<strong>写多读少</strong>的非唯一二级索引</li>
<li>特别适合<strong>大量 DML 操作</strong>但索引不常被查询的业务场景</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li>唯一索引（需要立即检查唯一性约束）</li>
<li>索引被频繁查询（会导致频繁合并操作）</li>
</ul>
<p><strong>相关配置</strong>：</p>
<ul>
<li><code>innodb_change_buffer_max_size</code>：Change Buffer 最大占 Buffer Pool 的比例（默认 25%）</li>
<li><code>innodb_change_buffering</code>：指定缓冲的变更类型（all&#x2F;none&#x2F;inserts&#x2F;deletes 等）</li>
</ul>
<h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><h3 id="【简单】MySQL-有哪些类型的日志？"><a href="#【简单】MySQL-有哪些类型的日志？" class="headerlink" title="【简单】MySQL 有哪些类型的日志？"></a>【简单】MySQL 有哪些类型的日志？</h3><p>MySQL 日志文件有很多，包括 ：</p>
<ul>
<li><strong>错误日志</strong>（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。</li>
<li><strong>慢查询日志</strong>（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li>
<li><strong>一般查询日志</strong>（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。</li>
<li><strong>二进制日志</strong>（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。</li>
</ul>
<p>还有两个 InnoDB 存储引擎特有的日志文件：</p>
<ul>
<li><strong>重做日志</strong>（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。</li>
<li><strong>回滚日志</strong>（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li>
</ul>
<h3 id="【简单】bin-log-和-redo-log-有什么区别？"><a href="#【简单】bin-log-和-redo-log-有什么区别？" class="headerlink" title="【简单】bin log 和 redo log 有什么区别？"></a>【简单】bin log 和 redo log 有什么区别？</h3><ul>
<li>bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志；而 redo log 只记 InnoDB 存储引擎的日志。</li>
<li>记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。</li>
<li>写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。</li>
<li>写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。</li>
</ul>
<h3 id="【简单】redo-log-如何刷盘？"><a href="#【简单】redo-log-如何刷盘？" class="headerlink" title="【简单】redo log 如何刷盘？"></a>【简单】redo log 如何刷盘？</h3><p>redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为 redo log buffer 的连续内存空间，也就是 redo 日志缓冲区。</p>
<p>在如下的一些情况中，log buffer 的数据会刷入磁盘：</p>
<ul>
<li>log buffer 空间不足时：log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约<strong>一半</strong>左右，就需要把这些日志刷新到磁盘上。</li>
<li>事务提交时：在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。</li>
<li>后台线程输入：有一个后台线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo log</code>到磁盘。</li>
<li>正常关闭服务器时</li>
<li>触发 checkpoint 规则</li>
</ul>
<p>重做日志缓存、重做日志文件都是以 <strong>块（block）</strong> 的方式进行保存的，称之为、<strong>重做日志块（redo log block）</strong>, 块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 <strong>log group</strong>，由一定数量的 <strong>log block</strong> 组成。</p>
<p>它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。</p>
<p>其中有两个标记位置：</p>
<p><code>write pos</code>是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>checkpoint</code>是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。</p>
<p>当<code>write_pos</code>追上<code>checkpoint</code>时，表示 redo log 日志已经写满。这时候就不能接着往里写数据了，需要执行<code>checkpoint</code>规则腾出可写空间。</p>
<p>所谓的 <strong>checkpoint 规则</strong>，就是 checkpoint 触发后，将 buffer 中日志页都刷到磁盘。</p>
<h3 id="【中等】日志为什么要两阶段提交？"><a href="#【中等】日志为什么要两阶段提交？" class="headerlink" title="【中等】日志为什么要两阶段提交？"></a>【中等】日志为什么要两阶段提交？</h3><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。</p>
<ol>
<li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<ul>
<li>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li>
<li>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
</ul>
</li>
<li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<h3 id="【中等】什么是-WAL？"><a href="#【中等】什么是-WAL？" class="headerlink" title="【中等】什么是 WAL？"></a>【中等】什么是 WAL？</h3><p>WAL（Write-Ahead Logging）是一种数据库事务日志管理技术，确保在修改数据之前先将修改记录写入日志。它的关键点就是 <strong>先写日志，再写磁盘</strong>。</p>
<p>WAL 是一种通用技术，被广泛应用于各种数据库，但实现各有不同。在 InnoDB 中，redo log 就是 WAL 的实现。</p>
<p>大致流程为：</p>
<ul>
<li>事务开始时，修改记录到 redo log 缓冲区。</li>
<li>redo log 缓冲区的数据周期性刷新到磁盘上的 redo log 文件。</li>
<li>事务提交时，确保 redo log 已写入磁盘，然后将数据页的修改写入数据文件。</li>
<li>系统崩溃时，通过 redo log 重新应用未完成的事务，恢复数据库到一致状态。</li>
</ul>
<h3 id="【中等】什么是-Log-Buffer？"><a href="#【中等】什么是-Log-Buffer？" class="headerlink" title="【中等】什么是 Log Buffer？"></a>【中等】什么是 Log Buffer？</h3><p><strong>Log Buffer</strong> 用于缓冲 redo log 的写入，减少频繁刷盘 fsync 的开销，将多次写入优化为一次批量写入。</p>
<p>redo log 是 InnoDB 的重做日志，用于崩溃恢复，确保数据正确性。redo log 采用 WAL 机制：先写日志，再写磁盘数据，将随机写入转换为顺序写入。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641668.png"></p>
<p><strong>Log Buffer 的刷盘时机</strong></p>
<ul>
<li><strong>事务提交时</strong>：事务产生的多条 redo log 会先缓存在 Log Buffer，提交时一次性写入文件（受配置参数控制）。</li>
<li><strong>容量触发</strong>：当 Log Buffer 超过总容量的一半（默认 16MB）时自动刷盘。</li>
<li><strong>后台线程</strong>：每隔 1 秒定时刷盘。</li>
</ul>
<p><strong>配置参数<code>innodb_flush_log_at_trx_commit</code></strong></p>
<ul>
<li><strong>0</strong>：事务提交不刷盘，依赖后台线程每秒刷盘。性能最佳，但可能丢失 1 秒数据。</li>
<li><strong>1</strong>（默认）：事务提交时同步刷盘（写 OS cache 并调用 fsync）。数据最安全，性能最差。</li>
<li><strong>2</strong>：事务提交时仅写 OS cache，后台线程每秒调用 fsync。性能折中，服务器宕机可能丢失 1 秒数据。</li>
</ul>
<h2 id="MySQL-复制"><a href="#MySQL-复制" class="headerlink" title="MySQL 复制"></a>MySQL 复制</h2><h3 id="【中等】MySQL-如何实现主从同步？"><a href="#【中等】MySQL-如何实现主从同步？" class="headerlink" title="【中等】MySQL 如何实现主从同步？"></a>【中等】MySQL 如何实现主从同步？</h3><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台从库上，从库本身也可以被配置成另外一台服务器的主库。主库和从库之间可以有多种不同的组合方式。</p>
<p>MySQL 复制采用主从同步，基于 <strong>binlog（二进制日志）</strong> 实现。其流程大致为：</p>
<ul>
<li>主库记录 <strong>DML&#x2F;DDL</strong> 操作到 binlog。</li>
<li>从库获取 binlog 并重放，保持数据同步。</li>
</ul>
<p>MySQL 支持三种复制方式：同步、异步、半同步。下面是三种方式的对比：</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>机制</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步复制</strong>（默认）</td>
<td>主库不等待从库响应</td>
<td>高性能</td>
<td>数据一致性弱（可能丢失）</td>
</tr>
<tr>
<td><strong>同步复制</strong></td>
<td>主库等待所有从库确认</td>
<td>强一致性</td>
<td>性能差，延迟高</td>
</tr>
<tr>
<td><strong>半同步复制</strong></td>
<td>主库等待至少一个从库确认</td>
<td>平衡性能与一致性</td>
<td>比异步略慢</td>
</tr>
</tbody></table>
<h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>MySQL 异步复制可以分为三个步骤，分别由三个线程完成：</p>
<ul>
<li><strong>binlog dump 线程</strong> - 主库接收事务请求，更新数据，并即时响应客户端（不等待从库）。主库上有一个特殊的 binlog dump 线程，负责将主服务器上的数据更改写入 binlog 中。</li>
<li><strong>I&#x2F;O 线程</strong> - 从库上有一个 I&#x2F;O 线程，负责从主库上读取 binlog，并写入从库的中继日志（relay log）中。</li>
<li><strong>SQL 线程</strong> - 从库上有一个 SQL 线程，负责重放中继日志（relay log），更新从库数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave.png"></p>
<p>需要注意的是，<strong>采用异步复制有丢失数据的风险</strong>，主库崩溃时，未同步的 binlog 可能丢失（<strong>弱一致性</strong>）。</p>
<h4 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h4><p>主库必须等待<strong>所有从库</strong>完成 binlog 同步后才响应客户端。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>数据强一致性（所有节点完全同步）</li>
<li>性能极差（延迟高，吞吐量低）</li>
<li>生产环境基本不使用</li>
</ul>
<h4 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h4><p>MySQL 5.7 引入了半同步复制：主库只需等待<strong>至少 N 个从库</strong>（可配置）确认即返回。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>性能与可靠性的平衡</strong>（比全同步快，比异步安全）。</li>
<li>仅当主库和所有已确认从库<strong>同时崩溃</strong>时可能丢数据。</li>
</ul>
<h3 id="【中等】如何处理-MySQL-主从同步延迟？"><a href="#【中等】如何处理-MySQL-主从同步延迟？" class="headerlink" title="【中等】如何处理 MySQL 主从同步延迟？"></a>【中等】如何处理 MySQL 主从同步延迟？</h3><p><strong>主从延迟的常见解决方案</strong></p>
<ul>
<li><strong>二次查询</strong>（兜底策略）：从库查不到时，再查主库。缺点是：恶意查询可能导致主库压力增大。</li>
<li><strong>强制写后读走主库</strong>：写入后立即读的操作绑定走主库。缺点是：代码耦合，灵活性差。</li>
<li><strong>关键业务读写主库，非关键业务读写分离</strong></li>
<li><strong>使用缓存</strong>：主库写入后同步缓存，查询优先查缓存。缺点是：引入缓存后，新增了一致性问题。</li>
<li><strong>提升从库配置</strong>：优化从库硬件（CPU、内存、磁盘等），提高同步效率。</li>
</ul>
<p><strong>MySQL 主从延迟的常见原因及优化方案</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>原因</strong></th>
<th align="left"><strong>优化方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">从库单线程复制</td>
<td align="left">启用 <strong>并行复制</strong>（多线程同步）。</td>
</tr>
<tr>
<td align="left">网络延迟</td>
<td align="left">优化网络，缩短主从物理距离。</td>
</tr>
<tr>
<td align="left">从库性能不足</td>
<td align="left">升级硬件（CPU、内存、存储）。</td>
</tr>
<tr>
<td align="left">长事务</td>
<td align="left">减少主库长事务，优化 SQL。</td>
</tr>
<tr>
<td align="left">从库数量过多</td>
<td align="left">合理控制从库数量，避免主库同步压力过大。</td>
</tr>
<tr>
<td align="left">从库查询负载高</td>
<td align="left">增加从库实例，优化慢查询。</td>
</tr>
</tbody></table>
<p><strong>小结</strong></p>
<ul>
<li>主从延迟 <strong>无法完全避免</strong>，只能优化降低延迟时间。</li>
<li>业务层面应结合 <strong>缓存、读写分离策略、关键业务走主库</strong> 等方式综合解决。</li>
<li>技术层面可优化 <strong>并行复制、网络、硬件</strong> 等。</li>
</ul>
<h2 id="MySQL-读写分离-分库分表"><a href="#MySQL-读写分离-分库分表" class="headerlink" title="MySQL 读写分离+分库分表"></a>MySQL 读写分离+分库分表</h2><h3 id="【中等】如何实现-MySQL-读写分离？"><a href="#【中等】如何实现-MySQL-读写分离？" class="headerlink" title="【中等】如何实现 MySQL 读写分离？"></a>【中等】如何实现 MySQL 读写分离？</h3><p><strong>读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作</strong>。</p>
<blockquote>
<p>为何要读写分离？</p>
</blockquote>
<ul>
<li><strong>有效减少锁竞争</strong> - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。</li>
<li><strong>提高查询吞吐量</strong> - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</li>
<li><strong>提升数据库可用性</strong> - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</li>
</ul>
<p>读写分离的实现是根据 SQL 语义分析，将读操作和写操作分别路由至主库与从库。</p>
<p>读写分离有两种实现方式：代码封装、中间件。以下是两种方案的对比：</p>
<table>
<thead>
<tr>
<th align="left"><strong>方案</strong></th>
<th align="left"><strong>实现方式</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码封装</strong></td>
<td align="left">业务层通过代理类路由读写请求（读走从库，写走主库）。</td>
<td align="left">简单灵活，可定制化 - 适合业务特定需求</td>
<td align="left">主从切换需修改配置并重启 - 多语言需重复开发</td>
</tr>
<tr>
<td align="left"><strong>中间件</strong></td>
<td align="left">独立代理服务（如 MySQL-Proxy、ShardingSphere），客户端无感知。</td>
<td align="left">屏蔽多语言差异，统一管理数据源</td>
<td align="left">有额外维护成本，可能成为性能瓶颈</td>
</tr>
</tbody></table>
<blockquote>
<p>结论：<strong>代码封装</strong>适合简单架构，但扩展性差；<strong>中间件</strong>适合复杂架构，但需维护。</p>
</blockquote>
<p><strong>常见的读写分离中间件</strong></p>
<ul>
<li><strong>MySQL-Proxy</strong>（官方）</li>
<li><strong>Atlas</strong>（360）</li>
<li><strong>ShardingSphere</strong>（Apache）</li>
<li><strong>Mycat</strong></li>
</ul>
<h3 id="【中等】什么是分库分表？为何要分库分表？"><a href="#【中等】什么是分库分表？为何要分库分表？" class="headerlink" title="【中等】什么是分库分表？为何要分库分表？"></a>【中等】什么是分库分表？为何要分库分表？</h3><blockquote>
<p>什么是分库分表？</p>
</blockquote>
<p><strong>分库分表</strong>是一种数据库水平拆分方案，用于解决单机数据库的<strong>存储瓶颈</strong>和<strong>性能瓶颈</strong>问题。</p>
<ul>
<li><strong>分库</strong>：将数据分散到不同的数据库实例（如 <code>DB1</code>、<code>DB2</code>）。</li>
<li><strong>分表</strong>：将数据分散到同一数据库的不同表（如 <code>order_1</code>、<code>order_2</code>）。</li>
</ul>
<blockquote>
<p>为何要分库分表？</p>
</blockquote>
<p>分库分表主要基于以下理由：</p>
<ul>
<li><strong>并发连接</strong> - 一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。</li>
<li><strong>磁盘容量</strong> - 磁盘容量占满，会导致服务器不可用。</li>
<li><strong>SQL 性能</strong> - 单表数据量过大，会导致 SQL 执行效率低下。一般，单表超过 1000 万条数据，就可以考虑分表了。</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>分库分表前</th>
<th>分库分表后</th>
</tr>
</thead>
<tbody><tr>
<td>并发支撑情况</td>
<td>MySQL 单机部署，扛不住高并发</td>
<td>MySQL 从单机到多机，能承受的并发增加了多倍</td>
</tr>
<tr>
<td>磁盘使用情况</td>
<td>MySQL 单机磁盘容量几乎撑满</td>
<td>拆分为多个库，数据库服务器磁盘使用率大大降低</td>
</tr>
<tr>
<td>SQL 执行性能</td>
<td>单表数据量太大，SQL 越跑越慢</td>
<td>单表数据量减少，SQL 执行效率明显提升</td>
</tr>
</tbody></table>
<h3 id="【中等】分库分表有哪些策略？"><a href="#【中等】分库分表有哪些策略？" class="headerlink" title="【中等】分库分表有哪些策略？"></a>【中等】分库分表有哪些策略？</h3><p>分库分表策略主要有两种：</p>
<ul>
<li>根据数值范围划分</li>
<li>根据 Hash 划分</li>
<li>路由表</li>
</ul>
<h4 id="数值范围路由"><a href="#数值范围路由" class="headerlink" title="数值范围路由"></a>数值范围路由</h4><p>数值范围路由，就是根据 ID、时间范围 这类具有排序性的字段来进行划分。例如：用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。</p>
<p>按这种策略划分出来的数据，具有数据连续性。</p>
<ul>
<li><strong>优点</strong>：数据迁移很简单。</li>
<li><strong>缺点</strong>：容易产生热点问题，大量的流量都打在最新的数据上了。</li>
</ul>
<h4 id="Hash-路由"><a href="#Hash-路由" class="headerlink" title="Hash 路由"></a>Hash 路由</h4><p>典型的 Hash 路由，如根据数值取模，当需要扩容时，一般以 2 的幂次方进行扩容（这样，扩容时迁移的数据量会小一些）。例如：用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。</p>
<p>一般采用 <strong>预分区</strong> 的方式，提前根据 <strong>数据量</strong> 规划好 <strong>分区数</strong>，比如划分为 <code>512</code> 或 <code>1024</code> 张表，保证可支撑未来一段时间的 <strong>数据容量</strong>，再根据 <strong>负载情况</strong> 将 <strong>表</strong> 迁移到其他 <strong>数据库</strong> 中。扩容时通常采用 <strong>翻倍扩容</strong>，避免 <strong>数据映射</strong> 全部被 <strong>打乱</strong>，导致 <strong>全量迁移</strong> 的情况。</p>
<ul>
<li><strong>优点</strong>：数据离散分布，不存在热点问题。</li>
<li><strong>缺点</strong>：数据迁移、扩容麻烦（之前的数据需要重新计算 hash 值重新分配到不同的库或表）。当节点数量变化时，如<strong>扩容</strong>或<strong>收缩</strong>节点，数据节点<strong>映射关系</strong>需要重新计算，会导致数据的 <strong>重新迁移</strong>。</li>
</ul>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>这种策略，就是用一张独立的表记录路由信息。</p>
<ul>
<li><strong>优点</strong>：简单、灵活，尤其是在扩容、迁移时，只需要迁移指定的数据，然后修改路由表即可。</li>
<li><strong>缺点</strong>：每次查询，必须先查路由表，增加了 IO 开销。并且，如果路由表本身太大，也会面临性能瓶颈，如果想对路由表再做分库分表，将出现死循环式的路由算法选择问题。</li>
</ul>
<h3 id="【困难】分库分表存在哪些问题？"><a href="#【困难】分库分表存在哪些问题？" class="headerlink" title="【困难】分库分表存在哪些问题？"></a>【困难】分库分表存在哪些问题？</h3><p>分库分表主要存在以下问题：</p>
<ul>
<li><strong>分布式 ID 问题</strong></li>
<li><strong>分布式事务问题</strong></li>
<li><strong>跨节点 Join 和聚合</strong></li>
<li><strong>跨分片的排序分页</strong></li>
</ul>
<h4 id="分布式-ID-问题"><a href="#分布式-ID-问题" class="headerlink" title="分布式 ID 问题"></a>分布式 ID 问题</h4><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。</p>
<blockquote>
<p>分布式 ID 的解决方案详见：<a href="https://dunwu.github.io/waterdrop/pages/058bdd15/">分布式 ID</a></p>
</blockquote>
<h4 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h4><p>跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</p>
<blockquote>
<p>分布式事务的解决方案详见：<a href="https://dunwu.github.io/waterdrop/pages/f293688d/">分布式事务</a></p>
</blockquote>
<h4 id="跨节点-Join-和聚合"><a href="#跨节点-Join-和聚合" class="headerlink" title="跨节点 Join 和聚合"></a>跨节点 Join 和聚合</h4><p>分库分表后，无法直接跨节点 <code>join</code> 、<code>count</code>、<code>order by</code>、<code>group by</code> 以及聚合。</p>
<p>针对这类问题，普遍做法是<strong>二次查询</strong>。</p>
<ul>
<li><p>在第一次查询时，获取各个节点上的结果。</p>
</li>
<li><p>在程序中将这些结果进行合并、筛选。</p>
</li>
</ul>
<h4 id="跨分片的排序分页"><a href="#跨分片的排序分页" class="headerlink" title="跨分片的排序分页"></a>跨分片的排序分页</h4><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506050815256.webp"></p>
<p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506050816625.webp"></p>
<p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p>
<p>那如何解决分库情况下的分页问题呢？有以下几种办法：</p>
<p>如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p>
<p>如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p>
<p>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p>
<h3 id="【困难】如何实现迁库和扩容？"><a href="#【困难】如何实现迁库和扩容？" class="headerlink" title="【困难】如何实现迁库和扩容？"></a>【困难】如何实现迁库和扩容？</h3><h4 id="停机迁移-扩容（不推荐）"><a href="#停机迁移-扩容（不推荐）" class="headerlink" title="停机迁移&#x2F;扩容（不推荐）"></a>停机迁移&#x2F;扩容（不推荐）</h4><p>停机迁移&#x2F;扩容是最暴力、最简单的迁移、扩容方案。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601114836.png"></p>
<p><strong>停机迁移&#x2F;扩容流程</strong>：</p>
<ol>
<li>预估停服时间，发布停服公告；停服，不允许数据访问。</li>
<li>编写临时的数据导入程序，从老数据库中读取数据。</li>
<li>将数据写入中间件。</li>
<li>中间件根据分片规则，将数据分发到分库（分表）中。</li>
<li>应用程序修改配置，重启。</li>
</ol>
<p><strong>停机迁移&#x2F;扩容方案分析</strong>：</p>
<ul>
<li><strong>优点</strong>：简单、无数据一致性问题。</li>
<li><strong>缺点</strong>：<ul>
<li>停服时间长（数据量大时可能需数小时）。</li>
<li>风险高，失败后难以回滚。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：代价过高，不推荐使用。</p>
<h4 id="双写迁移"><a href="#双写迁移" class="headerlink" title="双写迁移"></a>双写迁移</h4><p><strong>双写迁移方案核心思想</strong>：</p>
<ul>
<li>新旧库同时写入，通过开关控制读写状态（只写旧库、只写新库、双写）。</li>
<li>逐步切换读请求到新库，确保数据一致性。</li>
</ul>
<p><strong>双写迁移方案关键步骤</strong>：</p>
<ol>
<li><strong>双写阶段</strong>：先写旧库，再写新库，以旧库结果为准。记录旧库成功但新库失败的日志，用于补偿。</li>
<li><strong>数据校验</strong>：运行对比程序，检查新旧库数据差异并修复。</li>
<li><strong>灰度切换读请求</strong>：逐步将读流量切至新库，观察稳定性。</li>
<li><strong>最终切换</strong>：读写全部切至新库，清理旧库冗余数据。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601135751.png"></p>
<p><strong>双写迁移流程</strong>：</p>
<ol>
<li>修改应用程序配置，将数据同时写入老数据库和中间件。这就是所谓的<strong>双写</strong>，同时写俩库，老库和新库。</li>
<li>编写临时程序，读取老数据库。</li>
<li>将数据写入中间件。如果数据不存在，直接写入；如果数据存在，比较时间戳，只允许新数据覆盖老数据。</li>
<li>导入数据后，有可能数据还是存在不一致，那么就对数据进行校验，比对新老库的每条数据。如果存在差异，针对差异数据，执行（3）。循环（3）、（4）步骤，直至数据完全一致。</li>
<li>修改应用程序配置，将数据只写入中间件。</li>
<li>中间件根据分片规则，将数据分发到分库（分表）中。</li>
</ol>
<p><strong>双写迁移方案分析</strong>：</p>
<p><strong>优点</strong>：</p>
<ul>
<li>无需停服，业务影响小。</li>
<li>可灰度验证，风险可控。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>实现复杂，需处理双写一致性和补偿逻辑。</li>
</ul>
<h4 id="主从替换"><a href="#主从替换" class="headerlink" title="主从替换"></a>主从替换</h4><p>生产环境的数据库，为了保证高可用，一般会采用主从架构。主库支持读写操作，从库支持读操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601121215.png"></p>
<p>由于主从节点数据一致，所以将从库升级为主节点，并修改分片配置，将从节点作为分库之一，就实现了扩容。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601121400.png"></p>
<p><strong>主从替换方案流程</strong>：</p>
<ol>
<li>解除主从关系，从库升级为主库。</li>
<li>应用程序，修改配置，读写通过中间件。</li>
<li>分库分表中间，修改分片配置。将数据按照新的规则分发。</li>
<li>编写临时程序，清理冗余数据。比如：原来是一个单库，数据量为 400 万。从节点升级为分库之一后，每个分库都有 400 万数据，其中 200 万是冗余数据。清理完后，进行数据校验。</li>
<li>为每个分库添加新的从库，保证高可用。</li>
</ol>
<p><strong>主从替换方案分析</strong>：</p>
<ul>
<li><strong>无需停机</strong>，无需全量数据迁移。</li>
<li>利用现有从库资源，节省成本。</li>
</ul>
<h4 id="三种方案对比"><a href="#三种方案对比" class="headerlink" title="三种方案对比"></a>三种方案对比</h4><table>
<thead>
<tr>
<th align="left"><strong>方案</strong></th>
<th align="left"><strong>适用场景</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>停机迁移</strong></td>
<td align="left">小规模数据，容忍停服</td>
<td align="left">简单，无一致性问题</td>
<td align="left">停服时间长，风险高</td>
</tr>
<tr>
<td align="left"><strong>双写迁移</strong></td>
<td align="left">大规模数据，要求高可用</td>
<td align="left">无停服，灰度可控</td>
<td align="left">复杂，需补偿机制</td>
</tr>
<tr>
<td align="left"><strong>主从替换</strong></td>
<td align="left">已有主从架构</td>
<td align="left">无需迁移数据，快速扩容</td>
<td align="left">依赖现有从库，清理冗余复杂</td>
</tr>
</tbody></table>
<p><strong>推荐选择</strong>：</p>
<ul>
<li><strong>优先双写迁移</strong>：适合大多数业务，平衡风险与复杂度。</li>
<li><strong>主从升级</strong>：适合已有主从且数据量适中的场景。</li>
<li><strong>避免停机迁移</strong>：除非数据量极小且可接受停服。</li>
</ul>
<h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><h3 id="【中等】SQL-查询语句的执行顺序是怎么样的？"><a href="#【中等】SQL-查询语句的执行顺序是怎么样的？" class="headerlink" title="【中等】SQL 查询语句的执行顺序是怎么样的？"></a>【中等】SQL 查询语句的执行顺序是怎么样的？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506050817770.jpg"></p>
<p>所有的查询语句都是从 FROM 开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。</p>
<p><strong>执行顺序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8</span>) <span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span><span class="operator">&lt;</span>Select_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span> (<span class="number">3</span>) <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span><span class="keyword">JOIN</span><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span><span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span><span class="operator">|</span><span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span><span class="operator">&lt;</span>having_condtion<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">11</span>) LIMIT<span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77847158">SQL 的书写顺序和执行顺序</a></p>
</blockquote>
<h3 id="【困难】一条-SQL-查询语句是如何执行的？"><a href="#【困难】一条-SQL-查询语句是如何执行的？" class="headerlink" title="【困难】一条 SQL 查询语句是如何执行的？"></a>【困难】一条 SQL 查询语句是如何执行的？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202410022029759.png"></p>
<p>MySQL 整个查询执行过程，总的来说分为 6 个步骤：</p>
<ol>
<li><strong>连接器</strong> - 客户端和 MySQL 服务器建立连接；连接器负责跟客户端<strong>建立连接</strong>、<strong>获取权限</strong>、<strong>维持和管理连接</strong>。</li>
<li><strong>查询缓存</strong> - MySQL 服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。MySQL 缓存弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li>
<li><strong>分析器</strong> - MySQL 服务器进行 SQL 解析：<strong>语法分析</strong>、<strong>词法分析</strong>。</li>
<li><strong>优化器</strong> - MySQL 服务器用优化器<strong>生成对应的执行计划</strong>，<strong>根据策略选择最优索引</strong>。</li>
<li><strong>执行器</strong> - MySQL 服务器根据执行计划，调用存储引擎的 API 来<strong>执行查询</strong>。</li>
<li><strong>返回结果</strong> - MySQL 服务器将结果返回给客户端，同时缓存查询结果。</li>
</ol>
<h3 id="【困难】一条-SQL-更新语句是如何执行的？"><a href="#【困难】一条-SQL-更新语句是如何执行的？" class="headerlink" title="【困难】一条 SQL 更新语句是如何执行的？"></a>【困难】一条 SQL 更新语句是如何执行的？</h3><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p>
<ul>
<li><strong>redo log（重做日志）</strong><ul>
<li>InnoDB 存储引擎独有的日志（物理日志）</li>
<li>采用循环写入</li>
</ul>
</li>
<li><strong>bin log（归档日志）</strong><ul>
<li>MySQL Server 层通用日志（逻辑日志）</li>
<li>采用追加写入</li>
</ul>
</li>
</ul>
<p>为了保证 redo log 和 bin log 的数据一致性，所以采用两阶段提交方式更新日志。</p>
<h3 id="【困难】MySQL-如何选择执行计划？"><a href="#【困难】MySQL-如何选择执行计划？" class="headerlink" title="【困难】MySQL 如何选择执行计划？"></a>【困难】MySQL 如何选择执行计划？</h3><h1 id="MySQL-执行计划选择机制"><a href="#MySQL-执行计划选择机制" class="headerlink" title="MySQL 执行计划选择机制"></a><strong>MySQL 执行计划选择机制</strong></h1><p>MySQL 通过优化器（Optimizer）选择执行计划，核心流程如下：</p>
<p><strong>执行计划生成步骤</strong></p>
<ol>
<li><strong>解析 SQL</strong>：生成语法树，检查表&#x2F;列是否存在</li>
<li><strong>预处理阶段</strong>：展开视图、优化子查询</li>
<li><strong>优化器核心工作</strong>：<ul>
<li><strong>生成候选执行计划</strong>（全表扫描、索引扫描、JOIN 顺序等）</li>
<li><strong>成本估算</strong>（基于统计信息计算每个计划的 I&#x2F;O、CPU 消耗）</li>
<li><strong>选择成本最低的计划</strong></li>
</ul>
</li>
</ol>
<p><strong>影响执行计划的关键因素</strong></p>
<table>
<thead>
<tr>
<th>因素</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统计信息</strong></td>
<td>表大小、索引区分度等</td>
<td><code>ANALYZE TABLE</code>更新统计</td>
</tr>
<tr>
<td><strong>索引情况</strong></td>
<td>可用索引及其选择性</td>
<td>高区分度索引优先</td>
</tr>
<tr>
<td><strong>查询复杂度</strong></td>
<td>JOIN&#x2F;子查询数量</td>
<td>简单查询优先走索引</td>
</tr>
<tr>
<td><strong>系统变量</strong></td>
<td>优化器开关配置</td>
<td><code>optimizer_switch</code>参数</td>
</tr>
<tr>
<td><strong>HINT 指令</strong></td>
<td>强制干预优化器</td>
<td><code>/*+ INDEX(idx_name) */</code></td>
</tr>
</tbody></table>
<p><strong>成本估算模型</strong></p>
<p>优化器主要计算：</p>
<ul>
<li><strong>I&#x2F;O 成本</strong>：读取数据页的代价</li>
<li><strong>CPU 成本</strong>：处理数据的计算代价</li>
<li><strong>内存成本</strong>：排序&#x2F;临时表消耗</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总成本 = （数据页读取数 × 单页 I/O 成本）</span><br><span class="line">       + （扫描行数 × 行 CPU 处理成本）</span><br><span class="line">       + （排序行数 × 排序成本）</span><br></pre></td></tr></table></figure>

<p><strong>查看和干预执行计划</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看执行计划</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制使用索引（慎用）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(users idx_age) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新统计信息</span></span><br><span class="line">ANALYZE <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure>

<p><strong>常见执行计划问题</strong></p>
<ul>
<li><p><strong>索引失效</strong>：函数计算、隐式类型转换</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例：索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2023</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误 JOIN 顺序</strong>：解决方案：使用<code>STRAIGHT_JOIN</code>强制顺序</p>
</li>
<li><p><strong>临时表&#x2F;文件排序</strong>：关注<code>EXPLAIN</code>中的<code>Using temporary</code>&#x2F;<code>Using filesort</code></p>
</li>
</ul>
<p><strong>优化建议</strong></p>
<ul>
<li>定期<code>ANALYZE TABLE</code>更新统计信息</li>
<li>避免在索引列上使用函数</li>
<li>使用覆盖索引减少回表</li>
<li>监控<code>performance_schema</code>中的 SQL 执行历史</li>
</ul>
<blockquote>
<p><strong>注意</strong>：MySQL 8.0 引入直方图统计（<code>histogram</code>）和代价模型改进，大幅提升复杂查询的计划准确性。</p>
</blockquote>
<h3 id="【困难】order-by-是怎么工作的？"><a href="#【困难】order-by-是怎么工作的？" class="headerlink" title="【困难】order by 是怎么工作的？"></a>【困难】<code>order by</code> 是怎么工作的？</h3><p>用 explain 命令查看执行计划时，Extra 这个字段中的“Using filesort”表示的就是需要排序。</p>
<h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句执行流程如下所示 ：</p>
<p><strong>执行流程</strong>：</p>
<ul>
<li>初始化 <code>sort_buffer</code>，确定放入需要排序的字段（如 <code>name</code>、<code>city</code>、<code>age</code>）。</li>
<li>从索引中找到满足条件的记录，取出对应的字段值存入 <code>sort_buffer</code>。</li>
<li>对 <code>sort_buffer</code> 中的数据按照排序字段进行排序。</li>
<li>返回排序后的结果。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090300.png"></p>
<p><strong>内存与磁盘排序</strong>：</p>
<ul>
<li>如果排序数据量小于 <code>sort_buffer_size</code>，排序在内存中完成。</li>
<li>如果数据量过大，MySQL 会使用临时文件进行外部排序（归并排序）。<strong>MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</strong></li>
</ul>
<p><strong>优化器追踪</strong>：通过 <code>OPTIMIZER_TRACE</code> 可以查看排序过程中是否使用了临时文件（<code>number_of_tmp_files</code>）。</p>
<h4 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h4><ul>
<li><strong>执行流程</strong>：<ul>
<li>当单行数据过大时，MySQL 会采用 <code>rowid</code> 排序，只将排序字段（如 <code>name</code>）和主键 <code>id</code> 放入 <code>sort_buffer</code>。</li>
<li>排序完成后，根据 <code>id</code> 回表查询其他字段（如 <code>city</code>、<code>age</code>）。</li>
</ul>
</li>
<li><strong>性能影响</strong>：<code>rowid</code> 排序减少了 <code>sort_buffer</code> 的内存占用，但增加了回表操作，导致更多的磁盘 I&#x2F;O。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090919.png"></p>
<h4 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h4><ul>
<li><strong>内存优先</strong>：<ul>
<li>如果内存足够大，MySQL 优先使用全字段排序，以减少磁盘访问。</li>
<li>只有在内存不足时，才会使用 <code>rowid</code> 排序。</li>
</ul>
</li>
<li><strong>设计思想</strong>：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></li>
</ul>
<p>并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的</strong>。如果查询的字段和排序字段可以通过联合索引覆盖，MySQL 可以直接利用索引的有序性，避免排序操作。</p>
<h2 id="MySQL-优化"><a href="#MySQL-优化" class="headerlink" title="MySQL 优化"></a>MySQL 优化</h2><h3 id="【简单】如何发现慢-SQL？"><a href="#【简单】如何发现慢-SQL？" class="headerlink" title="【简单】如何发现慢 SQL？"></a>【简单】如何发现慢 SQL？</h3><p>慢 SQL 的监控主要通过两个途径：</p>
<ul>
<li><strong>慢查询日志</strong>：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li>
<li><strong>服务监控</strong>：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。</li>
</ul>
<h3 id="【简单】什么是执行计划？"><a href="#【简单】什么是执行计划？" class="headerlink" title="【简单】什么是执行计划？"></a>【简单】什么是执行计划？</h3><p><strong>“执行计划”是对 SQL 查询语句在数据库中执行过程的描述</strong>。 如果要分析某条 SQL 的性能问题，通常需要先查看 SQL 的执行计划，排查每一步 SQL 执行是否存在问题。</p>
<p>很多数据库都支持执行计划，MySQL 也不例外。在 MySQL 中，用户可以通过 <code>EXPLAIN</code> 命令查看优化器针对指定 SQL 生成的逻辑执行计划。</p>
<p>【示例】MySQL 执行计划示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line"><span class="keyword">          key</span>: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>执行计划返回结果参数说明：</p>
<ul>
<li><code>id</code> - SELECT 查询的标识符。每个 <code>SELECT</code> 都会自动分配一个唯一的标识符。</li>
<li><code>select_type</code> - <code>SELECT</code> 查询的类型。<ul>
<li><code>SIMPLE</code> - 表示此查询不包含 <code>UNION</code> 查询或子查询。</li>
<li><code>PRIMARY</code> - 表示此查询是最外层的查询。</li>
<li><code>UNION</code> - 表示此查询是 <code>UNION</code> 的第二或随后的查询。</li>
<li><code>DEPENDENT UNION</code> - <code>UNION</code> 中的第二个或后面的查询语句，取决于外面的查询。</li>
<li><code>UNION RESULT</code> - <code>UNION</code> 的结果。</li>
<li><code>SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>。</li>
<li><code>DEPENDENT SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>, 取决于外面的查询。即子查询依赖于外层查询的结果。</li>
</ul>
</li>
<li><code>table</code> - 查询的是哪个表，如果给表起别名了，则显示别名。</li>
<li><code>partitions</code> - 匹配的分区。</li>
<li><code>type</code> - 表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标。执行效率由高到低依次为：<ul>
<li><code>system</code>&#x2F;<code>const</code> - 表中只有一行数据匹配。此时根据索引查询一次就能找到对应的数据。如果是 B+ 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。<code>const</code> 表示此时索引在第一层，只需访问一层便能得到数据。</li>
<li><code>eq_ref</code> - 使用唯一索引扫描。常见于多表连接中使用主键和唯一索引作为关联条件。</li>
<li><code>ref</code> - 非唯一索引扫描。还可见于唯一索引最左原则匹配扫描。</li>
<li><code>range</code> - 索引范围扫描。比如 <code>&lt;</code>，<code>&gt;</code>，<code>between</code> 等操作。</li>
<li><code>index</code> - 索引全表扫描。此时遍历整个索引树。</li>
<li><code>ALL</code> - 表示全表扫描。需要遍历全表来找到对应的行。</li>
</ul>
</li>
<li><code>possible_keys</code> - 此次查询中可能选用的索引。</li>
<li><code>key</code> - 此次查询中实际使用的索引。如果这一项为 <code>NULL</code>，说明没有使用索引。</li>
<li><code>ref</code> - 哪个字段或常数与 key 一起被使用。</li>
<li><code>rows</code> - 显示此查询一共扫描了多少行，这个是一个估计值。</li>
<li><code>filtered</code> - 表示此查询条件所过滤的数据的百分比。</li>
<li><code>extra</code> - 额外的信息。<ul>
<li><code>Using index</code> - 使用覆盖索引，无需回表。</li>
<li><code>Using where</code> - 服务器在存储引擎检索后过滤。</li>
<li><code>Using temporary</code> - 使用临时表。MySQL 在对查询结果排序时使用临时表，常见于排序 <code>ORDER BY</code> 和分组查询 <code>GROUP BY</code>。效率低，要避免这种问题的出现。</li>
<li><code>Using filesort</code> - 额外排序。无法利用索引完成排序时，就不得不将查询匹配数据进行排序，甚至可能会通过文件进行排序，效率很低。</li>
<li><code>Using join buffer</code> - 使用连接缓冲</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多内容请参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></p>
</blockquote>
<h3 id="【简单】如何分析执行计划？"><a href="#【简单】如何分析执行计划？" class="headerlink" title="【简单】如何分析执行计划？"></a>【简单】如何分析执行计划？</h3><p><strong>执行计划关键字段</strong></p>
<ul>
<li><strong><code>type</code></strong> - 按性能从高到低排序：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code>。目标应尽可能避免 <code>ALL</code>（全表扫描）。</li>
<li><strong><code>possible_keys</code></strong> - 可能使用的索引。</li>
<li><strong><code>key</code></strong> - 实际使用的索引。</li>
<li><strong><code>rows</code></strong> - 预估需要检查的行数，值越小越好。</li>
<li><strong><code>Extra</code></strong> - 包含重要补充信息。</li>
</ul>
<p><strong>执行计划分析步骤</strong>：</p>
<ol>
<li>查看 <code>type</code> - 确保访问类型为 <code>const</code> 、 <code>eq_ref</code> 、 <code>ref</code> 或 <code>range</code> ，避免 <code>ALL</code> 。</li>
<li>查看 <code>key</code> - 确认是否使用了合适的索引。若 <code>key</code> 为 <code>NULL</code> 表示未使用索引，需优化。</li>
<li>查看 <code>rows</code> - 扫描的行数越少越好。</li>
<li>查看 <code>Extra</code> - 避免 <code>Using temporary</code>（使用临时表） 和 <code>Using filesort</code> （额外排序）。</li>
</ol>
<p>对应优化：</p>
<ul>
<li>如果 <code>type</code> 为 <code>ALL</code>，考虑为 <code>WHERE</code> 条件列添加索引。</li>
<li>如果 <code>Extra</code> 包含 <code>Using filesort</code> ，优化 <code>ORDER BY</code> 或 <code>GROUP BY</code> 。</li>
<li>如果 <code>rows</code> 过大，检查索引是否有效。</li>
</ul>
<h3 id="【中等】如何优化-SQL？"><a href="#【中等】如何优化-SQL？" class="headerlink" title="【中等】如何优化 SQL？"></a>【中等】如何优化 SQL？</h3><h4 id="避免不必要的列"><a href="#避免不必要的列" class="headerlink" title="避免不必要的列"></a>避免不必要的列</h4><p>这个是老生常谈，但还是经常会出的情况，SQL 查询的时候，应该只查询需要的列，而不要包含额外的列，像<code>slect *</code> 这种写法应该尽量避免。</p>
<h4 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h4><p>在数据量比较大，分页比较深的情况下，需要考虑分页的优化。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190289</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>优化方案：</p>
<ul>
<li><strong>延迟关联</strong></li>
</ul>
<p>先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> a,</span><br><span class="line"> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190289</span>,<span class="number">10</span> ) b</span><br><span class="line"> <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>书签方式</strong></li>
</ul>
<p>书签方式就是找到 limit 第一个参数对应的主键值，根据这个主键值再去过滤并 limit</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190</span></span><br></pre></td></tr></table></figure>

<h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><p>合理地设计和使用索引，是优化慢 SQL 的利器。</p>
<p><strong>利用覆盖索引</strong></p>
<p>InnoDB 使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p>
<p>例如对于如下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> test <span class="keyword">add</span> index idx_city_name (city, name);</span><br></pre></td></tr></table></figure>

<p><strong>低版本避免使用 or 查询</strong></p>
<p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p>
<p><strong>避免使用 !&#x3D; 或者 &lt;&gt; 操作符</strong></p>
<p>SQL 中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p>
<p>解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描</p>
<p>例如，把<code>column&lt;&gt;’aaa’，改成 column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p>
<p><strong>适当使用前缀索引</strong></p>
<p>适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。</p>
<p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> test <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>PS: 需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引</p>
<p><strong>避免列上函数运算</strong></p>
<p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">month</span>(updateTime) <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p><strong>正确使用联合索引</strong></p>
<p>使用联合索引的时候，注意最左匹配原则。</p>
<h4 id="JOIN-优化"><a href="#JOIN-优化" class="headerlink" title="JOIN 优化"></a>JOIN 优化</h4><p><strong>优化子查询</strong></p>
<p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p>
<p><strong>小表驱动大表</strong></p>
<p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL 内部会遍历驱动表，再去连接被驱动表。</p>
<p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B ;</span><br></pre></td></tr></table></figure>

<p><strong>适当增加冗余字段</strong></p>
<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>
<p><strong>避免使用 JOIN 关联太多的表</strong></p>
<p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p>
<p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p>
<h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p><strong>利用索引扫描做排序</strong></p>
<p>MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p>
<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢</p>
<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建立索引（date,staff_id,customer_id）</span></span><br><span class="line"><span class="keyword">select</span> staff_id, customer_id <span class="keyword">from</span> test <span class="keyword">where</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> staff_id,customer_id;</span><br></pre></td></tr></table></figure>

<p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p>
<p><strong>条件下推</strong></p>
<p>MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引</p>
<p>最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化</p>
<p>此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高。</p>
<h3 id="【中等】MySQL-中如何解决深分页问题？"><a href="#【中等】MySQL-中如何解决深分页问题？" class="headerlink" title="【中等】MySQL 中如何解决深分页问题？"></a>【中等】MySQL 中如何解决深分页问题？</h3><p>深分页 (Deep Pagination) 是指当数据量很大时，查询靠后的分页数据（比如第 1000 页）性能急剧下降的问题。</p>
<p>解决方案有以下几种：</p>
<p>（1）<strong>使用索引覆盖+延迟关联</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始深分页查询（性能差）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> large_table</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">    LIMIT <span class="number">100000</span>, <span class="number">10</span></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(id);</span><br></pre></td></tr></table></figure>

<p>（2）<strong>使用游标分页</strong>（记录上一页最后一条记录）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取上一页最后一条记录的 id=12345</span></span><br><span class="line"><span class="comment">-- 下一页查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>使用子查询优化</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> large_table</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> large_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】哪种-COUNT-性能最好？"><a href="#【中等】哪种-COUNT-性能最好？" class="headerlink" title="【中等】哪种 COUNT 性能最好？"></a>【中等】哪种 COUNT 性能最好？</h3><p>先说结论：<strong>按照效率排序的话，<code>COUNT（字段）</code> &lt; <code>COUNT（主键 id)</code> &lt; <code>COUNT(1)</code> ≈ <code>COUNT(*)</code><strong>。</strong>推荐采用 <code>COUNT(*)</code></strong> 。</p>
<p><strong>对于 <code>COUNT（主键 id)</code> 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<p><strong>对于 <code>COUNT(1)</code> 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p>单看这两个用法的差别的话，你能对比出来，<code>COUNT(1)</code> 执行得要比 <code>COUNT（主键 id)</code> 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
<p><strong>对于 <code>COUNT（字段）</code> 来说</strong>：</p>
<ul>
<li>如果这个“字段”是定义为 <code>not null</code> 的话，一行行地从记录里面读出这个字段，判断不能为 <code>null</code>，按行累加；</li>
<li>如果这个“字段”定义允许为 <code>null</code>，那么执行的时候，判断到有可能是 <code>null</code>，还要把值取出来再判断一下，不是 <code>null</code> 才累加。</li>
</ul>
<p><strong>但是 <code>COUNT(*)</code> 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。<code>COUNT(*)</code> 肯定不是 <code>null</code>，按行累加。</p>
<blockquote>
<p>InnoDB 和 MyISAM 的 <code>count(*)</code> 实现方式有什么区别？</p>
</blockquote>
<p>不同的 MySQL 引擎中，<code>COUNT(*)</code> 有不同的实现方式：</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>COUNT(*)</code> 的时候会直接返回这个数，效率很高；</li>
<li>而 InnoDB 引擎就麻烦了，它执行 <code>COUNT(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<blockquote>
<p>为什么 InnoDB 不跟 MyISAM 一样，也维护一个计数器？</p>
</blockquote>
<p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 <code>COUNT(*)</code> 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。</p>
<ul>
<li>MyISAM 表虽然 <code>COUNT(*)</code> 很快，但是不支持事务；</li>
<li><code>show table status</code> 命令虽然返回很快，但是不准确；</li>
<li>InnoDB 表直接 <code>COUNT(*)</code> 会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<blockquote>
<p>如何优化查询计数？</p>
</blockquote>
<ul>
<li>可以使用 Redis 保存计数，但存在数据丢失和逻辑不一致的问题。</li>
<li>可以使用数据库其他表保存计数，利用事务的原子性和隔离性，可以避免数据丢失和逻辑不一致的问题。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/">图解 MySQL 介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b39ce786/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b39ce786/" class="post-title-link" itemprop="url">MongoDB 建模</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-12 10:43:53" itemprop="dateCreated datePublished" datetime="2020-09-12T10:43:53+08:00">2020-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-建模"><a href="#MongoDB-建模" class="headerlink" title="MongoDB 建模"></a>MongoDB 建模</h1><p>::: info 概述</p>
<p>数据建模是指对数据库中的数据以及相关实体间的链接进行组织。MongoDB 中的数据具有<strong>灵活的模式模型</strong>，因此：</p>
<ul>
<li>单个 <a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-collection">集合</a> 中的 <a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/reference/glossary/#std-term-document">文档</a> 不必具有相同的字段集。</li>
<li>字段的数据类型可能因集合中的文档而异。</li>
</ul>
<p>通常，集合中的文档具有相似的结构。为确保数据模型的一致性，可以创建 <a target="_blank" rel="noopener" href="https://www.mongodb.com/zh-cn/docs/manual/core/schema-validation/#std-label-schema-validation-overview">模式验证规则</a>。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/b39ce786/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/79c04432/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/79c04432/" class="post-title-link" itemprop="url">MongoDB 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-09 20:47:14" itemprop="dateCreated datePublished" datetime="2020-09-09T20:47:14+08:00">2020-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-运维"><a href="#MongoDB-运维" class="headerlink" title="MongoDB 运维"></a>MongoDB 运维</h1><p>::: info 概述</p>
<p>本文介绍了 MongoDB 的基本安装、备份和恢复、数据导入导出。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/79c04432/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9bd04ae6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9bd04ae6/" class="post-title-link" itemprop="url">sqoop</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-09 17:53:08" itemprop="dateCreated datePublished" datetime="2020-09-09T17:53:08+08:00">2020-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h1><h2 id="Sqoop-简介"><a href="#Sqoop-简介" class="headerlink" title="Sqoop 简介"></a>Sqoop 简介</h2><p><strong>Sqoop 是一种工具，旨在在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
<p>Sqoop 是一个常用的数据迁移工具，主要用于在不同存储系统之间实现数据的导入与导出：</p>
<ul>
<li>导入数据：从 MySQL，Oracle 等关系型数据库中导入数据到 HDFS、Hive、HBase 等分布式文件存储系统中；</li>
<li>导出数据：从 分布式文件系统中导出数据到关系数据库中。</li>
</ul>
<p><img src="https://cdn-media-1.freecodecamp.org/images/rEfjXBnXyMjmyvtcIub-cxby3LS31vpFCFyt" alt="Image"></p>
<p>目前 Sqoop 主要分为 Sqoop1 和 Sqoop2 两个版本，其中，版本号为 1.4.x 属于 Sqoop1，而版本号为 1.99.x 的属于 Sqoop2。这两个版本开发时的定位方向不同，体系结构具有很大的差异，因此它们之间互不兼容。</p>
<p>Sqoop1 功能结构简单，部署方便，提供命令行操作方式，主要适用于系统服务管理人员进行简单的数据迁移操作；Sqoop2 功能完善、操作简便，同时支持多种访问模式（命令行操作、Web 访问、Rest API），引入角色安全机制增加安全性等多种优点，但是结构复杂，配置部署更加繁琐。</p>
<p>Sqoop 社区提供了多种连接器，可以在很多数据存储之间进行数据迁移。</p>
<ul>
<li><strong>内置连接器</strong><ul>
<li>经过优化的专用 RDBMS 连接器：MySQL、PostgreSQL、Oracle、DB2、SQL Server、Netzza 等</li>
<li>通用的 JDBC 连接器：支持 JDBC 协议的数据库</li>
</ul>
</li>
<li><strong>第三方连接器</strong><ul>
<li>数据仓库：Teradata</li>
<li>NoSQL 数据库：Couchbase</li>
</ul>
</li>
</ul>
<h2 id="Sqoop-原理"><a href="#Sqoop-原理" class="headerlink" title="Sqoop 原理"></a>Sqoop 原理</h2><p><strong>Sqoop 的工作原理是：将执行命令转化成 MapReduce 作业来实现数据的迁移</strong>。</p>
<h3 id="导入原理"><a href="#导入原理" class="headerlink" title="导入原理"></a>导入原理</h3><p>在导入数据之前，Sqoop 使用 JDBC 检查导入的数据表，检索出表中的所有列以及列的 SQL 数据类型，并将这些 SQL 类型映射为 Java 数据类型。在转换后的 MapReduce 应用中使用这些对应的 Java 类型来保存字段的值，Sqoop 的代码生成器使用这些信息来创建对应表的类，用于保存从表中抽取的记录。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/Sqoop/sqoop-import.png" alt="img"></p>
<h3 id="导出原理"><a href="#导出原理" class="headerlink" title="导出原理"></a>导出原理</h3><p>在导出数据之前，Sqoop 会根据数据库连接字符串来选择一个导出方法，对于大部分系统来说，Sqoop 会选择 JDBC。Sqoop 会根据目标表的定义生成一个 Java 类，这个生成的类能够从文本中解析出记录数据，并能够向表中插入类型合适的值，然后启动一个 MapReduce 作业，从 HDFS 中读取源数据文件，使用生成的类解析出记录，并且执行选定的导出方法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/Sqoop/sqoop-export.png" alt="img"></p>
<h2 id="Sqoop-应用"><a href="#Sqoop-应用" class="headerlink" title="Sqoop 应用"></a>Sqoop 应用</h2><blockquote>
<p>参考手册：</p>
<p><a target="_blank" rel="noopener" href="https://sqoop.apache.org/docs/1.99.7/admin/Installation.html">Sqoop 官方文档之安装说明</a></p>
<p><a target="_blank" rel="noopener" href="https://sqoop.apache.org/docs/1.99.7/user/CommandLineClient.html">Sqoop 官方文档之 Shell 命令</a></p>
<p><a target="_blank" rel="noopener" href="https://sqoop.apache.org/docs/1.99.7/user/CommandLineClient.html">Sqoop 官方文档之连接器</a></p>
</blockquote>
<h3 id="Sqoop-与-MySQL"><a href="#Sqoop-与-MySQL" class="headerlink" title="Sqoop 与 MySQL"></a>Sqoop 与 MySQL</h3><h4 id="查询-MySQL-所有数据库"><a href="#查询-MySQL-所有数据库" class="headerlink" title="查询 MySQL 所有数据库"></a>查询 MySQL 所有数据库</h4><p>通常用于 Sqoop 与 MySQL 连通测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqoop list-databases \</span><br><span class="line">--connect jdbc:mysql://hadoop001:3306/ \</span><br><span class="line">--username root \</span><br><span class="line">--password root</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a908521864b3f952eeea127801a3614e0cb29169e6667c19fa930d5bacd0ed88/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d6c6973742d6461746162617365732e706e67"><img src="https://camo.githubusercontent.com/a908521864b3f952eeea127801a3614e0cb29169e6667c19fa930d5bacd0ed88/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d6c6973742d6461746162617365732e706e67" alt="img"></a></p>
<h4 id="查询指定数据库中所有数据表"><a href="#查询指定数据库中所有数据表" class="headerlink" title="查询指定数据库中所有数据表"></a>查询指定数据库中所有数据表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqoop list-tables \</span><br><span class="line">--connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">--username root \</span><br><span class="line">--password root</span><br></pre></td></tr></table></figure>

<h3 id="Sqoop-与-HDFS"><a href="#Sqoop-与-HDFS" class="headerlink" title="Sqoop 与 HDFS"></a>Sqoop 与 HDFS</h3><h4 id="MySQL-数据导入到-HDFS"><a href="#MySQL-数据导入到-HDFS" class="headerlink" title="MySQL 数据导入到 HDFS"></a>MySQL 数据导入到 HDFS</h4><h5 id="导入命令"><a href="#导入命令" class="headerlink" title="导入命令"></a>导入命令</h5><p>示例：导出 MySQL 数据库中的 <code>help_keyword</code> 表到 HDFS 的 <code>/sqoop</code> 目录下，如果导入目录存在则先删除再导入，使用 3 个 <code>map tasks</code> 并行导入。</p>
<blockquote>
<p>注：help_keyword 是 MySQL 内置的一张字典表，之后的示例均使用这张表。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">--username root \</span><br><span class="line">--password root \</span><br><span class="line">--table help_keyword \           # 待导入的表</span><br><span class="line">--delete-target-dir \            # 目标目录存在则先删除</span><br><span class="line">--target-dir /sqoop \            # 导入的目标目录</span><br><span class="line">--fields-terminated-by &#x27;\t&#x27;  \   # 指定导出数据的分隔符</span><br><span class="line">-m 3                             # 指定并行执行的 map tasks 数量</span><br></pre></td></tr></table></figure>

<p>日志输出如下，可以看到输入数据被平均 <code>split</code> 为三份，分别由三个 <code>map task</code> 进行处理。数据默认以表的主键列作为拆分依据，如果你的表没有主键，有以下两种方案：</p>
<ul>
<li>添加 <code>-- autoreset-to-one-mapper</code> 参数，代表只启动一个 <code>map task</code>，即不并行执行；</li>
<li>若仍希望并行执行，则可以使用 <code>--split-by &lt;column-name&gt;</code> 指明拆分数据的参考列。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c2e23d7fe456107c3351a2da5d2ff651e851e8d36c134339f07297df0a96319a/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d6d61702d7461736b2e706e67"><img src="https://camo.githubusercontent.com/c2e23d7fe456107c3351a2da5d2ff651e851e8d36c134339f07297df0a96319a/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d6d61702d7461736b2e706e67" alt="img"></a></p>
<h5 id="导入验证"><a href="#导入验证" class="headerlink" title="导入验证"></a>导入验证</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看导入后的目录</span></span><br><span class="line">hadoop fs -ls  -R /sqoop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看导入内容</span></span><br><span class="line">hadoop fs -text  /sqoop/part-m-00000</span><br></pre></td></tr></table></figure>

<p>查看 HDFS 导入目录，可以看到表中数据被分为 3 部分进行存储，这是由指定的并行度决定的。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9e788568906a827b27cdcd07c1ee14d2410030a74af0233a06fe00b15a2c54d9/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686466735f6c732e706e67"><img src="https://camo.githubusercontent.com/9e788568906a827b27cdcd07c1ee14d2410030a74af0233a06fe00b15a2c54d9/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686466735f6c732e706e67" alt="img"></a></p>
<h4 id="HDFS-数据导出到-MySQL"><a href="#HDFS-数据导出到-MySQL" class="headerlink" title="HDFS 数据导出到 MySQL"></a>HDFS 数据导出到 MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop export  \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword_from_hdfs \        # 导出数据存储在 MySQL 的 help_keyword_from_hdf 的表中</span><br><span class="line">    --export-dir /sqoop  \</span><br><span class="line">    --input-fields-terminated-by &#x27;\t&#x27;\</span><br><span class="line">    --m 3</span><br></pre></td></tr></table></figure>

<p>表必须预先创建，建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> help_keyword_from_hdfs <span class="keyword">LIKE</span> help_keyword;</span><br></pre></td></tr></table></figure>

<h3 id="Sqoop-与-Hive"><a href="#Sqoop-与-Hive" class="headerlink" title="Sqoop 与 Hive"></a>Sqoop 与 Hive</h3><h4 id="MySQL-数据导入到-Hive"><a href="#MySQL-数据导入到-Hive" class="headerlink" title="MySQL 数据导入到 Hive"></a>MySQL 数据导入到 Hive</h4><p>Sqoop 导入数据到 Hive 是通过先将数据导入到 HDFS 上的临时目录，然后再将数据从 HDFS 上 <code>Load</code> 到 Hive 中，最后将临时目录删除。可以使用 <code>target-dir</code> 来指定临时目录。</p>
<h5 id="导入命令-1"><a href="#导入命令-1" class="headerlink" title="导入命令"></a>导入命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --table help_keyword \        # 待导入的表</span><br><span class="line">  --delete-target-dir \         # 如果临时目录存在删除</span><br><span class="line">  --target-dir /sqoop_hive  \   # 临时目录位置</span><br><span class="line">  --hive-database sqoop_test \  # 导入到 Hive 的 sqoop_test 数据库，数据库需要预先创建。不指定则默认为 default 库</span><br><span class="line">  --hive-import \               # 导入到 Hive</span><br><span class="line">  --hive-overwrite \            # 如果 Hive 表中有数据则覆盖，这会清除表中原有的数据，然后再写入</span><br><span class="line">  -m 3                          # 并行度</span><br></pre></td></tr></table></figure>

<p>导入到 Hive 中的 <code>sqoop_test</code> 数据库需要预先创建，不指定则默认使用 Hive 中的 <code>default</code> 库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 hive 中的所有数据库</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash"> SHOW DATABASES;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 sqoop_test 数据库</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash"> CREATE DATABASE sqoop_test;</span></span><br></pre></td></tr></table></figure>

<h5 id="导入验证-1"><a href="#导入验证-1" class="headerlink" title="导入验证"></a>导入验证</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 sqoop_test 数据库的所有表</span></span><br><span class="line"><span class="meta prompt_"> hive&gt; </span><span class="language-bash"> SHOW  TABLES  IN  sqoop_test;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看表中数据</span></span><br><span class="line"><span class="meta prompt_"> hive&gt; </span><span class="language-bash">SELECT * FROM sqoop_test.help_keyword;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/00cf19bbcf1278b0bd28640a5f59862ebdb55e0173e2228fce850cfbcc05e485/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686976655f7461626c65732e706e67"><img src="https://camo.githubusercontent.com/00cf19bbcf1278b0bd28640a5f59862ebdb55e0173e2228fce850cfbcc05e485/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686976655f7461626c65732e706e67" alt="img"></a></p>
<h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/27ca396ed586d5d9be1ba106f26dd672401785ac585e1c24adc63069343a6fe6/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686976655f6572726f722e706e67"><img src="https://camo.githubusercontent.com/27ca396ed586d5d9be1ba106f26dd672401785ac585e1c24adc63069343a6fe6/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f686976655f6572726f722e706e67" alt="img"></a></p>
<p>如果执行报错 <code>java.io.IOException: java.lang.ClassNotFoundException: org.apache.hadoop.hive.conf.HiveConf</code>，则需将 Hive 安装目录下 <code>lib</code> 下的 <code>hive-exec-**.jar</code> 放到 sqoop 的 <code>lib</code> 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop001 lib]# ll hive-exec-*</span><br><span class="line">-rw-r--r--. 1 1106 4001 19632031 11 月 13 21:45 hive-exec-1.1.0-cdh5.15.2.jar</span><br><span class="line">[root@hadoop001 lib]# cp hive-exec-1.1.0-cdh5.15.2.jar  $&#123;SQOOP_HOME&#125;/lib</span><br></pre></td></tr></table></figure>

<h4 id="Hive-导出数据到-MySQL"><a href="#Hive-导出数据到-MySQL" class="headerlink" title="Hive 导出数据到 MySQL"></a>Hive 导出数据到 MySQL</h4><p>由于 Hive 的数据是存储在 HDFS 上的，所以 Hive 导入数据到 MySQL，实际上就是 HDFS 导入数据到 MySQL。</p>
<h5 id="查看-Hive-表在-HDFS-的存储位置"><a href="#查看-Hive-表在-HDFS-的存储位置" class="headerlink" title="查看 Hive 表在 HDFS 的存储位置"></a>查看 Hive 表在 HDFS 的存储位置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入对应的数据库</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">use sqoop_test;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看表信息</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">desc formatted help_keyword;</span></span><br></pre></td></tr></table></figure>

<p><code>Location</code> 属性为其存储位置：</p>
<p><img src="https://camo.githubusercontent.com/ed9d22fb7fcdc3f71d067010820d1c7de41a243bf3cf8be572020923ecdf0802/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d686976652d6c6f636174696f6e2e706e67" alt="img"></p>
<p>这里可以查看一下这个目录，文件结构如下：</p>
<p><img src="https://camo.githubusercontent.com/27f1234dafcee45782a5f711e85a3161592a1ca787d587b4a7e14089b4bf7e72/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f702d686976652d686466732e706e67" alt="img"></p>
<h5 id="执行导出命令"><a href="#执行导出命令" class="headerlink" title="执行导出命令"></a>执行导出命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop export  \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword_from_hive \</span><br><span class="line">    --export-dir /user/hive/warehouse/sqoop_test.db/help_keyword  \</span><br><span class="line">    -input-fields-terminated-by &#x27;\001&#x27; \             # 需要注意的是 hive 中默认的分隔符为 \001</span><br><span class="line">    --m 3</span><br></pre></td></tr></table></figure>

<p>MySQL 中的表需要预先创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> help_keyword_from_hive <span class="keyword">LIKE</span> help_keyword;</span><br></pre></td></tr></table></figure>

<h3 id="Sqoop-与-HBase"><a href="#Sqoop-与-HBase" class="headerlink" title="Sqoop 与 HBase"></a>Sqoop 与 HBase</h3><blockquote>
<p>本小节只讲解从 RDBMS 导入数据到 HBase，因为暂时没有命令能够从 HBase 直接导出数据到 RDBMS。</p>
</blockquote>
<h4 id="MySQL-导入数据到-HBase"><a href="#MySQL-导入数据到-HBase" class="headerlink" title="MySQL 导入数据到 HBase"></a>MySQL 导入数据到 HBase</h4><h5 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h5><p>将 <code>help_keyword</code> 表中数据导入到 HBase 上的 <code>help_keyword_hbase</code> 表中，使用原表的主键 <code>help_keyword_id</code> 作为 <code>RowKey</code>，原表的所有列都会在 <code>keywordInfo</code> 列族下，目前只支持全部导入到一个列族下，不支持分别指定列族。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword \              # 待导入的表</span><br><span class="line">    --hbase-table help_keyword_hbase \  # hbase 表名称，表需要预先创建</span><br><span class="line">    --column-family keywordInfo \       # 所有列导入到 keywordInfo 列族下</span><br><span class="line">    --hbase-row-key help_keyword_id     # 使用原表的 help_keyword_id 作为 RowKey</span><br></pre></td></tr></table></figure>

<p>导入的 HBase 表需要预先创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有表</span></span><br><span class="line"><span class="meta prompt_">hbase&gt; </span><span class="language-bash">list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建表</span></span><br><span class="line"><span class="meta prompt_">hbase&gt; </span><span class="language-bash">create <span class="string">&#x27;help_keyword_hbase&#x27;</span>, <span class="string">&#x27;keywordInfo&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看表信息</span></span><br><span class="line"><span class="meta prompt_">hbase&gt; </span><span class="language-bash">desc <span class="string">&#x27;help_keyword_hbase&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="导入验证-2"><a href="#导入验证-2" class="headerlink" title="导入验证"></a>导入验证</h5><p>使用 <code>scan</code> 查看表数据：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/7fdd034cab4722d9e194d16a91ce0c23db4b9589d0c4d7c241b56034686b490a/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f68626173652e706e67"><img src="https://camo.githubusercontent.com/7fdd034cab4722d9e194d16a91ce0c23db4b9589d0c4d7c241b56034686b490a/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f73716f6f705f68626173652e706e67" alt="img"></a></p>
<h3 id="全库导出"><a href="#全库导出" class="headerlink" title="全库导出"></a>全库导出</h3><p>Sqoop 支持通过 <code>import-all-tables</code> 命令进行全库导出到 HDFS&#x2F;Hive，但需要注意有以下两个限制：</p>
<ul>
<li>所有表必须有主键；或者使用 <code>--autoreset-to-one-mapper</code>，代表只启动一个 <code>map task</code>;</li>
<li>你不能使用非默认的分割列，也不能通过 WHERE 子句添加任何限制。</li>
</ul>
<blockquote>
<p>第二点解释得比较拗口，这里列出官方原本的说明：</p>
<ul>
<li>You must not intend to use non-default splitting column, nor impose any conditions via a <code>WHERE</code> clause.</li>
</ul>
</blockquote>
<p>全库导出到 HDFS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqoop import-all-tables \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/数据库名 \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --warehouse-dir  /sqoop_all \     # 每个表会单独导出到一个目录，需要用此参数指明所有目录的父目录</span><br><span class="line">    --fields-terminated-by &#x27;\t&#x27;  \</span><br><span class="line">    -m 3</span><br></pre></td></tr></table></figure>

<p>全库导出到 Hive：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop import-all-tables -Dorg.apache.sqoop.splitter.allow_text_splitter=true \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/数据库名 \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --hive-database sqoop_test \         # 导出到 Hive 对应的库</span><br><span class="line">  --hive-import \</span><br><span class="line">  --hive-overwrite \</span><br><span class="line">  -m 3</span><br></pre></td></tr></table></figure>

<h3 id="Sqoop-数据过滤"><a href="#Sqoop-数据过滤" class="headerlink" title="Sqoop 数据过滤"></a>Sqoop 数据过滤</h3><h4 id="query-参数"><a href="#query-参数" class="headerlink" title="query 参数"></a>query 参数</h4><p>Sqoop 支持使用 <code>query</code> 参数定义查询 SQL，从而可以导出任何想要的结果集。使用示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">  --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">  --username root \</span><br><span class="line">  --password root \</span><br><span class="line">  --query &#x27;select * from help_keyword where  $CONDITIONS and  help_keyword_id &lt; 50&#x27; \</span><br><span class="line">  --delete-target-dir \</span><br><span class="line">  --target-dir /sqoop_hive  \</span><br><span class="line">  --hive-database sqoop_test \           # 指定导入目标数据库 不指定则默认使用 Hive 中的 default 库</span><br><span class="line">  --hive-table filter_help_keyword \     # 指定导入目标表</span><br><span class="line">  --split-by help_keyword_id \           # 指定用于 split 的列</span><br><span class="line">  --hive-import \                        # 导入到 Hive</span><br><span class="line">  --hive-overwrite \                     、</span><br><span class="line">  -m 3</span><br></pre></td></tr></table></figure>

<p>在使用 <code>query</code> 进行数据过滤时，需要注意以下三点：</p>
<ul>
<li>必须用 <code>--hive-table</code> 指明目标表；</li>
<li>如果并行度 <code>-m</code> 不为 1 或者没有指定 <code>--autoreset-to-one-mapper</code>，则需要用 <code>--split-by</code> 指明参考列；</li>
<li>SQL 的 <code>where</code> 字句必须包含 <code>$CONDITIONS</code>，这是固定写法，作用是动态替换。</li>
</ul>
<h4 id="增量导入"><a href="#增量导入" class="headerlink" title="增量导入"></a>增量导入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">    --connect jdbc:mysql://hadoop001:3306/mysql \</span><br><span class="line">    --username root \</span><br><span class="line">    --password root \</span><br><span class="line">    --table help_keyword \</span><br><span class="line">    --target-dir /sqoop_hive  \</span><br><span class="line">    --hive-database sqoop_test \</span><br><span class="line">    --incremental  append  \             # 指明模式</span><br><span class="line">    --check-column  help_keyword_id \    # 指明用于增量导入的参考列</span><br><span class="line">    --last-value 300  \                  # 指定参考列上次导入的最大值</span><br><span class="line">    --hive-import \</span><br><span class="line">    -m 3</span><br></pre></td></tr></table></figure>

<p><code>incremental</code> 参数有以下两个可选的选项：</p>
<ul>
<li><strong>append</strong>：要求参考列的值必须是递增的，所有大于 <code>last-value</code> 的值都会被导入；</li>
<li><strong>lastmodified</strong>：要求参考列的值必须是 <code>timestamp</code> 类型，且插入数据时候要在参考列插入当前时间戳，更新数据时也要更新参考列的时间戳，所有时间晚于 <code>last-value</code> 的数据都会被导入。</li>
</ul>
<p>通过上面的解释我们可以看出来，其实 Sqoop 的增量导入并没有太多神器的地方，就是依靠维护的参考列来判断哪些是增量数据。当然我们也可以使用上面介绍的 <code>query</code> 参数来进行手动的增量导出，这样反而更加灵活。</p>
<h4 id="类型支持"><a href="#类型支持" class="headerlink" title="类型支持"></a>类型支持</h4><p>Sqoop 默认支持数据库的大多数字段类型，但是某些特殊类型是不支持的。遇到不支持的类型，程序会抛出异常 <code>Hive does not support the SQL type for column xxx</code> 异常，此时可以通过下面两个参数进行强制类型转换：</p>
<ul>
<li><code>--map-column-java&lt;mapping&gt;</code> - 重写 SQL 到 Java 类型的映射；</li>
<li><code>--map-column-hive &lt;mapping&gt;</code> - 重写 Hive 到 Java 类型的映射。</li>
</ul>
<p>示例如下，将原先 <code>id</code> 字段强制转为 String 类型，<code>value</code> 字段强制转为 Integer 类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sqoop import ... --map-column-java <span class="built_in">id</span>=String,value=Integer</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://sqoop.apache.org/">Sqoop Github</a></li>
<li><a target="_blank" rel="noopener" href="https://sqoop.apache.org/">Sqoop 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/Sqoop%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.md">Sqoop 基本使用</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e8b82f62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e8b82f62/" class="post-title-link" itemprop="url">MySQL 锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-07 07:54:19" itemprop="dateCreated datePublished" datetime="2020-09-07T07:54:19+08:00">2020-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><blockquote>
<p>不同存储引擎对于锁的支持粒度是不同的，由于 InnoDB 是 MySQL 的默认存储引擎，所以本文以 InnoDB 对于锁的支持进行阐述。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310162345947.png"></p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>为了解决并发一致性问题，MySQL 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。</p>
<h3 id="独享锁和共享锁"><a href="#独享锁和共享锁" class="headerlink" title="独享锁和共享锁"></a>独享锁和共享锁</h3><p>InnoDB 实现标准行级锁定，根据是否独享资源，可以把锁分为两类：</p>
<ul>
<li><strong>独享锁（Exclusive）</strong>，简写为 X 锁，又称为“<strong>写锁</strong>”、“<strong>排它锁</strong>”。<ul>
<li>独享锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。</li>
<li>使用方式：<code>SELECT ... FOR UPDATE;</code></li>
</ul>
</li>
<li><strong>共享锁（Shared）</strong>，简写为 S 锁，又称为“<strong>读锁</strong>”。<ul>
<li>共享锁锁定的资源可以被其他用户读取，但不能修改。在进行 <code>SELECT</code> 的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。</li>
<li>使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要引入读写锁机制？</p>
</blockquote>
<p>实际上，读写锁是一种通用的锁机制，并非 MySQL 的专利。在很多软件领域，都存在读写锁机制。</p>
<p>因为读操作本身是线程安全的，而一般业务往往又是读多写少的情况。因此，如果对读操作进行互斥，是不必要的，并且会大大降低并发访问效率。正式为了应对这种问题，产生了读写锁机制。</p>
<p>读写锁的特点是：<strong>读读不互斥</strong>、<strong>读写互斥</strong>、<strong>写写互斥</strong>。简言之：<strong>只要存在写锁，其他事务就不能做任何操作</strong>。</p>
<blockquote>
<p>注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。</p>
</blockquote>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>基于加锁方式分类，MySQL 可以分为悲观锁和乐观锁。</p>
<ul>
<li><strong>悲观锁</strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul>
<li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li>
<li>实现方式：<strong>使用数据库中的锁机制</strong>。</li>
</ul>
</li>
<li><strong>乐观锁</strong> - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。<ul>
<li>实现方式：<strong>更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要引入乐观锁？</p>
</blockquote>
<p>乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。</p>
<p><strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。那么，为了提高并发度，能不能尽量不加锁呢？</p>
<p>乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。</p>
<ul>
<li><p>乐观锁的<strong>优点</strong>是：减少锁竞争，提高并发度。</p>
</li>
<li><p>乐观锁的<strong>缺点</strong>是：</p>
<ul>
<li><strong>存在 ABA 问题</strong>。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了</li>
<li>如果乐观锁所检查的数据存在大量锁竞争，会由于<strong>不断循环重试，产生大量的 CPU 开销</strong>。</li>
</ul>
</li>
</ul>
<p>【示例】MySQL 乐观锁示例</p>
<p>假设，order 表中有一个字段 status，表示订单状态：status 为 1 代表订单未支付；status 为 2 代表订单已支付。现在，要将 id 为 1 的订单状态置为已支付，则操作如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> status, version <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>乐观锁更多详情可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/laoyeye/p/8097684.html">使用 mysql 乐观锁解决并发问题</a></p>
</blockquote>
<h3 id="全局锁、表级锁、行级锁"><a href="#全局锁、表级锁、行级锁" class="headerlink" title="全局锁、表级锁、行级锁"></a>全局锁、表级锁、行级锁</h3><p>前文提到了，<strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。在不得不加锁的情况下，显然，加锁的范围越小，锁竞争的发生频率就越小，系统的并发程度就越高。但是，加锁也需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销，<strong>锁粒度越小，系统的锁操作开销就越大</strong>。因此，在选择锁粒度时，也需要在锁开销和并发程度之间做一个权衡。</p>
<p>根据加锁的范围，MySQL 的锁大致可以分为：</p>
<ul>
<li><strong>全局锁</strong> - <strong>“全局锁”会锁定整个数据库</strong>。</li>
<li><strong>表级锁（table lock）</strong> - <strong>“表级锁”锁定整张表</strong>。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。表级锁有：<ul>
<li><strong>表锁</strong> - 表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</li>
<li><strong>元数据锁（MDL）</strong> - MDL 不需要显式使用，在访问一个表的时候会被自动加上。</li>
<li><strong>意向锁（Intention Lock）</strong></li>
<li><strong>自增锁（AUTO-INC）</strong></li>
</ul>
</li>
<li><strong>行级锁（row lock）</strong> - <strong>“行级锁”锁定指定的行记录</strong>。这样其它线程还是可以对同一个表中的其它行记录进行操作。行级锁有：<ul>
<li><strong>记录锁（Record Lock）</strong></li>
<li><strong>间隙锁（Gap Lock）</strong></li>
<li><strong>临键锁（Next-Key Lock）</strong></li>
<li><strong>插入意向锁</strong></li>
</ul>
</li>
</ul>
<p>以上各种加锁粒度，在不同存储引擎中的支持情况并不相同。如：InnoDB 支持全局锁、表级锁、行级锁；而 MyISAM 只支持全局锁、表级锁。</p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p><strong>全局锁会锁定整个数据库</strong>。全局锁的典型使用场景是：<strong>全库逻辑备份</strong>。</p>
<h3 id="全局锁的用法"><a href="#全局锁的用法" class="headerlink" title="全局锁的用法"></a>全局锁的用法</h3><p>要给整个数据库<strong>加全局锁</strong>，可以执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<p>执行命名后，整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>如果要<strong>释放全局锁</strong>，可以执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>此外，在客户端断开的时候会自动释放锁。</p>
<h3 id="全局锁的限制"><a href="#全局锁的限制" class="headerlink" title="全局锁的限制"></a>全局锁的限制</h3><p>全局锁锁定期间，整个数据库都是只读状态，这意味着数据库不能更新数据。数据库备份很耗时，锁定整个数据库会导致业务停滞，如何避免这种问题？</p>
<p>在可重复读（Repeatable Read）隔离级别下，事务开启时会创建一个 Read View，并在整个事务期间使用该视图，确保数据一致性。即使其他事务在此期间修改数据，也不会影响备份事务的 <strong>Read View</strong>，从而保证备份数据的隔离性。如此一来，就无需加全局锁了。</p>
<p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 <code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。对于全部是 InnoDB 引擎的库，建议选择使用 <code>–single-transaction</code> 参数，对应用会更友好。如果有的表使用了不支持事务的引擎（如 MyIsAM），那么备份就只能通过 FTWRL 方法，导致阻塞业务。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p><strong>“表级锁”会锁定整张表</strong>。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。</p>
<p>**表锁的语法是 <code>lock tables … read/write</code>**，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为 xxx 表加读/写锁</span></span><br><span class="line">lock tables XXX read<span class="operator">/</span>write</span><br></pre></td></tr></table></figure>

<p>与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，<code>lock tables</code> 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 <code>lock tables</code> 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<h3 id="元数据锁（Metadata-Lock，MDL）"><a href="#元数据锁（Metadata-Lock，MDL）" class="headerlink" title="元数据锁（Metadata Lock，MDL）"></a>元数据锁（Metadata Lock，MDL）</h3><p>元数据锁，英文为 metadata lock，缩写为 MDL。</p>
<p><strong>MDL 无需显式使用，访问表的时候会被自动加上</strong>。MDL 的作用是，保证读写的正确性。假设，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>MySQL 5.5 版本中引入了 MDL。</p>
<ul>
<li>对一个表做“<strong>增删改查</strong>”操作的时候，加 <strong>MDL 读锁</strong>。读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。</li>
<li>对一个表做“<strong>结构变更</strong>”操作的时候，加 <strong>MDL 写锁</strong>。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>MDL 会直到事务提交才释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p>
<p>如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那么在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 <code>SELECT</code> 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 <code>SELECT</code> 语句，此时并不会阻塞，因为“读读”并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 <code>SELECT</code> 语句，就都会被阻塞。如果此时有大量该表的 <code>SELECT</code> 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。在 MySQL 的 <code>information_schema</code> 库的 <code>innodb_trx</code> 表中，可以查到当前执行中的事务。</p>
<h3 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h3><p>InnoDB 支持不同粒度的锁定，允许行锁和表锁共存。<strong>存在表级锁和行级锁时，必须先申请意向锁，再获取行级锁</strong>。意向锁是表级锁，表示事务稍后需要对表中的行使用哪种类型的锁（共享或独享）。<strong>意向锁是 InnoDB 自动添加的，不需要用户干预</strong>。</p>
<p>意向锁有两种类型：</p>
<ul>
<li><p><strong>意向共享锁（<code>IS</code>）</strong> - 表示事务有意向对表中的行设置共享锁（<code>S</code>）。</p>
</li>
<li><p><strong>意向独享锁（<code>IX</code>）</strong> - 表示事务有意向对表中的行设置独享锁（<code>X</code>）。</p>
</li>
</ul>
<p>比如 <code>SELECT ... FOR SHARE</code> 设置 <code>IS</code> 锁， <code>SELECT ... FOR UPDATE</code> 设置 <code>IX</code> 锁。</p>
<p>意向锁的规则如下：</p>
<ul>
<li>一个事务在获得某个数据行的共享锁（<code>S</code>）之前，必须先获得表的意向共享锁（<code>IS</code>）或者更强的锁；</li>
<li>一个事务在获得某个数据行的独享锁（<code>X</code>）之前，必须先获得表的意向独享锁（<code>IX</code>）。</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上 <code>IX</code> 锁，然后对该记录加 <code>X</code> 锁。而快照读（普通的 <code>SELECT</code>）是不会加行级锁的，快照读是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，<code>SELECT</code> 也是可以对记录加共享锁和独享锁的，具体方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先在表上加上 IS 锁，然后对读取的记录加 S 锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先在表上加上 IX 锁，然后对读取的记录加 X 锁</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><strong>IX&#x2F;IS 是表级锁，不会和行级的 X&#x2F;S 发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<code>lock tables ... read</code>）和独享表锁（<code>lock tables ... write</code>）发生冲突</strong>。</p>
<p>如果申请的锁与现有锁兼容，则锁申请成功；反之，则锁申请失败。锁申请失败的情况下，申请锁的事务会一直等待，直到存在冲突的锁被释放。如果存在与申请的锁相冲突的锁，并且该锁迟迟得不到释放，就会导致死锁。</p>
<blockquote>
<p>为什么要引入意向锁？</p>
</blockquote>
<p>如果没有意向锁，那么加独享表锁时，就需要遍历表里所有记录，查看是否有记录存在独享锁，这样效率会很低。</p>
<p>有了意向锁，在对记录加独享锁前，会先加上表级别的意向独享锁。此时，如果需要加独享表锁，可以直接查该表是否有意向独享锁：如果有，就意味着表里已经有记录被加了独享锁。这样一来，就不用去遍历表里的记录了。</p>
<p>综上所述，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h3 id="自增锁（AUTO-INC）"><a href="#自增锁（AUTO-INC）" class="headerlink" title="自增锁（AUTO-INC）"></a>自增锁（AUTO-INC）</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p>AUTO-INC 锁是特殊的表级锁，锁<strong>不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。但是，AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 <code>innodb_autoinc_lock_mode</code> 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 <code>innodb_autoinc_lock_mode = 0</code>，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li>
<li>当 <code>innodb_autoinc_lock_mode = 2</code>，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li>
<li>当 <code>innodb_autoinc_lock_mode = 1</code>：<ul>
<li>普通 <code>insert</code> 语句，自增锁在申请之后就马上释放；</li>
<li>类似 <code>insert … select</code> 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
</ul>
<p>以上模式中，<code>innodb_autoinc_lock_mode = 2</code> 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在“主从复制的场景”中会发生<strong>数据不一致的问题</strong>。要解决这个问题，可以设置 <code>binlog_format = row</code>，这样在 binlog 中记录的是主库分配的自增值，从库同步数据时，就可以保持一致。</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>
<p>在 InnoDB 引擎中，<strong>行锁是通过给索引上的索引项加锁来实现的</strong>。<strong>如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁</strong>。此外，在 InnoDB 引擎中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。因此，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p>行锁的具体实现算法有三种：Record Lock、Gap Lock 以及 Next-Key Lock。</p>
<h3 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h3><p><strong>记录锁（Record Lock）锁定一个记录上的索引，而不是记录本身</strong>。例如，执行 <code>SELECT value FROM t WHERE value BETWEEN 10 and 20 FOR UPDATE;</code> 后，会禁止任何其他事务插入、更新或删除 <code>t.value </code> 值在 10 到 20 范围之内的数据，因为该范围内的所有现有值之间的间隙已被锁定。</p>
<p>记录锁始终锁定索引记录，即使表定义为没有索引。如果表没有设置索引，InnoDB 会自动创建一个隐藏的聚簇索引并使用该索引进行记录锁定。</p>
<p>Record Lock 是有 S 锁和 X 锁之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<p>【示例】记录锁示例</p>
<blockquote>
<p>注：测试环境的事务隔离级别为可重复级别</p>
</blockquote>
<p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">)</span><br><span class="line">	ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">	<span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> `utf8`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分别插入 id 为 1、10、20 的数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>事务一、添加 X 型记录锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对 id 为 1 的记录添加 X 型记录锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 延迟 20 秒执行后续语句，保持锁定状态</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>事务二、被锁定的行记录无法修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改 id = 10 的行记录，正常执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> `t` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改 id = 1 的行记录，由于 id = 1 被 X 型记录锁锁定，直到事务一释放锁，方能执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> `t` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p><strong>间隙锁（Gap Lock）锁定索引之间的间隙，但是不包含索引本身</strong>。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，它们彼此不冲突，不同事务可以在间隙上持有冲突锁，并不存在互斥关系。例如，事务 A 可以在某个间隙上持有 S 型间隙锁，而事务 B 在同一间隙上持有 X 型间隙锁。允许存在冲突间隙锁的原因是：如果从索引中清除记录，则必须合并不同事务在该记录上持有的间隙锁。</p>
<p>间隙锁只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。如果将事务隔离级别更改为 读已提交，则间隙锁定对搜索和索引扫描禁用，并且仅用于外键约束检查和重复键检查。</p>
<p>在 MySQL 中，间隙锁默认是开启的，即 <code>innodb_locks_unsafe_for_binlog</code> 参数值是 <code>disable</code> 的，且 MySQL 中默认的是 RR 事务隔离级别。</p>
<p>【示例】间隙锁示例</p>
<blockquote>
<p>注：测试环境的事务隔离级别为可重复级别</p>
</blockquote>
<p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	<span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">)</span><br><span class="line">	ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">	<span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> `utf8`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分别插入 id 为 1、10、20 的数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>事务一、添加间隙锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对 id 为 1 的记录添加间隙锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t` <span class="keyword">WHERE</span> `id` <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 延迟 20 秒执行后续语句，保持锁定状态</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>事务二、被锁定范围内的行记录无法修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入 id 为 1 到 10 范围之外的数据，正常执行</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新 id 为 1 到 10 范围之外的数据，正常执行</span></span><br><span class="line"><span class="keyword">UPDATE</span> `t` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 id 为 1 到 10 范围之内的数据，被阻塞</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `t`(`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新 id 为 1 到 10 范围之内的数据，被阻塞</span></span><br><span class="line"><span class="keyword">UPDATE</span> `t` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `t` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h3><p><strong>临键锁（Next-Key Lock）是记录锁和间隙锁的结合</strong>，不仅锁定一个记录上的索引，也锁定索引之间的间隙（它锁定一个前开后闭区间）。</p>
<p>假设索引包含值 10、11、13 和 20，那么该索引可能的 Next-Key Lock 涵盖以下区间：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">-</span></span>∞<span class="punctuation">,</span> <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span><span class="punctuation">,</span> <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span><span class="punctuation">,</span> <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span><span class="punctuation">,</span> <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span><span class="punctuation">,</span> +∞)</span><br></pre></td></tr></table></figure>

<p>所以，Next-Key Lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。MVCC 不能解决幻读问题，<strong>Next-Key 锁就是为了解决幻读问题而提出的</strong>。在可重复读（<code>REPEATABLE READ</code>）隔离级别下，使用** MVCC + Next-Key 锁**可以解决幻读问题。</p>
<p>只有可重复读、串行化隔离级别下的特定操作才会取得间隙锁或 Next-Key Lock。在 <code>Select</code>、<code>Update</code> 和 <code>Delete</code> 时，除了基于唯一索引的查询之外，其它索引查询时都会获取间隙锁或 Next-Key Lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用间隙锁或 Next-Key Lock。</p>
<p>索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 <code>UPDATE</code>、<code>DELETE</code> 操作时，MySQL 不仅锁定 <code>WHERE</code> 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 Next-Key Lock。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁不是意向锁，而是一种特殊的间隙锁。当一个事务试图插入一条记录时，需要判断插入位置是否已被其他事务加了间隙锁（临键锁（Next-Key Lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻）；在此期间，会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>假设存在值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务在获得插入行上的排他锁之前，每个事务都使用插入意向锁锁定 4 和 7 之间的间隙，但不要互相阻塞，因为行不冲突。</p>
<p>【示例】获取插入意向锁</p>
<p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> child (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>, <span class="keyword">PRIMARY KEY</span>(id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> child (id) <span class="keyword">values</span> (<span class="number">90</span>),(<span class="number">102</span>);</span><br></pre></td></tr></table></figure>

<p>事务 A 对 id 大于 100 的索引记录设置独享锁。独享锁包括了 id&#x3D;102 之前的间隙锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> id  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br></pre></td></tr></table></figure>

<p>事务 B 将记录插入到间隙中。事务在等待获取独享锁时获取插入意向锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> child (id) <span class="keyword">VALUES</span> (<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>“死锁”是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p>
<p>产生死锁的场景：</p>
<ul>
<li><p>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</p>
</li>
<li><p>多个事务同时锁定同一个资源时，也会产生死锁。</p>
</li>
</ul>
<h3 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h3><p>（1）数据初始化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表 test</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据初始化</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>（2）两个事务严格按下表顺序执行，产生死锁</p>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td><code>BEGIN;</code></td>
<td><code>BEGIN;</code></td>
</tr>
<tr>
<td>– 查询 value &#x3D; 4 的记录<br/><code>SELECT * FROM test WHERE value = 4 FOR UPDATE;</code><br/>– 结果为空</td>
<td></td>
</tr>
<tr>
<td></td>
<td>– 查询 value &#x3D; 5 的记录<br/><code>SELECT * FROM test WHERE value = 5 FOR UPDATE;</code><br/>– 结果为空</td>
</tr>
<tr>
<td><code>INSERT INTO test (id, value) VALUES (4, 4);</code><br/>– 锁等待中</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>INSERT INTO test (id, value) VALUES (5, 5);</code><br/>– 锁等待中</td>
</tr>
<tr>
<td>– 由于死锁无法执行到此步骤<br/><code>COMMIT;</code></td>
<td>– 由于死锁无法执行到此步骤<br/><code>COMMIT;</code></td>
</tr>
</tbody></table>
<h3 id="死锁是如何产生的"><a href="#死锁是如何产生的" class="headerlink" title="死锁是如何产生的"></a>死锁是如何产生的</h3><p>行锁的具体实现算法有三种：Record Lock、Gap Lock 以及 Next-Key Lock。Record Lock 是专门对索引项加锁；Gap Lock 是对索引项之间的间隙加锁；Next-Key Lock 则是前面两种的组合，对索引项以其之间的间隙加锁。</p>
<p>只有在可重复读或以上隔离级别下的特定操作才会取得 Gap Lock 或 Next-Key Lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 Gap Lock 或 Next-Key Lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 Gap Lock 或 Next-Key Lock。</p>
<p>在 MySQL 中，Gap Lock 默认是开启的，即 <code>innodb_locks_unsafe_for_binlog</code> 参数值是 <code>disable</code> 的，且 MySQL 中默认的是可重复读事务隔离级别。</p>
<p>当我们执行以下查询 SQL 时，由于 <code>value</code> 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 Gap Lock，这里的 gap 范围是 (4,+∞）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>执行查询 SQL 语句获取的 Gap Lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 Gap Lock 是冲突的，所以当其它事务持有该间隙的 Gap Lock 时，需要等待其它事务释放 Gap Lock 之后，才能获取到插入意向锁。</p>
<p>以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630153139.png" alt="img"></p>
<p><strong>另一个死锁场景</strong></p>
<p>InnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154606.png" alt="img"></p>
<p>出现死锁的步骤：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154619.png" alt="img"></p>
<p>综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：</p>
<ul>
<li>更新表时，<strong>尽量使用主键更新</strong>，减少冲突；</li>
<li><strong>避免长事务</strong>，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；</li>
<li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li>
<li>在编程中<strong>尽量按照固定的顺序来处理数据库记录</strong>，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li>
<li>在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；</li>
<li>还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</li>
</ul>
<h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><p>当出现死锁以后，有两种策略：</p>
<ul>
<li><strong>设置事务等待锁的超时时间</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>
<li><strong>开启死锁检测</strong>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">极客时间教程 - Java 性能调优实战</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL 官方文档之 InnoDB Locking</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%82md">数据库系统原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laoyeye/p/8097684.html">使用 mysql 乐观锁解决并发问题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/blog/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/27/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"450cc5a47fe678dd974c220339e3ae28"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
