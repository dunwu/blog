<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/39/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/39/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/39/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/9d2583c3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/9d2583c3/" class="post-title-link" itemprop="url">SQLite</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-22 09:02:39" itemprop="dateCreated datePublished" datetime="2019-08-22T09:02:39+08:00">2019-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><blockquote>
<p>SQLite 是一个无服务器的、零配置的、事务性的的开源数据库引擎。<br>💻 <a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/tree/master/codes/javadb/javadb-sqlite">完整示例源码</a></p>
</blockquote>
<h2 id="SQLite-简介"><a href="#SQLite-简介" class="headerlink" title="SQLite 简介"></a>SQLite 简介</h2><p>SQLite 是一个C语言编写的轻量级、全功能、无服务器、零配置的的开源数据库引擎。</p>
<p>SQLite 的设计目标是嵌入式的数据库，很多嵌入式产品中都使用了它。SQLite 十分轻量，占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。SQLite 能够支持Windows&#x2F;Linux&#x2F;Unix等等主流的操作系统，同时能够跟很多程序语言相结合，同样比起Mysql、PostgreSQL这两款开源的世界著名数据库管理系统来讲，它的处理速度比他们都快。</p>
<p>SQLite 大小只有 3M 左右，可以将整个 SQLite 嵌入到应用中，而不用采用传统的客户端／服务器（Client&#x2F;Server）的架构。这样做的好处就是非常轻便，在许多智能设备和应用中都可以使用 SQLite，比如微信就采用了 SQLite 作为本地聊天记录的存储。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</li>
<li>SQLite 是无服务器的、零配置的，这意味着不需要安装或管理。</li>
<li>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</li>
<li>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于 250KiB。</li>
<li>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</li>
<li>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</li>
<li>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</li>
<li>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</li>
</ul>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RIGHT OUTER JOIN</td>
<td>只实现了 LEFT OUTER JOIN。</td>
</tr>
<tr>
<td>FULL OUTER JOIN</td>
<td>只实现了 LEFT OUTER JOIN。</td>
</tr>
<tr>
<td>ALTER TABLE</td>
<td>支持 RENAME TABLE 和 ALTER TABLE 的 ADD COLUMN variants 命令，不支持 DROP COLUMN、ALTER COLUMN、ADD CONSTRAINT。</td>
</tr>
<tr>
<td>Trigger 支持</td>
<td>支持 FOR EACH ROW 触发器，但不支持 FOR EACH STATEMENT 触发器。</td>
</tr>
<tr>
<td>VIEWs</td>
<td>在 SQLite 中，视图是只读的。您不可以在视图上执行 DELETE、INSERT 或 UPDATE 语句。</td>
</tr>
<tr>
<td>GRANT 和 REVOKE</td>
<td>可以应用的唯一的访问权限是底层操作系统的正常文件访问权限。</td>
</tr>
</tbody></table>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Sqlite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</p>
<p>一般，Linux 和 Mac 上会预安装 sqlite。如果没有安装，可以在<a target="_blank" rel="noopener" href="https://www.sqlite.org/download.html">官方下载地址</a>下载合适安装版本，自行安装。</p>
<h2 id="SQLite-语法"><a href="#SQLite-语法" class="headerlink" title="SQLite 语法"></a>SQLite 语法</h2><blockquote>
<p>这里不会详细列举所有 SQL 语法，仅列举 SQLite 除标准 SQL 以外的，一些自身特殊的 SQL 语法。</p>
<p>📖 扩展阅读：<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/blob/master/docs/database/sql/sql.md">标准 SQL 基本语法</a></p>
</blockquote>
<h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><p>SQLite 是<strong>不区分大小写</strong>的，但也有一些命令是大小写敏感的，比如 <strong>GLOB</strong> 和 <strong>glob</strong> 在 SQLite 的语句中有不同的含义。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释1</span></span><br><span class="line"><span class="comment"> 多行注释2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>如下，创建一个名为 test 的数据库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sqlite3 test.db</span></span><br><span class="line">SQLite version 3.7.17 2013-05-20 00:56:22</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line">Enter SQL statements terminated with a &quot;;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.databases</span></span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /root/test.db</span><br></pre></td></tr></table></figure>

<h3 id="退出数据库"><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.quit</span></span><br></pre></td></tr></table></figure>

<h3 id="附加数据库"><a href="#附加数据库" class="headerlink" title="附加数据库"></a>附加数据库</h3><p>假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。</p>
<p>SQLite 的 <strong><code>ATTACH DATABASE</code></strong> 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">ATTACH DATABASE <span class="string">&#x27;test.db&#x27;</span> AS <span class="string">&#x27;test&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.databases</span></span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /root/test.db</span><br><span class="line">2    test             /root/test.db</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：数据库名 <strong><code>main</code></strong> 和 <strong><code>temp</code></strong> 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息。</p>
</blockquote>
<h3 id="分离数据库"><a href="#分离数据库" class="headerlink" title="分离数据库"></a>分离数据库</h3><p>SQLite 的 <strong><code>DETACH DATABASE</code></strong> 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 <strong><code>ATTACH</code></strong> 语句附加的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.databases</span></span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /root/test.db</span><br><span class="line">2    test             /root/test.db</span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">DETACH DATABASE <span class="string">&#x27;test&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.databases</span></span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /root/test.db</span><br></pre></td></tr></table></figure>

<h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><p>如下，备份 test 数据库到 <code>/home/test.sql</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 test.db .dump &gt; /home/test.sql</span><br></pre></td></tr></table></figure>

<h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><p>如下，根据 <code>/home/test.sql</code> 恢复 test 数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 test.db &lt; test.sql</span><br></pre></td></tr></table></figure>

<h2 id="SQLite-数据类型"><a href="#SQLite-数据类型" class="headerlink" title="SQLite 数据类型"></a>SQLite 数据类型</h2><p>SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。</p>
<h3 id="SQLite-存储类"><a href="#SQLite-存储类" class="headerlink" title="SQLite 存储类"></a>SQLite 存储类</h3><p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p>
<table>
<thead>
<tr>
<th>存储类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>NULL</code></td>
<td>值是一个 NULL 值。</td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td>值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</td>
</tr>
<tr>
<td><code>REAL</code></td>
<td>值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</td>
</tr>
<tr>
<td><code>BLOB</code></td>
<td>值是一个 blob 数据，完全根据它的输入存储。</td>
</tr>
</tbody></table>
<p>SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。</p>
<h3 id="SQLite-亲和-Affinity-类型"><a href="#SQLite-亲和-Affinity-类型" class="headerlink" title="SQLite 亲和(Affinity)类型"></a>SQLite 亲和(Affinity)类型</h3><p>SQLite 支持列的亲和类型概念。任何列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。SQLite 目前的版本支持以下五种亲缘类型：</p>
<table>
<thead>
<tr>
<th>亲和类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>TEXT</code></td>
<td>数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。</td>
</tr>
<tr>
<td><code>NUMERIC</code></td>
<td>当文本数据被插入到亲缘性为 NUMERIC 的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么 SQLite 就会将该文本数据转换为 INTEGER 或 REAL 类型的数据，如果转换失败，SQLite 仍会以 TEXT 方式存储该数据。对于 NULL 或 BLOB 类型的新数据，SQLite 将不做任何转换，直接以 NULL 或 BLOB 的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如”30000.0”，如果该值可以转换为 INTEGER 同时又不会丢失数值信息，那么 SQLite 就会将其转换为 INTEGER 的存储方式。</td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td>对于亲缘类型为 INTEGER 的字段，其规则等同于 NUMERIC，唯一差别是在执行 CAST 表达式时。</td>
</tr>
<tr>
<td><code>REAL</code></td>
<td>其规则基本等同于 NUMERIC，唯一的差别是不会将”30000.0”这样的文本数据转换为 INTEGER 存储方式。</td>
</tr>
<tr>
<td><code>NONE</code></td>
<td>不做任何的转换，直接以该数据所属的数据类型进行存储。</td>
</tr>
</tbody></table>
<h3 id="SQLite-亲和类型-Affinity-及类型名称"><a href="#SQLite-亲和类型-Affinity-及类型名称" class="headerlink" title="SQLite 亲和类型(Affinity)及类型名称"></a>SQLite 亲和类型(Affinity)及类型名称</h3><p>下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的亲和类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>亲和类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>INT</code>, <code>INTEGER</code>, <code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>BIGINT</code>, <code>UNSIGNED BIG INT</code>, <code>INT2</code>, <code>INT8</code></td>
<td><code>INTEGER</code></td>
</tr>
<tr>
<td><code>CHARACTER(20)</code>, <code>VARCHAR(255)</code>, <code>VARYING CHARACTER(255)</code>, <code>NCHAR(55)</code>, <code>NATIVE CHARACTER(70)</code>, <code>NVARCHAR(100)</code>, <code>TEXT</code>, <code>CLOB</code></td>
<td><code>TEXT</code></td>
</tr>
<tr>
<td><code>BLOB</code>, <code>no datatype specified</code></td>
<td><code>NONE</code></td>
</tr>
<tr>
<td><code>REAL</code>, <code>DOUBLE</code>, <code>DOUBLE PRECISION</code>, <code>FLOAT</code></td>
<td><code>REAL</code></td>
</tr>
<tr>
<td><code>NUMERIC</code>, <code>DECIMAL(10,5)</code>, <code>BOOLEAN</code>, <code>DATE</code>, <code>DATETIME</code></td>
<td><code>NUMERIC</code></td>
</tr>
</tbody></table>
<h3 id="Boolean-数据类型"><a href="#Boolean-数据类型" class="headerlink" title="Boolean 数据类型"></a>Boolean 数据类型</h3><p>SQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。</p>
<h3 id="Date-与-Time-数据类型"><a href="#Date-与-Time-数据类型" class="headerlink" title="Date 与 Time 数据类型"></a>Date 与 Time 数据类型</h3><p>SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。</p>
<table>
<thead>
<tr>
<th>存储类</th>
<th>日期格式</th>
</tr>
</thead>
<tbody><tr>
<td><code>TEXT</code></td>
<td>格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。</td>
</tr>
<tr>
<td><code>REAL</code></td>
<td>从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td>从 1970-01-01 00:00:00 UTC 算起的秒数。</td>
</tr>
</tbody></table>
<p>您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。</p>
<h2 id="SQLite-命令"><a href="#SQLite-命令" class="headerlink" title="SQLite 命令"></a>SQLite 命令</h2><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="进入-SQLite-控制台"><a href="#进入-SQLite-控制台" class="headerlink" title="进入 SQLite 控制台"></a>进入 SQLite 控制台</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sqlite3</span></span><br><span class="line">SQLite version 3.7.17 2013-05-20 00:56:22</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line">Enter SQL statements terminated with a &quot;;&quot;</span><br><span class="line"><span class="meta prompt_">sqlite&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="进入-SQLite-控制台并指定数据库"><a href="#进入-SQLite-控制台并指定数据库" class="headerlink" title="进入 SQLite 控制台并指定数据库"></a>进入 SQLite 控制台并指定数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sqlite3 test.db</span></span><br><span class="line">SQLite version 3.7.17 2013-05-20 00:56:22</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line">Enter SQL statements terminated with a &quot;;&quot;</span><br><span class="line"><span class="meta prompt_">sqlite&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="退出-SQLite-控制台"><a href="#退出-SQLite-控制台" class="headerlink" title="退出 SQLite 控制台"></a>退出 SQLite 控制台</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt;</span><span class="language-bash">.quit</span></span><br></pre></td></tr></table></figure>

<h4 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt;</span><span class="language-bash">.<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>

<h3 id="常用命令清单"><a href="#常用命令清单" class="headerlink" title="常用命令清单"></a>常用命令清单</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.backup ?DB? FILE</td>
<td>备份 DB 数据库（默认是 “main”）到 FILE 文件。</td>
</tr>
<tr>
<td>.bail ON|OFF</td>
<td>发生错误后停止。默认为 OFF。</td>
</tr>
<tr>
<td>.databases</td>
<td>列出数据库的名称及其所依附的文件。</td>
</tr>
<tr>
<td>.dump ?TABLE?</td>
<td>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。</td>
</tr>
<tr>
<td>.echo ON|OFF</td>
<td>开启或关闭 echo 命令。</td>
</tr>
<tr>
<td>.exit</td>
<td>退出 SQLite 提示符。</td>
</tr>
<tr>
<td>.explain ON|OFF</td>
<td>开启或关闭适合于 EXPLAIN 的输出模式。如果没有带参数，则为 EXPLAIN on，及开启 EXPLAIN。</td>
</tr>
<tr>
<td>.header(s) ON|OFF</td>
<td>开启或关闭头部显示。</td>
</tr>
<tr>
<td>.help</td>
<td>显示消息。</td>
</tr>
<tr>
<td>.import FILE TABLE</td>
<td>导入来自 FILE 文件的数据到 TABLE 表中。</td>
</tr>
<tr>
<td>.indices ?TABLE?</td>
<td>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。</td>
</tr>
<tr>
<td>.load FILE ?ENTRY?</td>
<td>加载一个扩展库。</td>
</tr>
<tr>
<td>.log FILE|off</td>
<td>开启或关闭日志。FILE 文件可以是 stderr（标准错误）&#x2F;stdout（标准输出）。</td>
</tr>
<tr>
<td>.mode MODE</td>
<td>设置输出模式，MODE 可以是下列之一：<br/>csv 逗号分隔的值<br/>column 左对齐的列<br/>html HTML 的 <code>&lt;table&gt;</code> 代码<br/>insert TABLE 表的 SQL 插入（insert）语句<br/>line 每行一个值<br/>list 由 .separator 字符串分隔的值<br/>tabs 由 Tab 分隔的值<br/>tcl TCL 列表元素</td>
</tr>
<tr>
<td>.nullvalue STRING</td>
<td>在 NULL 值的地方输出 STRING 字符串。</td>
</tr>
<tr>
<td>.output FILENAME</td>
<td>发送输出到 FILENAME 文件。</td>
</tr>
<tr>
<td>.output stdout</td>
<td>发送输出到屏幕。</td>
</tr>
<tr>
<td>.print STRING…</td>
<td>逐字地输出 STRING 字符串。</td>
</tr>
<tr>
<td>.prompt MAIN CONTINUE</td>
<td>替换标准提示符。</td>
</tr>
<tr>
<td>.quit</td>
<td>退出 SQLite 提示符。</td>
</tr>
<tr>
<td>.read FILENAME</td>
<td>执行 FILENAME 文件中的 SQL。</td>
</tr>
<tr>
<td>.schema ?TABLE?</td>
<td>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。</td>
</tr>
<tr>
<td>.separator STRING</td>
<td>改变输出模式和 .import 所使用的分隔符。</td>
</tr>
<tr>
<td>.show</td>
<td>显示各种设置的当前值。</td>
</tr>
<tr>
<td>.stats ON|OFF</td>
<td>开启或关闭统计。</td>
</tr>
<tr>
<td>.tables ?PATTERN?</td>
<td>列出匹配 LIKE 模式的表的名称。</td>
</tr>
<tr>
<td>.timeout MS</td>
<td>尝试打开锁定的表 MS 毫秒。</td>
</tr>
<tr>
<td>.width NUM NUM</td>
<td>为 “column” 模式设置列宽度。</td>
</tr>
<tr>
<td>.timer ON|OFF</td>
<td>开启或关闭 CPU 定时器。</td>
</tr>
</tbody></table>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.<span class="keyword">header</span> <span class="keyword">on</span></span><br><span class="line">sqlite&gt;.mode <span class="keyword">column</span></span><br><span class="line">sqlite&gt;.timer <span class="keyword">on</span></span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果到文件"><a href="#输出结果到文件" class="headerlink" title="输出结果到文件"></a>输出结果到文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.mode list</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.separator |</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.output teyptest_file_1.txt</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash"><span class="keyword">select</span> * from tbl1;</span></span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.<span class="built_in">exit</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test_file_1.txt</span></span><br><span class="line">hello|10</span><br><span class="line">goodbye|20</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<h2 id="SQLite-JAVA-Client"><a href="#SQLite-JAVA-Client" class="headerlink" title="SQLite JAVA Client"></a>SQLite JAVA Client</h2><p>（1）在<a target="_blank" rel="noopener" href="https://bitbucket.org/xerial/sqlite-jdbc/downloads">官方下载地址</a>下载 sqlite-jdbc-(VERSION).jar ，然后将 jar 包放在项目中的 classpath。</p>
<p>（2）通过 API 打开一个 SQLite 数据库连接。</p>
<p>执行方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac Sample.java</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java -classpath <span class="string">&quot;.;sqlite-jdbc-(VERSION).jar&quot;</span> Sample   <span class="comment"># in Windows</span></span></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java -classpath <span class="string">&quot;.:sqlite-jdbc-(VERSION).jar&quot;</span> Sample   <span class="comment"># in Mac or Linux</span></span></span><br><span class="line">name = leo</span><br><span class="line">id = 1</span><br><span class="line">name = yui</span><br><span class="line">id = 2</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建数据库连接</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;jdbc:sqlite:sample.db&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">            statement.setQueryTimeout(<span class="number">30</span>);  <span class="comment">// 设置 sql 执行超时时间为 30s</span></span><br><span class="line"></span><br><span class="line">            statement.executeUpdate(<span class="string">&quot;drop table if exists person&quot;</span>);</span><br><span class="line">            statement.executeUpdate(<span class="string">&quot;create table person (id integer, name string)&quot;</span>);</span><br><span class="line">            statement.executeUpdate(<span class="string">&quot;insert into person values(1, &#x27;leo&#x27;)&quot;</span>);</span><br><span class="line">            statement.executeUpdate(<span class="string">&quot;insert into person values(2, &#x27;yui&#x27;)&quot;</span>);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from person&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">// 读取结果集</span></span><br><span class="line">                System.out.println(<span class="string">&quot;name = &quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;id = &quot;</span> + rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 如果错误信息是 &quot;out of memory&quot;，可能是找不到数据库文件</span></span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="comment">// 关闭连接失败</span></span><br><span class="line">                System.err.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何指定数据库文件"><a href="#如何指定数据库文件" class="headerlink" title="如何指定数据库文件"></a>如何指定数据库文件</h3><p>Windows</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Connection</span> <span class="string">connection = DriverManager.getConnection(&quot;jdbc:sqlite:C:/work/mydatabase.db&quot;);</span></span><br></pre></td></tr></table></figure>

<p>Unix (Linux, Mac OS X, etc)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Connection</span> <span class="string">connection = DriverManager.getConnection(&quot;jdbc:sqlite:/home/leo/work/mydatabase.db&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="如何使用内存数据库"><a href="#如何使用内存数据库" class="headerlink" title="如何使用内存数据库"></a>如何使用内存数据库</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Connection</span> <span class="string">connection = DriverManager.getConnection(&quot;jdbc:sqlite::memory:&quot;);</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/index.html">SQLite 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sqlite/sqlite">SQLite Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/docs.html">SQLite 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/cli.html">SQLite 官方命令行手册</a></li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/sqlite/sqlite-commands.html">http://www.runoob.com/sqlite/sqlite-commands.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xerial/sqlite-jdbc">https://github.com/xerial/sqlite-jdbc</a></li>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/sqlite/sqlite-java.html">http://www.runoob.com/sqlite/sqlite-java.html</a></li>
</ul>
<h2 id="🚪-传送"><a href="#🚪-传送" class="headerlink" title="🚪 传送"></a>🚪 传送</h2><p>◾ 💧 <a href="https://dunwu.github.io/waterdrop/">钝悟的 IT 知识图谱</a> ◾</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e6171578/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e6171578/" class="post-title-link" itemprop="url">Cassandra</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-22 09:02:39" itemprop="dateCreated datePublished" datetime="2019-08-22T09:02:39+08:00">2019-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>715</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h1><blockquote>
<p>Apache Cassandra 是一个高度可扩展的分区行存储。行被组织成具有所需主键的表。</p>
<p>最新版本：v4.0</p>
</blockquote>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>先决条件</p>
<ul>
<li>JDK8+</li>
<li>Python 2.7</li>
</ul>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Cassandra 是一套开源分布式 Key-Value 存储系统。它最初由 Facebook 开发，用于储存特别大的数据。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h4><ul>
<li>分布式</li>
<li>基于 column 的结构化</li>
<li>高伸展性</li>
</ul>
<p>Cassandra 的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成的一个分布式网络服务，对 Cassandra 的一个写操作，会被复制到其他节点上去，对 Cassandra 的读操作，也会被路由到某个节点上面去读取。对于一个 Cassandra 群集来说，扩展性能 是比较简单的事情，只管在群集里面添加节点就可以了。</p>
<h4 id="突出特性"><a href="#突出特性" class="headerlink" title="突出特性"></a>突出特性</h4><ul>
<li><strong>模式灵活</strong> - 使用 Cassandra，像文档存储，不必提前解决记录中的字段。你可以在系统运行时随意的添加或移除字段。这是一个惊人的效率提升，特别是在大型部署上。</li>
<li><strong>真正的可扩展性</strong> - Cassandra 是纯粹意义上的水平扩展。为给集群添加更多容量，可以指向另一台电脑。你不必重启任何进程，改变应用查询，或手动迁移任何数据。</li>
<li><strong>多数据中心识别</strong> - 你可以调整你的节点布局来避免某一个数据中心起火，一个备用的数据中心将至少有每条记录的完全复制。</li>
<li><strong>范围查询</strong> - 如果你不喜欢全部的键值查询，则可以设置键的范围来查询。</li>
<li><strong>列表数据结构</strong> - 在混合模式可以将超级列添加到 5 维。对于每个用户的索引，这是非常方便的。</li>
<li><strong>分布式写操作</strong> - 有可以在任何地方任何时间集中读或写任何数据。并且不会有任何单点失败。</li>
</ul>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul>
<li><a target="_blank" rel="noopener" href="http://cassandra.apache.org/">Cassandra 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/cassandra">Cassandra Github</a></li>
</ul>
<h2 id="🚪-传送"><a href="#🚪-传送" class="headerlink" title="🚪 传送"></a>🚪 传送</h2><p>◾ 💧 <a href="https://dunwu.github.io/waterdrop/">钝悟的 IT 知识图谱</a> ◾</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/058bdd15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/058bdd15/" class="post-title-link" itemprop="url">分布式 ID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-24 11:55:00" itemprop="dateCreated datePublished" datetime="2019-07-24T11:55:00+08:00">2019-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h1><h2 id="分布式-ID-简介"><a href="#分布式-ID-简介" class="headerlink" title="分布式 ID 简介"></a>分布式 ID 简介</h2><h3 id="什么是分布式-ID？"><a href="#什么是分布式-ID？" class="headerlink" title="什么是分布式 ID？"></a>什么是分布式 ID？</h3><p>ID 是 Identity 的缩写，用于唯一的标识一条数据。<strong>分布式 ID</strong>，顾名思义，是<strong>用于在分布式系统中唯一标识数据的 ID</strong>。</p>
<h3 id="为什么需要分布式-ID？"><a href="#为什么需要分布式-ID？" class="headerlink" title="为什么需要分布式 ID？"></a>为什么需要分布式 ID？</h3><p>传统数据库基本都支持针对单表生成唯一性的自增主键。随着数据的膨胀，单机成为了性能和容量的瓶颈。为了解决这个问题，有了分库分表技术。分库分表所要面临的第一个问题是：数据分布在不同机器上，数据库无法保证多个节点上产生的主键唯一。 这就需要用到分布式 ID 了，它起到了分布式系统中<strong>全局 ID</strong> 的作用。</p>
<h3 id="分布式-ID-的设计目标"><a href="#分布式-ID-的设计目标" class="headerlink" title="分布式 ID 的设计目标"></a>分布式 ID 的设计目标</h3><p>首先，分布式 ID 应该具备哪些特性呢？</p>
<ol>
<li><strong>全局唯一性</strong> - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>单调递增</strong> - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li>
<li><strong>高性能</strong> - 分布式 ID 的生成速度要快，对本地资源消耗要小。</li>
<li><strong>高可用</strong> - 生成分布式 ID 的服务要保证可用性无限接近于 100%。</li>
<li><strong>安全性</strong> - ID 中不应包括敏感信息。</li>
</ol>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID 是通用唯一识别码（Universally Unique Identifier）的缩写，是一种 128 位的标识符，由32个16进制字符表示。<strong>UUID 会根据运行应用的计算机网卡 MAC 地址、时间戳、命名空间等元素，通过一定的随机算法产生</strong>。</p>
<p>UUID 不保证全局唯一性，我们需要小心 ID 冲突（尽管这种可能性很小）。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">维基百科 - UUID</a> 中介绍了 5 种 UUID 算法。</p>
<h3 id="版本-1"><a href="#版本-1" class="headerlink" title="版本 1"></a>版本 1</h3><p>UUID 版本 1 <strong>根据时间和 MAC 地址生成 UUID</strong>。</p>
<p><img src="https://bleid.netlify.app/img/version/version_1_uuid.png" alt="img"></p>
<p>组成参数说明：</p>
<ul>
<li><strong>time_low</strong> - 与日期时间信息的低值有关</li>
<li><strong>time_mid</strong> - 与日期时间信息的 mid 值有关</li>
<li><strong>time_high_and_version</strong> - 与日期时间信息的高值有关</li>
<li><strong>clock_seq_hi_and_reserved</strong> - 与计算机系统的内部时钟序列有关</li>
<li><strong>MAC 地址</strong> - 设备的 MAC 地址</li>
</ul>
<h3 id="版本-2"><a href="#版本-2" class="headerlink" title="版本 2"></a>版本 2</h3><p>UUID 版本 2 <strong>根据时间和 MAC 地址、DCE Security 生成 UUID</strong>。</p>
<p>它将版本 1 中的日期时间信息替换为本地域名。它没有被广泛使用，因为它降低了唯一性。</p>
<h3 id="版本-3"><a href="#版本-3" class="headerlink" title="版本 3"></a>版本 3</h3><p>UUID 版本 3 <strong>使用命名空间和名称生成 UUID</strong>。<strong>命名空间</strong>本身是一个 UUID，URL 名称用作标识。二者组合后，通过 <strong>MD5</strong> 哈希算法计算生成 UUID。</p>
<p><img src="https://bleid.netlify.app/img/version/version_3_uuid.png" alt="img"></p>
<h3 id="版本-5"><a href="#版本-5" class="headerlink" title="版本 5"></a>版本 5</h3><p>UUID 版本 5 和 版本 4 近似，都<strong>使用命名空间和名称生成 UUID</strong>。差异在于：<strong>版本 3 采用 MD5 作为哈希算法</strong>；<strong>版本 5 采用 SHA1 作为哈希算法</strong>。</p>
<p><img src="https://bleid.netlify.app/img/version/version_5_uuid.png" alt="img"></p>
<p><strong>版本 3 、版本 5</strong> - 基于哈希命名空间标识符和名称生成 UUID，差异在于：版本 3 采用 MD5 作为哈希算法；版本 5 采用 SHA1 作为哈希算法。</p>
<h3 id="版本-4"><a href="#版本-4" class="headerlink" title="版本 4"></a>版本 4</h3><p>版本 4 随机生成 UUID，不包含其他 UUID 中使用的任何信息 （命名空间、MAC 地址、时间）。识别它的唯一方法是版本 4 UUID，字符只是 <strong>4</strong> 位于 UUID 第三部分的第一个位置。其他字符是随机生成的。</p>
<p><img src="https://bleid.netlify.app/img/version/version_4_uuid.png" alt="img"></p>
<p>版本 4 是最常见的 UUID 实现，JDK 中也提供了实现，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>

<h3 id="UUID-的优缺点"><a href="#UUID-的优缺点" class="headerlink" title="UUID 的优缺点"></a>UUID 的优缺点</h3><ul>
<li><strong>优点</strong><ul>
<li>简单、生成速度较快（本地生成，不依赖其他服务）</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li><strong>无序</strong> - 不能生成递增有序的数字，这不利于一些特定场景。如：MySQL InnoDB 存储引擎使用 B+ 树存储索引数据，索引数据在 B+ 树中是有序排列的。而 UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</li>
<li><strong>长度过长</strong> - UUID 需要占用 32 个字节</li>
<li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法，可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
</ul>
</li>
</ul>
<h2 id="数据库自增序列"><a href="#数据库自增序列" class="headerlink" title="数据库自增序列"></a>数据库自增序列</h2><p>大多数数据库都支持自增主键。基于此特性，可以利用事务管理控制生成唯一 ID。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p>（1）创建一个专用于生成 ID 的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `sequence_id` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stub` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `stub` (`stub`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 <code>stub</code> 字段创建了唯一索引，保证其唯一性。</p>
<p>（2）通过 <code>replace into</code> 来插入数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">REPLACE <span class="keyword">INTO</span> sequence_id (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;stub&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p>
<ul>
<li>第一步：尝试把数据插入到表中。</li>
<li>第二步：如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</li>
</ul>
<p>这种方式的优缺点也比较明显：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>方案简单</li>
<li>有序</li>
<li>ID 长度小</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>性能差</li>
<li>每次获取 ID 都要访问一次数据库，增加了对数据库的压力</li>
<li>不安全，根据发号数量信息可能推测出业务规模</li>
<li>单点问题，如果数据库宕机会造成服务不可用，可以使用高可用方案来解决，但会增加复杂度</li>
</ul>
</li>
</ul>
<h2 id="数据库生成号段"><a href="#数据库生成号段" class="headerlink" title="数据库生成号段"></a>数据库生成号段</h2><p>数据库自增序列这种模式，每次获取 ID 都要请求一次数据库。当请求并发量高时，会给数据库带来很大的压力，并且生成 ID 的性能也比较差。</p>
<p>可以采用<strong>批处理</strong>的思路来优化数据库自增序列方案。申请 ID 改为批量获取，不再一次只申请一个 ID，而是一次批量生成一个 segment（号段），号段的大小由 step（步长）控制。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz_tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `leaf_alloc` (</span><br><span class="line">  `biz_tag` <span class="type">varchar</span>(<span class="number">128</span>)  <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `max_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  `step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">256</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`biz_tag`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> leaf_alloc(biz_tag, max_id, step, description) <span class="keyword">values</span>(<span class="string">&#x27;leaf-segment-test&#x27;</span>, <span class="number">1</span>, <span class="number">2000</span>, <span class="string">&#x27;Test leaf Segment Mode Get Id&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>重要字段说明：</p>
<ul>
<li><code>biz_tag</code> 用来区分业务</li>
<li><code>max_id</code> 表示该 <code>biz_tag</code> 目前所被分配的 ID 号段的最大值</li>
<li><code>step</code> 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 <code>step</code> 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1&#x2F;step。</li>
</ul>
<p>大致架构如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5e4ff128.png" alt="image"></p>
<p>test_tag 在第一台 Leaf 机器上是 <code>1~1000</code> 的号段，当这个号段用完时，会去加载另一个长度为 step&#x3D;1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 <code>3001~4000</code>。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>

<p><strong>数据库号段模式的优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：<ul>
<li>有序</li>
<li>ID 长度小</li>
<li>效率比数据库自增序列方式高很多</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>号段使用完，还是需要向数据库发起事务更新，以获取新号段</li>
<li>不安全，根据发号数量信息可能推测出业务规模</li>
<li>单点问题，如果数据库宕机会造成服务不可用，可以使用高可用方案来解决，但会增加复杂度</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展：滴滴的 <a target="_blank" rel="noopener" href="https://github.com/didi/tinyid">tinyid</a> 和美团的 <a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">Leaf</a> 都是基于数据库生成号段方案实现的，不过都各自做了一些优化。</p>
<p>美团技术团队还对分布式 ID 生成做了一篇技术分享：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式 ID 生成系统</a>，其对于数据库号段模式的优化要点如下：</p>
<ul>
<li>Leaf 采用双 Buffer 优化，避免号段耗尽时，阻塞以获取新号段。其本质上是：通过双缓存，提前预热号段缓存。</li>
<li>此外，基于 Atlas（以改名 DBProxy）保障数据库的高可用。也就是保护了号段数据存储的高可用。</li>
</ul>
</blockquote>
<h2 id="原子计数器"><a href="#原子计数器" class="headerlink" title="原子计数器"></a>原子计数器</h2><p>一些 NoSQL 数据库提供了原子性的计数器，可以基于这点，来实现分布式 ID。</p>
<h3 id="Redis-生成自增键"><a href="#Redis-生成自增键" class="headerlink" title="Redis 生成自增键"></a>Redis 生成自增键</h3><p>Redis 的 String 类型提供 <code>INCR</code> 和 <code>INCRBY</code> 命令将 key 中储存的数字<strong>原子递增</strong>。</p>
<p>为避免单点问题，可以采用 Redis Cluster。</p>
<p><strong>Redis 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：高性能、有序</li>
<li><strong>缺点</strong>：和数据库自增序列方案的缺点类似</li>
</ul>
<h3 id="ZooKeeper-生成自增键"><a href="#ZooKeeper-生成自增键" class="headerlink" title="ZooKeeper 生成自增键"></a>ZooKeeper 生成自增键</h3><p>利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。</p>
<p><strong>每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端</strong>。ID 编码生成器可以作为 ZooKeeper 的服务端。客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/assets/CgqCHl8RTBGAB7QNAAAvwu3rspw007.png" alt="Drawing 2.png"></p>
<p>可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</p>
<p>:::details 要点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperDistributedId</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;127.0.0.1:2181&quot;</span>, retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启会话</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">id1</span> <span class="operator">=</span> client.create()</span><br><span class="line">                           .creatingParentsIfNeeded()</span><br><span class="line">                           .withMode(CreateMode.PERSISTENT_SEQUENTIAL)</span><br><span class="line">                           .forPath(<span class="string">&quot;/zkid/id_&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, id1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">id2</span> <span class="operator">=</span> client.create()</span><br><span class="line">                           .creatingParentsIfNeeded()</span><br><span class="line">                           .withMode(CreateMode.PERSISTENT_SEQUENTIAL)</span><br><span class="line">                           .forPath(<span class="string">&quot;/zkid/id_&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, id2);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; children = client.getChildren().forPath(<span class="string">&quot;/zkid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isNotEmpty(children)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">                client.delete().forPath(<span class="string">&quot;/zkid/&quot;</span> + child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/zkid&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<p><strong>ZooKeeper 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：简单、可靠性高</li>
<li><strong>缺点</strong>：性能不高</li>
</ul>
<h2 id="雪花算法（Snowflake）"><a href="#雪花算法（Snowflake）" class="headerlink" title="雪花算法（Snowflake）"></a>雪花算法（Snowflake）</h2><p>雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，<strong>它会生成一个 <code>64 bit</code> 的整数</strong>，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p>
<h3 id="键的组成"><a href="#键的组成" class="headerlink" title="键的组成"></a>键的组成</h3><p>使用<strong>雪花算法生成的主键，二进制表示形式包含 4 部分</strong>，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p>
<ul>
<li><strong>符号位 (1bit)</strong></li>
</ul>
<p>预留的符号位，恒为零。</p>
<ul>
<li><strong>时间戳位 (41bit)</strong></li>
</ul>
<p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：<code>365 * 24 * 60 * 60 * 1000</code>。通过计算可知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">41</span>) / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>

<p>结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p>
<ul>
<li><strong>工作进程位 (10bit)</strong></li>
</ul>
<p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p>
<ul>
<li><strong>序列号位 (12bit)</strong></li>
</ul>
<p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂），那么生成器会等待到下个毫秒继续生成。</p>
<p>雪花算法主键的详细结构见下图：</p>
<p><img src="https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png" alt="雪花算法"></p>
<h3 id="时钟回拨"><a href="#时钟回拨" class="headerlink" title="时钟回拨"></a>时钟回拨</h3><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p>
<p>雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。</p>
<p>我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。</p>
<p>用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况：</p>
<ul>
<li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略：<ul>
<li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li>
<li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ul>
</li>
</ul>
<h3 id="灵活定制"><a href="#灵活定制" class="headerlink" title="灵活定制"></a>灵活定制</h3><p>上面只是一个将 <code>64bit</code> 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前 QPS10 万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器 10 台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p>
<p>机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 &#x3D; 2bit，还剩下 2bit 可以用来进行扩展。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16624909d2007c22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="雪花算法小结"><a href="#雪花算法小结" class="headerlink" title="雪花算法小结"></a>雪花算法小结</h3><p>雪花算法的<strong>利弊</strong>：</p>
<ul>
<li><strong>优点</strong><ul>
<li>生成的 ID 都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li>
<li>可以根据自身业务特性分配 bit 位，非常灵活。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
</li>
</ul>
<p>雪花算法的<strong>适用场景</strong>：</p>
<p>当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bb0217ef265da0ac2567b42">如果再有人问你分布式 ID，这篇文章丢给他</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011282426">理解分布式 id 生成算法 SnowFlake</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式 ID 生成系统</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc4122.txt">UUID 规范</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">百度分布式 ID</a></li>
<li><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/key-generator/">ShardingSphere 分布式主键</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/bytebytego-system-design-alliance/7-famous-approaches-to-generate-distributed-id-with-comparison-table-af89afe4601f">7 Famous Approaches to Generate Distributed ID with Comparison Table</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14343086.html">冷饭新炒：理解 JDK 中 UUID 的底层实现</a></li>
<li><a target="_blank" rel="noopener" href="https://bleid.netlify.app/">What is UUID?</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3e7042f9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3e7042f9/" class="post-title-link" itemprop="url">zsh</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-11 16:52:00" itemprop="dateCreated datePublished" datetime="2019-07-11T16:52:00+08:00">2019-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="oh-my-zsh-应用"><a href="#oh-my-zsh-应用" class="headerlink" title="oh-my-zsh 应用"></a>oh-my-zsh 应用</h1><h2 id="Zsh-简介"><a href="#Zsh-简介" class="headerlink" title="Zsh 简介"></a>Zsh 简介</h2><h3 id="Zsh-是什么"><a href="#Zsh-是什么" class="headerlink" title="Zsh 是什么"></a>Zsh 是什么</h3><p>使用 Linux 的人都知道：<em><em>*Shell</em> 是一个用 C 语言编写的程序,它是用户使用 Linux 的桥梁。_Shell</em> 既是一种命令语言,又是一种程序设计语言**。</p>
<p>Shell 的类型有很多种，linux 下默认的是 bash，虽然 bash 的功能已经很强大，但对于以懒惰为美德的程序员来说，bash 的提示功能不够强大，界面也不够炫，并非理想工具。</p>
<p><a target="_blank" rel="noopener" href="http://www.zsh.org/"><strong>Zsh</strong></a> 也是一种 Shell（据传说 99% 的 Bash 操作 和 Zsh 是相同的），它的功能极其强大，只是配置过于复杂，起初只有极客才在用。后来，出现了一个名叫 <a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh"><strong>oh-my-zsh</strong></a> 的开源项目，使用 zsh 就变得十分简易了。</p>
<h2 id="Zsh-安装"><a href="#Zsh-安装" class="headerlink" title="Zsh 安装"></a>Zsh 安装</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul>
<li>CentOS 6.7 64 bit</li>
<li>root 用户</li>
</ul>
<h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><ul>
<li>先看下你的 CentOS 支持哪些 shell：<code>cat /etc/shells</code>，正常结果应该是这样的：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure>

<p>如果已经有 zsh ，那么我们就不必安装了。</p>
<ul>
<li>CentOS 安装：<code>sudo yum install -y zsh</code></li>
<li>Ubuntu 安装：<code>sudo apt-get install -y zsh</code></li>
<li>检查系统的 shell：<code>cat /etc/shells</code>，你会发现多了一个：<code>/bin/zsh</code></li>
</ul>
<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>使用 <a target="_blank" rel="noopener" href="http://www.zsh.org/"><strong>Zsh</strong></a>，怎么能离开灵魂伴侣 <a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh"><strong>oh-my-zsh</strong></a>？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 oh-my-zsh</span></span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>

<h3 id="配置-oh-my-zsh"><a href="#配置-oh-my-zsh" class="headerlink" title="配置 oh-my-zsh"></a>配置 oh-my-zsh</h3><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><blockquote>
<p>oh-my-zsh 插件太多，不一一列举，请参考：<a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins">oh-my-zsh 插件列表</a></p>
</blockquote>
<ul>
<li>启用 oh-my-zsh 中自带的插件。</li>
<li>查看 oh-my-zsh 插件数：<code>ls -l /root/.oh-my-zsh/plugins |grep &quot;^d&quot;|wc -l</code></li>
<li>编辑配置文件：<code>vim /root/.zshrc</code></li>
<li>插件推荐：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-autosuggestions"><code>zsh-autosuggestions</code></a><ul>
<li>这个插件会对历史命令一些补全，类似 fish 终端</li>
<li>安装，复制该命令：<code>git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-\~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code> - 编辑：<code>vim \~/.zshrc</code>，找到这一行，后括号里面的后面添加：<code>plugins=( 前面的一些插件名称，换行，加上：zsh-autosuggestions)</code> - 刷新下配置：<code>source \~/.zshrc</code></li>
</ul>
</li>
<li>extract<ul>
<li>功能强大的解压插件，所有类型的文件解压一个命令 x 全搞定，再也不需要去记 tar 后面到底是哪几个参数了。</li>
</ul>
</li>
<li>z<ul>
<li>强大的目录自动跳转命令，会记忆你曾经进入过的目录，用模糊匹配快速进入你想要的目录。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-syntax-highlighting"><code>zsh-syntax-highlighting</code></a><ul>
<li>这个插件会对终端命令高亮显示,比如正确的拼写会是绿色标识,否则是红色,另外对于一些 shell 输出语句也会有高亮显示,算是不错的辅助插件</li>
<li>安装，复制该命令：<code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-\~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></li>
<li>编辑：<code>vim \~/.zshrc</code>，找到这一行，后括号里面的后面添加：<code>plugins=( 前面的一些插件名称，换行，加上：zsh-syntax-highlighting)</code> - 刷新下配置：<code>source \~/.zshrc</code></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/mfaerevaag/wd"><code>wd</code></a><ul>
<li>简单地讲就是给指定目录映射一个全局的名字，以后方便直接跳转到这个目录，比如：</li>
<li>编辑配置文件，添加上 wd 的名字：<code>vim /root/.zshrc</code></li>
<li>我常去目录：**&#x2F;opt&#x2F;setups**，每次进入该目录下都需要这样：<code>cd /opt/setups</code></li>
<li>现在用 wd 给他映射一个快捷方式：<code>cd /opt/setups ; wd add setups</code></li>
<li>以后我在任何目录下只要运行：<code>wd setups</code> 就自动跑到 &#x2F;opt&#x2F;setups 目录下了</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/wting/autojump"><code>autojump</code></a><ul>
<li>这个插件会记录你常去的那些目录，然后做一下权重记录，你可以用这个命令看到你的习惯：<code>j --stat</code>，如果这个里面有你的记录，那你就只要敲最后一个文件夹名字即可进入，比如我个人习惯的 program：<code>j program</code>，就可以直接到：<code>/usr/program</code></li>
<li>插件下载：<code>wget https://github.com/downloads/wting/autojump/autojump_v21.1.2.tar.gz</code></li>
<li>解压：<code>tar zxvf autojump_v21.1.2.tar.gz</code></li>
<li>进入解压后目录并安装：<code>cd autojump_v21.1.2/ ; ./install.sh</code></li>
<li>再执行下这个：<code>source /etc/profile.d/autojump.sh</code></li>
<li>编辑配置文件，添加上 autojump 的名字：<code>vim /root/.zshrc</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><blockquote>
<p>oh-my-zsh 主题太多，不一一列举，请参考：<a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">oh-my-zsh 主题列表</a></p>
</blockquote>
<ul>
<li>查看 oh-my-zsh 主题数：<code>ls -l /root/.oh-my-zsh/themes |grep &quot;^-&quot;|wc -l</code></li>
<li>个人比较推荐的是（排名有先后）：<ul>
<li><code>ys</code></li>
<li><code>agnoster</code></li>
<li><code>avit</code></li>
<li><code>blinks</code></li>
</ul>
</li>
<li>编辑配置文件：<code>vim /root/.zshrc</code></li>
<li>配置好新主题需要重新连接 shell 才能看到效果</li>
</ul>
<p>zsh 效果如下：</p>
<p><img src="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png" alt="img"></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>呃，这个其实可以不用讲的，你自己用的时候你自己会发现的，各种便捷，特别是用 Tab 多的人一定会有各种惊喜的。</li>
<li>使用 ctrl-r 来搜索命令历史记录。按完此快捷键后，可以输入关键命令词语，如果历史记录有含有此词语会显示出来。</li>
<li>命令别名： - 在命令行中输入 alias 可以查看已经有的命令别名 - 自己新增一些别名，编辑文件：<code>vim \~/.zshrc</code>，在文件加入下面格式的命令，比如以下是网友提供的一些思路：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alias cls=&#x27;clear&#x27;</span><br><span class="line">alias ll=&#x27;ls -l&#x27;</span><br><span class="line">alias la=&#x27;ls -a&#x27;</span><br><span class="line">alias grep=&quot;grep --color=auto&quot;</span><br><span class="line">alias -s html=&#x27;vim&#x27;   # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开</span><br><span class="line">alias -s rb=&#x27;vim&#x27;     # 在命令行直接输入 ruby 文件，会在 Vim 中打开</span><br><span class="line">alias -s py=&#x27;vim&#x27;      # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span><br><span class="line">alias -s js=&#x27;vim&#x27;</span><br><span class="line">alias -s c=&#x27;vim&#x27;</span><br><span class="line">alias -s java=&#x27;vim&#x27;</span><br><span class="line">alias -s txt=&#x27;vim&#x27;</span><br><span class="line">alias -s gz=&#x27;tar -xzvf&#x27; # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开</span><br><span class="line">alias -s tgz=&#x27;tar -xzvf&#x27;</span><br><span class="line">alias -s zip=&#x27;unzip&#x27;</span><br><span class="line">alias -s bz2=&#x27;tar -xjvf&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh Github</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/366cf7bd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/366cf7bd/" class="post-title-link" itemprop="url">缓存基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-27 15:36:00" itemprop="dateCreated datePublished" datetime="2019-06-27T15:36:00+08:00">2019-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="缓存基本原理"><a href="#缓存基本原理" class="headerlink" title="缓存基本原理"></a>缓存基本原理</h1><blockquote>
<p>缓存是一种利用空间换时间的设计，其目标就是<strong>更快</strong>、<strong>更近</strong>。</p>
</blockquote>
<h2 id="缓存简介"><a href="#缓存简介" class="headerlink" title="缓存简介"></a>缓存简介</h2><h3 id="为什么需要缓存"><a href="#为什么需要缓存" class="headerlink" title="为什么需要缓存"></a>为什么需要缓存</h3><p>众所周知，当今是一个互联网时代，而互联网应用几乎遍及我们日常生活的方方面面。一般而言，一个互联网应用的请求&#x2F;响应流程会有以下几个主要流程：</p>
<ul>
<li>客户端发起请求，请求经过网络 I&#x2F;O，分发到服务层。</li>
<li>服务层可能有多级服务，请求需要被多个服务层层处理。</li>
<li>不同服务根据请求进行计算时，可能依赖于不同数据库的数据，需要通过网络 I&#x2F;O 读写数据库。</li>
</ul>
<p>显然，这一套流程下来，可能需要消耗大量的计算机资源，并且响应时间也可能很久。如果并发请求量很大的话，可能会进一步加剧这种问题。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151116093.png"></p>
<p>为了解决以上问题，最直接的方式就是引入缓存。缓存可以作用于请求&#x2F;响应流程的任意环节，并有效减少后续环节的执行次数，从而大大提升性能。</p>
<p>实际上，缓存作为性能优化的第一手段，被广泛应用于计算机的硬件、软件领域。</p>
<h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><p><strong>缓存就是数据交换的缓冲区，用于将频繁访问的数据暂存在访问速度快的存储介质</strong>。</p>
<p>缓存的本质是一种利用<strong>空间换时间</strong>的设计：牺牲一定的数据实时性，使得访问<strong>更快</strong>、<strong>更近</strong>：</p>
<ul>
<li>将数据存储到读取速度<strong>更快</strong>的存储（设备）；</li>
<li>将数据存储到<strong>离应用最近</strong>的位置；</li>
<li>将数据存储到<strong>离用户最近</strong>的位置。</li>
</ul>
<p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。</p>
<p><strong>缓存命中率</strong>是缓存的重要度量指标，命中率越高越好。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存命中率 <span class="operator">=</span> 从缓存中读取次数 / 总读取次数</span><br></pre></td></tr></table></figure>

<h3 id="何时需要缓存"><a href="#何时需要缓存" class="headerlink" title="何时需要缓存"></a>何时需要缓存</h3><p>引入缓存，会增加系统的复杂度，并牺牲一定的数据实时性。所以，引入缓存前，需要先权衡是否值得，考量点如下：</p>
<ul>
<li><strong>CPU 开销</strong> - 如果应用某个计算需要消耗大量 CPU，可以考虑缓存其计算结果。典型场景：复杂的、频繁调用的正则计算；分布式计算中间状态等。</li>
<li><strong>IO 开销</strong> - 如果数据库连接池比较繁忙，可以考虑缓存其查询结果。</li>
</ul>
<p>在数据层引入缓存，有以下几个好处：</p>
<ul>
<li>提升数据读取速度。</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力。</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。</li>
</ul>
<h3 id="缓存的基本原理"><a href="#缓存的基本原理" class="headerlink" title="缓存的基本原理"></a>缓存的基本原理</h3><p>根据业务场景，通常缓存有以下几种使用方式：</p>
<ul>
<li>懒汉式（读时触发）：先查询 DB 里的数据，然后把相关的数据写入 Cache。</li>
<li>饥饿式（写时触发）：写入 DB 后，然后把相关的数据也写入 Cache。</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。</li>
</ul>
<h2 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h2><p>缓存从架构维度来看，可以分为客户端缓存和服务端缓存。</p>
<p>缓存从集群维度来看，可以分为进程内缓存和分布式缓存。</p>
<p><strong>客户端缓存</strong></p>
<ul>
<li><strong>Http 缓存</strong>：HTTP&#x2F;1.1 中的 <code>Cache-Control</code>、HTTP&#x2F;1 中的 <code>Expires</code></li>
<li><strong>浏览器缓存</strong>：HTML5 提供的 SessionStorage 和 LocalStorage、Cookie</li>
<li><strong>APP 缓存</strong><ul>
<li>Android</li>
<li>IOS</li>
</ul>
</li>
</ul>
<p><strong>服务端缓存</strong></p>
<ul>
<li><strong>CDN 缓存</strong> - 存放 HTML、CSS、JS 等静态资源。</li>
<li><strong>反向代理缓存</strong> - 动静分离，只缓存用户请求的静态资源。</li>
<li><strong>数据库缓存</strong> - 数据库（如 Mysql）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。</li>
<li><strong>进程内缓存</strong> - 缓存应用字典等常用数据。</li>
<li><strong>分布式缓存</strong> - 缓存数据库中的热点数据。</li>
</ul>
<blockquote>
<p>其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。</p>
<p>后端开发一般聚焦于进程内缓存、分布式缓存。</p>
</blockquote>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><ol>
<li><p>浏览器发送请求前，根据请求头的 <code>expires</code> (HTTP&#x2F;1) 和 <code>cache-control</code> (HTTP&#x2F;1.1) 判断是否命中（包括是否过期）强缓存策略，</p>
<ol>
<li>如果命中，直接从缓存获取资源，并不会发送请求。</li>
<li>如果没有命中，则进入下一步。</li>
</ol>
</li>
<li><p>没有命中强缓存规则，浏览器会发送请求，根据请求头的 <code>last-modified</code> 和 <code>etag</code> 判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</p>
</li>
<li><p>如果前两步都没有命中，则直接从服务端获取资源。</p>
</li>
</ol>
<h3 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h3><blockquote>
<p><strong>CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）</strong>。</p>
<p>国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559138689425.png" alt="img"></p>
<h4 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h4><p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署 CDN 应用前的网络路径：</p>
<ul>
<li>请求：本机网络（局域网）&#x3D;&gt; 运营商网络 &#x3D;&gt; 应用服务器机房</li>
<li>响应：应用服务器机房 &#x3D;&gt; 运营商网络 &#x3D;&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。</p>
<p>（2）部署 CDN 应用后网络路径：</p>
<ul>
<li>请求：本机网络（局域网） &#x3D;&gt; 运营商网络</li>
<li>响应：运营商网络 &#x3D;&gt; 本机网络（局域网）</li>
</ul>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。</p>
<p>与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。</p>
<h4 id="CDN-特点"><a href="#CDN-特点" class="headerlink" title="CDN 特点"></a>CDN 特点</h4><p><strong>优点</strong></p>
<ul>
<li><strong>本地 Cache 加速</strong> - 提升访问速度，尤其含有大量图片和静态页面站点；</li>
<li><strong>实现跨运营商的网络加速</strong> - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</li>
<li><strong>远程加速</strong> - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；</li>
<li><strong>带宽优化</strong> - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li><strong>集群抗攻击</strong> - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>不适宜缓存动态资源</strong><ul>
<li>解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</li>
</ul>
</li>
<li><strong>存在数据的一致性问题</strong><ul>
<li>解决方案（主要是在性能和数据一致性二者间寻找一个平衡）</li>
<li>设置缓存失效时间（1 个小时，过期后同步数据）。</li>
<li>针对资源设置版本号。</li>
</ul>
</li>
</ul>
<h3 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h3><blockquote>
<p><strong>反向代理（Reverse Proxy）方式是指以代理服务器来接受网络连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个反向代理服务器。</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/web/nginx/reverse-proxy.png" alt="img"></p>
<h4 id="反向代理缓存原理"><a href="#反向代理缓存原理" class="headerlink" title="反向代理缓存原理"></a>反向代理缓存原理</h4><p>反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。</p>
<p>反向代理缓存的原理：</p>
<ul>
<li>如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。</li>
<li>如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。</li>
</ul>
<p>这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。</p>
<p><strong>反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理</strong>。常用的缓存应用服务器有 Varnish，Ngnix，Squid。</p>
<h4 id="反向代理缓存比较"><a href="#反向代理缓存比较" class="headerlink" title="反向代理缓存比较"></a>反向代理缓存比较</h4><p>常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：</p>
<ul>
<li>Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；</li>
<li>Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；</li>
<li>Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；</li>
<li>Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；</li>
<li>Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。</li>
</ul>
<h2 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h2><blockquote>
<p>进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。</p>
</blockquote>
<ul>
<li><code>硬盘缓存</code> - 将数据缓存到硬盘中，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。</li>
<li><code>内存缓存</code> - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。</li>
</ul>
<p>常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：<strong>不需要淘汰的缓存数据</strong>。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h3 id="LRUHashMap"><a href="#LRUHashMap" class="headerlink" title="LRUHashMap"></a>LRUHashMap</h3><p>可以通过**继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>**。重写 <code>removeEldestEntry</code> 方法，即可完成一个简单的最近最少使用算法。</p>
<p>缺点：</p>
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
<h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 采用了类似 <code>ConcurrentHashMap</code> 的思想，分段加锁，减少锁竞争。</p>
<p>Guava Cache 对于过期的 Entry 并没有马上过期（也就是并没有后台线程一直在扫），而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p>Caffeine 实现了 W-TinyLFU(<strong>LFU</strong> + <strong>LRU</strong> 算法的变种），其<strong>命中率和读写吞吐量大大优于 Guava Cache</strong>。</p>
<p>其实现原理较复杂，可以参考 <a target="_blank" rel="noopener" href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment">你应该知道的缓存进化史</a>。</p>
<h3 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h3><p>EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。</p>
<p>优点</p>
<ul>
<li>快速、简单</li>
<li>支持多种缓存策略：LRU、LFU、FIFO 淘汰算法</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过 RMI、可插入 API 等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供 Hibernate 的缓存实现</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>使用磁盘 Cache 的时候非常占用磁盘空间</strong></li>
<li><strong>不保证数据的安全</strong></li>
<li>虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。</li>
</ul>
<h3 id="进程内缓存对比"><a href="#进程内缓存对比" class="headerlink" title="进程内缓存对比"></a>进程内缓存对比</h3><p>常用进程内缓存技术对比：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody><tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法，LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：**如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 <code>Caffeine</code>**。</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><blockquote>
<p><strong>分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存</strong>。</p>
<p>分布式缓存的应用场景：</p>
<ul>
<li>缓存经过复杂计算得到的数据</li>
<li>缓存系统中频繁访问的热点数据，减轻数据库压力</li>
</ul>
</blockquote>
<p>不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。</p>
<h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://memcached.org/">Memcached</a> 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p>
<p>简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。</p>
</blockquote>
<h4 id="Memcached-特性"><a href="#Memcached-特性" class="headerlink" title="Memcached 特性"></a>Memcached 特性</h4><ul>
<li><strong>使用物理内存作为缓存区，可独立运行在服务器上</strong>。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcached 进程（不同端口）或者使用分布式 Memcached 进行缓存，将数据缓存到不同的物理机或者虚拟机上。</li>
<li><strong>使用 key-value 的方式来存储数据</strong>。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。</li>
<li><strong>协议简单，基于文本行的协议</strong>。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</li>
<li><strong>基于 libevent 高性能通信</strong>。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。</li>
<li><strong>分布式能力取决于 Memcached 客户端，服务器之间互不通信</strong>。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。</li>
<li><strong>采用 LRU 缓存淘汰策略</strong>。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key&#x2F;vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key&#x2F;value 对空间是否过期，这样可减轻服务器的负载。</li>
<li><strong>内置了一套高效的内存管理算法</strong>。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。</li>
<li><strong>不支持持久化</strong>。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。</li>
</ul>
<h4 id="Memcached-工作原理"><a href="#Memcached-工作原理" class="headerlink" title="Memcached 工作原理"></a>Memcached 工作原理</h4><p>（1）内存管理</p>
<p>Memcached 利用 <strong>slab allocation</strong> 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。</p>
<p>这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。</p>
<p>（2）缓存淘汰策略</p>
<p>Memcached 的缓存淘汰策略是 <strong>LRU</strong> + 到期失效策略。</p>
<p>当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。</p>
<p>在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：<strong>Memcached 不会监控存入的 key&#x2F;vlue 对是否过期</strong>，而是在获取 key 值时查看记录的时间戳，<strong>检查 key&#x2F;value 对空间是否过期</strong>，这样可减轻服务器的负载。</p>
<p>（3）分区</p>
<p>Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。</p>
<p>具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读&#x2F;写。</p>
<p>而这种选取集群节点的算法常见的有三种：</p>
<ul>
<li><strong>哈希取余算法</strong> - 使用公式：<code>hash（key）% N</code> 计算出 <strong>哈希值</strong> 来决定数据映射到哪一个节点。</li>
<li><strong>一致性哈希算法</strong> - 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</li>
<li><strong>虚拟 Hash 槽算法</strong> - 使用 <strong>分散度良好</strong> 的 <strong>哈希函数</strong> 把所有数据 <strong>映射</strong> 到一个 <strong>固定范围</strong> 的 <strong>整数集合</strong> 中，整数定义为 <strong>槽</strong>（<code>slot</code>），这个范围一般 <strong>远远大于</strong> 节点数。<strong>槽</strong> 是集群内 <strong>数据管理</strong> 和 <strong>迁移</strong> 的 <strong>基本单位</strong>。采用 <strong>大范围槽</strong> 的主要目的是为了方便 <strong>数据拆分</strong> 和 <strong>集群扩展</strong>。每个节点会负责 <strong>一定数量的槽</strong>。</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote>
<p>Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。</p>
<p>Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
</blockquote>
<h4 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h4><ul>
<li><p>支持多种数据类型 - string、hash、list、set、sorted set。</p>
</li>
<li><p>支持多种数据淘汰策略</p>
<ul>
<li><strong>volatile-lru</strong> - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong> - 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong> - 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong> - 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li><strong>allkeys-random</strong> - 从所有数据集中任意选择数据进行淘汰</li>
<li><strong>noeviction</strong> - 禁止驱逐数据</li>
</ul>
</li>
<li><p>提供两种持久化方式 - RDB 和 AOF</p>
</li>
<li><p>通过 Redis cluster 提供集群模式。</p>
</li>
</ul>
<h4 id="Redis-原理"><a href="#Redis-原理" class="headerlink" title="Redis 原理"></a>Redis 原理</h4><ul>
<li>缓存淘汰<ul>
<li>Redis 有两种数据淘汰实现<ul>
<li>消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它</li>
<li>积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。</li>
</ul>
</li>
</ul>
</li>
<li>分区<ul>
<li>Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。</li>
<li>Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。</li>
</ul>
</li>
<li>主从复制<ul>
<li>Redis 2.8 后支持异步复制。它有两种模式：<ul>
<li><code>完整重同步（full resychronization）</code> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><code>部分重同步（partial resychronization）</code> - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
</li>
<li>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。</li>
<li>如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。</li>
</ul>
</li>
<li>数据一致性<ul>
<li>Redis 不保证强一致性，因为这会使得集群性能大大降低。</li>
<li>Redis 是通过异步复制来实现最终一致性。</li>
</ul>
</li>
</ul>
<h3 id="分布式缓存对比"><a href="#分布式缓存对比" class="headerlink" title="分布式缓存对比"></a>分布式缓存对比</h3><p>不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200709224247.png" alt="img"></p>
<p>这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>MemCache</th>
<th>Redis</th>
<th>Tair</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>只支持简单的 Key-Value 结构</td>
<td>String,Hash, List, Set, Sorted Set</td>
<td>String,HashMap, List，Set</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>容量大小</td>
<td>数据纯内存，数据存储不宜过多</td>
<td>数据全内存，资源成本考量不宜超过 100GB</td>
<td>可以配置全内存或内存+磁盘引擎，数据容量可无限扩充</td>
</tr>
<tr>
<td>读写性能</td>
<td>很高</td>
<td>很高 (RT0.5ms 左右）</td>
<td>String 类型比较高 (RT1ms 左右），复杂类型比较慢 (RT5ms 左右）</td>
</tr>
<tr>
<td>过期策略</td>
<td>过期后，不删除缓存</td>
<td>有六种策略来处理过期数据</td>
<td>支持</td>
</tr>
</tbody></table>
<ul>
<li><code>MemCache</code> - 只适合基于内存的缓存框架；且不支持数据持久化和容灾。</li>
<li><code>Redis</code> - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。</li>
<li><code>Tair</code> - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。</li>
</ul>
<p>总结：如果服务对延迟比较敏感，Map&#x2F;Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。</p>
<h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><h3 id="整体缓存框架"><a href="#整体缓存框架" class="headerlink" title="整体缓存框架"></a>整体缓存框架</h3><p>通常，一个大型软件系统的缓存采用多级缓存方案：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151117832.png"></p>
<p>请求过程：</p>
<ol>
<li>浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；</li>
<li>如果 CDN 无缓存，则访问反向代理服务器；</li>
<li>如果反向代理服务器有缓存则直接返回；</li>
<li>如果反向代理服务器无缓存或动态请求，则访问应用服务器；</li>
<li>应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）</li>
<li>如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；</li>
<li>如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；</li>
</ol>
<h3 id="使用进程内缓存"><a href="#使用进程内缓存" class="headerlink" title="使用进程内缓存"></a>使用进程内缓存</h3><p><strong>如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案</strong>。</p>
<p>对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于：</p>
<ul>
<li>数据量不是很大且更新频率较低的数据。</li>
<li>如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。</li>
</ul>
<p>这种方案存在以下问题：</p>
<ul>
<li>如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。</li>
<li>由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。</li>
</ul>
<h3 id="使用分布式缓存"><a href="#使用分布式缓存" class="headerlink" title="使用分布式缓存"></a>使用分布式缓存</h3><p>如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。</p>
<p>其应用场景如图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151117747.png"></p>
<p>Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。</p>
<p>这种方案存在以下问题：</p>
<ol>
<li>缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。</li>
<li>访问分布式缓存服务会有一定的 I&#x2F;O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。</li>
</ol>
<h3 id="使用多级缓存"><a href="#使用多级缓存" class="headerlink" title="使用多级缓存"></a>使用多级缓存</h3><p>单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。</p>
<p>这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。</p>
<p>一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。</p>
<p>一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine&#x2F;Google Guava&#x2F;Ehcache&#x2F;HashMap）作为一级缓存；使用分布式缓存（如：Redis&#x2F;Memcached）作为二级缓存。</p>
<h4 id="多级缓存查询"><a href="#多级缓存查询" class="headerlink" title="多级缓存查询"></a>多级缓存查询</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151118006.png"></p>
<p>多级缓存查询流程如下：</p>
<ol>
<li>首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。</li>
<li>接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。</li>
<li>最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。</li>
</ol>
<h4 id="多级缓存更新"><a href="#多级缓存更新" class="headerlink" title="多级缓存更新"></a>多级缓存更新</h4><p>对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略：</p>
<ul>
<li>设置成写入后多少时间后过期</li>
<li>设置成写入后多少时间刷新</li>
</ul>
<p>对于 L2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。</p>
<p>为了解决进程内缓存不一致的问题，设计可以进一步优化：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151119761.png"></p>
<p>通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。</p>
<h2 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h2><p>缓存一般存于访问速度较快的存储介质，快也就意味着资源昂贵并且有限。正所谓，好钢要用在刀刃上。因此，缓存要合理利用，需要设定一些机制，将一些访问频率偏低或过期的数据淘汰。</p>
<p>淘汰缓存首先要做的是，确定什么时候触发淘汰缓存，一般有以下几个思路：</p>
<ul>
<li><strong>基于空间</strong> - 设置缓存空间大小。</li>
<li><strong>基于容量</strong> - 设置缓存存储记录数。</li>
<li><strong>基于时间</strong><ul>
<li><strong>TTL（Time To Live，即存活期）</strong> - 缓存数据从创建到过期的时间。</li>
<li><strong>TTI（Time To Idle，即空闲期）</strong> - 缓存数据多久没被访问的时间。</li>
</ul>
</li>
</ul>
<p>接下来，就要确定如何淘汰缓存，常见的缓存淘汰算法有以下几个：</p>
<ul>
<li><strong>FIFO（First In First Out，先进先出）</strong> - 淘汰最先进入的缓存数据。缓存的行为就像一个队列。<ul>
<li>优点：这种方案非常简单</li>
<li>缺点：可能会导致<strong>缓存命中率低</strong>。因为，进入缓存的先后顺序和访问频率无关，这种算法可能会将访问频率高的数据给淘汰。</li>
</ul>
</li>
<li><strong>LIFO（Last In First Out，后进先出）</strong> - 淘汰最后进入的缓存数据。缓存的行为就像一个栈。<ul>
<li>优点：这种方案非常简单</li>
<li>缺点：和 FIFO 一样，也可能会导致<strong>缓存命中率低</strong>。因为，进入缓存的先后顺序和访问频率无关，这种算法可能会将访问频率高的数据给淘汰。</li>
</ul>
</li>
<li><strong>MRU（Most Recently Used，最近最多使用）</strong> - 淘汰最近最多使用缓存。<ul>
<li>优点：适用于一些特殊场景，例如数据访问具有较强的局部性。举个例子，用户访问一个信息流页面，已经看过的内容，他肯定不想再看到，此时就可以使用 MRU。</li>
<li>缺点：某些情况下，可能会导致频繁的淘汰缓存，从而降低缓存命中率</li>
</ul>
</li>
<li><strong>LRU（Least Recently Used，最近最少使用）</strong> - 淘汰最近最少使用缓存。<ul>
<li>优点：避免了 FIFO <strong>缓存命中率低</strong>的问题。</li>
<li>缺点：存在<strong>临界区</strong>问题。假设，缓存只保留 1 分钟以内的热点数据。如果有个数据在 1 个小时的前 59 分钟访问了 1 万次（可见这是个热点数据），最后一分钟没有任何访问；而其他数据有被访问，就会导致这个热点数据被淘汰。</li>
</ul>
</li>
<li><strong>LFU（Less Frequently Used，最近最少频率使用）</strong> - 该算法对 LRU 做了进一步优化：利用额外的空间记录每个数据的使用频率，然后淘汰使用频率最低的数据，如果所有数据使用频率相同，可以用 FIFO 淘汰最早的缓存数据。<ul>
<li>优点：解决了 LRU 的<strong>临界区</strong>问题。</li>
<li>缺点：记录使用频率，会产生额外的空间开销</li>
</ul>
</li>
</ul>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将<strong>读请求和写请求串行化</strong>。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。</p>
<p>缓存更新的策略有几种模式：</p>
<ul>
<li>Cache Aside</li>
<li>Read&#x2F;Write Through</li>
</ul>
<p>需要注意的是：以上几种缓存更新策略，都无法保证数据强一致。如果一定要保证强一致性，可以通过两阶段提交（2PC）或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。</p>
<h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>Cache Aside 应该是最常见的缓存更新策略了。</p>
<p>Cache Aside 的思路是：<strong>先更新数据库，再删除缓存</strong>。具体来说：</p>
<ul>
<li><p><strong>失效</strong>：尝试读缓存，如果不命中，则读数据库，然后更新缓存。</p>
</li>
<li><p><strong>命中</strong>：尝试读缓存，命中则直接返回数据。</p>
</li>
<li><p><strong>更新</strong>：先更新数据库，再删除缓存。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151119858.png"></p>
<h5 id="为什么不能先更新数据库，再更新缓存？"><a href="#为什么不能先更新数据库，再更新缓存？" class="headerlink" title="为什么不能先更新数据库，再更新缓存？"></a>为什么不能先更新数据库，再更新缓存？</h5><p><strong>多个并发的写操作可能导致脏数据</strong>：当有多个并发的写请求时，无法保证更新数据库的顺序和更新缓存的顺序一致，从而导致数据库和缓存数据不一致的问题。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413113825.png"></p>
<blockquote>
<p>说明：如上图的场景中，两个写线程由于执行顺序，导致数据库中 val &#x3D; 2，而缓存中 val &#x3D; 1，数据不一致。</p>
</blockquote>
<h5 id="为什么不能先删缓存，再更新数据库？"><a href="#为什么不能先删缓存，再更新数据库？" class="headerlink" title="为什么不能先删缓存，再更新数据库？"></a>为什么不能先删缓存，再更新数据库？</h5><p><strong>存在并发读请求和写请求时，可能导致脏数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413113940.png"></p>
<blockquote>
<p>说明：如上图的场景中，读线程和写线程并行执行，导致数据库中 val &#x3D; 2，而缓存中 val &#x3D; 1，数据不一致。</p>
</blockquote>
<h5 id="先更新数据库，再删除缓存就没问题了吗"><a href="#先更新数据库，再删除缓存就没问题了吗" class="headerlink" title="先更新数据库，再删除缓存就没问题了吗"></a>先更新数据库，再删除缓存就没问题了吗</h5><p><strong>存在并发读请求和写请求时，可能导致脏数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413115140.png"></p>
<blockquote>
<p>上图中问题发生的概率非常低：因为通常数据库更新操作比内存操作耗时多出几个数量级，最后一步回写缓存速度非常快，通常会在更新数据库之前完成。所以 Cache Aside 模式选择先更新数据库，再删除缓存，而不是先删缓存，再更新数据库。</p>
<p>不过，如果真的出现了这种场景，为了避免缓存中一直保留着脏数据，可以为缓存设置过期时间，过期后缓存自动失效。通常，业务系统中允许少量数据短时间出现不一致的情况。</p>
</blockquote>
<h4 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read&#x2F;Write Through"></a>Read&#x2F;Write Through</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151120459.png"></p>
<p>Read Through 的思路是：<strong>查询时更新缓存</strong>。当缓存失效时，缓存服务自己进行加载。</p>
<p>Write Through 的思路是：当数据更新时，缓存服务负责更新缓存。</p>
<p>Through vs. Cache Aside</p>
<p>Read Through vs. Cache Aside</p>
<ul>
<li>Cache Aside 模式中，应用需要维护两个数据源头：一个是缓存，一个是数据库。</li>
<li>Read-Through 模式中，应用无需管理缓存和数据库，只需要将数据库的同步委托给缓存服务即可。</li>
</ul>
<h4 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h4><p>Write Behind 又叫 Write Back。Write Behind 的思路是：应用更新数据时，只更新缓存， 缓存服务每隔一段时间将缓存数据批量更新到数据库中，即延迟写入。这个设计的好处就是让提高 I&#x2F;O 效率，因为异步，Write Behind 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<blockquote>
<p>更详细的分析可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">分布式之数据库和缓存双写一致性方案解析 </a></p>
</blockquote>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>“缓存雪崩”是指，缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩</strong>。</p>
<p>举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>
<p>解决缓存雪崩的主要手段如下：</p>
<ul>
<li><strong>增加缓存系统可用性</strong>（事前）。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。</li>
<li><strong>采用多级缓存方案</strong>（事中）。例如：本地缓存（<strong>Ehcache</strong>&#x2F;<strong>Caffine</strong>&#x2F;<strong>Guava Cache</strong>） + 分布式缓存（<strong>Redis</strong>&#x2F; <strong>Memcached</strong>）。</li>
<li><strong>限流、降级、熔断方案</strong>（事中），避免被流量打死。如：使用 <strong>Hystrix</strong> 进行熔断、降级。</li>
<li>缓存如果支持<strong>持久化</strong>，可以在恢复工作后恢复数据（事后）。如：<strong>Redis</strong> 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<p>上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。</p>
<p>解决缓存雪崩的辅助手段如下：</p>
<ul>
<li><strong>监控缓存，弹性扩容</strong>。</li>
<li><strong>缓存的过期时间可以取个随机值</strong>。这么做是为避免缓存同时失效，使得数据库 IO 骤升。比如：以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>“缓存穿透”是指，查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库，当这样的请求多了后，数据库的压力就会增大。</strong></p>
<p>解决缓存穿透，一般有两种方法：</p>
<p>（一）缓存空值</p>
<p><strong>对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151115258.png"></p>
<p>采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。</p>
<p>（二）过滤不可能存在的数据</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151115189.png"></p>
<p><strong>制定一些规则过滤一些不可能存在的数据</strong>。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。</p>
<blockquote>
<p>针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。</p>
<p>此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。</p>
<p>针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。</p>
<p>而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。</p>
</blockquote>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>“缓存击穿”是指，热点缓存数据失效瞬间，大量请求直接访问数据库</strong>。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。</p>
<p>为了避免这个问题，我们可以采取下面的两个手段：</p>
<ul>
<li><strong>分布式锁</strong> - 锁住热点数据的 key，避免大量线程同时访问同一个 key。</li>
<li><strong>定时异步刷新</strong> - 可以对部分数据采取失效前自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。</p>
<ul>
<li>事前：Redis 高可用方案（<strong>Redis Cluster</strong> + <strong>主从</strong> + <strong>哨兵</strong>），避免缓存全面崩溃。</li>
<li>事中：（一）采用多级缓存方案，本地缓存（<strong>Ehcache</strong>&#x2F;<strong>Caffine</strong>&#x2F;<strong>Guava Cache</strong>） + 分布式缓存（<strong>Redis</strong>&#x2F; <strong>Memcached</strong>）。（二）限流 + 熔断 + 降级（<strong>Hystrix</strong>），避免极端情况下，数据库被打死。</li>
<li>事后：<strong>Redis</strong> 持久化（<strong>RDB</strong>+<strong>AOF</strong>），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<blockquote>
<p>分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。</p>
</blockquote>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。</p>
<p>解决方案：</p>
<ul>
<li><strong>手动刷新缓存</strong>：直接写个缓存刷新页面，上线时手工操作下。</li>
<li><strong>应用启动时刷新缓存</strong>：数据量不大，可以在项目启动的时候自动进行加载。</li>
<li><strong>定时异步刷新缓存</strong></li>
</ul>
<h3 id="如何缓存"><a href="#如何缓存" class="headerlink" title="如何缓存"></a>如何缓存</h3><h4 id="不过期缓存"><a href="#不过期缓存" class="headerlink" title="不过期缓存"></a>不过期缓存</h4><p>缓存更新模式：</p>
<ol>
<li>开启事务</li>
<li>写 SQL</li>
<li>提交事务</li>
<li>写缓存</li>
</ol>
<p><strong>不要把写缓存操作放在事务中，尤其是写分布式缓存</strong>。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。</p>
<p>这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。</p>
<h4 id="过期缓存"><a href="#过期缓存" class="headerlink" title="过期缓存"></a>过期缓存</h4><p>采用<strong>懒加载</strong>。对于热点数据，可以设置较短的缓存时间，并定期异步加载。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200710163555.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11322972.html">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://link.juejin.im/?target=https://juejin.im/post/5b7593496fb9a009b62904fa">你应该知道的缓存进化史</a></li>
<li><a href="https://link.juejin.im/?target=https://juejin.im/post/5b849878e51d4538c77a974a">如何优雅的设计和使用缓存？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/73ce0ef820f9">理解分布式系统中的缓存架构（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/03/17/cache-about.html">缓存那些事</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">分布式之数据库和缓存双写一致性方案解析 </a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102293437">Cache 的基本原理</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021716418">5 分钟看懂系列：HTTP 缓存机制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60950750">浏览器缓存看这一篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=7lxAfszjy68&list=PLBlnK6fEyqRjdT1xkkBZSXKwFKqQoYhwy&index=23">Cache Replacement Policies - RR, FIFO, LIFO, &amp; Optimal</a> - YouTube PPT 讲解视频，生动演示缓存淘汰算法</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=_Hh-NcdbHCY&list=PLBlnK6fEyqRjdT1xkkBZSXKwFKqQoYhwy&index=25">Cache Replacement Policies - MRU, LRU, Pseudo-LRU, &amp; LFU</a> - YouTube PPT 讲解视频，生动演示缓存淘汰算法</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f293688d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f293688d/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-21 11:30:00" itemprop="dateCreated datePublished" datetime="2019-06-21T11:30:00+08:00">2019-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>在数据存储环境中，可能会出现各种各样的问题：</p>
<ul>
<li>数据库软件或硬件可能会随时失效（包括正在执行写操作的过程中）。</li>
<li>应用程序可能随时崩愤（包括一系列操作执行到中间某一步）。</li>
<li>应用与数据库节点间的连接可能会随时中断，数据库节点间也存在同样问题。</li>
<li>多个客户端可能同时写入数据库，导致数据覆盖。</li>
<li>客户端可能读到一些无意义的、部分更新的数据。</li>
<li>客户端之间由于边界条件竞争所引入的各种奇怪问题。</li>
</ul>
<p>为了解决以上问题，产生了事务这个概念。</p>
<p><strong>事务（Transaction）指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190813952.png"></p>
<p>通俗的说，<strong>事务将多个读、写操作捆绑在一起成为一个逻辑操作单元</strong>。<strong>事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）</strong>。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于任何原因），应用层的错误处理就变得简单很多。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>那么，什么是 ACID 特性呢？ACID 是数据库事务正确执行的四个基本要素的单词缩写：</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>原子是指不可分解为更小粒度的东西。事务的原子性意味着：<strong>事务中的所有操作要么全部成功，要么全部失败</strong>。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>ACID 中的原子性并不关乎多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，后者其实是由 ACID 的隔离性所定义。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li><strong>同时运行的事务互不干扰</strong>。换句话说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h3><p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为<strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p>
<p>有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种<strong>跨系统的事务为分布式事务</strong>，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>举个互联网常用的交易业务为例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190750592.png"></p>
<p>上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190750182.png"></p>
<p>可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。</p>
<p>分布式事务相比于本地事务，实现复杂度要高很多，主要是因为其存在以下<strong>难点</strong>：</p>
<ul>
<li><strong>事务的原子性</strong>：事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的<strong>都做或都不做（All or Nothing）</strong>的原子性。</li>
<li><strong>事务的一致性</strong>：当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</li>
<li><strong>事务的隔离性</strong>：事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</li>
</ul>
<p>在分布式领域，要实现强一致性，代价非常高昂。因此，有人基于 CAP 理论以及 BASE 理论，有人就提出了<strong>柔性事务</strong>的概念。柔性事务是指：在不影响系统整体可用性的情况下 (Basically Available 基本可用），允许系统存在数据不一致的中间状态 (Soft State 软状态），在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><blockquote>
<p>CAP 定理是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。</p>
</blockquote>
<p><strong>CAP 定理</strong>，指的是：<strong>在一个分布式系统中，当发生网络分区时，那么强一致性和可用性只能二选一</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200746619.png"></p>
<p>CAP 就是取 Consistency、Availability、Partition Tolerance 的首字母而命名。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211102180526.png" alt="img"></p>
<ul>
<li>一致性（<strong>C</strong>onsistency）：在任何给定时间，网络中的所有节点都具有完全相同（最近）的值。</li>
<li>可用性（<strong>A</strong>vailability）：对网络的每个请求都会收到响应，但不能保证返回的数据是最新的。</li>
<li>分区容错性（<strong>P</strong>artition Tolerance）：即使任意数量的节点出现故障，网络仍会继续运行。</li>
</ul>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性（Consistency）指的是<strong>多个数据副本是否能保持一致</strong>的特性。</p>
<p>在一致性的条件下，分布式系统在执行写操作成功后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li><strong>强一致性</strong> - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。</li>
<li><strong>最终一致性</strong> - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。</li>
</ul>
<p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png" alt="img"></p>
<p>接下来，用户的读操作就会得到 v1。这就叫一致性。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png" alt="img"></p>
<p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png" alt="img"></p>
<p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png" alt="img"></p>
<p>这样的话，用户向 G2 发起读操作，也能得到 v1。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png" alt="img"></p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性指<strong>分布式系统在面对各种异常时可以提供正常服务的能力</strong>，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 <code>99.99%</code> 的时间是可用的。</p>
<p>在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p>分区容错性（Partition Tolerance）指 <strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<p>在一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中，这就叫分区。</p>
<p>假设，某个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。</p>
<p>提高分区容错性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容错性就提高了。</p>
<p>然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。</p>
<p>总的来说就是，数据存在的节点越多，分区容错性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。</p>
<p>大多数分布式系统都分布在多个子网络，每个子网络就叫做一个区（Partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png" alt="img"></p>
<p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p>
<p><strong>一般来说，分区容错无法避免</strong>，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p>
<h4 id="AP-or-CP"><a href="#AP-or-CP" class="headerlink" title="AP or CP"></a>AP or CP</h4><p>在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，<strong>CAP 理论实际在是要在可用性和一致性之间做权衡</strong>。</p>
<p>由于分布式数据存储（如区块链）的性质，分区容错性是一个既定的事实；网络中总会有失败&#x2F;无法访问的节点（尤其是因为互联网的不稳定特性）。 CAP 定理指出，当存在 P（分区）时，必须在 C（一致性）或 A（可用性）之间进行选择。</p>
<p>（1）AP 模式</p>
<blockquote>
<p><strong>AP</strong> <strong>模式</strong>：对网络的每个请求都会收到响应，即使网络由于网络分区故障而无法保证它是最新的。</p>
</blockquote>
<p>选择 <strong>AP</strong> <strong>模式</strong>，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误；但是，当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211102191819.png" style="width: 500px" />

<p>（2）CP 模式</p>
<blockquote>
<p><strong>CP</strong> <strong>模式</strong>：如果由于网络分区（故障节点）而无法保证特定信息是最新的，则系统将返回错误或超时。</p>
</blockquote>
<p>选择 <strong>CP</strong> <strong>模式</strong>，这样能够提供一部分的可用性。采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入。</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211102191820.png" style="width: 500px" />

<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><h4 id="什么是-BASE-定理"><a href="#什么是-BASE-定理" class="headerlink" title="什么是 BASE 定理"></a>什么是 BASE 定理</h4><blockquote>
<p><strong>BASE 定理是对 CAP 中一致性和可用性权衡的结果</strong>。</p>
</blockquote>
<p>不符合 ACID 标准的系统有时被冠以 BASE。BASE 是 <strong><code>基本可用（Basically Available）</code><strong>、</strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。</p>
<p>BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<ul>
<li><strong>基本可用（Basically Available）</strong>分布式系统在出现故障的时候，<strong>保证核心可用，允许损失部分可用性</strong>。例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</li>
<li><strong>软状态（Soft State）</strong>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即<strong>允许系统不同节点的数据副本之间进行同步的过程存在延时</strong>。</li>
<li><strong>最终一致性（Eventually Consistent）</strong>强调的是<strong>系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态</strong>。</li>
</ul>
<h4 id="BASE-vs-ACID"><a href="#BASE-vs-ACID" class="headerlink" title="BASE vs. ACID"></a>BASE vs. ACID</h4><p>BASE 的理论的<strong>核心思想</strong>是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过<strong>牺牲强一致性来达到可用性</strong>，通常运用在大型分布式系统中。</p>
<p>BASE 唯一可以确定的是“它不是 ACID”，此外它几乎没有承诺任何东西。</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211102192406.png" style="width: 640px" />

<h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><p>在分布式领域，要实现强一致性，代价非常高昂。因此，有人基于 CAP 理论以及 BASE 理论，提出了<strong>柔性事务</strong>的概念。</p>
<p>柔性事务是指：在不影响系统整体可用性的情况下 (Basically Available 基本可用），允许系统存在数据不一致的中间状态 (Soft State 软状态），在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<p>下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。</p>
<ul>
<li><strong>可见性（对外可查询）</strong>：在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。</li>
<li><strong>操作幂等性</strong>：幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。</li>
</ul>
<h2 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h2><h3 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h3><p>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即<strong>将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段</strong>。事务的发起者称协调者，事务的执行者称参与者。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈，决定提交或回滚</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
<h4 id="阶段-1：准备阶段"><a href="#阶段-1：准备阶段" class="headerlink" title="阶段 1：准备阶段"></a>阶段 1：准备阶段</h4><ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。</li>
</ol>
<h4 id="阶段-2：提交阶段"><a href="#阶段-2：提交阶段" class="headerlink" title="阶段 2：提交阶段"></a>阶段 2：提交阶段</h4><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚 (rollback) 消息；否则，发送提交 (commit) 消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。（注意：必须在最后阶段释放锁资源） 接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况 1，当所有参与者均反馈 yes，提交事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190751196.png"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。</li>
<li>参与者执行 commit 请求，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack（应答）完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2，当任何阶段 1 一个参与者反馈 no，中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190751172.png"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出回滚请求（即 rollback 请求）。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<h3 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h3><p>2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li><strong>性能问题</strong> - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li><strong>可靠性问题</strong> - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li><strong>数据一致性问题</strong> - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h2 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a>三阶段提交（3PC）</h2><h3 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h3><p>三阶段提交协议（Three-phase Commit，3PC），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>三阶段提交将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h3 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h3><h4 id="阶段-1：canCommit"><a href="#阶段-1：canCommit" class="headerlink" title="阶段 1：canCommit"></a>阶段 1：canCommit</h4><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应（参与者不执行事务操作），否则返回 no 响应：</p>
<ol>
<li>协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li>
</ol>
<h4 id="阶段-2：preCommit"><a href="#阶段-2：preCommit" class="headerlink" title="阶段 2：preCommit"></a>阶段 2：preCommit</h4><p>协调者根据阶段 1 canCommit 参与者的反应情况来决定是否可以基于事务的 preCommit 操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190752281.png"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 preCommit 请求，进入准备阶段。</li>
<li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li>
</ol>
</blockquote>
<p><strong>情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190752525.png"></p>
<blockquote>
<ol>
<li>协调者向所有参与者发出 abort 请求。</li>
<li>无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ol>
</blockquote>
<h4 id="阶段-3：doCommit"><a href="#阶段-3：doCommit" class="headerlink" title="阶段 3：doCommit"></a>阶段 3：doCommit</h4><p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190753250.png"></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，则向所有参与者发出 doCommit 请求。</li>
<li>参与者收到 doCommit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li>
</ol>
</blockquote>
<p><strong>情况 2：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190753329.png"></p>
<blockquote>
<ol>
<li>如果协调者处于工作状态，向所有参与者发出 abort 请求。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。</li>
</ol>
</blockquote>
<p>注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<h3 id="方案总结-1"><a href="#方案总结-1" class="headerlink" title="方案总结"></a>方案总结</h3><ul>
<li>优点：<strong>相比二阶段提交，三阶段降低了阻塞范围</strong>，在<strong>等待超时后协调者或参与者会中断事务</strong>。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</li>
<li>缺点：<strong>数据不一致问题依然存在</strong>，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</li>
</ul>
<h2 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h2><h3 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h3><p>TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>
<p>TCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现；</p>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
<p>TCC 事务的 Try、Confirm、Cancel 可以理解为 SQL 事务中的 Lock、Commit、Rollback。</p>
<h3 id="处理流程-2"><a href="#处理流程-2" class="headerlink" title="处理流程"></a>处理流程</h3><p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<h4 id="Try-阶段"><a href="#Try-阶段" class="headerlink" title="Try 阶段"></a>Try 阶段</h4><p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查（一致性）</li>
<li>预留必须业务资源（准隔离性）</li>
<li>Try 尝试执行业务 TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
</ul>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<h4 id="Confirm-Cancel-阶段"><a href="#Confirm-Cancel-阶段" class="headerlink" title="Confirm &#x2F; Cancel 阶段"></a>Confirm &#x2F; Cancel 阶段</h4><p>根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p><strong>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190757821.png"></p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p><strong>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190757821.png"></p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<h3 id="方案总结-2"><a href="#方案总结-2" class="headerlink" title="方案总结"></a>方案总结</h3><p>TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：</p>
<ul>
<li><strong>性能提升</strong> - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li><strong>数据最终一致性</strong> - 基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li><strong>可靠性</strong> - 解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点： TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，<strong>业务耦合度较高</strong>，提高了开发成本。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><h3 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h3><p>本地消息表的方案最初是由 ebay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>“，或”<strong>业务处理失败 + 事务消息发送成功</strong>“的棘手情况出现，保证 2 个系统事务的数据一致性。</p>
<h3 id="处理流程-3"><a href="#处理流程-3" class="headerlink" title="处理流程"></a>处理流程</h3><p>下面把分布式事务最先开始处理的事务方称为事务主动方，在事务主动方之后处理的业务内的其他事务称为事务被动方。</p>
<p>为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190758570.png"></p>
<blockquote>
<ol>
<li><strong>步骤 1、事务主动方处理本地事务。</strong> 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表（图中 1、2)。</li>
<li><strong>步骤 2、事务主动方通过 MQ 通知事务被动方处理事务</strong>。 消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。</li>
<li><strong>步骤 3、事务被动方通过 MQ 返回处理结果。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成（图中 6 - 8)</li>
</ol>
</blockquote>
<p>为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<ul>
<li>当步骤 1 处理出错，事务回滚，相当于什么都没发生。</li>
<li>当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询超时 d 的消息数据，再次发送消息到 MQ 进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ul>
</blockquote>
<h3 id="方案总结-3"><a href="#方案总结-3" class="headerlink" title="方案总结"></a>方案总结</h3><p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，<strong>消息数据的可靠性不依赖于消息中间件</strong>，弱化了对 MQ 中间件特性的依赖。</li>
<li><strong>方案简单</strong>，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，<strong>耦合性高，不可复用</strong>。</li>
<li>需要额外维护消息数据的传输，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h2 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h2><p>MQ 事务方案本质是利用 MQ 功能实现的本地消息表。事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p>
<ul>
<li><strong>Kafka</strong> 的解决方案是：直接抛出异常，让用户自行处理。用户可以在业务代码中反复重试提交，直到提交成功，或者删除之前修改的数据记录进行事务补偿。</li>
<li><strong>RocketMQ</strong> 的解决方案是：通过事务反查机制来解决事务消息提交失败的问题。如果 Producer 在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</li>
</ul>
<h3 id="RocketMQ-事务消息实现"><a href="#RocketMQ-事务消息实现" class="headerlink" title="RocketMQ 事务消息实现"></a>RocketMQ 事务消息实现</h3><p>事务消息是 Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p>
<p><strong>事务消息处理流程</strong></p>
<p>事务消息交互流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190758755.png"></p>
<ol>
<li>生产者将消息发送至 Apache RocketMQ 服务端。</li>
<li>Apache RocketMQ 服务端将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为半事务消息。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit 或是 Rollback），服务端收到确认结果后处理逻辑如下：</li>
</ol>
<ul>
<li>二次确认结果为 Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为 Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
<ol start="5">
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 <strong>说明</strong> 服务端回查的间隔时间和最大回查次数，请参见 <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半事务消息进行处理。</li>
</ol>
<p><strong>事务消息生命周期</strong> <img src="https://rocketmq.apache.org/zh/assets/images/lifecyclefortrans-fe4a49f1c9fdae5d590a64546722036f.png" alt="事务消息"></p>
<ul>
<li>初始化：半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>事务待提交：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</li>
<li>消息回滚：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</li>
<li>提交待消费：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，Apache RocketMQ 会对消息进行重试处理。具体信息，请参见 <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消费重试</a>。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。 Apache RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。更多信息，请参见 <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/11messagestorepolicy">消息存储和清理机制</a>。</li>
</ul>
<h3 id="MQ-事务方案总结"><a href="#MQ-事务方案总结" class="headerlink" title="MQ 事务方案总结"></a>MQ 事务方案总结</h3><p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li><strong>业务解耦</strong> - 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li><strong>吞吐量优于本地消息表</strong>方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li><strong>一次消息发送需要两次网络请求</strong> (half 消息 + commit&#x2F;rollback 消息）</li>
<li><strong>业务处理服务需要实现消息状态回查接口</strong></li>
</ul>
<h2 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h2><h3 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h3><p>1987 年，Hector Garcia-Molina 和 Kenneth Salem 发表了名为 <a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">SAGAS</a> 的论文，讲述了如何处理 long lived transaction（长活事务）。Saga 事务的核心思想是：将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序依次调用补偿操作。</p>
<h3 id="处理流程-4"><a href="#处理流程-4" class="headerlink" title="处理流程"></a>处理流程</h3><p><strong>Saga 事务基本协议如下</strong>：</p>
<ul>
<li><strong>将长事务拆分为多个有序子事务</strong> - 每个 Saga 事务由一系列幂等的有序子事务 (sub-transaction) Ti 组成。</li>
<li><strong>每个子事务 Ti 都有对应的幂等补偿动作 Ci</strong>，补偿动作用于撤销 Ti 造成的结果。</li>
</ul>
<p>可以看到，和 TCC 相比，Saga 没有“预留”动作，它的 Ti 就是直接提交到库。</p>
<p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga 的执行顺序有两种：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190758952.png"></p>
<ul>
<li>事务正常执行完成 T1, T2, T3, …, Tn，例如：扣减库存 (T1)，创建订单 (T2)，支付 (T3)，依次有序完成整个事务。</li>
<li>事务回滚 T1, T2, …, Tj, Cj,…, C2, C1，其中 0 &lt; j &lt; n，例如：扣减库存 (T1)，创建订单 (T2)，支付 (T3，支付失败），支付回滚 (C3)，订单回滚 (C2)，恢复库存 (C1)。</li>
</ul>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><p>Saga 定义了两种恢复策略：</p>
<ul>
<li>向前恢复 (forward recovery)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190759028.png"></p>
<p>对应于上面第一种执行顺序，<strong>适用于必须要成功的场景</strong>，<strong>失败需要进行重试</strong>，执行顺序是类似于这样的：T1, T2, …, Tj（失败）, Tj（重试）,…, Tn，其中 j 是发生错误的子事务 (sub-transaction)。该情况下不需要 Ci。</p>
<ul>
<li>向后恢复 (backward recovery)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190800829.png"></p>
<p>对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务 (sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p>
<p>Saga 事务常见的有两种不同的实现方式：命令协调和事件编排。</p>
<h4 id="命令协调"><a href="#命令协调" class="headerlink" title="命令协调"></a>命令协调</h4><ul>
<li><strong>命令协调 (Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></li>
</ul>
<p>中央协调器（Orchestrator，简称 OSO）以命令&#x2F;回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190800891.png"></p>
<p>以电商订单的例子为例：</p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务。</li>
<li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ol>
</blockquote>
<p>中央协调器必须事先知道执行整个订单事务所需的流程（例如通过读取配置）。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<h4 id="事件编排"><a href="#事件编排" class="headerlink" title="事件编排"></a>事件编排</h4><ul>
<li><strong>事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</li>
</ul>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p>以电商订单的例子为例：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190808479.png"></p>
<blockquote>
<ol>
<li>事务发起方的主业务逻辑发布开始订单事件</li>
<li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件</li>
<li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件</li>
<li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件</li>
<li>主业务逻辑监听订单已支付事件并处理。</li>
</ol>
</blockquote>
<p>事件编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p>
<h3 id="方案总结-4"><a href="#方案总结-4" class="headerlink" title="方案总结"></a>方案总结</h3><p><strong>命令协调设计的优点和缺点：</strong></p>
<p>优点如下：</p>
<ul>
<li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器</li>
<li>程序开发简单，只需要执行命令&#x2F;回复（其实回复消息也是一种事件消息），降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p><strong>事件&#x2F;编排设计的优点和缺点</strong></p>
<p>优点如下：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<p>值得补充的是，由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性，当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="各方案使用场景"><a href="#各方案使用场景" class="headerlink" title="各方案使用场景"></a>各方案使用场景</h3><p>介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。</p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈信息决定各参与者是否要提交操作还是中止操作</strong>。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，<strong>引入超时机制</strong>。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong><ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>消息事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案对比：</p>
<ul>
<li>2PC&#x2F;3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表&#x2F;消息事务都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。</li>
<li>Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>2PC</th>
<th>3PC</th>
<th>TCC</th>
<th>本地消息表</th>
<th>MQ 事务</th>
<th>SAGA</th>
</tr>
</thead>
<tbody><tr>
<td>数据一致性</td>
<td>强</td>
<td>强</td>
<td>若</td>
<td>弱</td>
<td>弱</td>
<td>弱</td>
</tr>
<tr>
<td>容错性</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>复杂性</td>
<td>中</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>低</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>维护成本</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="分布式事务方案设计"><a href="#分布式事务方案设计" class="headerlink" title="分布式事务方案设计"></a>分布式事务方案设计</h3><p>本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。</p>
<p>实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。</p>
<blockquote>
<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询</p>
</blockquote>
<p>有些问题，看起来很重要，但实际上我们可以通过<strong>合理的设计</strong>或者将<strong>问题分解</strong>来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。</p>
<p>如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用<strong>人工解决</strong>的方式，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf"><strong>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</strong></a>，<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936718012430"><strong>解读</strong></a> - 经典的 CAP 理论，即：在一个分布式系统中，当发生网络分区时，那么强一致性和可用性只能二选一。</li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/"><strong>CAP Twelve Years Later: How the “Rules” Have Changed</strong></a>, <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/64778723/answer/224266038"><strong>解读</strong></a> - CAP 理论的新解读，并阐述 CAP 理论的一些常见误区。</li>
<li><a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/BASE%3A-An-Acid-Alternative-Pritchett/2e72e6c022dd33115304ecfcb6dad7ea609534a4"><strong>BASE: An Acid Alternative</strong></a>，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/base-an-acid-alternative.html"><strong>译文</strong></a> - BASE 理论是对 CAP 中一致性和可用性的权衡，提出采用适当的方式来使系统达到最终一致性。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c0e5bf8e51d45063322fe50">理解分布式事务</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">RocketMQ 官方文档之事务消息</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">SAGAS</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/16deae27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/16deae27/" class="post-title-link" itemprop="url">分布式会话基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-04 23:42:00" itemprop="dateCreated datePublished" datetime="2019-06-04T23:42:00+08:00">2019-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式会话基本原理"><a href="#分布式会话基本原理" class="headerlink" title="分布式会话基本原理"></a>分布式会话基本原理</h1><blockquote>
<p>由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
</blockquote>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p>
<h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p>
<p>一个简单的 cookie 设置如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>&lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<h3 id="Cookie-的工作步骤"><a href="#Cookie-的工作步骤" class="headerlink" title="Cookie 的工作步骤"></a>Cookie 的工作步骤</h3><ol>
<li>浏览器请求服务器，如果服务器需要记录该用户的状态，就是用 response 向浏览器颁发一个 Cookie。</li>
<li>浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<h3 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h3><p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p>
<h3 id="Cookie-的重要属性"><a href="#Cookie-的重要属性" class="headerlink" title="Cookie 的重要属性"></a>Cookie 的重要属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>name&#x3D;value</strong></td>
<td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td>
</tr>
<tr>
<td><strong>domain</strong></td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td><strong>path</strong></td>
<td>**指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘**。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td>
</tr>
<tr>
<td><strong>maxAge</strong></td>
<td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td>
</tr>
<tr>
<td><strong>expires</strong></td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td>
</tr>
<tr>
<td><strong>secure</strong></td>
<td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td>
</tr>
<tr>
<td><strong>httpOnly</strong></td>
<td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td>
</tr>
</tbody></table>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<ul>
<li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li>
<li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d0b3cf5~tplv-t2oaga2asx-watermark.awebp" alt="session.png"></p>
<h3 id="Session-的工作步骤"><a href="#Session-的工作步骤" class="headerlink" title="Session 的工作步骤"></a>Session 的工作步骤</h3><ol>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ol>
<p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><p>Cookie 和 Session 的主要区别可以参考以下表格：</p>
<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用范围</strong></td>
<td>保存在客户端（浏览器）</td>
<td>保存在服务器端</td>
</tr>
<tr>
<td><strong>隐私策略</strong></td>
<td>存储在客户端，比较容易遭到非法获取</td>
<td>存储在服务端，安全性相对 Cookie 要好一些</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>只能保存 ASCII</td>
<td>可以保存任意数据类型。<br/>一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</td>
</tr>
<tr>
<td><strong>存储大小</strong></td>
<td>不能超过 4K</td>
<td>存储大小远高于 Cookie</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可设置为永久保存<br/>比如我们经常使用的默认登录（记住我）功能</td>
<td>一般失效时间较短<br/>客户端关闭或者 Session 超时都会失效。</td>
</tr>
</tbody></table>
<h2 id="如果禁用-Cookie-怎么办"><a href="#如果禁用-Cookie-怎么办" class="headerlink" title="如果禁用 Cookie 怎么办"></a>如果禁用 Cookie 怎么办</h2><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h2 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h2><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于缓存的 session 共享 ✅</li>
</ol>
<blockquote>
<p>推荐：基于缓存的 session 共享</p>
</blockquote>
<h3 id="粘性-Session"><a href="#粘性-Session" class="headerlink" title="粘性 Session"></a>粘性 Session</h3><blockquote>
<p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：<strong>当服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</p>
</blockquote>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>

<h3 id="Session-复制共享"><a href="#Session-复制共享" class="headerlink" title="Session 复制共享"></a>Session 复制共享</h3><blockquote>
<p>Session 复制共享（Session Replication）<strong>在服务器节点之间进行 Session 同步操作</strong>，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</p>
</blockquote>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>

<h3 id="基于缓存的-session-共享"><a href="#基于缓存的-session-共享" class="headerlink" title="基于缓存的 session 共享"></a>基于缓存的 session 共享</h3><blockquote>
<p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
</blockquote>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="JWT-Token"><a href="#JWT-Token" class="headerlink" title="JWT Token"></a>JWT Token</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>
<h3 id="tomcat-redis"><a href="#tomcat-redis" class="headerlink" title="tomcat + redis"></a>tomcat + redis</h3><p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p>
<p>在 tomcat 的配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">&quot;&#123;redis.host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">&quot;&#123;redis.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">&quot;&#123;redis.dbnum&#125;&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后指定 redis 的 host 和 port 就 ok 了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinelMaster</span>=<span class="string">&quot;mymaster&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">sentinels</span>=<span class="string">&quot;&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">maxInactiveInterval</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p>
<h3 id="spring-session-redis"><a href="#spring-session-redis" class="headerlink" title="spring session + redis"></a>spring session + redis</h3><p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p>
<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-session">sping session</a> 是一个很好的选择。</p>
<p>在 pom.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 spring 配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisHttpSessionConfiguration&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInactiveIntervalInSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hostName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis_hostname&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis_port&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis_pwd&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usePool&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolConfig&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 web.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/putIntoSession&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> &#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;name&quot;</span>,  <span class="string">&quot;leo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getFromSession&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是 ok 的，给 spring session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p>
<p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/L316476844/distributed-session">集群&#x2F;分布式环境 Session 的几种策略</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cd9037ee51d456e5c5babca">你真的了解 Cookie 和 Session 吗</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aede266f265da0ba266e0ef">聊一聊 session 和 cookie</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=I01XMRo2ESg">YouTube 视频 - What is a cookie?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QWw7Wd2gUJk">YouTube 视频 - How cookies can track you (Simply Explained)</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">MDN HTTP cookies</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b8f8aeae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/b8f8aeae/" class="post-title-link" itemprop="url">分布式锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-04 23:42:00" itemprop="dateCreated datePublished" datetime="2019-06-04T23:42:00+08:00">2019-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/" itemprop="url" rel="index"><span itemprop="name">分布式协同</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式协同综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>在计算机科学中，<strong>锁是在并发场景下用于强行限制资源访问的一种同步机制</strong>，即用于在并发控制中通过互斥手段来保证数据同步安全。</p>
<p>在 Java 进程中，可以使用 Lock、synchronized 等来支持并发锁。如果是同一台机器的不同进程，想要同时操作一个共享资源（例如修改同一个文件），可以使用操作系统提供的「文件锁」或「信号量」来做互斥。这些发生在同一台机器上的互斥操作，可以称为<strong>本地锁</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190814629.png"></p>
<p>本地锁无法协同不同机器间的互斥操作。为了解决这个问题，需要引入分布式锁。</p>
<p><strong>分布式锁</strong>，顾名思义，应用于分布式场景下，它和单进程中的锁并没有本质上的不同，只是控制对象由一个进程中的多个线程变成了多个进程中的多个线程。此外，临界区的资源也由进程内共享资源变成了分布式系统内部共享资源。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190815373.png"></p>
<p>分布式锁典型应用场景是：</p>
<ul>
<li><strong>选举 Leader</strong> - 分布式锁可用于确保：在任何指定时间内，只有一个节点成为领导者。</li>
<li><strong>任务调度</strong> - 在分布式任务调度器中，分布式锁确保一个调度任务仅由一个 worker 节点执行，从而防止重复执行。</li>
<li><strong>资源配置</strong> - 在管理共享资源（如文件系统、网络 Socket 或硬件设备）时，分布式锁可确保一次只有一个进程可以访问资源。</li>
<li><strong>微服务协调</strong> - 当多个微服务需要执行协同操作时，例如更新不同数据库中的相关数据，分布式锁可以确保这些操作以可控和有序的方式执行。</li>
<li><strong>库存管理</strong> - 在电商系统中，分布式锁可以管理库存更新，以确保当多个用户尝试同时购买相同商品时，正确增减库存，防止超卖。</li>
<li><strong>会话管理</strong> - 在分布式环境中处理用户会话时，分布式锁可以确保用户会话一次只能由一个服务器修改，从而防止不一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503302119532.gif"></p>
<p>图来自：<a target="_blank" rel="noopener" href="https://blog.bytebytego.com/i/149472287/why-do-we-need-to-use-a-distributed-lock">https://blog.bytebytego.com/i/149472287/why-do-we-need-to-use-a-distributed-lock</a></p>
<h2 id="分布式锁的设计目标"><a href="#分布式锁的设计目标" class="headerlink" title="分布式锁的设计目标"></a>分布式锁的设计目标</h2><p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（Redis，Memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<p>分布式锁的实现要点大同小异，仅在实现细节上有所不同。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p><strong>分布式锁必须是独一无二的</strong>，表现形式为：向数据存储插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</p>
<ul>
<li>保证 key 唯一性的最简单的方式是使用 UUID。</li>
<li>此外，可以参考 Snowflake ID（雪花算法），将机器地址（IP 地址、机器 ID、MAC 地址）、Jvm 进程 ID（应用 ID、服务 ID）、时间戳等关键信息拼接起来作为唯一标识。</li>
<li>应用自行保证</li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>在分布式锁的场景中，部分失败和异步网络这两个问题是同时存在的。如果一个进程获得了锁，但是这个进程与锁服务之间的网络出现了问题，导致无法通信，那么这个情况下，如果锁服务让它一直持有锁，就会导致死锁的发生。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190816412.png"></p>
<p>常见的解决思路是引入<strong>超时机制</strong>，即成功申请锁后，超过一定时间，锁失效（删除 key）。这样就不会出现锁一直不释放，导致其他线程无法获取锁的情况。Redis 分布式锁就采用了这种思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202412190816042.png"></p>
<p>超时机制解锁了死锁问题，但又引入了一个新问题：如果应用加锁时，对于操作共享资源的时长估计不足，可能会出现：操作尚未执行完，但是锁没了的尴尬情况。为了解决这个问题，需要引入<strong>锁续期</strong>机制：当持有锁的线程尚未执行完操作前，不断周期性检测锁的超时时间，一旦发现快要过期，就自动为锁续期。</p>
<p>ZooKeeper 分布式锁避免死锁采用了另外一种思路。ZooKeeper 的存储单元叫 znode，它是以文件层级形式组织，天然就存在物理空间隔离。并且 ZooKeeper 支持临时节点 + Watch 机制，可以在客户端断连时主动删除临时节点，所以不存在死锁问题。</p>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p><strong>可重入</strong>指的是：<strong>同一个线程在没有释放锁之前，能否再次获得该锁</strong>。其实现方案是：只需在加锁的时候，<strong>记录好当前获取锁的节点 + 线程组合的唯一标识</strong>，然后在后续的加锁请求时，如果当前请求的节点 + 线程的唯一标识和当前持有锁的相同，那么就直接返回加锁成功；如果不相同，则按正常加锁流程处理。</p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>当多个线程请求同一锁时，它们必须按照请求的顺序来获取锁，即先来先得的原则。锁的公平性的实现也非常简单，对于被阻塞的加锁请求，我们只要先记录好它们的顺序，在锁被释放后，按顺序颁发就可以了。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>有时候，加锁失败可能只是由于网络波动、请求超时等原因，稍候就可以成功获取锁。为了应对这种情况，加锁操作需要支持重试机制。常见的做法是，设置一个加锁超时时间，在该时间范围内，不断自旋重试加锁操作，超时后再判定加锁失败。</p>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>分布式锁若存储在单一节点，一旦该节点宕机或失联，就会导致锁失效。将分布式锁存储在多数据库实例中，加锁时并发写入 <code>N</code> 个节点，只要 <code>N / 2 + 1</code> 个节点写入成功即视为加锁成功。</p>
<h2 id="数据库分布式锁"><a href="#数据库分布式锁" class="headerlink" title="数据库分布式锁"></a>数据库分布式锁</h2><h3 id="数据库分布式锁原理"><a href="#数据库分布式锁原理" class="headerlink" title="数据库分布式锁原理"></a>数据库分布式锁原理</h3><p>基于数据库实现分布式锁的思路是：维护一张锁记录表，为用于标识分布式锁的字段增加<strong>唯一性约束</strong>。利用唯一性约束的互斥性，当且仅当成功插入记录，即表示加锁成功。</p>
<p>（1）创建锁表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `distributed_lock` (</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">	`resource` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;资源&#x27;</span>,</span><br><span class="line">	`count` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;锁次数，统计可重入锁&#x27;</span>,</span><br><span class="line">	`<span class="keyword">desc</span>` TEXT <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">	`create_time` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	`update_time` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY `uniq_resource`(`resource`)</span><br><span class="line">)</span><br><span class="line">	ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> `utf8mb4`;</span><br></pre></td></tr></table></figure>

<p>（2）获取锁</p>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>

<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<p>（3）释放锁</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库分布式锁小结"><a href="#数据库分布式锁小结" class="headerlink" title="数据库分布式锁小结"></a>数据库分布式锁小结</h3><p>数据库分布式锁的<strong>问题</strong>：</p>
<ul>
<li><strong>死锁</strong>：一旦释放锁操作失败，或持有锁的机器宕机、断连，就会导致锁记录一直存在，其他线程无法再获得锁。解决办法：为锁增加失效时间字段，启动一个定时任务，隔一段时间清除一次过期的数据。</li>
<li><strong>非阻塞</strong>：因为 <code>insert</code> 操作一旦失败就会报错，因此未获得锁的线程并不会进入排队队列，要想获得锁就要再次触发加锁操作。解决办法：循环重试，直到插入成功，这么做会产生一定额外开销。</li>
<li><strong>非重入</strong>：同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。解决办法：在数据库表中加个字段，记录当前获得锁的节点信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
<li><strong>单点问题</strong>：如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。解决办法：单点问题可以用多数据库实例，同时写入 <code>N</code> 个节点，<code>N / 2 + 1</code> 个成功就加锁成功。</li>
</ul>
<p>数据库分布式锁的<strong>利弊</strong>：</p>
<ul>
<li><strong>优点</strong>：直接借助数据库，简单易懂。</li>
<li><strong>缺点</strong>：会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。此外，数据库性能易成为瓶颈。</li>
</ul>
<h2 id="ZooKeeper-分布式锁"><a href="#ZooKeeper-分布式锁" class="headerlink" title="ZooKeeper 分布式锁"></a>ZooKeeper 分布式锁</h2><h3 id="ZooKeeper-分布式锁原理"><a href="#ZooKeeper-分布式锁原理" class="headerlink" title="ZooKeeper 分布式锁原理"></a>ZooKeeper 分布式锁原理</h3><p>ZooKeeper 分布式锁的实现基于 ZooKeeper 的两个重要特性：</p>
<ul>
<li><strong>顺序临时节点</strong>：ZooKeeper 的存储类似于 DNS 那样的具有层级的命名空间。ZooKeeper 节点类型可以分为持久节点（<code>PERSISTENT</code>）、临时节点（<code>EPHEMERAL</code>），每个节点还能被标记为有序性（<code>SEQUENTIAL</code>），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。</li>
<li><strong>Watch 机制</strong>：ZooKeeper 允许用户在指定节点上注册一些 <code>Watcher</code>，并且在特定事件触发的时候，ZooKeeper 服务端会将事件通知给用户。</li>
</ul>
<p>下面是 ZooKeeper 分布式锁的工作流程：</p>
<ol>
<li>创建一个目录节点，比如叫做 <code>/locks</code>；</li>
<li>线程 A 想获取锁，就在 <code>/locks</code> 目录下创建临时顺序 zk 节点；</li>
<li>获取 <code>/locks</code>目录下所有的子节点，检查是否存在比自己顺序更小的节点：若不存在，则说明当前线程创建的节点顺序最小，获取锁成功；</li>
<li>此时，线程 B 试图获取锁，发现自己的节点顺序不是最小，设置监听锁号在自己前一位的节点；</li>
<li>线程 A 处理完，删除自己的节点。线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://curator.apache.org/docs/about/">Apache Curator</a> 提供了基于 ZooKeeper 实现的可重入公平锁 <code>InterProcessMutex</code>，它正是采用了上面所述的工作流程。</p>
<p>:::details ZooKeeper 分布式锁实现示例</p>
<p>下面是一个简单的 <code>InterProcessMutex</code> 封装示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.collection.CollectionUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperReentrantDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁路径，即锁的唯一标识，对应 zk 的一个 PERSISTENT 节点，加锁时会在该节点下新建 EPHEMERAL 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk 的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * curator 客户端提供的 zk 可重入公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZookeeperReentrantDistributedLock</span><span class="params">(String lockId, CuratorFramework client)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        <span class="built_in">this</span>.path = <span class="string">&quot;/locks/&quot;</span> + lockId;</span><br><span class="line">        <span class="built_in">this</span>.mutex = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(<span class="built_in">this</span>.client, <span class="built_in">this</span>.path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            System.out.println(<span class="string">&quot;lock success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;lock exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> mutex.acquire(timeout, unit);</span><br><span class="line">            <span class="keyword">if</span> (isOk) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;tryLock success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isOk;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;tryLock exception&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;unlock success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;unlock exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除根路径</span></span><br><span class="line">            <span class="comment">// 生产环境中应指定线程池</span></span><br><span class="line">            CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;String&gt; list = client.getChildren().forPath(path);</span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtil.isEmpty(list)) &#123;</span><br><span class="line">                        client.delete().forPath(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;final unlock exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;127.0.0.1:2181&quot;</span>, retryPolicy);</span><br><span class="line">client.start();</span><br><span class="line"><span class="type">ZookeeperReentrantDistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperReentrantDistributedLock</span>(<span class="string">&quot;订单流水号&quot;</span>, client);</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="ZooKeeper-分布式锁小结"><a href="#ZooKeeper-分布式锁小结" class="headerlink" title="ZooKeeper 分布式锁小结"></a>ZooKeeper 分布式锁小结</h3><p>ZooKeeper 分布式锁的<strong>优点</strong>是较为<strong>可靠</strong>：</p>
<ul>
<li><strong>避免死锁</strong>：ZooKeeper 通过临时节点 + 监听机制，可以保证：如果持有临时节点的线程主动解锁或断连，Zk 会自动删除临时节点，这意味着锁的释放。所以，不存在锁永久不释放从而导致死锁的问题。</li>
<li><strong>单点问题</strong>：ZooKeeper 采用主从架构，并确保主从同步是强一致的，因此不会出现单点问题。</li>
</ul>
<p>ZooKeeper 分布式锁的<strong>缺点</strong>是：加锁、解锁操作，本质上是对 ZooKeeper 的写操作，全部由 ZooKeeper 主节点负责。如果加锁、解锁的吞吐量很大，容易出现单点写入瓶颈。</p>
<h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h3 id="Redis-分布式锁原理"><a href="#Redis-分布式锁原理" class="headerlink" title="Redis 分布式锁原理"></a>Redis 分布式锁原理</h3><h4 id="极简版本"><a href="#极简版本" class="headerlink" title="极简版本"></a>极简版本</h4><p>我们先来看一下，如何实现一个极简版本的 Redis 分布式锁。</p>
<p>（1）加锁</p>
<p>Redis 中的 <code>setnx</code> 命令，表示当且仅当 key 不存在时，才会写入 key。由于其互斥性，所以可以基于此来实现分布式锁。</p>
<p>执行 <code>setnx key val</code>，若返回 1，表示写入成功，即加锁成功；若返回 0，表示该 key 已存在，写入失败，即加锁失败。</p>
<p>（2）解锁</p>
<p>Redis 分布式锁如何解锁呢？</p>
<p>很简单，删除 key 就意味着释放锁，即执行 <code>del key</code> 命令。</p>
<h4 id="避免死锁-1"><a href="#避免死锁-1" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>极简版本的解决方案有一个很大的问题：<strong>存在死锁的可能</strong>。持有锁的节点如果执行业务过程中出现异常或机器宕机，都可能导致无法释放锁。这种情况下，其他节点永远也无法再获取锁。</p>
<p>对于异常，在 Java 中，可以通过 <code>try...catch...finally</code> 来保证：最终一定会释放锁，其他编程语言也有相似的语法特性。</p>
<p>对于机器宕机这种情况，如何处理呢？通常的对策是：为锁加上<strong>超时机制，过期自动删除</strong>。</p>
<p>在 Redis 中，<code>expire</code> 命令可以为 key 设置一个超时时间，一旦过期，Redis 会自动删除 key。如此看来，<code>setnx</code> + <code>expire</code> 组合使用，就能解决死锁问题了。可惜，没那么简单。Redis 只能保证单一命令的原子性，不保证组合命令的原子性。</p>
<p>那么，Redis 中有没有一条命令可以实现 setnx + expire 的组合语义呢？还真有，可以通过下面的命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面两条命令是等价的</span></span><br><span class="line">SET key val NX PX 30000</span><br><span class="line">SET key val NX EX 30</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>NX</code>：该参数表示当且仅当 key 不存在，才能写入成功</li>
<li><code>PX</code>：超时时间，单位毫秒</li>
<li><code>EX</code>：超时时间，单位秒</li>
</ul>
<h4 id="超时续期"><a href="#超时续期" class="headerlink" title="超时续期"></a>超时续期</h4><p>为了避免死锁，我们为锁添加了超时时间。但这里有一个问题，如果应用加锁时，对于操作共享资源的时长估计不足，可能会出现：操作尚未执行完，但是锁没了的尴尬情况。为了解决这个问题，很自然会想到，时间不够，就续期呗。</p>
<p>具体来说，如何续期呢？一种方案是：加锁后，启动一个定时任务，周期性检测锁是否快要过期，如果快要过期并且操作尚未结束，就对锁进行自动续期。自行实现这个方案似乎有点繁琐，好在开源 Redis 客户端 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 中已经为锁的<strong>超时续期</strong>提供了一个成熟的机制——WatchDog（看门狗）。我们可以直接拿来主义即可。</p>
<h4 id="安全解锁"><a href="#安全解锁" class="headerlink" title="安全解锁"></a>安全解锁</h4><p>前文提到了，解锁的操作，实际上就是 <code>del key</code>。这里存在一个问题：因为没有任何判断，任何节点都可以随意删除 key，换句话说，锁可能会被其他节点释放。如何避免这个问题呢？解决方法就是：为锁添加<strong>唯一性标识</strong>来进行互斥。唯一性标识可以是 UUID，可以是雪花算法 ID 等。</p>
<p>在 Redis 分布式锁中，唯一性标识的具体实现就是在 <code>set key val</code> 时，将唯一性标识 id 作为 <code>val</code> 写入。<strong>解锁前，先判断 key 的 value，必须和 set 时写入的 id 值保持一致，以此确认锁归属于自己</strong>。解锁的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.get(<span class="string">&quot;key&quot;</span>) == id)</span><br><span class="line">	redis.del(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里依然存在一个问题，由于需要在 Redis 中，先 <code>get</code>，后 <code>del</code> 操作，所以无法保证操作的原子性。为了保证原子性，可以将这段伪代码用 lua 脚本来实现，这么做的理由是 Redis 中支持原子性的执行 lua 脚本。下面是安全解锁的 lua 脚本代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="自旋重试"><a href="#自旋重试" class="headerlink" title="自旋重试"></a>自旋重试</h4><p>有时候，加锁失败可能只是由于网络波动、请求超时等原因，稍候就可以成功获取锁。为了应对这种情况，加锁操作需要支持重试机制。常见的做法是，设置一个加锁超时时间，在该时间范围内，不断自旋重试加锁操作，超时后再判定加锁失败。</p>
<p>下面是一个自旋重试获取锁的伪代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, uniqId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功，执行业务操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - begin;</span><br><span class="line">        <span class="keyword">if</span> (time &gt;= timeout) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis-分布式锁小结"><a href="#Redis-分布式锁小结" class="headerlink" title="Redis 分布式锁小结"></a>Redis 分布式锁小结</h3><p>在前文中，为了实现一个靠谱的 Redis 分布式锁，我们讨论了避免死锁、超时续期、安全解锁几个问题以及应对策略。但是，依然存在一些其他问题：</p>
<ul>
<li><strong>不可重入</strong> - 同一个线程无法多次获取同一把锁。</li>
<li><strong>单点问题</strong> - Redis 主从同步存在延迟，有可能导致锁冲突。举例来说：线程一在主节点加锁，如果主节点尚未同步给从节点就发生宕机；此时，Redis 集群会选举一个从节点作为新的主节点。此时，新的主节点没有锁的数据，若有其他线程试图加锁，就可以成功获取锁，即出现同时有多个线程持有锁的情况。解决这个问题，可以使用 RedLock 算法。</li>
</ul>
<h2 id="RedLock-分布式锁"><a href="#RedLock-分布式锁" class="headerlink" title="RedLock 分布式锁"></a>RedLock 分布式锁</h2><p>RedLock 分布式锁，是 Redis 的作者 Antirez 提出的一种解决方案。</p>
<blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/develop/use/patterns/distributed-locks/">RedLock 官方文档</a></p>
</blockquote>
<h3 id="RedLock-分布式锁原理"><a href="#RedLock-分布式锁原理" class="headerlink" title="RedLock 分布式锁原理"></a>RedLock 分布式锁原理</h3><p>RedLock 分布式锁在普通 Redis 分布式锁的基础上，进行了扩展，其要点在于：</p>
<ul>
<li>（1）加锁操作不是写入单一节点，而是同时写入多个主节点，官方推荐集群中至少有 5 个主节点。</li>
<li>（2）只要半数以上的主节点写入成功，即视为加锁成功。</li>
<li>（3）大多数节点加锁的总耗时，要小于锁设置的过期时间。</li>
<li>（4）解锁时，要向所有节点发起请求。</li>
</ul>
<p>下面来逐一解释以上各要点的用意：</p>
<blockquote>
<p>（1）RedLock 加锁时，为什么要同时写入多个主节点？</p>
</blockquote>
<p>这是为了避免单点问题，即使有部分实例出现异常，依然可以正常提供加锁、解锁能力。</p>
<blockquote>
<p>（2）为什么要半数以上的主节点写入成功，才视为加锁成功？</p>
</blockquote>
<p>在分布式系统中，为了达成共识，常常采用“多数派”策略来进行决策：大多数节点认可的行为，就视为整体通过。</p>
<blockquote>
<p>（3）为什么加锁成功后，还要计算加锁的累计耗时？</p>
</blockquote>
<p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久。而且，网络情况是复杂的，可能存在延迟、丢包、超时等情况。网络请求越多，异常发生的概率就越大。所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经<strong>超过</strong>了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p>
<blockquote>
<p>（4）解锁时，为什么要向所有节点发起请求？</p>
</blockquote>
<p>因为网络环境的复杂性，可能会存在这种情况：向某主节点写入锁信息，实际写入成功，但是响应超时或丢包。所以，释放锁时，不管之前有没有加锁成功，需要释放<strong>所有节点</strong>的锁，以保证清理节点上<strong>残留</strong>的锁。</p>
<h3 id="RedLock-分布式锁小结"><a href="#RedLock-分布式锁小结" class="headerlink" title="RedLock 分布式锁小结"></a>RedLock 分布式锁小结</h3><p>RedLock 分布式锁的解决方案看上去考虑的面面俱到，似乎已经万无一失了，但真的是如此吗？</p>
<p>分布式领域典中典著作《数据密集型应用系统设计》的作者 Martin 就曾对 RedLock 提出了质疑，他和 Redis 以及 RedLock 的作者 Antirez 掀起了一场激烈的争论。</p>
<blockquote>
<p>二人的讨论文章如下，有兴趣可以看一下：</p>
<ul>
<li>Martin 质疑 RedLock 的文章：<a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></li>
<li>Antirez 的辩驳文章：<a target="_blank" rel="noopener" href="https://antirez.com/news/101">Is Redlock safe?</a></li>
</ul>
</blockquote>
<p>Martin 的观点：</p>
<p>（1）<strong>RedLock 不能完全保证安全性</strong></p>
<p>分布式系统会遇到三座大山：<strong>NPC</strong></p>
<ul>
<li>N：Network Delay，<strong>网络延迟</strong>；</li>
<li>P：Process Pause，进程暂停（<strong>GC</strong>）；</li>
<li>C：Clock Drift，<strong>时钟漂移</strong>。</li>
</ul>
<p>RedLock 在遇到以上情况时，不能保证安全性。</p>
<p>（2）RedLock 加锁、解锁需要处理多个节点，代价太高</p>
<p>（3）提出 fencing token 的方案，保证正确性</p>
<p>这个模型流程如下：</p>
<ul>
<li>客户端在获取锁时，锁服务可以提供一个<strong>递增</strong>的 token</li>
<li>客户端拿着这个 token 去操作共享资源</li>
<li>共享资源可以根据 token 拒绝<strong>后来者</strong>的请求</li>
</ul>
<p>Antirez 的观点：</p>
<ul>
<li>同意时钟跳跃对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。并且如果误差不大，也是可以接受的。</li>
<li>Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</li>
</ul>
<p>总结来说，<strong>已知的分布式锁，无论采用什么解决方案，在极端情况下，都无法保证百分百的安全。</strong></p>
<h2 id="Redisson-提供的分布式锁"><a href="#Redisson-提供的分布式锁" class="headerlink" title="Redisson 提供的分布式锁"></a>Redisson 提供的分布式锁</h2><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 是一个流行的 Redis Java 客户端，它基于 Netty 开发，并提供了丰富的扩展功能，如：<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/counters/">分布式计数器</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/collections/">分布式集合</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/locks-and-synchronizers/">分布式锁</a> 等。</p>
<p>Redisson 支持的分布式锁有多种：Lock, FairLock, MultiLock, RedLock, ReadWriteLock, Semaphore, PermitExpirableSemaphore, CountDownLatch，可以根据场景需要去选择，非常方便。一般而言，使用 Redis 分布式锁，推荐直接使用 Redisson 提供的 API，功能全面且较为可靠。</p>
<p>下面是 Redisson Lock API 的一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional lock method</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or acquire lock and automatically unlock it after 10 seconds</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or wait for lock aquisition up to 100 seconds</span></span><br><span class="line"><span class="comment">// and automatically unlock it after 10 seconds</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Redisson 分布式锁的实现要点</strong>：</p>
<ul>
<li><strong>锁的获取</strong>：Redisson 使用 Lua 脚本，利用 <code>exists + hexists + hincrby</code> 命令来保证只有一个线程能成功设置键（表示获得锁）。同时，Redisson 会通过 <code>pexpire</code> 命令为锁设置过期时间，防止因宕机等原因导致锁无法释放（即死锁问题）。</li>
<li><strong>锁的续期</strong>：为了防止锁在持有过程中过期导致其他线程抢占锁，Redisson 实现了锁自动续期的功能。持有锁的线程会定期续期，即更新锁的过期时间，确保任务没有完成时锁不会失效。</li>
<li><strong>锁的释放</strong>：锁释放时，Redisson 也是通过 Lua 脚本保证释放操作的原子性。利用 <code>hexists + del</code> 确保只有持有锁的线程才能释放锁，防止误释放锁的情况。Lua 脚本同时利用 publish 命令，广播唤醒其它等待的线程。</li>
<li><strong>可重入锁</strong>：Redisson 支持可重入锁，持有锁的线程可以多次获取同一把锁而不会被阻塞。具体是利用 Redis 中的哈希结构，哈希中的 key 为线程 ID，如果重入则 value +1，如果释放则 value -1，减到 0 说明锁被释放了，则 del 锁。</li>
</ul>
<h2 id="分布式锁技术选型"><a href="#分布式锁技术选型" class="headerlink" title="分布式锁技术选型"></a>分布式锁技术选型</h2><p>下面是主流分布式锁技术方案的对比，可以在技术选型时作为参考：</p>
<table>
<thead>
<tr>
<th></th>
<th>数据库分布式锁</th>
<th>Redis 分布式锁</th>
<th>ZooKeeper 分布式锁</th>
</tr>
</thead>
<tbody><tr>
<td>方案要点</td>
<td>1. 维护一张锁表，为锁的唯一标识字段添加唯一性约束。<br/>2. 只要 insert 成功，即视为加锁成功。</td>
<td><code>set lockKey randomValue NX PX/EX time</code> 当且仅当 key 不存在时才可以写入，并且设定超时时间，以避免死锁。</td>
<td>加锁本质上是在 zk 中指定目录创建<strong>顺序临时接节点</strong>，序号最小即加锁成功。节点删除时，有监听通知机制告知申请锁的线程。</td>
</tr>
<tr>
<td>方案难度</td>
<td>实现简单、易于理解</td>
<td>较为简单，但要使其更可靠，需要有一些完善策略</td>
<td>应用简单，但 zk 内部机制并不简单</td>
</tr>
<tr>
<td>性能</td>
<td>性能最差，易成为瓶颈</td>
<td>性能最高</td>
<td>性能弱于 Redis</td>
</tr>
<tr>
<td>可靠性</td>
<td>有锁表的风险</td>
<td>较为可靠（需要一些完善策略）</td>
<td>可靠性最高</td>
</tr>
<tr>
<td>适用场景</td>
<td>一般不采用</td>
<td>适用于高并发的场景</td>
<td>适用于要求可靠，但并发量不高的场景</td>
</tr>
<tr>
<td>开源实现</td>
<td>无</td>
<td><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a></td>
<td><a target="_blank" rel="noopener" href="https://curator.apache.org/docs/about/">Apache Curator</a></td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a20cd8bf265da43163cdd9a">分布式锁实现汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JzCHpIOiFVmBoAko58ZuGw">分布式锁实现原理与最佳实践 - 阿里云开发者</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-N4x6EkxwAYDGdJhwvmZLw">聊聊分布式锁 - 字节跳动技术团队</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yZC6VJGxt1ANZkn0SljZBg">Redis、ZooKeeper、Etcd，谁有最好用的分布式锁？ - 腾讯云开发者</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/84d17d55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/84d17d55/" class="post-title-link" itemprop="url">传输控制协议 TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-31 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-31T11:51:00+08:00">2019-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-TCP"><a href="#什么是-TCP" class="headerlink" title="什么是 TCP"></a>什么是 TCP</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559263786555.png" alt="img"></p>
<h3 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h3><ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code><ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="TCP-的适用场景"><a href="#TCP-的适用场景" class="headerlink" title="TCP 的适用场景"></a>TCP 的适用场景</h3><p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="TCP-报文"><a href="#TCP-报文" class="headerlink" title="TCP 报文"></a>TCP 报文</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559264511812.png" alt="img"></p>
<p>报文字段不一一阐述，重点关注以下几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559264593860.png" alt="img"></p>
<h2 id="TCP-通信流程"><a href="#TCP-通信流程" class="headerlink" title="TCP 通信流程"></a>TCP 通信流程</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559264679371.png" alt="img"></p>
<p>TCP 完整的通信分为三块：</p>
<ol>
<li>三次握手建立连接</li>
<li>数据传输</li>
<li>四次挥手端口连接</li>
</ol>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/network/transport/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="img"></p>
<p>如上图所示，三次握手流程如下：</p>
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN&#x2F;ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/network/transport/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif" alt="img"></p>
<ol>
<li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li>
<li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li>
<li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li>
</ol>
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559265819762.png" alt="img"></p>
<ol>
<li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li>
<li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li>
<li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li>
<li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559265927658.png" alt="img"></p>
<p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p>
<h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a7835a46fb9a063606eb801">图解 TCP 三次握手与四次分手</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qzcsu/article/details/72861891">TCP 的三次握手与四次挥手（详解+动图）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36629696/article/details/80740678">TCP 详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f372c2b8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f372c2b8/" class="post-title-link" itemprop="url">用户数据报协议 UDP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-31 11:51:00" itemprop="dateCreated datePublished" datetime="2019-05-31T11:51:00+08:00">2019-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>730</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1559263939493.png" alt="img"></p>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h3 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h3><ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<h3 id="UDP-应用场景"><a href="#UDP-应用场景" class="headerlink" title="UDP 应用场景"></a>UDP 应用场景</h3><ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h2 id="UDP-报文"><a href="#UDP-报文" class="headerlink" title="UDP 报文"></a>UDP 报文</h2><p>UDP 数据报分为数据字段和首部字段。<br>首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/38/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/38/">38</a><span class="page-number current">39</span><a class="page-number" href="/blog/page/40/">40</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/40/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"9982c49eccae4d7eeb5ff289a75d371c"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
