<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/22/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/22/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/22/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/5b3ad94d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/5b3ad94d/" class="post-title-link" itemprop="url">分布式综合面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式综合面试"><a href="#分布式综合面试" class="headerlink" title="分布式综合面试"></a>分布式综合面试</h1><h2 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a>，<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163428"><strong>译文</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56146800"><strong>解读</strong></a> - Lamport 介绍 happened before、偏序关系（partial ordering）、逻辑时钟（Logical Clocks）概念，提出解决分布式系统中区分事件发生的时序问题的方法。</li>
<li><a target="_blank" rel="noopener" href="http://courses.csail.mit.edu/6.852/01/papers/VirtTime_GlobState.pdf"><strong>Virtual Time and Global States of Distributed Systems</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56886156"><strong>解读</strong></a> - 逻辑时钟无法描述事件的因果关系。本文提出了向量时钟，这种算法利用了向量这种数据结构将全局各个进程的逻辑时间戳广播给各个进程，通过向量时间戳就能够比较任意两个事件的因果关系。</li>
<li><a target="_blank" rel="noopener" href="https://writings.sh/post/logical-clocks">逻辑时钟 - 如何刻画分布式中的事件顺序</a></li>
</ul>
<p>:::</p>
<h3 id="【简单】为什么需要逻辑时钟？"><a href="#【简单】为什么需要逻辑时钟？" class="headerlink" title="【简单】为什么需要逻辑时钟？"></a>【简单】为什么需要逻辑时钟？</h3><p>::: tip 要点</p>
<p><strong>不同节点的物理时钟即使校准（NTP）也无法完全保持一致</strong>。</p>
<p>:::</p>
<p>为什么需要逻辑时钟？分布式系统中以系统时间来确定事件顺序有什么问题吗？</p>
<p><strong>不同节点的物理时钟无法完全保持一致</strong>。即使引入一个全局时钟（例如：NTP）来进行校准，由于网络通信延迟的不确定性，以及时钟计时的偏差，无法保证每个节点的时间完全一致。</p>
<p>在分布式系统中，由于网络通信延迟的不确定性， <strong>仅仅以接收顺序作为整个分布式系统中事件的发生顺序是不可取的</strong>。</p>
<h3 id="【中等】什么是偏序？什么是全序？"><a href="#【中等】什么是偏序？什么是全序？" class="headerlink" title="【中等】什么是偏序？什么是全序？"></a>【中等】什么是偏序？什么是全序？</h3><p>全序和偏序是数学上的术语，按照数学内容阐述比较晦涩，简单来说：</p>
<ul>
<li><strong>偏序</strong>是部分可比较的有序关系。</li>
<li><strong>全序</strong>是在偏序基础上，要求全部元素必须可比较的有序关系。</li>
</ul>
<h3 id="【困难】什么是逻辑时钟？"><a href="#【困难】什么是逻辑时钟？" class="headerlink" title="【困难】什么是逻辑时钟？"></a>【困难】什么是逻辑时钟？</h3><p>::: info 扩展阅读</p>
<p><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a></p>
<p>:::</p>
<p>::: tip 要点</p>
<ul>
<li><strong>Lamport 逻辑时钟构建了一个全序时钟来描述事件顺序</strong>。</li>
<li><strong>Lamport 逻辑时钟的缺陷是无法描述同时发生的事件</strong>。</li>
</ul>
<p>:::</p>
<p>1978 年，Lamport 在 <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a> 中提出了逻辑时钟的概念，来解决分布式系统中区分事件发生的时序问题。</p>
<p><strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序</strong>。</p>
<p>分布式系统中按是否存在节点交互可分为三类事件，一类发生于节点内部，二是发送事件，三是接收事件。Lamport 时间戳原理如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405170810350.webp" alt="Lamport timestamps space time (图片来源: wikipedia)_"></p>
<ol>
<li>每个事件对应一个 Lamport 计数器，初始值为 0</li>
<li>如果事件在节点内发生，计数器加 1</li>
<li>如果事件属于发送事件，计数器加 1 并在消息中带上该计数器</li>
<li>如果事件属于接收事件，计数器 &#x3D; Max(本地计数器，消息中的计数器) + 1</li>
</ol>
<p>综上，<strong>Lamport 逻辑时钟构建了一个全序时钟来描述事件顺序</strong>。<strong>Lamport 逻辑时钟的缺陷是无法描述同时发生的事件</strong>。</p>
<h3 id="【困难】什么是向量时钟？"><a href="#【困难】什么是向量时钟？" class="headerlink" title="【困难】什么是向量时钟？"></a>【困难】什么是向量时钟？</h3><p>::: tip 要点</p>
<ul>
<li>向量时钟在逻辑时钟基础上改进：<strong>不仅记录了本节点的时间戳，还记录了其他节点的时间戳</strong>。</li>
<li>其本质在于<strong>将逻辑时钟的全序计数器改造为向量时钟的偏序大小关系</strong>：向量有序，则事件有序；向量平行，则事件并发。</li>
<li><strong>向量时钟可以发现数据冲突，但不能解决数据冲突</strong>。</li>
</ul>
<p>:::</p>
<p><strong>向量时钟</strong>其实是在逻辑时钟的基础上进行了演进，算法逻辑类似，只是<strong>不仅记录了本节点的时间戳，还记录了其他节点的时间戳</strong>。其本质在于<strong>将逻辑时钟的全序计数器改造为向量时钟的偏序大小关系</strong>：向量有序，则事件有序；向量平行，则事件并发。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405170811135.webp" alt="Vector clock space time (图片来源: wikipedia)"></p>
<p><strong>向量时钟可以发现数据冲突，但不能解决数据冲突</strong>。</p>
<h3 id="【困难】什么是版本向量时钟？"><a href="#【困难】什么是版本向量时钟？" class="headerlink" title="【困难】什么是版本向量时钟？"></a>【困难】什么是版本向量时钟？</h3><p>::: tip 要点</p>
<p><strong>版本向量时钟只有在更新数据的时候做向量自增</strong>。</p>
<p>:::</p>
<p>在向量时钟算法中， 消息传播后，发送方的向量一定会小于接收者的向量， 是因为接收者对齐了发送者的原因。</p>
<p>版本向量在此基础上，做了一点加强：消息传播后，发送方也对齐接收者的向量，也就是双向对齐，在版本向量中，叫做<strong>同步</strong>。</p>
<p>发送消息和接收消息的时候不再自增向量中的自己的计数器，而是只做双方的向量对齐操作。 也就是，<strong>只有在更新数据的时候做向量自增</strong>。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><h3 id="【简单】什么是强一致性？什么是弱一致性？什么是最终一致性？"><a href="#【简单】什么是强一致性？什么是弱一致性？什么是最终一致性？" class="headerlink" title="【简单】什么是强一致性？什么是弱一致性？什么是最终一致性？"></a>【简单】什么是强一致性？什么是弱一致性？什么是最终一致性？</h3><p><strong>一致性（Consistency）</strong>指的是<strong>多个数据副本是否能保持一致</strong>的特性。</p>
<p>数据一致性又可以分为以下几点：</p>
<ul>
<li><strong>强一致性</strong> - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。通俗的说，分布式系统在执行写操作成功后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</li>
<li><strong>弱一致性</strong> - 系统在写入数据成功后，不承诺立即能读到最新的值，也不承诺什么时候能读到，但是过一段时间之后用户可以看到更新后的值。那么用户读不到最新数据的这段时间被称为“不一致窗口时间”。</li>
<li><strong>最终一致性</strong> - 最终一致性作为弱一致性中的特例，强调的是所有数据副本，在经过一段时间的同步后，最终能够到达一致的状态，不需要实时保证系统数据的强一致性。</li>
</ul>
<h3 id="【简单】什么是-ACID？"><a href="#【简单】什么是-ACID？" class="headerlink" title="【简单】什么是 ACID？"></a>【简单】什么是 ACID？</h3><p>那么，什么是 ACID 特性呢？ACID 是数据库事务正确执行的四个基本要素的单词缩写：</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>原子是指不可分解为更小粒度的东西。事务的原子性意味着：<strong>事务中的所有操作要么全部成功，要么全部失败</strong>。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>ACID 中的原子性并不关乎多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，后者其实是由 ACID 的隔离性所定义。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li><strong>同时运行的事务互不干扰</strong>。换句话说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h2 id="CAP-BASE"><a href="#CAP-BASE" class="headerlink" title="CAP &amp; BASE"></a>CAP &amp; BASE</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf"><strong>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</strong></a>，<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936718012430"><strong>解读</strong></a> - 经典的 CAP 定理，即：在一个分布式系统中，当发生网络分区时，那么强一致性和可用性只能二选一。</li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/"><strong>CAP Twelve Years Later: How the “Rules” Have Changed</strong></a>, <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/64778723/answer/224266038"><strong>解读</strong></a> - CAP 定理的新解读，并阐述 CAP 定理的一些常见误区。</li>
<li><a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/BASE%3A-An-Acid-Alternative-Pritchett/2e72e6c022dd33115304ecfcb6dad7ea609534a4"><strong>BASE: An Acid Alternative</strong></a>，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/base-an-acid-alternative.html"><strong>译文</strong></a> - BASE 定理是对 CAP 中一致性和可用性的权衡，提出采用适当的方式来使系统达到最终一致性。</li>
</ul>
<p>:::</p>
<h3 id="【中等】什么是-CAP-定理？"><a href="#【中等】什么是-CAP-定理？" class="headerlink" title="【中等】什么是 CAP 定理？"></a>【中等】什么是 CAP 定理？</h3><p>::: tip 要点</p>
<ul>
<li>CAP 就是取 Consistency、Availability、Partition Tolerance 的首字母而命名。</li>
<li>CAP 定理提出：Consistency、Availability、Partition Tolerance 三者不可兼得。</li>
<li>在分布式系统中，分区容错不可避免，因此，<strong>CAP 定理实际上是要在可用性（A）和一致性（C）之间做权衡</strong>。</li>
</ul>
<p>:::</p>
<p>CAP 定理提出：分布式系统有三个指标，这三个指标不能同时做到：</p>
<ul>
<li><strong>一致性（Consistency）</strong> - 在任何给定时间，网络中的所有节点都具有完全相同（最近）的值。</li>
<li><strong>可用性（Availability）</strong> - 对网络的每个请求都会返回响应，但不能保证返回的数据是最新的。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> - 即使任意数量的节点出现故障，网络仍会继续运行。</li>
</ul>
<p>CAP 就是取 Consistency、Availability、Partition Tolerance 的首字母而命名。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405160639643.png"></p>
<p>在分布式系统中，分区容错性是一个既定的事实：因为分布式系统总会出现各种各样的问题，如由于网络原因而导致节点失联；发生机器故障；机器重启或升级等等。因此，<strong>CAP 定理实际上是要在可用性（A）和一致性（C）之间做权衡</strong>。</p>
<h3 id="【中等】选择-CP-还是-AP？"><a href="#【中等】选择-CP-还是-AP？" class="headerlink" title="【中等】选择 CP 还是 AP？"></a>【中等】选择 CP 还是 AP？</h3><p>::: tip 要点</p>
<p>选择 AP 还是 CP，视具体业务场景而定。</p>
<p>以注册中心而论，可用性比一致性更重要，选 AP 更合适。</p>
<p>:::</p>
<p>在分布式系统中，分区容错性是一个既定的事实：因为分布式系统总会出现各种各样的问题，如由于网络原因而导致节点失联；发生机器故障；机器重启或升级等等。因此，<strong>CAP 定理实际上是要在可用性（A）和一致性（C）之间做权衡</strong>。</p>
<ul>
<li>选择 <strong>AP 模式</strong>，偏向于保证服务的高可用性。用户访问系统的时候，都能得到响应数据，不会出现响应错误；但是，当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。</li>
<li>选择 <strong>CP 模式</strong>，一旦因为消息丢失、延迟过高发生了网络分区，就会影响用户的体验和业务的可用性。因为为了防止数据不一致，系统将拒绝新数据的写入。</li>
</ul>
<p>一个最具代表性的问题是：服务注册中心应该选择 AP 还是 CP？</p>
<p>在微服务架构下，服务注册和服务发现机制中主要有三种角色：</p>
<ul>
<li><strong>服务提供者</strong>（RPC Server &#x2F; Provider）</li>
<li><strong>服务消费者</strong>（RPC Client &#x2F; Consumer）</li>
<li><strong>服务注册中心</strong>（Registry）</li>
</ul>
<p><strong>注册中心</strong>负责协调服务注册和服务发现，显然它是核心中的核心。主流的注册中心有很多，如：ZooKeeper、Nacos、Eureka、Consul、etcd 等。在针对注册中心进行技术选型时，其 CAP 设计也是一个比较的维度。</p>
<ul>
<li>CP 模型代表：ZooKeeper、etcd。系统强调数据的一致性，当数据一致性无法保证时（如：正在选举主节点），系统拒绝请求。</li>
<li>AP 模型代表：Nacos、Eureka。系统强调可用性，牺牲一定的一致性（即服务节点上的数据不保证是最新的），来保证整体服务可用。</li>
</ul>
<p>对于服务注册中心而言，即使不同节点保存的服务注册信息存在差异，也不会造成灾难性的后果，仅仅是信息滞后而已。但是，如果为了追求数据一致性，使得服务发现短时间内不可用，负面影响更严重。所以，对于服务注册中心而言，可用性比一致性更重要，一般应该选择 AP 模型。</p>
<h3 id="【中等】CAP-定理真的正确吗？"><a href="#【中等】CAP-定理真的正确吗？" class="headerlink" title="【中等】CAP 定理真的正确吗？"></a>【中等】CAP 定理真的正确吗？</h3><p>::: tip 要点</p>
<p>CAP 理论模型局限性很大，未考虑网络分区以外的各种故障、异常情况，因此对于复杂的分布式系统场景指导意义不足。</p>
<p>:::</p>
<p>CAP 定理在分布式系统领域大名鼎鼎，以至于被很多人视为了真理。然而，CAP 定理真的正确吗？</p>
<p>网络分区是一种故障，不管喜欢还是不喜欢，它都可能发生，所以无法选择或逃避分区的问题。在网络正常的时候，系统可以同时保证一致性（线性化）和可用性。而一旦发生了网络故障，必须要么选择一致性，要么选择可用性。因此，对 CAP 更准确的理解应该是：<strong>当发生网络分区（P）的情况下，可用性（A）和一致性（C）二者只能选其一</strong>。</p>
<p>CAP 定理所描述的模型实际上局限性很大，它只考虑了一种一致性模型和一种故障（网络分区故障），而没有考虑网络延迟、节点失效等情况。因此，它对于指导一个具体的分布式系统设计来说，没有太大的实际价值。</p>
<p>值得一提的是，在 CAP 定理提出十二年之后，其提出者也发表了一篇文章 <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/"><strong>CAP Twelve Years Later: How the “Rules” Have Changed</strong></a>，来阐述 CAP 定理的局限性。</p>
<h3 id="【中等】什么是-BASE-定理？"><a href="#【中等】什么是-BASE-定理？" class="headerlink" title="【中等】什么是 BASE 定理？"></a>【中等】什么是 BASE 定理？</h3><p>::: tip 要点</p>
<p>BASE 是 <strong><code>基本可用（Basically Available）</code><strong>、</strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。</p>
<p>BASE 核心思想是：要求最终一致性，通过牺牲强一致性来达到可用性。</p>
<p>:::</p>
<p>BASE 是 <strong><code>基本可用（Basically Available）</code><strong>、</strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。BASE 定理是对 CAP 定理中可用性（A）和一致性（C）权衡的结果。</p>
<p>BASE 定理的<strong>核心思想</strong>是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过<strong>牺牲强一致性来达到可用性</strong>，通常运用在大型分布式系统中。</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211102192406.png" style="width: 640px" />

<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">Part-time Parliament 论文</a></li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos Made Simple 论文</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31780743">Paxos 算法详解</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Paxos%E7%AE%97%E6%B3%95">Wiki - Paxos 算法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TW411M7Fx?from=search&seid=11524608198747599965">一致性算法（Paxos、Raft、Zab）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av36556594">Raft 作者讲解 Paxos 视频</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=d7nAGI_NZPk">Paxos 算法讲解视频</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/d287e6b0/">深入剖析共识性算法 Paxos</a></li>
</ul>
<p>:::</p>
<h3 id="【困难】Paxos-是怎样工作的？"><a href="#【困难】Paxos-是怎样工作的？" class="headerlink" title="【困难】Paxos 是怎样工作的？"></a>【困难】Paxos 是怎样工作的？</h3><p>::: tip 要点</p>
<p>Paxos 是一个分布式系统共识性算法。它的核心思想是<strong>【两阶段提交】</strong>和<strong>【多数派决议】</strong>。</p>
<p>Paxos 将分布式系统中的节点分 Proposer、Acceptor、Learner 三种角色。</p>
<p>Paxos 算法包含 2 个部分：</p>
<ul>
<li><strong>Basic Paxos 算法</strong>：描述的是多节点之间如何就某个值达成共识。<strong>Basic Paxos 是通过二阶段提交的方式来达成共识的</strong>。</li>
<li><strong>Multi Paxos 思想</strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。</li>
</ul>
<p>:::</p>
<p><strong>Paxos 是一种基于消息传递且具有容错性的共识性（consensus）算法</strong>。</p>
<p>Paxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。</p>
<p>Paxos 利用多数派 (Majority) 机制保证了一定的容错能力，即 <code>N</code> 个节点的系统最多允许 <code>N / 2 - 1</code> 个节点同时出现故障。</p>
<p>Paxos 算法包含 2 个部分：</p>
<ul>
<li><strong>Basic Paxos 算法</strong>：描述的是多节点之间如何就某个值达成共识。</li>
<li><strong>Multi Paxos 思想</strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。</li>
</ul>
<h4 id="Basic-Paxos-算法"><a href="#Basic-Paxos-算法" class="headerlink" title="Basic Paxos 算法"></a>Basic Paxos 算法</h4><p><strong>Basic Paxos 是通过二阶段提交的方式来达成共识的</strong>。</p>
<p>Paxos 将分布式系统中的节点分 Proposer、Acceptor、Learner 三种角色。</p>
<ul>
<li><strong>提议者（Proposer）</strong>：发出提案（Proposal），用于投票表决。Proposal 信息包括提案编号 (Proposal ID) 和提议的值 (Value)。在绝大多数场景中，集群中收到客户端请求的节点，才是提议者。这样做的好处是，对业务代码没有入侵性，也就是说，我们不需要在业务代码中实现算法逻辑。</li>
<li><strong>接受者（Acceptor）</strong>：对每个 Proposal 进行投票，若 Proposal 获得多数 Acceptor 的接受，则称该 Proposal 被批准。一般来说，集群中的所有节点都在扮演接受者的角色，参与共识协商，并接受和存储数据。</li>
<li><strong>学习者（Learner）</strong>：不参与接受，从 Proposers&#x2F;Acceptors 学习、记录最新达成共识的提案（Value）。一般来说，学习者是数据备份节点，比如主从架构中的从节点，被动地接受数据，容灾备份。</li>
</ul>
<p>Paxos 算法有 3 个阶段，其中，前 2 个阶段负责协商并达成共识：</p>
<ol>
<li><strong>准备（Prepare）阶段</strong>：Proposer 向 Acceptors 发出 Prepare 请求，Acceptors 针对收到的 Prepare 请求进行 Promise 承诺。</li>
<li><strong>接受（Accept）阶段</strong>：Proposer 收到多数 Acceptors 承诺的 Promise 后，向 Acceptors 发出 Propose 请求，Acceptors 针对收到的 Propose 请求进行 Accept 处理。</li>
<li><strong>学习（Learn）阶段</strong>：Proposer 在收到多数 Acceptors 的 Accept 之后，标志着本次 Accept 成功，决议形成，将形成的决议发送给所有 Learners。</li>
</ol>
<h4 id="Multi-Paxos-思想"><a href="#Multi-Paxos-思想" class="headerlink" title="Multi Paxos 思想"></a>Multi Paxos 思想</h4><p>Basic Paxos 有以下问题，导致它不能应用于实际：</p>
<ul>
<li><strong>Basic Paxos 算法只能对一个值形成决议</strong>。</li>
<li><strong>Basic Paxos 算法会消耗大量网络带宽</strong>。Basic Paxos 中，决议的形成至少需要两次网络通信，在高并发情况下可能需要更多的网络通信，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos 搞不定了。</li>
</ul>
<p>Multi Paxos 基于 Basic Paxos 做了两点改进：</p>
<ul>
<li><strong>针对每一个要确定的值，运行一次 Paxos 算法实例（Instance），形成决议</strong>。每一个 Paxos 实例使用唯一的 Instance ID 标识。</li>
<li><strong>在所有 Proposer 中选举一个 Leader，由 Leader 唯一地提交 Proposal 给 Acceptor 进行表决</strong>。这样没有 Proposer 竞争，解决了活锁问题。在系统中仅有一个 Leader 进行 Value 提交的情况下，Prepare 阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li>
</ul>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft 算法论文</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft 算法论文译文</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></li>
<li><a target="_blank" rel="noopener" href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jdon.com/artichect/raft.html">分布式系统的 Raft 算法</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32052223">Raft 算法详解</a></li>
<li><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus</a> - 一个动画教程</li>
<li><a target="_blank" rel="noopener" href="https://raft.github.io/">The Raft Consensus Algorithm</a> - 一个交互式动画教程</li>
<li><a href="https://dunwu.github.io/waterdrop/pages/3a64eb94/">深入剖析共识性算法 Raft</a></li>
</ul>
<p>:::</p>
<h3 id="【困难】Raft-是怎样工作的？"><a href="#【困难】Raft-是怎样工作的？" class="headerlink" title="【困难】Raft 是怎样工作的？"></a>【困难】Raft 是怎样工作的？</h3><p>::: tip 要点</p>
<p><strong><a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft</a> 是一种管理日志复制的分布式共识性算法</strong>。</p>
<p>Raft 将一致性问题分解成了三个子问题：</p>
<ul>
<li><strong>选举 Leader</strong>：<ul>
<li><strong>Leader 心跳</strong>：Leader 定时向 Follower 发心跳以续活；Follower 超时未收到心跳，视其为下线。</li>
<li><strong>投票选举</strong>：Follower 判断 Leader 下线后，发起 Leader 选举，成为 Candidate。</li>
<li><strong>多数派原则</strong>：得到大多数选票的 Candidate 当选为 Leader。</li>
<li><strong>随机的竞选超时时间</strong>：<ul>
<li>每个 Follower 都设置一个随机的竞选超时时间，该时间范围内，未收到 Leader 的心跳，就视为当前 Term 无 Leader，再次 Leader 选举。</li>
<li>之所以是随机时间，是为了避免重复出现相同投票结果，导致始终选不出 Leader 的情况（一种典型的活锁）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>日志复制</strong>：Leader 负责处理所有客户端读写请求；Follower 只负责同步 Leader 的日志，并更新本地的日志状态机（Offset）</li>
<li><strong>安全性</strong><ul>
<li><strong>选举限制</strong>：拥有最新的已提交的日志条目的 Follower 才有资格成为 Leader。</li>
<li><strong>提交旧任期的日志条目</strong>：<strong>Raft 永远不会通过计算副本数目的方式去提交一个之前 Term 内的日志条目</strong>。</li>
<li><strong>日志压缩</strong>：Raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。以此，避免日志无限膨胀，导致故障恢复过久。</li>
</ul>
</li>
</ul>
<p>:::</p>
<p><strong><a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft</a> 是一种管理日志复制的分布式共识性算法</strong>。从本质上说，<strong>Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft</a> 出现之前，Paxos 一直是分布式共识性算法的标准。Paxos <strong>难以理解，更难以实现</strong>。Raft 的设计目标是简化 Paxos，使得算法<strong>既容易理解，也容易实现</strong>。</p>
<p>Raft 将一致性问题分解成了三个子问题：</p>
<ul>
<li><strong>选举 Leader</strong></li>
<li><strong>日志复制</strong></li>
<li><strong>安全性</strong></li>
</ul>
<h4 id="Raft-概念"><a href="#Raft-概念" class="headerlink" title="Raft 概念"></a>Raft 概念</h4><p><strong>（1）服务器角色</strong></p>
<p>在 Raft 中，任何时刻，每个服务器都处于这三个角色之一 ：</p>
<ul>
<li><strong><code>Leader</code></strong> - 领导者，通常一个系统中是<strong>一主（Leader）多从（Follower）</strong>。Leader <strong>负责处理所有的客户端请求</strong>。</li>
<li><strong><code>Follower</code></strong> - 跟随者，<strong>不会发送任何请求</strong>，只是简单的 <strong>响应来自 Leader 或者 Candidate 的请求</strong>。</li>
<li><strong><code>Candidate</code></strong> - 参选者，选举新 Leader 时的临时角色。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200131215742.png"></p>
<p><strong>（2）任期</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200131220742.png"></p>
<p>Raft 把时间分割成任意长度的 <strong><em><code>任期（Term）</code></em><strong>，任期用连续的整数标记。每一段任期从一次</strong>选举</strong>开始。<strong>Raft 保证了在一个给定的任期内，最多只有一个领导者</strong>。</p>
<p><strong>任期在 Raft 算法中充当逻辑时钟的作用，使得服务器节点可以查明一些过期的信息（比如过期的 Leader）。每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号。</strong></p>
<p><strong>（3）选举 Leader</strong></p>
<p><strong>领导者心跳消息</strong>：Raft 使用一种心跳机制来触发 Leader 选举。<strong>Leader 需要周期性的向所有 Follower 发送心跳消息</strong>，以此维持 Leader 身份。</p>
<p><strong>随机的竞选超时时间</strong>：每个 Follower 都设置了一个<strong>随机的竞选超时时间</strong>，一般为 <code>150ms ~ 300ms</code>，如果在竞选超时时间内没有收到 Leader 的心跳消息，就会认为当前 Term 没有可用的 Leader，并发起选举来选出新的 Leader。开始一次选举过程，Follower 先要增加自己的当前 Term 号，并<strong>转换为 Candidate</strong>。</p>
<p>Candidate 会并行的<strong>向集群中的所有服务器节点发送投票请求（<code>RequestVote RPC</code>）</strong>，它会保持当前状态直到以下三件事情之一发生：</p>
<ul>
<li><strong>自己成为 Leader</strong></li>
<li><strong>其他的服务器成为 Leader</strong></li>
<li><strong>没有任何服务器成为 Leader</strong></li>
</ul>
<p>Raft 算法通过：领导者心跳消息、随机选举超时时间、得到大多数选票才通过原则、任期最新者优先、先来先服务等投票原则，保证了一个任期只有一位领导，也极大地减少了选举失败的情况。</p>
<h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202405170817072.png"></p>
<ol>
<li>Leader 负责处理所有客户端的请求。</li>
<li>Leader 把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发送 <code>AppendEntries RPC</code> 请求，要求 Follower 复制日志条目。</li>
<li>Follower 复制成功后，返回确认消息。</li>
<li>当这个日志条目被半数以上的服务器复制后，Leader 提交这个日志条目到它的复制状态机，并向客户端返回执行结果。</li>
</ol>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ul>
<li><strong>选举限制</strong>：拥有最新的已提交的日志条目的 Follower 才有资格成为 Leader。</li>
<li><strong>提交旧任期的日志条目</strong>：<strong>Raft 永远不会通过计算副本数目的方式去提交一个之前 Term 内的日志条目</strong>。</li>
<li><strong>日志压缩</strong>：Raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。以此，避免日志无限膨胀，导致故障恢复过久。</li>
</ul>
<h2 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h2><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://diyhpl.us/~bryan/papers2/distributed/distributed-systems/zab.totally-ordered-broadcast-protocol.2008.pdf"><strong>A Simple Totally Ordered Broadcast Protocol</strong></a> - 概述 ZooKeeper 的全序广播协议（Zab）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/Zookeeper%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.md">ZooKeeper 简介及核心概念</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/zookeeper-chubby">详解分布式协调服务 ZooKeeper</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper">Introduction to Apache ZooKeeper</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/da131252/">ZAB 协议</a></li>
</ul>
<p>:::</p>
<h3 id="【困难】ZAB-是怎样工作的？"><a href="#【困难】ZAB-是怎样工作的？" class="headerlink" title="【困难】ZAB 是怎样工作的？"></a>【困难】ZAB 是怎样工作的？</h3><p>::: tip 要点</p>
<p>ZAB 协议是 Zookeeper 专门设计的一种<strong>支持故障恢复的原子广播协议</strong>。</p>
<p>ZAB 协议定义了两个可以<strong>无限循环</strong>的流程：</p>
<ul>
<li><strong><code>选举 Leader</code><strong>：用于故障恢复，从而保证高可用。采用</strong>多数派原则</strong>选举 Leader。</li>
<li>**<code>原子广播</code>**：用于主从同步，从而保证数据一致性。<ul>
<li>Leader 负责所有读写；每次更新事务会有一个唯一标识（<strong>ZXID</strong>）</li>
<li>Leader 会广播同步数据给 Follower，当半数以上 Follower 更新成功，Leader 才会提交数据。</li>
</ul>
</li>
</ul>
<p>:::</p>
<p>ZAB 协议是 Zookeeper 专门设计的一种<strong>支持故障恢复的原子广播协议</strong>。</p>
<p>ZAB 协议是 ZooKeeper 的数据一致性和高可用解决方案。</p>
<p>ZAB 协议定义了两个可以<strong>无限循环</strong>的流程：</p>
<ul>
<li><strong><code>选举 Leader</code></strong> - 用于故障恢复，从而保证高可用。</li>
<li><strong><code>原子广播</code></strong> - 用于主从同步，从而保证数据一致性。</li>
</ul>
<h4 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h4><p>ZooKeeper 集群采用一主（称为 Leader）多从（称为 Follower）模式，主从节点通过副本机制保证数据一致。</p>
<ul>
<li><strong>如果 Follower 节点挂了</strong> - ZooKeeper 集群中的每个节点都会单独在内存中维护自身的状态，并且各节点之间都保持着通讯，<strong>只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务</strong>。</li>
<li><strong>如果 Leader 节点挂了</strong> - 如果 Leader 节点挂了，系统就不能正常工作了。此时，需要通过 ZAB 协议的选举 Leader 机制来进行故障恢复。</li>
</ul>
<p>ZAB 协议的选举 Leader 机制简单来说，就是：基于过半选举机制产生新的 Leader，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出选举 Leader 模式，进入原子广播模式。</p>
<h4 id="原子广播"><a href="#原子广播" class="headerlink" title="原子广播"></a>原子广播</h4><p><strong>ZooKeeper 通过副本机制来实现高可用</strong>。</p>
<p>那么，ZooKeeper 是如何实现副本机制的呢？答案是：ZAB 协议的原子广播。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper_3.png"></p>
<p>ZAB 协议的原子广播要求：</p>
<p>**<em>所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应</em>**。这有些类似数据库中的两阶段提交协议。</p>
<p>在整个消息的广播过程中，Leader 服务器会每个事务请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。</p>
<h2 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h2><h3 id="【困难】Gossip-是怎样工作的？"><a href="#【困难】Gossip-是怎样工作的？" class="headerlink" title="【困难】Gossip 是怎样工作的？"></a>【困难】Gossip 是怎样工作的？</h3><p>::: info 扩展阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf">Epidemic Algorithms for Replicated Database Maintenance</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议</a></li>
<li><a target="_blank" rel="noopener" href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/">INTRODUCTION TO GOSSIP</a></li>
<li><a target="_blank" rel="noopener" href="https://flopezluis.github.io/gossip-simulator/">Goosip 协议仿真动画</a></li>
</ul>
<p>:::</p>
<p>::: tip 要点</p>
<p>Gossip 是一种用于分布式系统节点间信息交换的协议。</p>
<p>Gossip 的设计思想基于<strong>去中心化</strong>和<strong>最终一致性</strong>。</p>
<p>Gossip 协议的工作原理：</p>
<ul>
<li><strong>周期性、成对通信</strong>：每个节点每隔一段时间就<strong>随机</strong>选择集群中的另一个节点（这个节点称为“邻居”）。</li>
<li><strong>交换信息</strong>：两个节点连接后，会<strong>互相交换</strong>自己拥有的信息（例如，其他节点的状态、存储的数据等）。</li>
<li><strong>感染式传播</strong>：接收到新信息的节点，会将这些新信息融入到自己的信息库中。在下一次周期中，它又会成为传染源，将（包含新信息的）所有信息再次传播给其他随机节点。</li>
<li><strong>最终一致性</strong>：不需要中央协调，经过一段时间后，通过这种“八卦”式的传播，集群中的所有节点最终都会拥有完全相同的信息。</li>
</ul>
<p>:::</p>
<p>Gossip 也叫 Epidemic Protocol （流行病协议），这个协议基于<strong>最终一致性</strong>以及<strong>去中心化</strong>设计思想。主要用于<strong>分布式节点之间进行信息交换和数据同步</strong>，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络（去中心化）。</p>
<p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p>
<p>Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。<strong>异步是它的优点，而消息冗余则是它的缺点</strong>。</p>
<p>Goosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个<strong>最终一致性</strong>协议。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210708234308.gif"></p>
<p>Gossip 有两种类型：</p>
<ul>
<li><strong>Anti-Entropy(反熵)<strong>：</strong>以固定的概率传播所有的数据</strong>。反熵时通讯成本会很高，可以通过引入校验和等机制，降低需要对比的数据量和通讯消息等。反熵不适合动态变化或节点数比较多的分布式环境。</li>
<li><strong>Rumor-Mongering(谣言传播)<strong>：</strong>仅传播新到达的数据</strong>。谣言传播模型指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。在谣言传播模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个谣言消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，谣言传播模型下，系统有一定的概率会不一致。而由于，谣言传播模型下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/8d17f325/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/8d17f325/" class="post-title-link" itemprop="url">分布式简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式简介"><a href="#分布式简介" class="headerlink" title="分布式简介"></a>分布式简介</h1><h2 id="分布式系统的发展历程"><a href="#分布式系统的发展历程" class="headerlink" title="分布式系统的发展历程"></a>分布式系统的发展历程</h2><p>罗马不是一天建成的，同理，现代分布式系统架构也不是一蹴而就的，而是逐步发展的演化过程。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。</p>
<p>了解分布式系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。</p>
<h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><ul>
<li><strong>场景</strong>：网站运营初期，访问用户少，一台服务器绰绰有余。</li>
<li><strong>特征</strong>：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></li>
<li><strong>描述</strong>：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200702718.png"></p>
<h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><ul>
<li><strong>场景</strong>：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</li>
<li><strong>特征</strong>：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></li>
<li><strong>描述</strong>：三台服务器对性能要求各不相同：<ul>
<li>应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；</li>
<li>数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；</li>
<li>文件服务器需要存储大量文件，因此需要更大容量的硬盘。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200703123.png"></p>
<h3 id="使用缓存改善性能"><a href="#使用缓存改善性能" class="headerlink" title="使用缓存改善性能"></a>使用缓存改善性能</h3><ul>
<li><strong>场景</strong>：随着用户逐渐增多，数据库压力太大导致访问延迟。</li>
<li><strong>特征</strong>：由于网站访问和财富分配一样遵循二八定律：_80% 的业务访问集中在 20% 的数据上_。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></li>
<li><strong>描述</strong>：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。<ul>
<li>本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。</li>
<li>分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200705172.png"></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li><strong>场景</strong>：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</li>
<li><strong>特征</strong>：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></li>
<li><strong>描述</strong>：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200704005.png"></p>
<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><ul>
<li><strong>场景</strong>：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</li>
<li><strong>特征</strong>：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></li>
<li><strong>描述</strong>：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200707199.png"></p>
<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><ul>
<li><strong>场景</strong>：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</li>
<li><strong>特征</strong>：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></li>
<li><strong>描述</strong>：CDN 和反向代理的基本原理都是缓存，区别在于：<ul>
<li>CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；</li>
<li>而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200710745.png"></p>
<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><ul>
<li><strong>场景</strong>：大型网站的业务场景日益复杂，分为多个产品线。</li>
<li><strong>特征</strong>：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></li>
<li><strong>描述</strong>：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。<ul>
<li><strong>纵向拆分</strong>：<strong>将一个大应用拆分为多个小应用</strong>，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</li>
<li><strong>横向拆分</strong>：<strong>将复用的业务拆分出来，独立部署为分布式服务</strong>，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200710835.png"></p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><ul>
<li><strong>场景</strong>：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</li>
<li><strong>特征</strong>：<strong>数据库采用分布式数据库。</strong></li>
<li><strong>描述</strong>：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200711984.png"></p>
<h3 id="分布式组件"><a href="#分布式组件" class="headerlink" title="分布式组件"></a>分布式组件</h3><ul>
<li><strong>场景</strong>：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</li>
<li><strong>特征</strong>：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></li>
<li><strong>描述</strong>：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200711267.png"></p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ul>
<li><strong>场景</strong>：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</li>
<li><strong>特征</strong>：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></li>
<li>描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200711681.png"></p>
<h2 id="分布式指标"><a href="#分布式指标" class="headerlink" title="分布式指标"></a>分布式指标</h2><p><strong>分布式系统的目标是提升系统的整体性能和吞吐量，另外还要尽量保证分布式系统的容错性</strong>。</p>
<p>由分布式系统的目标很容易得出分布式系统的关键指标：性能、可用性、可扩展性。这些指标，正对应着耳熟能详的分布式系统“三高”特性——高并发、高性能、高可用。</p>
<h3 id="性能（Performance）"><a href="#性能（Performance）" class="headerlink" title="性能（Performance）"></a>性能（Performance）</h3><p>性能用于衡量一个系统处理各种任务的能力。</p>
<p>常见的性能指标有：</p>
<ul>
<li><strong>吞吐量（Throughput）</strong> - 系统在一定时间内可以处理的任务数。常见的吞吐量指标有：<ul>
<li><strong>QPS</strong> - Queries Per Second 的缩写，即每秒查询数。</li>
<li><strong>TPS</strong> - Transactions Per Second 的缩写，即每秒事务数。</li>
</ul>
</li>
<li><strong>响应时间（Response Time）</strong> - 执行一个请求从开始到最后收到响应数据所花费的总体时间，即从客户端发起请求到收到服务器响应结果的时间。</li>
<li><strong>并发数（Concurrency）</strong> - 并发数是指系统能同时处理请求的数量，这个也反映了系统的负载能力。并发意味着可以同时进行多个处理。并发在现代编程中无处不在，网络中有多台计算机同时存在，一台计算机上同时运行着多个应用程序。</li>
</ul>
<p>以上三个指标的关系大致为：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPS（TPS）<span class="operator">=</span> 并发数 / 平均响应时间</span><br><span class="line">并发数 <span class="operator">=</span> QPS（TPS） * 平均响应时间</span><br></pre></td></tr></table></figure>

<h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3><p><strong>可用性</strong>：指的是系统在面对各种异常时可以正确提供服务的能力。</p>
<p>系统的可用性可以用<strong>系统停止服务的时间与总的时间之比衡量。</strong></p>
<p>行业内一般用几个 9 表示可用性指标，对应用的可用性程度一般衡量标准有三个 9 到五个 9；一般我们的系统至少要到 4 个 9（99.99%）的可用性才能谈得上高可用。</p>
<table>
<thead>
<tr>
<th align="center">可用性</th>
<th align="center">年故障时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">99.9999%</td>
<td align="center">32 秒</td>
</tr>
<tr>
<td align="center">99.999%</td>
<td align="center">5 分 15 秒</td>
</tr>
<tr>
<td align="center">99.99%</td>
<td align="center">52 分 34 秒</td>
</tr>
<tr>
<td align="center">99.9%</td>
<td align="center">8 小时 46 分</td>
</tr>
<tr>
<td align="center">99%</td>
<td align="center">3 天 15 小时 36 分</td>
</tr>
</tbody></table>
<p>而所谓的高可用，就是：<strong>在任何情况下，让服务尽最大可能对外提供服务</strong>。</p>
<h3 id="可扩展性（Scalability）"><a href="#可扩展性（Scalability）" class="headerlink" title="可扩展性（Scalability）"></a>可扩展性（Scalability）</h3><p><strong>可扩展性（Scalability）</strong>指的是分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。</p>
<p>系统扩展可以分为垂直扩展、水平扩展。</p>
<ul>
<li><strong>垂直扩展</strong>，即<strong>提升单机的硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。通俗来说，就三个字：<strong>得加钱</strong>！</li>
<li><strong>水平扩展</strong>：采用分而治之的思想，通过集群来分担吞吐量。集群中的应用机器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：<ul>
<li><strong>集群化、分区化</strong>：将一个完整的应用化整为零，如果是无状态应用，可以直接集群化部署；如果是有状态应用，可以将状态数据分区（分片），然后部署到多台机器上。</li>
<li><strong>负载均衡</strong>：集群化、分区化后，要解决的问题是，请求应该被分发（寻址）到哪台机器上。这就需要通过某种策略来控制分发，这种技术就是负载均衡。</li>
</ul>
</li>
</ul>
<h2 id="分布式系统分类"><a href="#分布式系统分类" class="headerlink" title="分布式系统分类"></a>分布式系统分类</h2><p>分布式技术错综复杂、知识庞杂，且各种技术相互耦合，所以不容易划分层次。</p>
<p>从应用的维度来看，大致可以将分布式系统分为以下四类：</p>
<ul>
<li><strong>分布式计算</strong>：解决应用的分布式计算问题。基于分布式计算模式，包括批处理计算、离线计算、在线计算、融合计算等，根据应用类型构建高效智能的分布式计算框架。</li>
<li><strong>分布式存储</strong>：解决数据的分布式和多元化问题。包括分布式数据库、分布式文件系统、分布式缓存等，支持不同类型的数据的存储和管理。</li>
<li><strong>分布式通信</strong>：解决进程间的分布式通信问题。通过消息队列、远程调用等方式，实现简单高效的通信。</li>
<li><strong>分布式资源管理</strong>：解决资源的分布式和异构性问题。将 CPU、内存、IO 等物理资源虚拟化，新城逻辑资源池，以便统一管理。</li>
</ul>
<p>此外，分布式系统都需要面对一些共性问题，可以视为分布式系统技术的基石：</p>
<ul>
<li><strong>分布式协同</strong> - 解决分布式状态及数据一致性的问题。代表技术：分布式互斥、分布式共识、分布式选举、分布式选举等。</li>
<li><strong>分布式调度</strong> - 解决分布式系统资源、请求分配调度的问题。代表技术：服务注册和发现、服务路由、负载均衡、流量控制等。</li>
<li><strong>分布式容错</strong> - 解决分布式系统中故障分析、处理的问题，保证系统整体可靠性。代表技术：链路追踪、故障隔离、故障转移等。</li>
<li><strong>分布式部署</strong> - 解决分布式系统部署问题。代表技术：CI&#x2F;CD、容器化等。</li>
</ul>
<h2 id="分布式系统的挑战"><a href="#分布式系统的挑战" class="headerlink" title="分布式系统的挑战"></a>分布式系统的挑战</h2><p>当程序运行在单机上时，通常会以一种可预测的方式运行：要么正常，要么异常。</p>
<p>一旦程序运行在多台机器上时，面临的场景就会变得复杂而难以预料。在分布式系统中，系统的某些部分可能会出现不可预知的故障，这被称为<strong>部分失效（partial failure）</strong>。问题的难点就在于部分失效是<strong>不确定性的</strong>。你甚至不确定请求是否成功了，因为消息通过网络传播的时间也是不确定的！这种不确定性和部分失效的可能性，使得分布式系统难以工作。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20171107014323/http://blog.fogcreek.com/eight-fallacies-of-distributed-computing-tech-talk/"><strong>The Eight Fallacies of Distributed Computing - Tech Talk</strong></a> 一文中提出了分布式系统新手常有的 8 种误区。</p>
</blockquote>
<p>为什么我们要深刻地认识这 8 个错误？这是因为，我们需要清楚地认识到——<strong>在分布式系统中，故障是不可避免的</strong>。因此，如果要构建一个可靠的分布式系统，就必须要建立容错机制。很可能大部分组件在大部分时间都正常工作。然而，迟早会有一部分系统出现故障，软件必须以某种方式处理。故障处理必须是软件设计的一部分，并且作为软件的运维，你需要知道在发生故障的情况下，软件可能会表现出怎样的行为。</p>
<h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p>互联网以及大多数数据中心的内部网络（通常是以太网）都是异步网络。当通过网络发送数据包时，数据包可能会丢失或者延迟；同样，回复也可能会丢失或延迟。所以如果没有收到回复，并不能确定消息是否发送成功。传输的过程中，可能有各种各样的问题：</p>
<ol>
<li>请求可能已经丢失（可能是被拔掉了网线）。</li>
<li>请求可能正在某个队列中等待，无法马上发送（可能是网络或接收方已经超负荷）。</li>
<li>远程接收节点可能已经失效（可能是崩愤或关机）。</li>
<li>远程节点可能暂时无法响应（例如正在运行长时间的垃圾回收）。</li>
<li>远程接收节点已经完成了请求处理，但回复却在网络中丢失（例如网络交换机配置错误）。</li>
<li>远程接收节点已经完成了请求处理，但回复却被延迟处理（例如网络或者发送者的机器过载）。</li>
</ol>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig8-1.png" alt="如果发送请求并没有得到响应，则无法区分（a）请求是否丢失，（b）远程节点是否关闭，或（c）响应是否丢失"></p>
<p>在大多数情况下，系统并没有准确判断节点是否发生故障的机制。因此，分布式系统中，一般通过<strong>超时检测</strong>来判断远程节点是否可用。但是，超时无法区分网络和节点故障，且可变的网络延迟有时会导致节点被误认为发生崩溃。</p>
<p>超时检测的一个关键点是超时大小的设置：</p>
<ul>
<li><p>超时时间如果设置过大，意味着等待时间更久，才能判定节点失效（在此期间，用户只能等待或拿到错误信息）。</p>
</li>
<li><p>超时时间如果设置过小，虽然可以更快检测故障，但增加了误判的可能——节点可能实际上是活着的。当一个节点被宣告为失效，其承担的职责要交给到其他节点，这个过程会给其他节点以及网络带来额外负担，特别是如果此时系统已经处于高负荷状态。</p>
</li>
</ul>
<p>对此，可以先设置一个经验值，然后通过实验逐步调整：先在多台机器上，多次测量往返时间，以确定延迟的大概范围；然后结合应用特点，在故障检测与过早超时风险之间选择一个合适的中间值。更好的做法是：持续测量响应时间及其变化（抖动），然后根据最新的响应时间分布来动态调整。</p>
<h2 id="不可靠的时钟"><a href="#不可靠的时钟" class="headerlink" title="不可靠的时钟"></a>不可靠的时钟</h2><p>时钟和计时非常重要。有许多应用程序以各种方式依赖于时钟，例如：</p>
<ol>
<li>某个请求是否超时了？</li>
<li>某项服务的 99 %的响应时间是多少？</li>
<li>在过去的五分钟内，服务平均每秒处理多少个查询？</li>
<li>用户在我们的网站上浏览花了多段时间？</li>
<li>这篇文章什么时候发表？</li>
<li>在什么时间发送提醒邮件？</li>
<li>这个缓存条目何时过期？</li>
<li>日志文件中错误消息的时间戳是多少？</li>
</ol>
<p>在分布式系统中，时间总是件棘手的问题，由于跨节点通信不可能即时完成，消息经由网络从一台机器到另一台机器总是需要花费时间。收到消息的时间应该晚于发送的时间，但是由于网络的不确定延迟，精确测量面临着很多挑战。这些情况使得多节点通信时很难确定事情发生的先后顺序。</p>
<p>为了保证每台机器的时间同步，最常用的机制是 <strong>网络时间协议（Network Time Protocol, NTP）</strong>，它可以根据一组专门的时间服务器来调整本地时间。需要注意的是，即使使用了 NTP 进行时间同步，但是依然会存在一些误差：一方面受限于 NTP 本身的同步精度，此外还受限于网络通信的延迟。</p>
<p>如果想要保证时序，另一种方案是采用逻辑时钟。<strong>逻辑时钟（logic clock）</strong>是基于递增计数器，对于排序事件来说是更安全的选择。逻辑时钟仅测量事件的相对顺序（无论一个事件发生在另一个事件之前还是之后）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a> - 这可能是目前最好的分布式存储书籍，强力推荐【进阶】</li>
<li><a target="_blank" rel="noopener" href="https://web.archive.org/web/20171107014323/http://blog.fogcreek.com/eight-fallacies-of-distributed-computing-tech-talk/">The Eight Fallacies of Distributed Computing - Tech Talk</a> - 分布式系统新手常犯的 8 个错误，并探讨了其会带来的影响。</li>
<li><a target="_blank" rel="noopener" href="http://book.mixu.net/distsys/">Distributed Systems for Fun and Profit</a> - 一本学习小册，涵盖了分布式系统中的关键问题，包括时间的作用和不同的复制策略。</li>
<li><a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.7628&rep=rep1&type=pdf">A Note on Distributed Systems</a> - 这是一篇经典的论文，讲述了为什么在分布式系统中，远程交互不能像本地对象那样进行。</li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a>，<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163428"><strong>译文</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56146800"><strong>解读</strong></a> - Lamport 介绍 happened before、偏序关系（partial ordering）、逻辑时钟（Logical Clocks）概念，提出解决分布式系统中区分事件发生的时序问题的方法。</li>
<li><a target="_blank" rel="noopener" href="http://courses.csail.mit.edu/6.852/01/papers/VirtTime_GlobState.pdf"><strong>Virtual Time and Global States of Distributed Systems</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56886156"><strong>解读</strong></a> - 逻辑时钟无法描述事件的因果关系。本文提出了向量时钟，这种算法利用了向量这种数据结构将全局各个进程的逻辑时间戳广播给各个进程，通过向量时间戳就能够比较任意两个事件的因果关系。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3b069c65/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3b069c65/" class="post-title-link" itemprop="url">拜占庭将军问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h1><blockquote>
<p>拜占庭将军问题是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E6%B3%A2%E7%89%B9">莱斯利·兰波特</a>在其同名论文中提出的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C">分布式对等网络</a>通信容错问题。其实是借拜占庭将军的例子，抛出了分布式共识性问题，并探讨和论证了解决的方法。</p>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%A8%88%E7%AE%97">分布式计算</a>中，不同的节点通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的节点可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一群拜占庭将军各领一支军队共同围困一座城市。</p>
<p>为了简化问题，军队的行动策略只有两种：<strong>进攻</strong>（Attack，后面简称 A）或 <strong>撤退</strong>（Retreat，后面简称 R）。如果这些军队不是统一进攻或撤退，就可能因兵力不足导致失败。因此，<strong>将军们通过投票来达成一致策略：同进或同退</strong>。</p>
<p>因为将军们分别在城市的不同方位，所以他们只能<strong>通过信使互相联系</strong>。在投票过程中，<strong>每位将军都将自己的投票信息（A 或 R）通知其他所有将军</strong>，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以分析出共同的投票结果而决定行动策略。</p>
<p>这个抽象模型的问题在于：<strong>将军中可能存在叛徒，他们不仅会发出误导性投票，还可能选择性地发送投票信息</strong>。</p>
<p>由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。</p>
<p>假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p>
<p>上述的故事可以映射到分布式系统中，_将军代表分布式系统中的节点；信使代表通信系统；叛徒代表故障或异常_。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210704104211.png"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote>
<p>兰伯特针对拜占庭将军问题，给出了两个解决方案：口头协议和书面协议。</p>
<p>本文介绍一下口头协议。</p>
</blockquote>
<p>在口头协议中，拜占庭将军问题被简化为<strong>将军 - 副官</strong>模型，其核心规则如下：</p>
<ul>
<li>忠诚的副官遵守同一命令。</li>
<li>若将军是忠诚的，所有忠诚的副官都执行他的命令。</li>
<li><strong>如果叛徒人数为 m，将军人数不能少于 3m + 1</strong> ，那么拜占庭将军问题就能解决了。——关于这个公式，可以不必深究，如果对推导过程感兴趣，可以参考论文。</li>
</ul>
<p><strong>示例一、叛徒人数为 1，将军人数为 3</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200748580.png"></p>
<p>这个示例中，将军人数不满足 3m + 1，无法保证忠诚的副官都执行将军的命令。</p>
<p><strong>示例二、叛徒人数为 1，将军人数为 4</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310200748488.png"></p>
<p>这个示例中，将军人数满足 3m + 1，无论是副官中有叛徒，还是将军是叛徒，都能保证忠诚的副官执行将军的命令。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">Wiki - 拜占庭将军问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av78588312/">拜占庭将军问题视频讲解</a> - 李永乐老师讲解的通俗易懂</li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/5f2fa796/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/5f2fa796/" class="post-title-link" itemprop="url">如何设计系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何设计系统"><a href="#如何设计系统" class="headerlink" title="如何设计系统"></a>如何设计系统</h1><h2 id="系统设计过程"><a href="#系统设计过程" class="headerlink" title="系统设计过程"></a>系统设计过程</h2><h3 id="步骤一、约束和用例"><a href="#步骤一、约束和用例" class="headerlink" title="步骤一、约束和用例"></a>步骤一、约束和用例</h3><p>对于任何系统设计，第一件应该做的事是：阐明系统的约束并确定系统需要满足哪些用例。</p>
<p>永远不要假设没有明确说明的事情。一定要尽力收集、理解需求，并设计一个很好地涵盖这些要求的解决方案。</p>
<p>例如，URL 缩短服务可能只为几千个用户提供服务，但每个用户都可能共享数百万个 URL。它可能旨在处理对缩短的 URL 的数百万次点击或数十次点击。该服务可能必须提供有关每个缩短的 URL 的大量统计信息（这会增加您的数据大小），或者可能根本不需要统计信息。</p>
<p>您还必须考虑预期会发生的用例。您的系统将根据其预期功能进行设计。不要忘记确保你知道面试官一开始没有告诉你的所有要求。</p>
<h3 id="步骤二、顶层设计"><a href="#步骤二、顶层设计" class="headerlink" title="步骤二、顶层设计"></a>步骤二、顶层设计</h3><p>一旦确定了要设计的系统的范围，接下来就要做顶层设计：概述系统架构中所需的所有重要组件。</p>
<p>此时，应该绘制出主要组件以及它们之间的连接。通常，这种顶层设计是基于主流技术的组合。这就要求设计必须熟悉这些技术，了解其利弊以及适合使用的场景。</p>
<h3 id="步骤三、分析瓶颈"><a href="#步骤三、分析瓶颈" class="headerlink" title="步骤三、分析瓶颈"></a>步骤三、分析瓶颈</h3><p>顶层设计很可能会遇到一个或多个瓶颈。这完全没问题，不要指望一个新系统可以立即处理世界上的所有负载。它只需要可扩展，以便您能够使用一些标准工具和技术对其进行改进。</p>
<p>现在有了顶层设计，就要考虑这些组件在系统扩展时面临的瓶颈。也许，系统需要一个负载均衡器和集群来处理用户请求。或者，由于数据容量庞大，以至于需要将数据库分库分表（分布在多台机器上）。这些方案有什么利弊，是否适用？数据库是否太慢，是否需要一些内存缓存？</p>
<p>通常每个解决方案都是某种权衡和取舍。改变某事会使其他事情恶化。然而，重要的是能够讨论这些权衡，并根据定义的约束和用例来衡量它们对系统的影响。</p>
<p>一旦分析清楚核心瓶颈，就可以着手在下一步中去解决它们。</p>
<h3 id="步骤四、扩展设计"><a href="#步骤四、扩展设计" class="headerlink" title="步骤四、扩展设计"></a>步骤四、扩展设计</h3><p>首先，你需要了解以下技术手段：</p>
<ul>
<li>垂直扩展</li>
<li>水平罗占</li>
<li>缓存</li>
<li>负载均衡</li>
<li>数据库复制</li>
<li>数据库分区</li>
<li>异步</li>
<li>NoSql</li>
</ul>
<p>在系统设计方面，回顾现实中的架构非常有用。注意使用了哪些技术。继续研究每一项新技术，看看它解决了什么问题，它的替代品是什么，它擅长的地方，以及失败的地方。</p>
<p>一切都是权衡的结果——这是系统设计中最基本的概念之一。</p>
<p>一些推荐的学习资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2017/10/23/one-model-at-a-time-integrating-and-running-deep-learning-mo.html">生产中的深度学习</a>：关于 EyeEm 如何构建在大量图像上运行多个深度学习模型的生产系统的精彩故事</li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html">Uber</a>：一篇关于 Uber 如何快速扩展的好文章，关于将您的服务分解为分布在许多存储库中的许多微服务。</li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html">Facebook</a>：Facebook 如何在直播中同时处理 800,000 名观众</li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html">Kraken.io</a>：如何大规模缩放图像优化，本文将更详细地看一些具体使用的硬件方案，以及部署、监控等重要方面</li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html">Twitter</a>：Twitter 如何处理每秒 3,000 张图片上传以及为什么它使用的旧方式现在行不通</li>
<li>最后，Twitter 子组件的一些很好的例子：存储数据（<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=5cKTP36HVgI">video</a> | <a target="_blank" rel="noopener" href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html">text</a>）和时间轴（<a target="_blank" rel="noopener" href="http://www.infoq.com/presentations/Twitter-Timeline-Scalability">video</a> | <a target="_blank" rel="noopener" href="http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html">text</a>）。</li>
<li>有关更高级的示例，请查看 Google、Youtube（<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=w5WVu624fY8">video</a> | <a target="_blank" rel="noopener" href="http://highscalability.com/youtube-architecture">text</a>）、<a target="_blank" rel="noopener" href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html">Tumblr</a>、<a target="_blank" rel="noopener" href="http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html">StackOverflow</a> 和 <a target="_blank" rel="noopener" href="http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html">Datashift</a> 上的这些帖子。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer">system-design-primer</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hiredintech.com/courses/system-design">System Design for Tech Interviews</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3298ba00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3298ba00/" class="post-title-link" itemprop="url">权限认证综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="权限认证综述"><a href="#权限认证综述" class="headerlink" title="权限认证综述"></a>权限认证综述</h1><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是指根据声明者所特有的识别信息，确认声明者的身份。认证在英文中对应于 identification 这个单词。</p>
<p>最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术：</p>
<ul>
<li>身份证</li>
<li>用户名和密码认证</li>
<li>用户手机认证：手机短信、手机二维码扫描、手势密码</li>
<li>用户邮箱认证</li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6238">基于时间序列和用户相关的一次性口令</a></li>
<li>用户的生物学特征认证：指纹、语音、眼睛虹膜</li>
<li>用户的大数据识别认证</li>
<li>等等</li>
</ul>
<p>为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>简单来说，授权一般是指获取用户的委派权限。在英文中对应于 authorization 这个单词。</p>
<p>在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念，</p>
<ul>
<li><strong>资源所有者</strong>：拥有资源的所有权利，一般就是资源的拥有者。</li>
<li><strong>资源执行者</strong>：被委派去执行资源的相关操作。</li>
<li><strong>操作权限</strong>：可以对资源进行的某种操作。</li>
<li><strong>资源</strong>：有价值的信息或数据等，受到安全保护。</li>
</ul>
<p>需要说明的是，资源所有者和执行者可以是自然人，就是普通用户，但不限于自然人。在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器。比如用户在浏览器上登录一个网站，那么这个浏览器就成为一个执行者，它在用户登录后获取了用户的授权，代表着用户执行各种指令，进行购物、下单、付钱、转账等等操作。</p>
<p>同时，资源所有者和执行者可以是分开的不同实体，也可以是同一个。若是分开的两者，则资源执行者是以资源所有者的代理形式而存在。</p>
<p>授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。</p>
<p>在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，</p>
<ul>
<li>通过 web 服务器的 session 机制，一个访问会话保持着用户的授权信息</li>
<li>通过 web 浏览器的 cookie 机制，一个网站的 cookie 保持着用户的授权信息</li>
<li>颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息</li>
</ul>
<p>前面两者常见于 web 开发，需要有浏览器的支持。</p>
<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p>鉴权是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在英文中对应于 authentication 这个单词。</p>
<p>鉴权主要是对声明者所声明的真实性进行校验。若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。</p>
<p>因此，鉴权的实现方式是和授权方式有一一对应关系。对授权所颁发授信媒介进行解析，确认其真实性。下面是鉴权的一些实现方式，</p>
<ul>
<li>门禁卡：通过门禁卡识别器</li>
<li>钥匙：通过相匹配的锁</li>
<li>银行卡：通过银行卡识别器</li>
<li>互联网 web 开发领域的 session&#x2F;cookie&#x2F;token：校验 session&#x2F;cookie&#x2F;token 的合法性和有效性</li>
</ul>
<p>鉴权是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。</p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。权限控制在英文中对应于 access&#x2F;permission control。</p>
<p>对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。</p>
<p>先看权限（Permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。</p>
<p>若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为，</p>
<ul>
<li>这是一个门禁卡，拥有开公司所有的门的权限</li>
<li>这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门</li>
</ul>
<p>可以看到，权限作为一个抽象的概念，将执行者和可具体执行的操作相分离。</p>
<p>在上文的讨论中，鉴权的输出是权限（Permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。</p>
<p>对于控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行。现实生活中控制的实现方式，多种多样，</p>
<ul>
<li>门禁：控制门的开关</li>
<li>自行车锁：控制车轮</li>
<li>互联网 web 后端服务：控制接口访问，允许或拒绝访问请求</li>
</ul>
<h2 id="认证和鉴权"><a href="#认证和鉴权" class="headerlink" title="认证和鉴权"></a>认证和鉴权</h2><p>认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系，</p>
<p>认证–&gt;授权–&gt;鉴权–&gt;权限控制</p>
<p>需要说明的是，这四个环节在有些时候会同时发生。 例如在下面的几个场景，</p>
<ul>
<li>使用门禁卡开门：认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生</li>
<li>用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。</li>
</ul>
<p>无论怎样，若从时间顺序方面来看，这四个环节是按时间前后、依次相继发生的关系。</p>
<p>认证和鉴权的关系：</p>
<p>这两个概念在很多时候是被混淆最多的概念。被混淆的主要原因，如上文所述，很多时候认证、授权、鉴权和权限控制一同发生，以至于被误解为，认证就是鉴权，鉴权就是认证。</p>
<p>其实两者是不一样的概念，两者都有对身份的确认过程，但是两者的主要区别在于，</p>
<ul>
<li>认证是确认声明者的本身身份，其作为授权的上游衔接而存在</li>
<li>鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c0063bdf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c0063bdf/" class="post-title-link" itemprop="url">Cinchcast 的架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Cinchcast-的架构"><a href="#Cinchcast-的架构" class="headerlink" title="Cinchcast 的架构"></a>Cinchcast 的架构</h1><p>Cinchcast 提供的解决方案允许公司创建、共享、衡量和货币化音频内容，以接触和吸引对其业务最重要的人。我们的技术将会议桥接器与实时音频流相结合，以简化在线活动并增强参与者的参与度。 Cinchcast 技术还用于为全球最大的音频社交网络 Blogtalkradio 提供动力。今天，我们的平台每天制作和分发超过 1,500 小时的原创内容。在本文中，我们描述了我们为扩展平台以支持这种规模的数据而做出的工程决策。</p>
<h2 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h2><ul>
<li>浏览量每月超过 5000 万</li>
<li>创建了 50000 小时的音频内容</li>
<li>1500 万个流媒体</li>
<li>175,000,000 次广告展示</li>
<li>峰值每秒 40000 并发请求</li>
<li>MSSQL、Redis、ElasticSearch 集群中存储的数据达到每天数 TB，</li>
<li>10 人工程师团队</li>
<li>生产环境大概有 100 左右的硬件节点</li>
</ul>
<h2 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h2><p>线上网站部署在布鲁克林的数据中心。但 QA 和 Staging 环境则使用了 Amazon EC2 云实例。</p>
<p>——考虑到数据安全，大部分公司不愿意把真实数据部署在云端。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li>大概有 50 台 Web 服务器</li>
<li>15 台 MS SQL 数据库服务器</li>
<li>2 台 Redis 的 NoSQL 的键值服务器</li>
<li>2 台 NodeJS 服务器</li>
<li>2 台 弹性搜索集群服务器</li>
</ul>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul>
<li>NET 4 C#：ASP.NET 和 MVC3</li>
<li>IDE 用的是 Visual Studio 2010 Team Suite</li>
<li>用 StyleCop、ReSharper 来强化代码标准</li>
<li>使用敏捷。其中大的功能用 Scrum，小任务则通过看板任务墙管理</li>
<li>测试和持续集成使用 Jenkins + Nunit</li>
<li>自动化测试则是 Selenium 和 Sauce On Demand</li>
</ul>
<h2 id="软件和使用的技术"><a href="#软件和使用的技术" class="headerlink" title="软件和使用的技术"></a>软件和使用的技术</h2><ul>
<li>Windows Server 2008 R2 的 64 位操作系统</li>
<li>基于微软 Windows Server 2008 Web 服务器下运行的 SQL Server 2005</li>
<li>负载均衡是 EQL(Equalizer load balancers)</li>
<li>Redis 作为分布式缓存层和消息分发队列</li>
<li>NodeJS 用来进行实时分析和更新仪表盘</li>
<li>搜索用得是 ElasticSearch，日志分析是通过 Sawmill+自定义分析器脚本</li>
</ul>
<h2 id="监测"><a href="#监测" class="headerlink" title="监测"></a>监测</h2><ul>
<li>NewRelic：性能监控</li>
<li>性能对 KPI（转换率，页面浏览量）的影响：Chartbeat：</li>
<li>Gomez，WhatsupGold，Nagios 等用来各种预警和报警</li>
<li>SQL Server monitoring 的监控：来自 Red Gate 的 SQL Monitor</li>
</ul>
<h2 id="我们的原则"><a href="#我们的原则" class="headerlink" title="我们的原则"></a>我们的原则</h2><ul>
<li>尊重他人的时间。不要带着问题来，要拿出解决办法。</li>
<li>不要去追逐当下的热点技术，先实现基本功能，然后再做锦上添花的。务实是最重要的。</li>
<li>成为一个“如何做”的团队而不是总是说“不”的团队</li>
<li>预先处理总比亡羊补牢要好，把安全植入到软件开发生命周期中，通过培训开发人员如何写出安全的软件并把它从一开始就作为业务优先考虑之处。</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>所有 Javascript、CSS 和图像都缓存在 CDN 级别。 DNS 指向一个 CDN，它将请求传递给源服务器。我们使用 Cotendo 是因为它允许在 CDN 上做出 L7 路由决策。</li>
<li>单独的 Web 服务器集群用于为普通用户和广告用户的请求提供服务，通过 cookie 进行区分。</li>
<li>我们正在转向面向服务的架构，其中系统的关键部分，例如搜索、身份验证、缓存，都是以各种语言实现的 RESTFUL 服务。这些服务还提供了一个缓存层。</li>
<li>REDIS NOSQL 键值存储（redis.io）用作数据库调用之前的缓存层。</li>
<li>Scaleout 用于在网络服务器集群中维护会话状态。但是，我们正在考虑切换到 REDIS。</li>
</ul>
<h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ul>
<li>SQL Server 数据库中的文本搜索不好用，经常出现 CPU 阻塞，所以 Cinchcast 切换到 ElasticSearch，一个 Lucene 的衍生工具。</li>
<li>微软内置的会话模块容易出现死锁，他们用 AngiesList 会话模块取代了它，并把数据存储到 Redis。</li>
<li>日志是发现问题的关键。</li>
<li>重新发明轮子，有时候也可以是一件好事。例如，在一个供应商的提供的 JS &#x2F; CSS 的产品导致性能问题的时候，他们通过重写显著改善了网站的性能。</li>
<li>并不是所有的数据都是关系型的。</li>
<li>在开发中不使用指标检测就像在风暴中不参考高度表来降落飞机，因此整个开发过程中，一定要通过网站吞吐量，解决错误的时间、代码覆盖率，等指标来衡量你的效率。 总的来说，对于日 PV 百万级的网站来说，Cinchcast 的架构、研发、运维等层面的技术选型和经验值得学习和参考。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html">每天产生 1500 小时的音频</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d3934133/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d3934133/" class="post-title-link" itemprop="url">亚马逊的架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>160</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="亚马逊的架构"><a href="#亚马逊的架构" class="headerlink" title="亚马逊的架构"></a>亚马逊的架构</h1><h2 id="摘录的要点"><a href="#摘录的要点" class="headerlink" title="摘录的要点"></a>摘录的要点</h2><p>可扩展：添加资源，性能成正比提升</p>
<p>分布式、去中心化</p>
<p>隔离性：面向服务，聚合数以百计的服务，对外统一提供服务</p>
<p>同时支持 REST 和 SOAP</p>
<p>团队在精不在多，节省沟通成本</p>
<p>状态管理是大规模系统的核心问题，如分布式 Session 等</p>
<p>设计应尽量简单，很多问题可以用业务逻辑去解决，而不是通过技术</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/amazon-architecture">Amazon 的架构</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d56f7960/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d56f7960/" class="post-title-link" itemprop="url">短地址服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 08:15:33" itemprop="dateCreated datePublished" datetime="2021-11-08T08:15:33+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计-Pastebin-com-或者-Bit-ly"><a href="#设计-Pastebin-com-或者-Bit-ly" class="headerlink" title="设计 Pastebin.com (或者 Bit.ly)"></a>设计 Pastebin.com (或者 Bit.ly)</h1><blockquote>
<p>本文搬运自 <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/solutions/system_design/pastebin/README-zh-Hans.md">设计 Pastebin.com (或者 Bit.ly)</a></p>
</blockquote>
<p><strong>注意: 为了避免重复，当前文档会直接链接到<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E7%9A%84%E7%B4%A2%E5%BC%95">系统设计主题</a>的相关区域，请参考链接内容以获得综合的讨论点、权衡和替代方案。</strong></p>
<p><strong>设计 Bit.ly</strong> - 是一个类似的问题，区别是 pastebin 需要存储的是 paste 的内容，而不是原始的未短化的 url。</p>
<h2 id="步骤一、需求分析"><a href="#步骤一、需求分析" class="headerlink" title="步骤一、需求分析"></a>步骤一、需求分析</h2><blockquote>
<p>收集这个问题的需求和范畴。<br>问相关问题来明确用例和约束。<br>讨论一些假设。</p>
</blockquote>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><h4 id="问题范围"><a href="#问题范围" class="headerlink" title="问题范围"></a>问题范围</h4><ul>
<li><strong>用户</strong> 输入一段文本，然后得到一个随机生成的链接<ul>
<li>过期设置<ul>
<li>默认的设置是不会过期的</li>
<li>可以选择设置一个过期的时间</li>
</ul>
</li>
</ul>
</li>
<li><strong>用户</strong> 输入一个 paste 的 url 后，可以看到它存储的内容</li>
<li><strong>用户</strong> 是匿名的</li>
<li><strong>Service</strong> 跟踪页面分析<ul>
<li>一个月的访问统计</li>
</ul>
</li>
<li><strong>Service</strong> 删除过期的 pastes</li>
<li><strong>Service</strong> 需要高可用</li>
</ul>
<h4 id="超出范畴的用例"><a href="#超出范畴的用例" class="headerlink" title="超出范畴的用例"></a>超出范畴的用例</h4><ul>
<li><strong>用户</strong> 可以注册一个账户<ul>
<li><strong>用户</strong> 通过验证邮箱</li>
</ul>
</li>
<li><strong>用户</strong> 可以用注册的账户登录<ul>
<li><strong>用户</strong> 可以编辑文档</li>
</ul>
</li>
<li><strong>用户</strong> 可以设置可见性</li>
<li><strong>用户</strong> 可以设置短链接</li>
</ul>
<h3 id="约束和假设"><a href="#约束和假设" class="headerlink" title="约束和假设"></a>约束和假设</h3><h4 id="状态假设"><a href="#状态假设" class="headerlink" title="状态假设"></a>状态假设</h4><ul>
<li>访问流量不是均匀分布的</li>
<li>打开一个短链接应该是很快的</li>
<li>pastes 只能是文本</li>
<li>页面访问分析数据可以不用实时</li>
<li>一千万的用户量</li>
<li>每个月一千万的 paste 写入量</li>
<li>每个月一亿的 paste 读取量</li>
<li>读写比例在 10:1</li>
</ul>
<h4 id="性能估算"><a href="#性能估算" class="headerlink" title="性能估算"></a>性能估算</h4><ul>
<li>每个 paste 的大小<ul>
<li>每一个 paste 1 KB</li>
<li><code>shortlink</code> - 7 bytes</li>
<li><code>expiration_length_in_minutes</code> - 4 bytes</li>
<li><code>created_at</code> - 5 bytes</li>
<li><code>paste_path</code> - 255 bytes</li>
<li>总共 &#x3D; ~1.27 KB</li>
</ul>
</li>
<li>每个月新的 paste 内容在 12.7GB<ul>
<li>(1.27 * 10000000)KB &#x2F; 月的 paste</li>
<li>三年内将近 450GB 的新 paste 内容</li>
<li>三年内 3.6 亿短链接</li>
<li>假设大部分都是新的 paste，而不是需要更新已存在的 paste</li>
</ul>
</li>
<li>平均 4paste&#x2F;s 的写入速度</li>
<li>平均 40paste&#x2F;s 的读取速度</li>
</ul>
<p>简单的转换指南:</p>
<ul>
<li>2.5 百万 req&#x2F;s</li>
<li>1 req&#x2F;s &#x3D; 2.5 百万 req&#x2F;month</li>
<li>40 req&#x2F;s &#x3D; 1 亿 req&#x2F;month</li>
<li>400 req&#x2F;s &#x3D; 10 亿 req&#x2F;month</li>
</ul>
<h2 id="步骤二、顶层设计"><a href="#步骤二、顶层设计" class="headerlink" title="步骤二、顶层设计"></a>步骤二、顶层设计</h2><blockquote>
<p>概述一个包括所有重要的组件的高层次设计</p>
</blockquote>
<p><img src="http://i.imgur.com/BKsBnmG.png" alt="Imgur"></p>
<h2 id="步骤三、核心组件设计"><a href="#步骤三、核心组件设计" class="headerlink" title="步骤三、核心组件设计"></a>步骤三、核心组件设计</h2><blockquote>
<p>深入每一个核心组件的细节</p>
</blockquote>
<h3 id="用例：用户输入一段文本，然后得到一个随机生成的链接"><a href="#用例：用户输入一段文本，然后得到一个随机生成的链接" class="headerlink" title="用例：用户输入一段文本，然后得到一个随机生成的链接"></a>用例：用户输入一段文本，然后得到一个随机生成的链接</h3><p>我们可以用一个 <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Frdbms">关系型数据库</a>作为一个大的哈希表，用来把生成的 url 映射到一个包含 paste 文件的文件服务器和路径上。</p>
<p>为了避免托管一个文件服务器，我们可以用一个托管的<strong>对象存储</strong>，比如 Amazon 的 S3 或者<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8">NoSQL 文档类型存储</a>。</p>
<p>作为一个大的哈希表的关系型数据库的替代方案，我们可以用<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8">NoSQL 键值存储</a>。我们需要讨论<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#sql-%E8%BF%98%E6%98%AF-nosql">选择 SQL 或 NoSQL 之间的权衡</a>。下面的讨论是使用关系型数据库方法。</p>
<ul>
<li><strong>客户端</strong> 发送一个创建 paste 的请求到作为一个<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理</a>启动的 <strong>Web 服务器</strong>。</li>
<li><strong>Web 服务器</strong> 转发请求给 <strong>写接口</strong> 服务器</li>
<li><strong>写接口</strong> 服务器执行如下操作：<ul>
<li>生成一个唯一的 url<ul>
<li>检查这个 url 在 <strong>SQL 数据库</strong> 里面是否是唯一的</li>
<li>如果这个 url 不是唯一的，生成另外一个 url</li>
<li>如果我们支持自定义 url，我们可以使用用户提供的 url（也需要检查是否重复）</li>
</ul>
</li>
<li>把生成的 url 存储到 <strong>SQL 数据库</strong> 的 <code>pastes</code> 表里面</li>
<li>存储 paste 的内容数据到 <strong>对象存储</strong> 里面</li>
<li>返回生成的 url</li>
</ul>
</li>
</ul>
<p><strong>向面试官阐明你需要写多少代码</strong></p>
<p><code>pastes</code> 表可以有如下结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shortlink <span class="type">char</span>(<span class="number">7</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">expiration_length_in_minutes <span class="type">int</span> <span class="keyword">NOT NULL</span></span><br><span class="line">created_at datetime <span class="keyword">NOT NULL</span></span><br><span class="line">paste_path <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">PRIMARY KEY</span>(shortlink)</span><br></pre></td></tr></table></figure>

<p>我们将在 <code>shortlink</code> 字段和 <code>created_at</code> 字段上创建一个<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%B4%A2%E5%BC%95">数据库索引</a>，用来提高查询的速度（避免因为扫描全表导致的长时间查询）并将数据保存在内存中，从内存里面顺序读取 1MB 的数据需要大概 250 微秒，而从 SSD 上读取则需要花费 4 倍的时间，从硬盘上则需要花费 80 倍的时间。<sup><a href=https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#每个程序员都应该知道的延迟数 > 1</a></sup></p>
<p>为了生成唯一的 url，我们可以：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MD5"><strong>MD5</strong></a> 来哈希用户的 IP 地址 + 时间戳<ul>
<li>MD5 是一个普遍用来生成一个 128-bit 长度的哈希值的一种哈希方法</li>
<li>MD5 是一致分布的</li>
<li>或者我们也可以用 MD5 哈希一个随机生成的数据</li>
</ul>
</li>
<li>用 <a target="_blank" rel="noopener" href="https://www.kerstner.at/2012/07/shortening-strings-using-base-62-encoding/"><strong>Base 62</strong></a> 编码 MD5 哈希值<ul>
<li>对于 urls，使用 Base 62 编码 <code>[a-zA-Z0-9]</code> 是比较合适的</li>
<li>对于每一个原始输入只会有一个 hash 结果，Base 62 是确定的（不涉及随机性）</li>
<li>Base 64 是另外一个流行的编码方案，但是对于 urls，会因为额外的 <code>+</code> 和 <code>-</code> 字符串而产生一些问题</li>
<li>以下 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener">Base 62 伪代码</a> 执行的时间复杂度是 O(k)，k 是数字的数量 &#x3D; 7：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base_encode</span>(<span class="params">num, base=<span class="number">62</span></span>):</span><br><span class="line">    digits = []</span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">0</span></span><br><span class="line">      remainder = modulo(num, base)</span><br><span class="line">      digits.push(remainder)</span><br><span class="line">      num = divide(num, base)</span><br><span class="line">    digits = digits.reverse</span><br></pre></td></tr></table></figure>

<ul>
<li>取输出的前 7 个字符，结果会有 62^7 个可能的值，应该足以满足在 3 年内处理 3.6 亿个短链接的约束：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = base_encode(md5(ip_address+timestamp))[:URL_LENGTH]</span><br></pre></td></tr></table></figure>

<p>我们将会用一个公开的 <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest"><strong>REST 风格接口</strong></a>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X POST --data <span class="string">&#x27;&#123;&quot;expiration_length_in_minutes&quot;:&quot;60&quot;, \&quot;paste_contents&quot;:&quot;Hello World!&quot;&#125;&#x27;</span> https://pastebin.com/api/v1/paste</span></span><br></pre></td></tr></table></figure>

<p>Response:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;shortlink&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foobar&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用于内部通信，我们可以用 <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AErpc">RPC</a>。</p>
<h3 id="用例：用户输入一个-paste-的-url-后可以看到它存储的内容"><a href="#用例：用户输入一个-paste-的-url-后可以看到它存储的内容" class="headerlink" title="用例：用户输入一个 paste 的 url 后可以看到它存储的内容"></a>用例：用户输入一个 paste 的 url 后可以看到它存储的内容</h3><ul>
<li><strong>客户端</strong> 发送一个获取 paste 请求到 <strong>Web Server</strong></li>
<li><strong>Web Server</strong> 转发请求给 <strong>读取接口</strong> 服务器</li>
<li><strong>读取接口</strong> 服务器执行如下操作：<ul>
<li>在 <strong>SQL 数据库</strong> 检查这个生成的 url<ul>
<li>如果这个 url 在 <strong>SQL 数据库</strong> 里面，则从 <strong>对象存储</strong> 获取这个 paste 的内容</li>
<li>否则，返回一个错误页面给用户</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>REST API：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://pastebin.com/api/v1/paste?shortlink=foobar</span><br></pre></td></tr></table></figure>

<p>Response:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;paste_contents&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expiration_length_in_minutes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="用例：-服务跟踪分析页面"><a href="#用例：-服务跟踪分析页面" class="headerlink" title="用例： 服务跟踪分析页面"></a>用例： 服务跟踪分析页面</h3><p>因为实时分析不是必须的，所以我们可以简单的 <strong>MapReduce</strong> <strong>Web Server</strong> 的日志，用来生成点击次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HitCounts</span>(<span class="title class_ inherited__">MRJob</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract_url</span>(<span class="params">self, line</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Extract the generated url from the log line.&quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract_year_month</span>(<span class="params">self, line</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the year and month portions of the timestamp.&quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mapper</span>(<span class="params">self, _, line</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Parse each log line, extract and transform relevant lines.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Emit key value pairs of the form:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (2016-01, url0), 1</span></span><br><span class="line"><span class="string">        (2016-01, url0), 1</span></span><br><span class="line"><span class="string">        (2016-01, url1), 1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        url = <span class="variable language_">self</span>.extract_url(line)</span><br><span class="line">        period = <span class="variable language_">self</span>.extract_year_month(line)</span><br><span class="line">        <span class="keyword">yield</span> (period, url), <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reducer</span>(<span class="params">self, key, values</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Sum values for each key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (2016-01, url0), 2</span></span><br><span class="line"><span class="string">        (2016-01, url1), 1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> key, <span class="built_in">sum</span>(values)</span><br></pre></td></tr></table></figure>

<h3 id="用例：-服务删除过期的-pastes"><a href="#用例：-服务删除过期的-pastes" class="headerlink" title="用例： 服务删除过期的 pastes"></a>用例： 服务删除过期的 pastes</h3><p>为了删除过期的 pastes，我们可以直接搜索 <strong>SQL 数据库</strong> 中所有的过期时间比当前时间更早的记录，<br>所有过期的记录将从这张表里面删除（或者将其标记为过期）。</p>
<h2 id="步骤四、扩展设计"><a href="#步骤四、扩展设计" class="headerlink" title="步骤四、扩展设计"></a>步骤四、扩展设计</h2><blockquote>
<p>给定约束条件，识别和解决瓶颈。</p>
</blockquote>
<p><img src="http://i.imgur.com/4edXG0T.png" alt="Imgur"></p>
<p><strong>重要提示: 不要简单的从最初的设计直接跳到最终的设计</strong></p>
<p>说明您将迭代地执行这样的操作：1)<strong>Benchmark&#x2F;Load 测试</strong>，2)<strong>Profile</strong> 出瓶颈，3)在评估替代方案和权衡时解决瓶颈，4)重复前面，可以参考在 AWS 上设计一个可以支持百万用户的系统这个用来解决如何迭代地扩展初始设计的例子。</p>
<p>重要的是讨论在初始设计中可能遇到的瓶颈，以及如何解决每个瓶颈。比如，在多个 <strong>Web 服务器</strong> 上添加 <strong>负载平衡器</strong> 可以解决哪些问题？ <strong>CDN</strong> 解决哪些问题？<strong>Master-Slave Replicas</strong> 解决哪些问题? 替代方案是什么和怎么对每一个替代方案进行权衡比较？</p>
<p>我们将介绍一些组件来完成设计，并解决可伸缩性问题。内部的负载平衡器并不能减少杂乱。</p>
<p><strong>为了避免重复的讨论</strong>， 参考以下<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E7%9A%84%E7%B4%A2%E5%BC%95">系统设计主题</a>获取主要讨论要点、权衡和替代方案：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">DNS</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccdn">CDN</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">负载均衡器</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95">水平扩展</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理（web 服务器）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Frdbms">关系型数据库管理系统 (RDBMS)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2">SQL write master-slave failover</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主从复制</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%BC%8F">一致性模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A8%A1%E5%BC%8F">可用性模式</a></li>
</ul>
<p><strong>分析存储数据库</strong> 可以用比如 Amazon Redshift 或者 Google BigQuery 这样的数据仓库解决方案。</p>
<p>一个像 Amazon S3 这样的 <strong>对象存储</strong>，可以轻松处理每月 12.7 GB 的新内容约束。</p>
<p>要处理 <em>平均</em> 每秒 40 读请求(峰值更高)，其中热点内容的流量应该由 <strong>内存缓存</strong> 处理，而不是数据库。<strong>内存缓存</strong> 对于处理分布不均匀的流量和流量峰值也很有用。只要副本没有陷入复制写的泥潭，<strong>SQL Read Replicas</strong> 应该能够处理缓存丢失。</p>
<p>对于单个 <strong>SQL Write Master-Slave</strong>，<em>平均</em> 每秒 4paste 写入 (峰值更高) 应该是可以做到的。否则，我们需要使用额外的 SQL 扩展模式:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%81%94%E5%90%88">联合</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%88%86%E7%89%87">分片</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%9D%9E%E8%A7%84%E8%8C%83%E5%8C%96">非规范化</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#SQL%E8%B0%83%E4%BC%98">SQL 调优</a></li>
</ul>
<p>我们还应该考虑将一些数据移动到 <strong>NoSQL 数据库</strong>。</p>
<h2 id="额外的话题"><a href="#额外的话题" class="headerlink" title="额外的话题"></a>额外的话题</h2><blockquote>
<p>是否更深入探讨额外主题，取决于问题的范围和面试剩余的时间。</p>
</blockquote>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8">键值存储</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8">文档存储</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%88%97%E5%9E%8B%E5%AD%98%E5%82%A8">列型存储</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93">图数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#sql-%E8%BF%98%E6%98%AF-nosql">sql 还是 nosql</a></li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>在哪缓存<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98">客户端缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#cdn-%E7%BC%93%E5%AD%98">CDN 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98">Web 服务器缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98">数据库缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98">应用缓存</a></li>
</ul>
</li>
<li>缓存什么<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98">数据库查询级别的缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%AF%B9%E8%B1%A1%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98">对象级别的缓存</a></li>
</ul>
</li>
<li>何时更新缓存<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F">缓存模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%9B%B4%E5%86%99%E6%A8%A1%E5%BC%8F">直写模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%9B%9E%E5%86%99%E6%A8%A1%E5%BC%8F">回写模式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%88%B7%E6%96%B0">刷新</a></li>
</ul>
</li>
</ul>
<h3 id="异步和微服务"><a href="#异步和微服务" class="headerlink" title="异步和微服务"></a>异步和微服务</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">任务队列</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%83%8C%E5%8E%8B">背压</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a></li>
</ul>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul>
<li>讨论权衡:<ul>
<li>跟客户端之间的外部通信 - <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest">HTTP APIs following REST</a></li>
<li>内部通信 - <a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AErpc">RPC</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">服务发现</a></li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>参考<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%AE%89%E5%85%A8">安全</a>。</p>
<h3 id="延迟数字"><a href="#延迟数字" class="headerlink" title="延迟数字"></a>延迟数字</h3><p>见<a target="_blank" rel="noopener" href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%95%B0">每个程序员都应该知道的延迟数</a>。</p>
<h3 id="持续进行"><a href="#持续进行" class="headerlink" title="持续进行"></a>持续进行</h3><ul>
<li>继续对系统进行基准测试和监控，以在瓶颈出现时解决它们</li>
<li>扩展是一个迭代的过程</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6ce53be6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6ce53be6/" class="post-title-link" itemprop="url">《极客时间教程 - 架构实战案例解析》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-26 23:32:00" itemprop="dateCreated datePublished" datetime="2021-08-26T23:32:00+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-架构实战案例解析》笔记"><a href="#《极客时间教程-架构实战案例解析》笔记" class="headerlink" title="《极客时间教程 - 架构实战案例解析》笔记"></a>《极客时间教程 - 架构实战案例解析》笔记</h1><h2 id="架构的本质：如何打造一个有序的系统？"><a href="#架构的本质：如何打造一个有序的系统？" class="headerlink" title="架构的本质：如何打造一个有序的系统？"></a>架构的本质：如何打造一个有序的系统？</h2><p>架构的本质：<strong>通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化</strong>。</p>
<ul>
<li><p>首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。</p>
</li>
<li><p>其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。</p>
<ul>
<li>“分”就是把系统拆分为各个子系统、模块、组件</li>
<li>“合”就是基于业务流程和技术手段，把各个组件有机整合在一起</li>
</ul>
</li>
</ul>
<p><strong>架构的分类</strong></p>
<ul>
<li>业务架构</li>
<li>应用架构</li>
<li>技术架构</li>
</ul>
<p><strong>什么是好架构？</strong></p>
<ul>
<li>一个好的架构设计既要满足业务的可扩展、可复用；</li>
<li>也要满足系统的高可用、高性能和可伸缩，并尽量采用低成本的方式落地。</li>
</ul>
<p><strong>架构师的自我修养</strong></p>
<ul>
<li>优秀的程序员</li>
<li>沟通交流（感性）</li>
<li>权衡取舍（理性）</li>
<li>多领域知识（技术的广度）</li>
<li>技术前瞻性（技术的深度）</li>
<li>看透问题本质（思维的深度）</li>
<li>抽象思维（思维的高度）</li>
</ul>
<h2 id="业务架构：作为开发，你真的了解业务吗？"><a href="#业务架构：作为开发，你真的了解业务吗？" class="headerlink" title="业务架构：作为开发，你真的了解业务吗？"></a>业务架构：作为开发，你真的了解业务吗？</h2><p>从架构角度看，业务架构是源头，然后才是技术架构。</p>
<p><strong>业务架构师和产品经理有什么区别？</strong></p>
<ul>
<li><strong>产品经理定义了系统的外观</strong><ul>
<li>告诉用户，系统长什么样子</li>
<li>告诉开发，要实现什么功能</li>
</ul>
</li>
<li><strong>架构师将业务抽象为结构化的模块体系</strong><ul>
<li>把业务流程拆分，按照业务域的维度来划分系统模块。</li>
<li>并定义这些模块之间的关系，最终形成一个高度结构化的模块体系。</li>
</ul>
</li>
</ul>
<h3 id="架构目标之业务的可扩展"><a href="#架构目标之业务的可扩展" class="headerlink" title="架构目标之业务的可扩展"></a>架构目标之业务的可扩展</h3><p><strong>业务的主题是变化和创新，系统的主题是稳定和可靠</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220630230555.png"></p>
<h3 id="架构目标之业务的可复用"><a href="#架构目标之业务的可复用" class="headerlink" title="架构目标之业务的可复用"></a>架构目标之业务的可复用</h3><p>业务架构设计如何实现业务的可复用呢</p>
<p>首先，<strong>模块的职责定位要非常清晰</strong>。对于模块来说，在定位范围内的职责要全部涵盖到，而不在这个范围的职责全部不要。</p>
<p>其次，<strong>模块的数据模型和接口设计要保证通用</strong>。架构师需要归纳业务场景，通过抽象提炼，形成通用化的设计，以此来满足多个类似场景的需求。</p>
<p>最后，<strong>实现模块的高复用，还需要做好业务的层次划分</strong>。我们知道，越是底层的业务，它就相对更固定。举个例子，同样是订单业务域，对于底层订单的增删改查功能，不同类型的订单都是一样的，但对于上层的订单生命周期管理，外卖订单和堂食订单可能就不一样。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220630231612.png"></p>
<h2 id="可扩展架构：如何打造一个善变的柔性系统？"><a href="#可扩展架构：如何打造一个善变的柔性系统？" class="headerlink" title="可扩展架构：如何打造一个善变的柔性系统？"></a>可扩展架构：如何打造一个善变的柔性系统？</h2><p>系统的构成：模块 + 关系</p>
<p>模块是系统的基本组成部分，它泛指子系统、应用、服务或功能模块。关系指模块之间的依赖关系。</p>
<p>模块的要求：</p>
<ul>
<li>定位明确，概念完整</li>
<li>自成体系，粒度适中</li>
</ul>
<p>依赖关系的要求：</p>
<ul>
<li>最好是单向的</li>
<li>最好是层次化结构</li>
</ul>
<p>模块的业务逻辑尽量围绕自身内部数据进行处理，对外部依赖越小，模块的封装性越好，稳定性也越强，不会随着外部模块的调整而调整。</p>
<p>业务架构扩展性的本质是：通过构建合理的模块体系，有效地控制系统复杂度，最小化业务变化引起的系统调整。</p>
<p>那如何打造一个合理的模块体系呢？具体的架构手段就是按照业务对系统进行拆分和整合：<br>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p>
<p>通过模块通用化，模块的数量减少了，模块的定位更清晰，概念更完整，职责更聚焦。在实<br>践中，当不同业务线对某个功能需求比较类似时，我们经常会使用这个手段。</p>
<p>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p>
<p>一般做业务架构时，我们先考虑垂直拆分，从大方向上，把不同业务给区分清楚，然后再针对具体业务，按照业务处理流程进行水平拆分</p>
<p>业务平台化是模块依赖关系层次化的一个特例，只是它偏向于基础能力，在实践中，当业务<br>线很多，业务规则很复杂时，我们经常把底层业务能力抽取出来，进行平台化处理。</p>
<h2 id="可扩展架构案例（一）：电商平台架构是如何演变的？"><a href="#可扩展架构案例（一）：电商平台架构是如何演变的？" class="headerlink" title="可扩展架构案例（一）：电商平台架构是如何演变的？"></a>可扩展架构案例（一）：电商平台架构是如何演变的？</h2><p>电商平台架构发展的大致过程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701065653.png"></p>
<h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>在单体架构中，只有一个应用，所有代码跑在一个进程，所有的表放在一个 DB 里。</p>
<p>单体应用内部一般采用分层结构，从上到下，一般分为表示层、业务层、数据访问层、DB 层。表示层负责用户体验，业务层负责业务逻辑，数据访问层负责 DB 的数据存取。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701065747.png"></p>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式架构，简单来说就是系统由多个独立的应用组成，它们互相协作，成为一个整体。</p>
<p>分布式架构包括了多个应用，每个应用分别负责不同的业务线，当一个应用需要另一个应用的功能时，会通过 API 接口进行调用。在分布式架构中，API 接口属于应用的一部分，它和表示层共享底层的业务逻辑。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701070033.png"></p>
<p>分布式架构适用于业务相关性低、耦合少的业务系统。</p>
<h3 id="SOA-架构"><a href="#SOA-架构" class="headerlink" title="SOA 架构"></a>SOA 架构</h3><p>SOA 架构（Service Oriented Architecture）是一种面向服务的架构，它的发展经历了两个阶段：传统的 SOA 架构，它解决的是企业内部大量异构系统集成的问题；新的 SOA 架构，它解决的是系统重复建设的问题。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701070410.png"></p>
<p>在 SOA 架构中，每个服务都对应一个现有的系统，所有这些服务都部署在一个中心化的平台上，我们称之为企业服务总线 ESB（Enterprise Service Bus），ESB 负责管理所有调用过程的技术复杂性，包括服务的注册和路由、各种通信协议的支持等等。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务强调围绕业务，进行清晰的业务和数据边界划分，并通过良好定义的接口输出业务能力，这和 SOA 架构里的服务有点类似。但两者不同的地方在于，微服务是去中心化的，不需要 SOA 架构中 ESB 的集中管理方式。</p>
<p>一方面，微服务强调所谓的哑管道，即客户端可以通过 HTTP 等简单的技术手段，访问微服务，避免重的通信协议和数据编码支持。另一方面，微服务强调智能终端，所有的业务逻辑包含在微服务内部，不需要额外的中间层提供业务规则处理。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701070749.png"></p>
<h2 id="可扩展架构案例（二）：App-服务端架构是如何升级的？"><a href="#可扩展架构案例（二）：App-服务端架构是如何升级的？" class="headerlink" title="可扩展架构案例（二）：App 服务端架构是如何升级的？"></a>可扩展架构案例（二）：App 服务端架构是如何升级的？</h2><h3 id="V1-0-架构"><a href="#V1-0-架构" class="headerlink" title="V1.0 架构"></a>V1.0 架构</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701071239.png"></p>
<p>问题：</p>
<ul>
<li>移动服务端对 Jar 包的紧密依赖</li>
<li>移动团队的职责过分复杂</li>
<li>团队并行开发困难</li>
</ul>
<h3 id="V2-0-架构"><a href="#V2-0-架构" class="headerlink" title="V2.0 架构"></a>V2.0 架构</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701071257.png"></p>
<p>问题：</p>
<ul>
<li>移动端和 PC 端互相干扰</li>
<li>重复造轮子</li>
<li>稳定性较差</li>
</ul>
<h3 id="V3-0-架构"><a href="#V3-0-架构" class="headerlink" title="V3.0 架构"></a>V3.0 架构</h3><p>首先，我们对每个业务线的服务端进行拆分，让 App 接口和 PC 端接口各自在物理上独立，但它们共享核心的业务逻辑。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701071719.png"></p>
<h4 id="移动网关的内部实现"><a href="#移动网关的内部实现" class="headerlink" title="移动网关的内部实现"></a>移动网关的内部实现</h4><ul>
<li><strong>通用层</strong><ul>
<li>首先是通用层，它负责所有系统级功能的处理，比如通讯协议适配、安全、监控、日志等等，这些功能统一由网关的通用层进行预处理，避免了各个业务线的重复开发。</li>
<li>在具体实现时，每个通用功能的处理逻辑都会封装成一个拦截器，这些拦截器遵循统一的接口定义，并且拦截器都是可配置的。当有外部请求过来，网关会依次调用这些拦截器，完成各个系统级功能的处理。</li>
</ul>
</li>
<li><strong>接口路由层</strong><ul>
<li>移动端请求经过通用层的预处理之后，将会进一步分发给后端的业务适配器进行处理。</li>
<li>在配置文件里，对接口请求的 URL 和业务适配器进行映射，接口路由层的分发逻辑就是根据请求中的 URL，在配置文件里找到对应的适配器，然后把请求交给适配器进行后续的处理。</li>
</ul>
</li>
<li><strong>服务适配层</strong><ul>
<li>适配器首先用来解决内外部接口的适配，除此之外，适配器还可以根据需要，对多个内部服<br>务做业务聚合，这样可以对 App 前端提供粗粒度的接口服务，减少远程网络的调用次数。</li>
</ul>
</li>
</ul>
<h2 id="可扩展架构案例（三）：你真的需要一个中台吗？"><a href="#可扩展架构案例（三）：你真的需要一个中台吗？" class="headerlink" title="可扩展架构案例（三）：你真的需要一个中台吗？"></a>可扩展架构案例（三）：你真的需要一个中台吗？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701072503.png"></p>
<p>前台：面向 C 端的应用。前台对外</p>
<p>后台：企业内部系统。后台对内</p>
<p>中台：通过实现基础业务的平台化，实现了企业级业务能力的快速复用</p>
<h3 id="中台的适用性"><a href="#中台的适用性" class="headerlink" title="中台的适用性"></a>中台的适用性</h3><p>第一种是独立地建设新业务线，这样，各个业务线并列，系统整体上是一个“川”字型的结构</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701152539.png"></p>
<p>第二种做法是，把各业务线中相同的核心逻辑抽取出来，通过抽象设计，实现通用化，共同服务于所有业务线的需求，系统结构整体上是一个“山”字型。这样，我们就能一处建设，多处复用，一处修改，多处变化，从而实现最大程度的复用。</p>
<p>何时从“川”字型转为“山”字形呢？</p>
<ul>
<li>一方面，这和公司业务线的数量有关，业务线越多，意味着重复建设的成本会更大，当我们开始上第 3 条业务线时，就应该要考虑转到“山”字形了。</li>
<li>另一方面，也和各个业务线的相似度有关，相似度越高，意味着业务线之间有更多类似的逻辑，更适合“山”字形。</li>
</ul>
<p>中台实现了通用基础业务的平台化。从变化速度来看，企业基础的业务是相对固定的，而具体上层业务场景是相对多变的；从数量来看，基础业务数量是有限的，而具体业务场景是无限的。因此，有了完善的中台，我们就可以通过有限而比较固定的基础业务，来满足无限而快速变化的上层业务场景了。</p>
<p>从业务角度来看，中台收敛了业务场景，统一了业务规则；从系统角度看，中台相当于操作系统，对外提供标准接口，屏蔽了底层系统的复杂性；从数据角度看，中台收敛了数据，比如使用同一套订单数据模型，让所有渠道的订单使用相同的订单模型，所有订单数据落到同一个订单库。</p>
<p>中台通过实现基础业务的平台化，实现了企业级业务能力的快速复用。</p>
<p>松散的微服务 -&gt; 共享服务体系 -&gt; 中台</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701153820.png"></p>
<p>传统企业中台架构设计</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701153933.png"></p>
<p>中台代表了企业核心的业务能力，它自成体系，能够为 C 端的互联网场景提供通用的能力，并通过各种插件和后台打通。</p>
<p>对于互联网企业来说，有大量微服务做基础，往中台转是改良，目的是更好地衔接前台和后台，实现业务的快速创新；<br>对于传统企业来说，内部有大量的遗留系统，落地中台是革命，目的是盘活老系统，全面实现企业的数字化转型。</p>
<h2 id="可复用架构：如何实现高层次的复用？"><a href="#可复用架构：如何实现高层次的复用？" class="headerlink" title="可复用架构：如何实现高层次的复用？"></a>可复用架构：如何实现高层次的复用？</h2><p>从复用的程度来看，从高到低，我们可以依次划分为产品复用 &gt; 业务流程复用 &gt; 业务实体复用 &gt; 组件复用 &gt; 代码复用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701154211.png"></p>
<p>技术复用：代码级复用和技术组件复用都属于工具层面，它们的好处是在很多地方都可以用，但和业务场景隔得有点远，不直接对应业务功能，因此复用的价值相对比较低。</p>
<p>业务复用</p>
<ul>
<li>业务实体复用针对细分的业务领域</li>
<li>业务流程的复用针对的是业务场景</li>
<li>最高层次的复用是对整个系统的复用</li>
</ul>
<h2 id="可复用架构案例（一）：如何设计一个基础服务？"><a href="#可复用架构案例（一）：如何设计一个基础服务？" class="headerlink" title="可复用架构案例（一）：如何设计一个基础服务？"></a>可复用架构案例（一）：如何设计一个基础服务？</h2><p>对于落地一个共享服务来说，服务边界的划分和功能的抽象设计是核心。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701160043.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220701160116.png"></p>
<h2 id="可复用架构案例（二）：如何对现有系统做微服务改造？"><a href="#可复用架构案例（二）：如何对现有系统做微服务改造？" class="headerlink" title="可复用架构案例（二）：如何对现有系统做微服务改造？"></a>可复用架构案例（二）：如何对现有系统做微服务改造？</h2><p>圈表：圈表就是用来确定库存微服务具体包含哪些表，也就是确定服务的数据模型。</p>
<p>收集 SQL：收集所有业务系统访问这些表的 SQL 语句，包括它的业务场景说明、访问频率等等。库存微服务后续就针对这些 SQL 进行封装，提供相应的接口给业务系统使用。</p>
<p>拆分 SQL：有些 SQL 不仅仅访问圈定的这几张库存表，还会和产品库中的其他表进行关联。</p>
<h2 id="可复用架构案例（三）：中台是如何炼成的？"><a href="#可复用架构案例（三）：中台是如何炼成的？" class="headerlink" title="可复用架构案例（三）：中台是如何炼成的？"></a>可复用架构案例（三）：中台是如何炼成的？</h2><ol>
<li>业务上有什么重大变化，导致当前系统的弊端已经很明显，不能适应业务发展了呢？</li>
<li>架构改造时，如何在业务、系统、资源三者之间做好平衡，对系统进行分步式的改造呢？</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220702222041.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220702222341.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220702222438.png"></p>
<h2 id="技术架构：作为开发，你真的了解系统吗？"><a href="#技术架构：作为开发，你真的了解系统吗？" class="headerlink" title="技术架构：作为开发，你真的了解系统吗？"></a>技术架构：作为开发，你真的了解系统吗？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703085109.png"></p>
<p>技术架构的职责，首先是负责系统所有组件的技术选型，然后确保这些组件可以正常运行。</p>
<p><strong>业务架构解决的是系统功能性问题</strong>。</p>
<p><strong>技术架构解决的是系统非功能性问题</strong>。</p>
<p>技术架构目标</p>
<ul>
<li>高可用</li>
<li>高性能</li>
<li>伸缩性</li>
<li>安全性</li>
</ul>
<h2 id="高可用架构：如何让你的系统不掉链子？"><a href="#高可用架构：如何让你的系统不掉链子？" class="headerlink" title="高可用架构：如何让你的系统不掉链子？"></a>高可用架构：如何让你的系统不掉链子？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703092202.png"></p>
<p>故障分类</p>
<ul>
<li><strong>资源不可用</strong>，包括网络和服务器出故障，网络出故障表明节点连接不上，服务器出故障表明该节点本身不能正常工作。</li>
<li><strong>资源不足</strong>，常规的流量进来，节点能正常工作，但在高并发的情况下，节点无法正常工作，对外表现为响应超时。</li>
<li><strong>节点的功能有问题</strong>，这个主要体现在我们开发的代码上，比如它的内部业务逻辑有问题，或者是接口不兼容导致客户端调用出了问题；另外有些不够成熟的中间件，有时也会有功能性问题。</li>
</ul>
<p>高可用策略和架构原则</p>
<p>事前，尽量避免问题的发生；始终，要考虑转移故障，降低故障影响，快速恢复系统；事后，要对故障进行复盘，考虑技术、流程上的完善措施。</p>
<h2 id="高可用架构案例（一）：如何实现-O2O-平台日订单-500-万？"><a href="#高可用架构案例（一）：如何实现-O2O-平台日订单-500-万？" class="headerlink" title="高可用架构案例（一）：如何实现 O2O 平台日订单 500 万？"></a>高可用架构案例（一）：如何实现 O2O 平台日订单 500 万？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703092811.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703092957.png"></p>
<h2 id="高可用架构案例（二）：如何第一时间知道系统哪里有问题？"><a href="#高可用架构案例（二）：如何第一时间知道系统哪里有问题？" class="headerlink" title="高可用架构案例（二）：如何第一时间知道系统哪里有问题？"></a>高可用架构案例（二）：如何第一时间知道系统哪里有问题？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703093328.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703093652.png"></p>
<h2 id="高可用架构案例（三）：如何打造一体化的监控系统？"><a href="#高可用架构案例（三）：如何打造一体化的监控系统？" class="headerlink" title="高可用架构案例（三）：如何打造一体化的监控系统？"></a>高可用架构案例（三）：如何打造一体化的监控系统？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703103558.png"></p>
<h2 id="高性能和可伸缩架构：业务增长，能不能加台机器就搞定？"><a href="#高性能和可伸缩架构：业务增长，能不能加台机器就搞定？" class="headerlink" title="高性能和可伸缩架构：业务增长，能不能加台机器就搞定？"></a>高性能和可伸缩架构：业务增长，能不能加台机器就搞定？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703103855.png"></p>
<ul>
<li>加快单个请求处理<ul>
<li>优化处理路径上每个节点的处理速度</li>
<li>并行处理单个请求</li>
</ul>
</li>
<li>同时处理多个请求：负载均衡</li>
<li>请求处理异步化：MQ</li>
</ul>
<p>性能提升思路：</p>
<ul>
<li>可水平拆分和无状态</li>
<li>短事务和柔性事务</li>
<li>缓存</li>
<li>并行计算</li>
<li>异步处理</li>
<li>容器化</li>
</ul>
<h2 id="高性能架构案例：如何设计一个秒杀系统？"><a href="#高性能架构案例：如何设计一个秒杀系统？" class="headerlink" title="高性能架构案例：如何设计一个秒杀系统？"></a>高性能架构案例：如何设计一个秒杀系统？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703105340.png"></p>
<h2 id="可伸缩架构案例：数据太多，如何无限扩展你的数据库？"><a href="#可伸缩架构案例：数据太多，如何无限扩展你的数据库？" class="headerlink" title="可伸缩架构案例：数据太多，如何无限扩展你的数据库？"></a>可伸缩架构案例：数据太多，如何无限扩展你的数据库？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703110828.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703110925.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703111011.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703135733.png"></p>
<h2 id="案例：电商平台技术架构是如何演变的？"><a href="#案例：电商平台技术架构是如何演变的？" class="headerlink" title="案例：电商平台技术架构是如何演变的？"></a>案例：电商平台技术架构是如何演变的？</h2><p>单体架构</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703135849.png"></p>
<p>SOA 架构</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703135906.png"></p>
<p>微服务架构</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703135939.png"></p>
<p>垂直拆分（分库）</p>
<p>水平拆分</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703140033.png"></p>
<p>多机房部署</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703140123.png"></p>
<p>服务调用本地化</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703140249.png"></p>
<p>依赖分级管理</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703140310.png"></p>
<p>多机房独立部署</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703140404.png"></p>
<h2 id="从务实的角度，给你架构设计的重点知识和学习路径"><a href="#从务实的角度，给你架构设计的重点知识和学习路径" class="headerlink" title="从务实的角度，给你架构设计的重点知识和学习路径"></a>从务实的角度，给你架构设计的重点知识和学习路径</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703141209.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220703141328.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046301">架构实战案例解析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/50787f00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/50787f00/" class="post-title-link" itemprop="url">《数据密集型应用系统设计》笔记一——数据系统基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-26 23:32:00" itemprop="dateCreated datePublished" datetime="2021-08-26T23:32:00+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《数据密集型应用系统设计》笔记一——数据系统基础"><a href="#《数据密集型应用系统设计》笔记一——数据系统基础" class="headerlink" title="《数据密集型应用系统设计》笔记一——数据系统基础"></a>《数据密集型应用系统设计》笔记一——数据系统基础</h1><h2 id="第一章：可靠、可扩展与可维护的应用系统"><a href="#第一章：可靠、可扩展与可维护的应用系统" class="headerlink" title="第一章：可靠、可扩展与可维护的应用系统"></a>第一章：可靠、可扩展与可维护的应用系统</h2><h3 id="认识数据系统"><a href="#认识数据系统" class="headerlink" title="认识数据系统"></a>认识数据系统</h3><p>单一工具难以满足复杂应用系统的需求，因此整体工作被拆解为一系列能被单个工具高效完成的任务，并通过<strong>应用代码</strong>将它们缝合起来。比如一个缓存、索引、数据库协作的例子： <img src="https://picture-bed-1251805293.file.myqcloud.com/1630635449781-eccd8717-84aa-4d52-b8d7-98790e2c92c7.png" alt="image.png"> 一个应用被称为数据密集型的，如果数据是其主要挑战（数据量，数据复杂度、数据变化速度）——与之相对的是计算密集型，即处理器速度是其瓶颈。 软件系统中很重要的三个问题：</p>
<ol>
<li><strong>可靠性</strong>（Reliability）：系统面临各种错误（硬件故障、软件故障、人为错误），仍可正常工作。</li>
<li><strong>可扩展性</strong>（Scalability）：有合理的办法应对系统的增长（数据量、流量、复杂性）。</li>
<li><strong>可维护性</strong>（Maintainability）：许多不同的人在不同的生命周期，都能高效地在系统上工作。</li>
</ol>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>可靠性意味着：即时发生了某些错误，系统仍然可以继续正常工作。</p>
<p>可能出错的事情称为错误（fault）或故障，系统可应对错误则称为容错（fault tolerant）或者弹性（resilient）。</p>
<p>故障与失效（failure）不完全一致。故障通常被定义为组件偏离其正常规格，而失效意味着系统作为一个整体，停止对外提供服务。</p>
<p>常见的故障分类：</p>
<ul>
<li><strong>硬件故障</strong><ul>
<li>故障场景：硬盘崩溃、内存故障、停电、断网等。</li>
<li>应对策略：添加冗余硬件以备用；软件容错（如：负载均衡）。</li>
</ul>
</li>
<li><strong>软件故障</strong><ul>
<li>故障场景：各种难以预料的 Bug。</li>
<li>应对策略：仔细考虑细节；全面测试；监控、告警；系统&#x2F;数据隔离机制；自动化部署、回滚机制等。</li>
</ul>
</li>
<li><strong>人为失误</strong><ul>
<li>故障场景：操作不当、配置错误等。</li>
<li>应对策略：快速恢复机制；监控、告警等。</li>
</ul>
</li>
</ul>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>可扩展性（Scalability）是用来描述系统应对负载增长能力的术语。</p>
<h4 id="描述负载"><a href="#描述负载" class="headerlink" title="描述负载"></a>描述负载</h4><p>负载可以用称为负载参数的若干数字来描述。参数的最佳选择取决于系统的体系结构。它可能是 QPS、数据库中写入的比例、日活用户量、缓存命中率等。</p>
<p>推特发送推文的设计变迁：</p>
<p>推文放在全局推文集合中，查询的时候做 join</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630635645347-1e1e5660-4229-42a2-9bf9-da9850ff944b.png" alt="image.png"></p>
<p>推文插入到每个关注者的时间线中，「扇出」比较大，当有千万粉丝的大 V 发推压力大</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630635669997-5d4951ae-5ec3-426d-9fc4-35a3cf579088.png" alt="image.png"></p>
<p>推特从方案一变成了方案二，然后变成了两者结合的方式</p>
<h4 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h4><p>负责增加将会发生什么：</p>
<ol>
<li>负载增加，但系统资源保持不变时，系统性能将受到什么影响？</li>
<li>负载增加，如果希望性能保持不变时，需要增加多少系统资源？</li>
</ol>
<p>批处理系统，通常关心吞吐量（throughput）；在线系统，通常更关心响应时间（response time）。</p>
<p>度量场景的响应时间，平均响应时间并不是一个合适的指标，因为它无法告诉有多少用户实际经历了多少延迟。最好使用百分位数，比如中位数（P50）、P95、P99、P999 等标识。</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630635717226-c218a4b8-b6f9-4e35-8f10-549d65cf3e23.png" alt="image.png"></p>
<p>测量客户端的响应时间非常重要（而不是服务端），比如会出现头部阻塞、网络延迟等。</p>
<p>实践中的百分位点，可以用一个滑动的时间窗口（比如 10 分钟）进行统计。可以对列表进行排序，效率低的话，考虑一下正向衰减，t-digest 等近似计算方法。</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630635787568-a7885c39-997f-4edb-8fb9-79eff18467a2.png" alt="image.png"></p>
<p>响应时间：中位数指标比平均响应时间更适合描述等待时间。</p>
<p>如何应对负载：垂直扩展（升级硬件）和水平扩展（集群、分布式）</p>
<h4 id="应对负载的方法"><a href="#应对负载的方法" class="headerlink" title="应对负载的方法"></a>应对负载的方法</h4><ul>
<li>垂直扩展：升级硬件</li>
<li>水平扩展：将负载分布到多台小机器上</li>
<li>弹性设计：自动检测负载增加，然后自动添加计算资源</li>
<li>无状态服务可以组成集群进行扩展；有状态服务从单点到分布式，复杂性会大大增加，因此，应该尽量将数据库放在单节点上。</li>
</ul>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>三个设计原则：</p>
<ul>
<li><strong>可运维性</strong>：运维更轻松。应对：监控、链路追踪、CI&#x2F;CD、规范流程等。</li>
<li><strong>简单性</strong>：简化复杂度。应对：良好的抽象。</li>
<li><strong>可演化性</strong>：易于改变。应对：DDD、TDD、重构、敏捷。</li>
</ul>
<h2 id="第二章：数据模型与查询语言"><a href="#第二章：数据模型与查询语言" class="headerlink" title="第二章：数据模型与查询语言"></a>第二章：数据模型与查询语言</h2><h3 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h3><p>关系模型 - 数据被组织成<strong>关系</strong>（SQL 中称作<strong>表</strong>），其中每个关系是<strong>元组</strong>（SQL 中称作<strong>行</strong>) 的无序集合。</p>
<p>NoSql - 不仅是 SQL（Not Only SQL）</p>
<p>相比于关系型数据库，为什么用 NoSql？</p>
<ul>
<li>需要更好的扩展性，以应对非常大的数据集或高并发。</li>
<li>关系模型不能很好地支持一些特殊的查询。</li>
<li>关系模型有很多限制，不够灵活。</li>
</ul>
<p>当前以及未来很长一段时间，关系型数据库和 NoSql 并存的混合持久化是一种常态。</p>
<p>复杂的应用程序可能会有更多的中间层，每层都通过提供一个简洁的数据模型来隐藏下层的复杂性。</p>
<p>如果数据大多是一对多关系（树结构数据）或者记录之间没有关系，那么文档模型是最合适的。</p>
<p>关系模型能够处理简单的多对多关系，但是随着数据之间的关联越来越复杂，将数据建模转化为图模型会更加自然。</p>
<h4 id="对象关系不匹配"><a href="#对象关系不匹配" class="headerlink" title="对象关系不匹配"></a>对象关系不匹配</h4><p>使用面向对象语言，需要一个转换层，才能转成 SQL 数据模型。模型之间的脱离有时被称为阻抗失谐。</p>
<p>Hibernate 这样的 <strong>对象关系映射（ORM）</strong> 框架则减少这个转换层所需的样板代码量，但是它们不能完全隐藏这两个模型之间的差异。</p>
<p>对于一份简历而言，关系型模型描述一对多的关系需要多张表。</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630640250504-01ef3f97-39be-4c23-9a9e-ce17c1cde6a9.png" alt="image.png"> 对于简历这样的数据结构，主要是一个自包含的文档，用 JSON 表示非常合适。JSON 相比于多表模式，有更好的局部性，可以一次查询出一个用户的所有信息。JSON 其实是树形层级结构。<img src="https://picture-bed-1251805293.file.myqcloud.com/1630640396753-c7fed755-b19b-4948-9c84-53d232548633.png" alt="image.png"></p>
<h4 id="多对一和多对多的关系"><a href="#多对一和多对多的关系" class="headerlink" title="多对一和多对多的关系"></a>多对一和多对多的关系</h4><p>使用 ID 的好处是，因为它对人类没有任何直接意义，所以永远不需要直接改变：即使 ID 标识的信息发生了变化，它也可以保持不变。</p>
<p>文档模型不适合表达多对一的关系。对于关系数据库，由于支持联结操作，可以更方便地通过 ID 来引用其他表的行。而在文档数据库中，一对多的树状结构不需要联结，即使支持联结通常也比较弱。</p>
<p>如果数据库本身不支持联结，则必须通过对数据库进行多次查询来模拟联结。</p>
<p>考虑以下可能对简历进行的修改或补充：</p>
<ul>
<li>组织和学校作为实体：组织、学校有各自的主页。</li>
<li>推荐：用户可以推荐其他用户在自己的简历上。</li>
</ul>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630641413918-4cee1b5a-9bd2-4375-b86a-8d6d7183ee34.png" alt="image.png"></p>
<h4 id="文档数据库是否在重演历史？"><a href="#文档数据库是否在重演历史？" class="headerlink" title="文档数据库是否在重演历史？"></a>文档数据库是否在重演历史？</h4><p>20 世纪 70 年代，最受欢迎的是<strong>层次模型（hierarchical model）</strong>，它与文档数据库使用的 JSON 模型有很多相似之处。它将所有数据表示为嵌套在记录中的记录树。层次模型能很好地支持一对多的关系，但是很难支持多对多的关系，而且不支持联结。</p>
<p>为解决层次模型的局限性而提出的方案：</p>
<ul>
<li><strong>关系模型（relational model）</strong> - 后来，演变成了 SQL，并被广泛接受</li>
<li><strong>网络模型（network model）</strong> - 最初很受关注，但最终被淡忘</li>
</ul>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1630641447595-4315fa0f-8338-4596-88d1-e423e040ac62.png" alt="image.png"></p>
<h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><p>每个记录可能有多个父节点。</p>
<p>网络模型中，记录之间的链接不是外键，而更像编程语言中的指针（会存储在磁盘上）。访问记录的唯一方法是选择一条始于根记录的路径，并沿着相关链接一次访问，这条链接链条也被称为<strong>访问路径（access path）</strong>。</p>
<p>最简单的情况下，访问路径类似遍历链表：从链表头开始，每次查看一条记录，直到找到所需的记录。但在多对多关系的情况中，存在多条不同的路径可以通向相同的记录，网络模型的程序员必须跟踪这些不同的访问路径。</p>
<p>缺点：查询和更新数据库非常麻烦。</p>
<h5 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h5><p>关系模型定义了所有数据的格式：<strong>关系（表）</strong> 只是 <strong>元组（行）</strong> 的集合，仅此而已。</p>
<p>在关系数据库中，查询优化器自动决定以何种顺序执行查询，以及使用哪些索引。</p>
<h5 id="文档数据库的比较"><a href="#文档数据库的比较" class="headerlink" title="文档数据库的比较"></a>文档数据库的比较</h5><p>文档数据库是某种方式的层次模型：即在其负记录中保存了嵌套记录，而不是存储在单独的表中。</p>
<p>但是，在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：在这两种情况下，相关项目都由唯一的标识符引用，该标识符在关系模型中被称为<strong>外键</strong>，在文档模型中被称为<strong>文档引用。</strong>标识符可以查询时通过联结操作或相关后续查询来解析。</p>
<h4 id="关系数据库与文档数据库现状"><a href="#关系数据库与文档数据库现状" class="headerlink" title="关系数据库与文档数据库现状"></a>关系数据库与文档数据库现状</h4><p>支持文档数据模型的主要论据是<strong>模式灵活性</strong>，由于局部性而带来较好的性能。关系模型则强在联结操作、多对一和多对多关系更简洁的表达上。</p>
<h5 id="哪种数据模型的应用代码更简单"><a href="#哪种数据模型的应用代码更简单" class="headerlink" title="哪种数据模型的应用代码更简单"></a>哪种数据模型的应用代码更简单</h5><p>文档模型：</p>
<ul>
<li>优点：<ul>
<li>如果应用程序中的数据具有类似<strong>文档</strong>的结构（即一对多关系树，通常一次性加载整个树），那么使用文档模型更为合适。而关系模型则倾向于数据分解，把文档结构分解为多个表。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不能直接引用文档中的嵌套的项目，而是需要说“用户 251 的位置列表中的第二项”（很像分层模型中的访问路径）。但是，只要文件嵌套不太深，这通常不是问题。</li>
<li>文档数据库对联结的支持不足。这是否是问题取决于应用，如果应用程序使用多对多关系，那么文档模型就没不合适了。</li>
</ul>
</li>
</ul>
<p>对于高度关联的数据，文档模型不太适合，关系模型更适合。</p>
<h5 id="文档模型中的模式灵活性"><a href="#文档模型中的模式灵活性" class="headerlink" title="文档模型中的模式灵活性"></a>文档模型中的模式灵活性</h5><p>文档模型是「读时模式」</p>
<ul>
<li>文档数据库有时称为<strong>无模式（schemaless）</strong>，但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。</li>
<li>一个更精确的术语是<strong>读时模式（schema-on-read）</strong>（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是<strong>写时模式（schema-on-write）</strong>（传统的关系数据库方法中，模式明确，且数据库确保数据写入时都必须遵循）。</li>
<li>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。</li>
</ul>
<p>模式变更</p>
<ul>
<li>读时模式变更字段很容易，只用改应用代码</li>
<li>写时模式变更字段速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE 语句。MySQL 是一个值得注意的例外，它执行 ALTER TABLE 时会复制整个表，这可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机时间，尽管存在各种工具来解决这个限制。</li>
</ul>
<h5 id="查询的数据局部性"><a href="#查询的数据局部性" class="headerlink" title="查询的数据局部性"></a>查询的数据局部性</h5><p>文档通常存储为编码为 JSON、XML 或其二进制变体（如 MongoDB 的 BSON）的连续字符串。</p>
<p>读文档：</p>
<ul>
<li>如果应用需要频繁访问整个文档，则存储局部性具有性能优势。</li>
<li>局部性优势仅适用于需要同时访问文档大部分内容的场景。</li>
</ul>
<p>写文档：</p>
<ul>
<li>更新文档时，通常需要重写整个文档。</li>
<li>通常建议文档应该尽量小且避免写入时增加文档大小。</li>
</ul>
<h5 id="文档数据库与关系数据库的融合"><a href="#文档数据库与关系数据库的融合" class="headerlink" title="文档数据库与关系数据库的融合"></a>文档数据库与关系数据库的融合</h5><ul>
<li>MySQL 等逐步增加了对 JSON 和 XML 的支持</li>
<li>融合关系模型与文档模型是未来数据库发展的一条很好的途径。</li>
</ul>
<h3 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h3><ul>
<li><p>关系模型包含了一种查询数据的新方法：SQL 是一种 <strong>声明式</strong> 查询语言，而 IMS 和 CODASYL 使用 <strong>命令式</strong> 代码来查询数据库。</p>
</li>
<li><p><strong>命令式语言</strong>告诉计算机以特定顺序执行某些操作，比如常见的编程语言。</p>
</li>
<li><p><strong>声明式查询语言</strong>只需指定所需的数据模式，结果需要满足哪些条件，以及如何转换数据（例如，排序，分组和集合） ，而不需指明如何实现这一目标</p>
</li>
</ul>
<h4 id="Web-上的声明式查询（略）"><a href="#Web-上的声明式查询（略）" class="headerlink" title="Web 上的声明式查询（略）"></a>Web 上的声明式查询（略）</h4><h4 id="MapReduce-查询"><a href="#MapReduce-查询" class="headerlink" title="MapReduce 查询"></a>MapReduce 查询</h4><p>MapReduce 是一种编程模型，用于在许多机器上批量处理海量数据。一些 NoSQL 支持有限的 MapReduce 方式在大量文档上执行只读查询。</p>
<h3 id="图数据模型（略）"><a href="#图数据模型（略）" class="headerlink" title="图数据模型（略）"></a>图数据模型（略）</h3><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>历史上，数据最初被表示为一棵大树（层次模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。 最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型“NoSQL”数据存储在两个主要方向上存在分歧：</p>
<ul>
<li>文档数据库的应用场景是：数据来自于自包含文档，且文档之间的关联很少。</li>
<li>图数据库则的应用场景是：所有数据都可能会相互关联。</li>
</ul>
<p>文档模型、关系模型和图模型，都应用广泛。不同模型之间可以相互模拟，但是处理起来比较笨拙。</p>
<p>文档数据库和图数据库有一个共同点，那就是它们通常不会对存储的数据强加某个模式，这样比较灵活。</p>
<h2 id="第三章：存储与检索"><a href="#第三章：存储与检索" class="headerlink" title="第三章：存储与检索"></a>第三章：存储与检索</h2><p>从最基本的层面看，数据库只需做两件事情：存储和检索。</p>
<h3 id="数据库核心：数据结构"><a href="#数据库核心：数据结构" class="headerlink" title="数据库核心：数据结构"></a>数据库核心：数据结构</h3><p>为了高效地查找数据库中特定键的值， 需要新的数据结构： 索引。</p>
<p>存储系统的设计权衡：适当的索引可以加速读取查询，但每个索引都会减慢写速度。数据库通常不会对所有内容进行索引。</p>
<p>索引类型：</p>
<ul>
<li>哈希索引</li>
<li>B+ 树</li>
<li>LSM 树</li>
<li>等等</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></p>
</blockquote>
<h3 id="事务处理与分析处理"><a href="#事务处理与分析处理" class="headerlink" title="事务处理与分析处理"></a>事务处理与分析处理</h3><h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><p>如果表中有数以万亿行、PB 大小的数据，则适合用于存储在列式存储中。</p>
<h2 id="第四章：数据编码与演化"><a href="#第四章：数据编码与演化" class="headerlink" title="第四章：数据编码与演化"></a>第四章：数据编码与演化</h2><p>本章节主要介绍各种序列化、反序列化方式。略</p>
<h3 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h3><h3 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h3><p>向前和向后的兼容对于可演化性来说非常重要。</p>
<h4 id="基于数据库的数据流"><a href="#基于数据库的数据流" class="headerlink" title="基于数据库的数据流"></a>基于数据库的数据流</h4><h5 id="在不同的时间写入不同的值"><a href="#在不同的时间写入不同的值" class="headerlink" title="在不同的时间写入不同的值"></a>在不同的时间写入不同的值</h5><p>数据库通常支持在不同的时间写入不同的值。</p>
<p>在集群中部署新版本是一个逐一的过程，必然存在这样的时间段：集群中部分是新机器，部分是老机器。</p>
<p>当旧版本的应用视图更新新版本的应用所写入的数据时，可能会丢失数据。</p>
<p><img src="https://picture-bed-1251805293.file.myqcloud.com/1633665482803-0f0f81b1-9abc-4171-b532-577637eecfe6.png" alt="image.png"></p>
<h5 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h5><p>生成数据库快照时，数据转储通常使用最新的模式进行编码。</p>
<h4 id="基于服务的数据流：REST-和-RPC"><a href="#基于服务的数据流：REST-和-RPC" class="headerlink" title="基于服务的数据流：REST 和 RPC"></a>基于服务的数据流：REST 和 RPC</h4><ul>
<li>最常见的网络通信方式：C&#x2F;S 架构（客户端+服务端）。</li>
<li>Web 服务：收、发 GET 和 POST 请求。</li>
<li>将大型应用分而治之：微服务架构。</li>
<li>微服务架构的一个关键设计目标：服务可以独立部署和演化。</li>
</ul>
<h5 id="Web-服务"><a href="#Web-服务" class="headerlink" title="Web 服务"></a>Web 服务</h5><ul>
<li>当 HTTP 被用作与服务通信的底层协议时，它被称为 Web 服务</li>
<li>有两种流行的 Web 服务方法：REST 和 SOAP。</li>
</ul>
<p>REST 不是一种协议，而是一个基于 HTTP 原则的设计理念。它强调简单的数据格式，使用 URL 来标识资源，并使用 HTTP 功能进行缓存控制，身份验证和内容类型协商。与 SOAP 相比，REST 已经越来越受欢迎，至少在跨组织服务集成的背景下，并经常与微服务相关。根据 REST 原则设计的 API 称为 RESTful。</p>
<p>SOAP 是一种基于 XML 的协议，用于发送网络 API 请求。虽然，它最常用于 HTTP，但其目的是独立于 HTTP，并避免使用大多数 HTTP 功能。SOAP Web 服务的 API 使用 WSDL 语言来描述。 WSDL 支持代码生成，客户端可以使用本地类和方法调用（编码为 XML 消息并由框架再次解码）访问远程服务。尽管 SOAP 及其各种扩展表面上是标准化的，但是不同厂商的实现之间的互操作性往往会造成问题。</p>
<h5 id="远程过程调用（RPC）的问题"><a href="#远程过程调用（RPC）的问题" class="headerlink" title="远程过程调用（RPC）的问题"></a>远程过程调用（RPC）的问题</h5><p>RPC 模型试图向远程网络服务发出请求，看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为位置透明）。</p>
<p>RPC 的缺陷：</p>
<ul>
<li>本地函数调用是可预测的，并且成功或失败仅取决于控制的参数。而网络请求是不可预知的。</li>
<li>本地函数调用要么返回结果，要么抛出异常，或者永远不返回（因为进入无限循环或进程崩溃）。网络请求有另一个可能的结果：由于超时，它可能会没有返回结果。这种情况下，无法得知发生了什么。</li>
<li>如果重试失败的网络请求，可能会发生请求实际上已经完成，只有响应丢失的情况。在这种情况下，重试将导致该操作被执行多次，除非在协议中建立重复数据消除（ <strong>幂等（idempotence）</strong>）机制。本地函数调用没有这个问题。</li>
<li>每次调用本地功能时，通常需要大致相同的时间来执行。网络请求慢得多，不可预知。</li>
<li>调用本地函数时，可以高效地将引用（指针）传递给本地内存中的对象。当发出网络请求时，所有这些参数都需要被编码成可以通过网络发送的字节序列。如果参数是像数字或字符串这样的基本类型倒是没关系，但是对于较大的对象很快就会变成问题。</li>
<li>客户端和服务端可以用不同的编程语言实现。所以，RPC 框架必须将数据类型从一种语言转换成另一种语言。</li>
</ul>
<p>RPC 比 REST 性能好。但是，REST 更加方便，不限定特定的语言，有更好的通用性。因此，REST 是公共 API 的主流；RPC 框架则侧重于同一组织内多个服务间的请求，且通常在同一数据中心。</p>
<h4 id="基于消息传递的数据流"><a href="#基于消息传递的数据流" class="headerlink" title="基于消息传递的数据流"></a>基于消息传递的数据流</h4><h5 id="消息代理"><a href="#消息代理" class="headerlink" title="消息代理"></a>消息代理</h5><p>通常，消息代理的使用方式如下：</p>
<p>生产者向指定的队列或主题发消息；消息代理确保消息被传递给队列或主题的一个或多个消费者或订阅者。同一主题上，可以有多个生产者和多个消费者。</p>
<h5 id="分布式-Actor-框架"><a href="#分布式-Actor-框架" class="headerlink" title="分布式 Actor 框架"></a>分布式 Actor 框架</h5><p>Actor 模型是用于单个进程中并发的编程模型。每个 Actor 通常代表一个客户端或实体，它可能具有某些本地状态，并且它通过发送和接受异步消息与其他 Actor 通信。</p>
<p>分布式的 Actor 框架实质上时将消息代理和 Actor 编程模型集成到单个框架中。</p>
<p>三种流行的分布式 Actor 框架：</p>
<ul>
<li>Akka 使用 Java 的内置序列化，它不提供向前或向后兼容性。但是，可以用类似 Protocol Buffer 替代；</li>
<li>Orleans 不支持滚动升级部署的自定义数据编码格式；</li>
<li>Erlang OTP，很难对记录模式进行更改。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>许多服务需要支持滚动升级：向前、向后兼容性。</p>
<p>我们讨论了几种数据编码格式及其兼容性属性：</p>
<ul>
<li>编程语言特定的编码仅限于单一编程语言，往往无法提供前向和后向兼容性。</li>
<li>JSON，XML 和 CSV 等文本格式非常普遍，其兼容性取决于您如何使用它们。它们有可选的模式语言，这有时是有用的，有时却是一个障碍。这些格式对某些数据类型的支持有些模糊，必须小心数字和二进制字符串等问题。</li>
<li>像 Thrift，Protocol Buffers 和 Avro 这样的二进制模式驱动格式，支持使用清晰定义的前向和后向兼容性语义进行紧凑，高效的编码。这些模式对于静态类型语言中的文档和非常有用。但是，他们有一个缺点，就是在数据可读之前需要对数据进行解码。</li>
</ul>
<p>我们还讨论了数据流的几种模式，说明了数据编码重要性的不同场景：</p>
<ul>
<li>数据库，写入数据库的进程对数据进行编码，并从数据库读取进程对其进行解码。</li>
<li>RPC 和 REST API，客户端对请求进行编码，服务器对请求进行解码并对响应进行编码，客户端最终对响应进行解码。</li>
<li>异步消息传递（使用消息代理或 Actor），节点之间通过互发消息进行通信，消息由发送者编码并由接收者解码。</li>
</ul>
<p>结论：前向兼容性和滚动升级在某种程度上是可以实现的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/"><strong>数据密集型应用系统设计</strong></a> - 这可能是目前最好的分布式存储书籍，强力推荐【进阶】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/21/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/blog/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/23/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"1fefcb4e45087badee62f6d5af2c550d"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
