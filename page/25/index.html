<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/25/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/25/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/25/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f23795fd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f23795fd/" class="post-title-link" itemprop="url">深入理解 Java String 类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-25 18:43:11" itemprop="dateCreated datePublished" datetime="2020-12-25T18:43:11+08:00">2020-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-String-类型"><a href="#深入理解-Java-String-类型" class="headerlink" title="深入理解 Java String 类型"></a>深入理解 Java String 类型</h1><blockquote>
<p>String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。</p>
</blockquote>
<h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p>我们先来看下 <code>String</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类被 <code>final</code> 关键字修饰，表示<strong>不可继承 <code>String</code> 类</strong>。</p>
<p><code>String</code> 类的数据存储于 <code>char[]</code> 数组，这个数组被 <code>final</code> 关键字修饰，表示 <strong><code>String</code> 对象不可被更改</strong>。</p>
<p>为什么 Java 要这样设计？</p>
<p>（1）<strong>保证 String 对象安全性</strong>。避免 String 被篡改。</p>
<p>（2）<strong>保证 hash 值不会频繁变更</strong>。</p>
<p>（3）<strong>可以实现字符串常量池</strong>。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 <code>String str=&quot;abc&quot;;</code> 另一种是字符串变量通过 new 形式的创建，如 <code>String str = new String(&quot;abc&quot;)</code>。</p>
<p>使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p>
<p><code>String str = new String(&quot;abc&quot;)</code> 这种方式，首先在编译类文件时，<code>&quot;abc&quot;</code> 常量字符串将会放入到常量结构中，在类加载时，<code>&quot;abc&quot;</code> 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 <code>String</code> 的构造函数，同时引用常量池中的 <code>&quot;abc&quot;</code> 字符串，在堆内存中创建一个 <code>String</code> 对象；最后，str 将引用 <code>String</code> 对象。</p>
<h2 id="String-的性能考量"><a href="#String-的性能考量" class="headerlink" title="String 的性能考量"></a>String 的性能考量</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><strong>字符串常量的拼接，编译器会将其优化为一个常量字符串</strong>。</p>
<p>【示例】字符串常量拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 本行代码在 class 文件中，会被编译器直接优化为：</span></span><br><span class="line">    <span class="comment">// String str = &quot;abc&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串变量的拼接，编译器会优化成 <code>StringBuilder</code> 的方式</strong>。</p>
<p>【示例】字符串变量的拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本行代码会被编译器优化为：</span></span><br><span class="line">        <span class="comment">// str = (new StringBuilder(String.valueOf(str))).append(i).toString();</span></span><br><span class="line">        str = str + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，每次循环都会生成一个新的 <code>StringBuilder</code> 实例，同样也会降低系统的性能。</p>
<p>字符串拼接的正确方案：</p>
<ul>
<li>如果需要使用<strong>字符串拼接，应该优先考虑 <code>StringBuilder</code> 的 <code>append</code> 方法替代使用 <code>+</code> 号</strong>。</li>
<li>如果在并发编程中，<code>String</code> 对象的拼接涉及到线程安全，可以使用 <code>StringBuffer</code>。但是要注意，由于 <code>StringBuffer</code> 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 <code>StringBuilder</code> 差一些。</li>
</ul>
<h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p><strong><code>String</code> 的 <code>split()</code> 方法使用正则表达式实现其强大的分割功能</strong>。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。</p>
<p>所以，应该慎重使用 <code>split()</code> 方法，<strong>可以考虑用 <code>String.indexOf()</code> 方法代替 <code>split()</code> 方法完成字符串的分割</strong>。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。</p>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern"></a>String.intern</h3><p><strong>在每次赋值的时候使用 <code>String</code> 的 <code>intern</code> 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉</strong>。</p>
<p>在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。</p>
<p>如果调用 <code>intern</code> 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedLocation</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	<span class="keyword">private</span> String region;</span><br><span class="line">	<span class="keyword">private</span> String countryCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SharedLocation</span> <span class="variable">sharedLocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedLocation</span>();</span><br><span class="line">sharedLocation.setCity(messageInfo.getCity().intern());		sharedLocation.setCountryCode(messageInfo.getRegion().intern());</span><br><span class="line">sharedLocation.setRegion(messageInfo.getCountryCode().intern());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>intern</code> 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。</p>
</blockquote>
<h2 id="String、StringBuffer、StringBuilder-有什么区别"><a href="#String、StringBuffer、StringBuilder-有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder 有什么区别"></a>String、StringBuffer、StringBuilder 有什么区别</h2><p><code>String</code> 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 <code>Immutable</code> 类，被声明成为 <code>final class</code>，所有属性也都是 <code>final</code> 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 <code>String</code> 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p><code>StringBuffer</code> 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 <code>append</code> 或者 <code>add</code> 方法，把字符串添加到已有序列的末尾或者指定位置。<code>StringBuffer</code> 是一个<strong>线程安全的</strong>可修改字符序列。<code>StringBuffer</code> 的线程安全是通过在各种修改数据的方法上用 <code>synchronized</code> 关键字修饰实现的。</p>
<p><code>StringBuilder</code> 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 <code>AbstractStringBuilder</code>，里面包含了基本操作，区别仅在于最终的方法是否加了 <code>synchronized</code>。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 <code>arraycopy</code>。</p>
<p>**除非有线程安全的需要，不然一般都使用 <code>StringBuilder</code>**。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">极客时间教程 - Java 性能调优实战</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/82">极客时间教程 - Java 核心技术面试精讲</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6726e7a6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6726e7a6/" class="post-title-link" itemprop="url">Java 正则从入门到精通</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-25 18:43:11" itemprop="dateCreated datePublished" datetime="2020-12-25T18:43:11+08:00">2020-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">高级特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>37k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-正则从入门到精通"><a href="#Java-正则从入门到精通" class="headerlink" title="Java 正则从入门到精通"></a>Java 正则从入门到精通</h1><blockquote>
<p>关键词：Pattern、Matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、DFA、NFA</p>
</blockquote>
<h2 id="正则简介"><a href="#正则简介" class="headerlink" title="正则简介"></a>正则简介</h2><h3 id="正则表达式是什么"><a href="#正则表达式是什么" class="headerlink" title="正则表达式是什么"></a>正则表达式是什么</h3><p>正则表达式（Regular Expression）是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。</p>
<h3 id="如何学习正则"><a href="#如何学习正则" class="headerlink" title="如何学习正则"></a>如何学习正则</h3><p>正则表达式是一个强大的文本匹配工具，但是它的规则很复杂，理解起来较为困难，容易让人望而生畏。</p>
<p>刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。我觉得正则表达式和武侠修练武功差不多，应该先练招式，再练心法。如果一开始就直接看正则的规则，保证你会懵逼。当你熟悉基本招式（正则基本使用案例）后，也该修炼修炼心法（正则语法）了。真正的高手不能只靠死记硬背那么几招把式。就像张三丰教张无忌太极拳一样，领悟心法，融会贯通，少侠你就可以无招胜有招，成为传说中的绝世高手。</p>
<p><strong>以上闲话可归纳为一句：学习正则应该从实例去理解规则。</strong></p>
<h2 id="正则工具类"><a href="#正则工具类" class="headerlink" title="正则工具类"></a>正则工具类</h2><p>JDK 中的 <code>java.util.regex</code> 包提供了对正则表达式的支持。</p>
<p><code>java.util.regex</code> 有三个核心类：</p>
<ul>
<li><strong>Pattern 类：</strong><code>Pattern</code> 是一个正则表达式的编译表示。</li>
<li><strong>Matcher 类：</strong><code>Matcher</code> 是对输入字符串进行解释和匹配操作的引擎。</li>
<li><strong>PatternSyntaxException：</strong><code>PatternSyntaxException</code> 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li>
</ul>
<p><strong>注：</strong>需要格外注意一点，在 Java 中使用反斜杠”\“时必须写成 <code>&quot;\\&quot;</code>。所以本文的代码出现形如 <code>String regex = &quot;\\$\\&#123;.*?\\&#125;&quot;</code> 其实就是 <code>\$\&#123;.\*?\&#125;</code>。</p>
<h3 id="Pattern-类"><a href="#Pattern-类" class="headerlink" title="Pattern 类"></a>Pattern 类</h3><p><code>Pattern</code>类没有公共构造方法。要创建一个<code>Pattern</code>对象，你必须首先调用其<strong>静态方法</strong><code>compile</code>，加载正则规则字符串，然后返回一个 Pattern 对象。</p>
<p>与<code>Pattern</code>类一样，<code>Matcher</code>类也没有公共构造方法。你需要调用<code>Pattern</code>对象的<code>matcher</code>方法来获得一个<code>Matcher</code>对象。</p>
<p>【示例】Pattern 和 Matcher 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br></pre></td></tr></table></figure>

<h3 id="Matcher-类"><a href="#Matcher-类" class="headerlink" title="Matcher 类"></a>Matcher 类</h3><p><code>Matcher</code> 类可以说是 <code>java.util.regex</code> 中的核心类，它有三类功能：校验、查找、替换。</p>
<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>为了校验文本是否与正则规则匹配，Matcher 提供了以下几个返回值为 <code>boolean</code> 的方法。</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**public boolean lookingAt() ** 尝试将从区域开头开始的输入序列与该模式匹配。</td>
</tr>
<tr>
<td>2</td>
<td>**public boolean find() **尝试查找与该模式匹配的输入序列的下一个子序列。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public boolean find(int start）</strong>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td>
</tr>
<tr>
<td>4</td>
<td>**public boolean matches() **尝试将整个区域与模式匹配。</td>
</tr>
</tbody></table>
<p>如果你傻傻分不清上面的查找方法有什么区别，那么下面一个例子就可以让你秒懂。</p>
<p>【示例】lookingAt、find、matches</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	checkLookingAt(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	checkLookingAt(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">	checkFind(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	checkFind(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">	checkMatches(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	checkMatches(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	checkMatches(<span class="string">&quot;helloworld&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkLookingAt</span><span class="params">(String regex, String content)</span> &#123;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="keyword">if</span> (m.lookingAt()) &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tlookingAt： &quot;</span> + regex);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tnot lookingAt： &quot;</span> + regex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkFind</span><span class="params">(String regex, String content)</span> &#123;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="keyword">if</span> (m.find()) &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tfind： &quot;</span> + regex);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tnot find： &quot;</span> + regex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkMatches</span><span class="params">(String regex, String content)</span> &#123;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tmatches： &quot;</span> + regex);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(content + <span class="string">&quot;\tnot matches： &quot;</span> + regex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">helloworld	lookingAt： hello</span><br><span class="line">helloworld<span class="built_in">	not</span> lookingAt： world</span><br><span class="line">helloworld	find： hello</span><br><span class="line">helloworld	find： world</span><br><span class="line">helloworld<span class="built_in">	not</span><span class="built_in"> matches</span>： hello</span><br><span class="line">helloworld<span class="built_in">	not</span><span class="built_in"> matches</span>： world</span><br><span class="line">helloworld<span class="built_in">	matches</span>： helloworld</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p><code>regex = &quot;world&quot;</code> 表示的正则规则是以 world 开头的字符串，<code>regex = &quot;hello&quot;</code> 和 <code>regex = &quot;helloworld&quot;</code> 也是同理。</p>
<ul>
<li><code>lookingAt</code>方法从头部开始，检查 content 字符串是否有子字符串于正则规则匹配。</li>
<li><code>find</code>方法检查 content 字符串是否有子字符串于正则规则匹配，不管字符串所在位置。</li>
<li><code>matches</code>方法检查 content 字符串整体是否与正则规则匹配。</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>为了查找文本匹配正则规则的位置，<code>Matcher</code>提供了以下方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**public int start() **返回以前匹配的初始索引。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public int start(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td>3</td>
<td>**public int end()**返回最后匹配字符之后的偏移量。</td>
</tr>
<tr>
<td>4</td>
<td>**public int end(int group)**返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td>
</tr>
<tr>
<td>5</td>
<td>**public String group()**返回前一个符合匹配条件的子序列。</td>
</tr>
<tr>
<td>6</td>
<td>**public String group(int group)**返回指定的符合匹配条件的子序列。</td>
</tr>
</tbody></table>
<p>【示例】使用 start()、end()、group() 查找所有匹配正则条件的子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;helloworld helloworld&quot;</span>;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	System.out.println(<span class="string">&quot;content: &quot;</span> + content);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">		i++;</span><br><span class="line">		System.out.println(<span class="string">&quot;[&quot;</span> + i + <span class="string">&quot;th] found&quot;</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;start: &quot;</span> + m.start() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;end: &quot;</span> + m.end() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;group: &quot;</span> + m.group() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content: helloworld helloworld</span><br><span class="line">[<span class="number">1</span>th] <span class="built_in">found</span></span><br><span class="line"><span class="keyword">start</span>: <span class="number">5</span>, <span class="keyword">end</span>: <span class="number">10</span>, <span class="keyword">group</span>: world</span><br><span class="line">[<span class="number">2</span>th] <span class="built_in">found</span></span><br><span class="line"><span class="keyword">start</span>: <span class="number">16</span>, <span class="keyword">end</span>: <span class="number">21</span>, <span class="keyword">group</span>: world</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>例子很直白，不言自明了吧。</p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>替换方法是替换输入字符串里文本的方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**public Matcher appendReplacement(StringBuffer sb, String replacement)**实现非终端添加和替换步骤。</td>
</tr>
<tr>
<td>2</td>
<td>**public StringBuffer appendTail(StringBuffer sb)**实现终端添加和替换步骤。</td>
</tr>
<tr>
<td>3</td>
<td>**public String replaceAll(String replacement) ** 替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public String replaceFirst(String replacement)</strong> 替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td>
</tr>
<tr>
<td>5</td>
<td>**public static String quoteReplacement(String s)**返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给 Matcher 类的 appendReplacement 方法一个字面字符串一样工作。</td>
</tr>
</tbody></table>
<p>【示例】replaceFirst 和 replaceAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;can&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="string">&quot;can not&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;I can because I think I can.&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;content: &quot;</span> + content);</span><br><span class="line">	System.out.println(<span class="string">&quot;replaceFirst: &quot;</span> + m.replaceFirst(replace));</span><br><span class="line">	System.out.println(<span class="string">&quot;replaceAll: &quot;</span> + m.replaceAll(replace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">content</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span><span class="operator">.</span></span><br><span class="line"><span class="variable">replaceFirst</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span><span class="operator">.</span></span><br><span class="line"><span class="variable">replaceAll</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span><span class="operator">.</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>replaceFirst：替换第一个匹配正则规则的子序列。</p>
<p>replaceAll：替换所有匹配正则规则的子序列。</p>
<p>【示例】appendReplacement、appendTail 和 replaceAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;can&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="string">&quot;can not&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;I can because I think I can.&quot;</span>;</span><br><span class="line">	<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;content: &quot;</span> + content);</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">		m.appendReplacement(sb, replace);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;appendReplacement: &quot;</span> + sb);</span><br><span class="line">	m.appendTail(sb);</span><br><span class="line">	System.out.println(<span class="string">&quot;appendTail: &quot;</span> + sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">content</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span><span class="operator">.</span></span><br><span class="line"><span class="variable">appendReplacement</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span></span><br><span class="line"><span class="variable">appendTail</span><span class="operator">:</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span> <span class="variable">because</span> <span class="built_in">I</span> <span class="variable">think</span> <span class="built_in">I</span> <span class="variable">can</span> <span class="variable">not</span><span class="operator">.</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>从输出结果可以看出，<code>appendReplacement</code>和<code>appendTail</code>方法组合起来用，功能和<code>replaceAll</code>是一样的。</p>
<p>如果你查看<code>replaceAll</code>的源码，会发现其内部就是使用<code>appendReplacement</code>和<code>appendTail</code>方法组合来实现的。</p>
<p>【示例】quoteReplacement 和 replaceAll，解决特殊字符替换问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\$\\&#123;.*?\\&#125;&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="string">&quot;$&#123;product&#125;&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;product is $&#123;productName&#125;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="type">String</span> <span class="variable">replaceAll</span> <span class="operator">=</span> m.replaceAll(replace);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;content: &quot;</span> + content);</span><br><span class="line">	System.out.println(<span class="string">&quot;replaceAll: &quot;</span> + replaceAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalArgumentException</span>: No group with name &#123;product&#125;</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.regex</span><span class="selector-class">.Matcher</span><span class="selector-class">.appendReplacement</span>(Matcher<span class="selector-class">.java</span>:<span class="number">849</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.regex</span><span class="selector-class">.Matcher</span><span class="selector-class">.replaceAll</span>(Matcher<span class="selector-class">.java</span>:<span class="number">955</span>)</span><br><span class="line">	at org<span class="selector-class">.zp</span><span class="selector-class">.notes</span><span class="selector-class">.javase</span><span class="selector-class">.regex</span><span class="selector-class">.RegexDemo</span><span class="selector-class">.wrongMethod</span>(RegexDemo<span class="selector-class">.java</span>:<span class="number">42</span>)</span><br><span class="line">	at org<span class="selector-class">.zp</span><span class="selector-class">.notes</span><span class="selector-class">.javase</span><span class="selector-class">.regex</span><span class="selector-class">.RegexDemo</span><span class="selector-class">.main</span>(RegexDemo<span class="selector-class">.java</span>:<span class="number">18</span>)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke0</span>(Native Method)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line">	at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method<span class="selector-class">.java</span>:<span class="number">498</span>)</span><br><span class="line">	at com<span class="selector-class">.intellij</span><span class="selector-class">.rt</span><span class="selector-class">.execution</span><span class="selector-class">.application</span><span class="selector-class">.AppMain</span><span class="selector-class">.main</span>(AppMain<span class="selector-class">.java</span>:<span class="number">147</span>)</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p><code>String regex = &quot;\\$\\&#123;.*?\\&#125;&quot;;</code>表示匹配类似<code>$&#123;name&#125;</code>这样的字符串。由于<code>$</code>、<code>&#123;</code> 、<code>&#125;</code>都是特殊字符，需要用反义字符<code>\</code>来修饰才能被当做一个字符串字符来处理。</p>
<p>上面的例子是想将 <code>$&#123;productName&#125;</code> 替换为 <code>$&#123;product&#125;</code> ，然而<code>replaceAll</code>方法却将传入的字符串中的<code>$</code>当做特殊字符来处理了。结果产生异常。</p>
<p>如何解决这个问题?</p>
<p>JDK1.5 引入了<code>quoteReplacement</code>方法。它可以用来转换特殊字符。其实源码非常简单，就是判断字符串中如果有<code>\</code>或<code>$</code>，就为它加一个转义字符<code>\</code></p>
<p>我们对上面的代码略作调整：</p>
<p><code>m.replaceAll(replace)</code>改为<code>m.replaceAll(Matcher.quoteReplacement(replace))</code>，新代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\$\\&#123;.*?\\&#125;&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="string">&quot;$&#123;product&#125;&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;product is $&#123;productName&#125;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="type">String</span> <span class="variable">replaceAll</span> <span class="operator">=</span> m.replaceAll(Matcher.quoteReplacement(replace));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;content: &quot;</span> + content);</span><br><span class="line">	System.out.println(<span class="string">&quot;replaceAll: &quot;</span> + replaceAll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">content</span>: <span class="built_in">product</span> <span class="built_in">is</span> $&#123;productName&#125;.</span><br><span class="line">replaceAll: <span class="built_in">product</span> <span class="built_in">is</span> $&#123;<span class="built_in">product</span>&#125;.</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>字符串中如果有<code>\</code>或<code>$</code>，不能被正常解析的问题解决。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。</p>
<h3 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h3><p>正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。让我们从一个个实例出发，由浅入深的去体会正则的奥妙。</p>
<h4 id="多选（-）"><a href="#多选（-）" class="headerlink" title="多选（|）"></a>多选（<code>|</code>）</h4><p>【示例】匹配一个确定的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkMatches(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要匹配一个确定的字符串，非常简单，如例 1 所示。但是，如果你不确定要匹配的字符串，希望有多个选择，怎么办？答案是：使用元字符<code>|</code> ，它的含义是或。</p>
<p>【示例】匹配多个可选的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：|</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;yes|no&quot;</span>, <span class="string">&quot;yes&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;yes|no&quot;</span>, <span class="string">&quot;no&quot;</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;yes|no&quot;</span>, <span class="string">&quot;right&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// yes	matches： yes|no</span></span><br><span class="line"><span class="comment">// no	matches： yes|no</span></span><br><span class="line"><span class="comment">// right	not matches： yes|no</span></span><br></pre></td></tr></table></figure>

<h4 id="分组（-）"><a href="#分组（-）" class="headerlink" title="分组（()）"></a>分组（<code>()</code>）</h4><p>如果你希望表达式由多个子表达式组成，你可以使用 <code>()</code>。</p>
<p>【示例】匹配组合字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;(play|end)(ing|ed)&quot;</span>, <span class="string">&quot;ended&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;(play|end)(ing|ed)&quot;</span>, <span class="string">&quot;ending&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;(play|end)(ing|ed)&quot;</span>, <span class="string">&quot;playing&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;(play|end)(ing|ed)&quot;</span>, <span class="string">&quot;played&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// ended	matches： (play|end)(ing|ed)</span></span><br><span class="line"><span class="comment">// ending	matches： (play|end)(ing|ed)</span></span><br><span class="line"><span class="comment">// playing	matches： (play|end)(ing|ed)</span></span><br><span class="line"><span class="comment">// played	matches： (play|end)(ing|ed)</span></span><br></pre></td></tr></table></figure>

<h4 id="指定单字符有效范围（-）"><a href="#指定单字符有效范围（-）" class="headerlink" title="指定单字符有效范围（[]）"></a>指定单字符有效范围（<code>[]</code>）</h4><p>前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用<code>[]</code> 。</p>
<p>【示例】字符在指定范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[abc]&quot;</span>, <span class="string">&quot;b&quot;</span>));  <span class="comment">// 字符只能是a、b、c</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[a-z]&quot;</span>, <span class="string">&quot;m&quot;</span>)); <span class="comment">// 字符只能是a - z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[A-Z]&quot;</span>, <span class="string">&quot;O&quot;</span>)); <span class="comment">// 字符只能是A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[a-zA-Z]&quot;</span>, <span class="string">&quot;K&quot;</span>)); <span class="comment">// 字符只能是a - z和A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[a-zA-Z]&quot;</span>, <span class="string">&quot;k&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[0-9]&quot;</span>, <span class="string">&quot;5&quot;</span>)); <span class="comment">// 字符只能是0 - 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// b	matches： [abc]</span></span><br><span class="line"><span class="comment">// m	matches： [a-z]</span></span><br><span class="line"><span class="comment">// O	matches： [A-Z]</span></span><br><span class="line"><span class="comment">// K	matches： [a-zA-Z]</span></span><br><span class="line"><span class="comment">// k	matches： [a-zA-Z]</span></span><br><span class="line"><span class="comment">// 5	matches： [0-9]</span></span><br></pre></td></tr></table></figure>

<h4 id="指定单字符无效范围（-）"><a href="#指定单字符无效范围（-）" class="headerlink" title="指定单字符无效范围（ [^]）"></a>指定单字符无效范围（ <code>[^]</code>）</h4><p>【示例】字符不能在指定范围</p>
<p>如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用<code>[^]</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[^]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^abc]&quot;</span>, <span class="string">&quot;b&quot;</span>)); <span class="comment">// 字符不能是a、b、c</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^a-z]&quot;</span>, <span class="string">&quot;m&quot;</span>)); <span class="comment">// 字符不能是a - z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^A-Z]&quot;</span>, <span class="string">&quot;O&quot;</span>)); <span class="comment">// 字符不能是A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^a-zA-Z]&quot;</span>, <span class="string">&quot;K&quot;</span>)); <span class="comment">// 字符不能是a - z和A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^a-zA-Z]&quot;</span>, <span class="string">&quot;k&quot;</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^0-9]&quot;</span>, <span class="string">&quot;5&quot;</span>)); <span class="comment">// 字符不能是0 - 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// b	not matches： [^abc]</span></span><br><span class="line"><span class="comment">// m	not matches： [^a-z]</span></span><br><span class="line"><span class="comment">// O	not matches： [^A-Z]</span></span><br><span class="line"><span class="comment">// K	not matches： [^a-zA-Z]</span></span><br><span class="line"><span class="comment">// k	not matches： [^a-zA-Z]</span></span><br><span class="line"><span class="comment">// 5	not matches： [^0-9]</span></span><br></pre></td></tr></table></figure>

<h4 id="限制字符数量（-）"><a href="#限制字符数量（-）" class="headerlink" title="限制字符数量（{}）"></a>限制字符数量（<code>&#123;&#125;</code>）</h4><p>如果想要控制字符出现的次数，可以使用 <code>&#123;&#125;</code>。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;n&#125;</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>n 是一个非负整数。至少匹配 n 次。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<p>【示例】限制字符出现次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;n&#125;: n 是一个非负整数。匹配确定的 n 次。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1&#125;&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1&#125;&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1&#125;&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1&#125;&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,&#125;: n 是一个非负整数。至少匹配 n 次。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1,&#125;&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1,&#125;&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1,&#125;&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;1,&#125;&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,m&#125;: m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;2,5&#125;&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;2,5&#125;&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;2,5&#125;&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap&#123;2,5&#125;&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// a	not matches： ap&#123;1&#125;</span></span><br><span class="line"><span class="comment">// ap	matches： ap&#123;1&#125;</span></span><br><span class="line"><span class="comment">// app	not matches： ap&#123;1&#125;</span></span><br><span class="line"><span class="comment">// apppppppppp	not matches： ap&#123;1&#125;</span></span><br><span class="line"><span class="comment">// a	not matches： ap&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ap	matches： ap&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// app	matches： ap&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// apppppppppp	matches： ap&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// a	not matches： ap&#123;2,5&#125;</span></span><br><span class="line"><span class="comment">// ap	not matches： ap&#123;2,5&#125;</span></span><br><span class="line"><span class="comment">// app	matches： ap&#123;2,5&#125;</span></span><br><span class="line"><span class="comment">// apppppppppp	not matches： ap&#123;2,5&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="转义字符（-）"><a href="#转义字符（-）" class="headerlink" title="转义字符（/）"></a>转义字符（<code>/</code>）</h4><p>如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 的转义字符：<span class="string">\*</span></span><br><span class="line">+ 的转义字符：<span class="string">\+</span></span><br><span class="line">? 的转义字符：<span class="string">\?</span></span><br><span class="line">^ 的转义字符：<span class="string">\^</span></span><br><span class="line">$ 的转义字符：<span class="string">\$</span></span><br><span class="line">. 的转义字符：<span class="string">\.</span></span><br></pre></td></tr></table></figure>

<p>如果是转义符 <code>\</code> 本身，你需要使用 <code>\\</code> 。</p>
<h4 id="指定表达式字符串的开始（-）和结尾（-）"><a href="#指定表达式字符串的开始（-）和结尾（-）" class="headerlink" title="指定表达式字符串的开始（^）和结尾（$）"></a>指定表达式字符串的开始（<code>^</code>）和结尾（<code>$</code>）</h4><p>如果希望匹配的字符串必须以特定字符串开头，可以使用 <code>^</code> 。</p>
<blockquote>
<p>注意：请特别留意，这里的 <code>^</code> 一定要和 <code>[^]</code> 中的 <code>^</code> 区分。</p>
</blockquote>
<p>【示例】限制字符串头部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;^app[a-z]&#123;0,&#125;&quot;</span>, <span class="string">&quot;apple&quot;</span>)); <span class="comment">// 字符串必须以app开头</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;^app[a-z]&#123;0,&#125;&quot;</span>, <span class="string">&quot;aplause&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// apple	matches： ^app[a-z]&#123;0,&#125;</span></span><br><span class="line"><span class="comment">// aplause	not matches： ^app[a-z]&#123;0,&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果希望匹配的字符串必须以特定字符串结尾，可以使用 <code>$</code> 。</p>
<p>【示例】限制字符串尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;[a-z]&#123;0,&#125;ing$&quot;</span>, <span class="string">&quot;playing&quot;</span>)); <span class="comment">// 字符串必须以ing结尾</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[a-z]&#123;0,&#125;ing$&quot;</span>, <span class="string">&quot;long&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// playing	matches： [a-z]&#123;0,&#125;ing$</span></span><br><span class="line"><span class="comment">// long	not matches： [a-z]&#123;0,&#125;ing$</span></span><br></pre></td></tr></table></figure>

<h3 id="等价字符"><a href="#等价字符" class="headerlink" title="等价字符"></a>等价字符</h3><p>等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。</p>
<p>在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。</p>
<p>等价字符的好处在于简化了基本元字符的写法。</p>
<h4 id="表示某一类型字符的等价字符"><a href="#表示某一类型字符的等价字符" class="headerlink" title="表示某一类型字符的等价字符"></a>表示某一类型字符的等价字符</h4><p>下表中的等价字符都表示某一类型的字符。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.</code></strong></td>
<td>匹配除“\n”之外的任何单个字符。</td>
</tr>
<tr>
<td><strong><code>\d</code></strong></td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td><strong><code>\D</code></strong></td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td><strong><code>\w</code></strong></td>
<td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是 Unicode 字符集。</td>
</tr>
<tr>
<td><strong><code>\W</code></strong></td>
<td>匹配任何非单词字符。</td>
</tr>
<tr>
<td><strong><code>\s</code></strong></td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><strong><code>\S</code></strong></td>
<td>匹配任何可见字符。等价于[ \f\n\r\t\v]。</td>
</tr>
</tbody></table>
<p>【示例】基本等价字符的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配除“\n”之外的任何单个字符</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;.&#123;1,&#125;&quot;</span>, <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;.&#123;1,&#125;&quot;</span>, <span class="string">&quot;~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\&quot;</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;[^\n]&quot;</span>, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配一个数字字符。等价于[0-9]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;\\d&#123;1,&#125;&quot;</span>, <span class="string">&quot;0123456789&quot;</span>));</span><br><span class="line"><span class="comment">// 匹配一个非数字字符。等价于[^0-9]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;\\D&#123;1,&#125;&quot;</span>, <span class="string">&quot;0123456789&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是Unicode字符集</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;\\w&#123;1,&#125;&quot;</span>, <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_&quot;</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;\\w&#123;1,&#125;&quot;</span>, <span class="string">&quot;~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\&quot;</span>));</span><br><span class="line"><span class="comment">// 匹配任何非单词字符</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;\\W&#123;1,&#125;&quot;</span>, <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_&quot;</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;\\W&#123;1,&#125;&quot;</span>, <span class="string">&quot;~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">&quot;\\s&#123;1,&#125;&quot;</span>, <span class="string">&quot; \f\r\n\t&quot;</span>));</span><br><span class="line"><span class="comment">// 匹配任何可见字符。等价于[^ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">&quot;\\S&#123;1,&#125;&quot;</span>, <span class="string">&quot; \f\r\n\t&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： .&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	matches： .&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// \n	not matches： .</span></span><br><span class="line"><span class="comment">// \n	not matches： [^\n]</span></span><br><span class="line"><span class="comment">// 0123456789	matches： \\d&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// 0123456789	not matches： \\D&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： \\w&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	not matches： \\w&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	not matches： \\W&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// ~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	matches： \\W&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// \f\r\n\t	matches： \\s&#123;1,&#125;</span></span><br><span class="line"><span class="comment">// \f\r\n\t	not matches： \\S&#123;1,&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="限制字符数量的等价字符"><a href="#限制字符数量的等价字符" class="headerlink" title="限制字符数量的等价字符"></a>限制字符数量的等价字符</h4><p>在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - <code>&#123;&#125;</code> 。</p>
<p>此外，还有 <code>*</code>、<code>+</code>、<code>?</code> 这个三个为了简化写法而出现的等价字符，我们来认识一下。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。等价于{1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。等价于 {0,1}。</td>
</tr>
</tbody></table>
<p><strong>案例 限制字符数量的等价字符</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *: 匹配前面的子表达式零次或多次。* 等价于&#123;0,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap*&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap*&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap*&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap*&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// +: 匹配前面的子表达式一次或多次。+ 等价于 &#123;1,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap+&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap+&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap+&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap+&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 匹配前面的子表达式零次或一次。? 等价于 &#123;0,1&#125;。</span></span><br><span class="line">checkMatches(<span class="string">&quot;ap?&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap?&quot;</span>, <span class="string">&quot;ap&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap?&quot;</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">checkMatches(<span class="string">&quot;ap?&quot;</span>, <span class="string">&quot;apppppppppp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// a	matches： ap*</span></span><br><span class="line"><span class="comment">// ap	matches： ap*</span></span><br><span class="line"><span class="comment">// app	matches： ap*</span></span><br><span class="line"><span class="comment">// apppppppppp	matches： ap*</span></span><br><span class="line"><span class="comment">// a	not matches： ap+</span></span><br><span class="line"><span class="comment">// ap	matches： ap+</span></span><br><span class="line"><span class="comment">// app	matches： ap+</span></span><br><span class="line"><span class="comment">// apppppppppp	matches： ap+</span></span><br><span class="line"><span class="comment">// a	matches： ap?</span></span><br><span class="line"><span class="comment">// ap	matches： ap?</span></span><br><span class="line"><span class="comment">// app	not matches： ap?</span></span><br><span class="line"><span class="comment">// apppppppppp	not matches： ap?</span></span><br></pre></td></tr></table></figure>

<h4 id="元字符优先级顺序"><a href="#元字符优先级顺序" class="headerlink" title="元字符优先级顺序"></a>元字符优先级顺序</h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>()</code>、<code>(?:)</code>、<code>(?=)</code>、<code>[]</code></td>
<td>括号和中括号</td>
</tr>
<tr>
<td><code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code></td>
<td>限定符</td>
</tr>
<tr>
<td><code>^</code>、<code>$</code>、<code>*任何字符</code>、<code>任何字符*</code></td>
<td>定位点和序列</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96;</td>
</tr>
</tbody></table>
<p>字符具有高于替换运算符的优先级，使得 <code>m|food</code> 匹配 <code>m</code> 或 <code>food</code> 。若要匹配 <code>mood</code> 或 <code>food</code> ，请使用括号创建子表达式，从而产生 <code>(m|f)ood</code> 。</p>
<h2 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a>分组构造</h2><p>在基本元字符章节，提到了 <code>()</code> 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。</p>
<p>所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。</p>
<h3 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h3><p>下表为分组构造中的捕获和非捕获分类。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>捕获或非捕获</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的反向引用</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>零宽度正预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>零宽度负预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>零宽度正回顾后发断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>零宽度负回顾后发断言</td>
<td>非捕获</td>
</tr>
</tbody></table>
<blockquote>
<p>注：Java 正则引擎不支持平衡组。</p>
</blockquote>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><h5 id="带编号的反向引用"><a href="#带编号的反向引用" class="headerlink" title="带编号的反向引用"></a>带编号的反向引用</h5><p>带编号的反向引用使用以下语法：<code>\number</code></p>
<p>其中<em>number</em> 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 如果正则表达式模式中未定义<em>number</em>，则将发生分析错误</p>
<p><strong>【示例】匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (\w+)\s\1\W(\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(\\w+)\\s\\1\\W(\\w+)&quot;</span>,</span><br><span class="line">		<span class="string">&quot;He said that that was the the correct answer.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = (\w+)\s\1\W(\w+), content: He said that that was the the correct answer.</span></span><br><span class="line"><span class="comment">// [1th] start: 8, end: 21, group: that that was</span></span><br><span class="line"><span class="comment">// [2th] start: 22, end: 37, group: the the correct</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>(\w+)</code>：匹配一个或多个单词字符。</li>
<li><code>\s</code>：与空白字符匹配。</li>
<li><code>\1</code>：匹配第一个组，即(\w+)。</li>
<li><code>\W</code>：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</li>
</ul>
<h4 id="命名的反向引用"><a href="#命名的反向引用" class="headerlink" title="命名的反向引用"></a>命名的反向引用</h4><p>命名后向引用通过使用下面的语法进行定义：<code>\k&lt;name &gt;</code></p>
<p><strong>【示例】匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?&lt;duplicateWord&gt;\\w+)\\s\\k&lt;duplicateWord&gt;\\W(?&lt;nextWord&gt;\\w+)&quot;</span>,</span><br><span class="line">		<span class="string">&quot;He said that that was the the correct answer.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+), content: He said that that was the the correct answer.</span></span><br><span class="line"><span class="comment">// [1th] start: 8, end: 21, group: that that was</span></span><br><span class="line"><span class="comment">// [2th] start: 22, end: 37, group: the the correct</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>(?&lt;duplicateWord&gt;\w+)</code>：匹配一个或多个单词字符。 命名此捕获组 duplicateWord。</li>
<li><code>\s</code>: 与空白字符匹配。</li>
<li><code>\k&lt;duplicateWord&gt;</code>：匹配名为 duplicateWord 的捕获的组。</li>
<li><code>\W</code>：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</li>
<li><code>(?&lt;nextWord&gt;\w+)</code>：匹配一个或多个单词字符。 命名此捕获组 nextWord。</li>
</ul>
<h3 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h3><p><code>(?:exp)</code> 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</p>
<p><strong>【示例】匹配以.结束的语句。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配由句号终止的语句。</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?:\\b(?:\\w+)\\W*)+\\.&quot;</span>, <span class="string">&quot;This is a short sentence. Never end&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = (?:\b(?:\w+)\W*)+\., content: This is a short sentence. Never end</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 25, group: This is a short sentence.</span></span><br></pre></td></tr></table></figure>

<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置</td>
</tr>
</tbody></table>
<h4 id="匹配-exp-前面的位置"><a href="#匹配-exp-前面的位置" class="headerlink" title="匹配 exp 前面的位置"></a>匹配 exp 前面的位置</h4><p><code>(?=exp)</code> 表示输入字符串必须匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \b\w+(?=\sis\b) 表示要捕获is之前的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;\\b\\w+(?=\\sis\\b)&quot;</span>, <span class="string">&quot;The dog is a Malamute.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">&quot;\\b\\w+(?=\\sis\\b)&quot;</span>, <span class="string">&quot;The island has beautiful birds.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">&quot;\\b\\w+(?=\\sis\\b)&quot;</span>, <span class="string">&quot;The pitch missed home plate.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;\\b\\w+(?=\\sis\\b)&quot;</span>, <span class="string">&quot;Sunday is a weekend day.&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = \b\w+(?=\sis\b), content: The dog is a Malamute.</span></span><br><span class="line"><span class="comment">// [1th] start: 4, end: 7, group: dog</span></span><br><span class="line"><span class="comment">// regex = \b\w+(?=\sis\b), content: The island has beautiful birds.</span></span><br><span class="line"><span class="comment">// not found</span></span><br><span class="line"><span class="comment">// regex = \b\w+(?=\sis\b), content: The pitch missed home plate.</span></span><br><span class="line"><span class="comment">// not found</span></span><br><span class="line"><span class="comment">// regex = \b\w+(?=\sis\b), content: Sunday is a weekend day.</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 6, group: Sunday</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>\b</code>：在单词边界处开始匹配。</li>
<li><code>\w+</code>：匹配一个或多个单词字符。</li>
<li><code>(?=\sis\b)</code>：确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。 如果如此，则匹配成功。</li>
</ul>
<h4 id="匹配-exp-后面的位置"><a href="#匹配-exp-后面的位置" class="headerlink" title="匹配 exp 后面的位置"></a>匹配 exp 后面的位置</h4><p><code>(?&lt;=exp)</code> 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;=\b20)\d&#123;2&#125;\b 表示要捕获以20开头的数字的后面部分</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?&lt;=\\b20)\\d&#123;2&#125;\\b&quot;</span>, <span class="string">&quot;2010 1999 1861 2140 2009&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = (?&lt;=\b20)\d&#123;2&#125;\b, content: 2010 1999 1861 2140 2009</span></span><br><span class="line"><span class="comment">// [1th] start: 2, end: 4, group: 10</span></span><br><span class="line"><span class="comment">// [2th] start: 22, end: 24, group: 09</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>\d&#123;2&#125;</code>：匹配两个十进制数字。</li>
<li><code>&#123;?&lt;=\b20)</code>：如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。</li>
<li><code>\b</code>：在单词边界处结束匹配。</li>
</ul>
<h4 id="匹配后面跟的不是-exp-的位置"><a href="#匹配后面跟的不是-exp-的位置" class="headerlink" title="匹配后面跟的不是 exp 的位置"></a>匹配后面跟的不是 exp 的位置</h4><p><code>(?!exp)</code> 表示输入字符串不得匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<p>【示例】捕获未以“un”开头的单词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \b(?!un)\w+\b 表示要捕获未以“un”开头的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;\\b(?!un)\\w+\\b&quot;</span>, <span class="string">&quot;unite one unethical ethics use untie ultimate&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = \b(?!un)\w+\b, content: unite one unethical ethics use untie ultimate</span></span><br><span class="line"><span class="comment">// [1th] start: 6, end: 9, group: one</span></span><br><span class="line"><span class="comment">// [2th] start: 20, end: 26, group: ethics</span></span><br><span class="line"><span class="comment">// [3th] start: 27, end: 30, group: use</span></span><br><span class="line"><span class="comment">// [4th] start: 37, end: 45, group: ultimate</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>\b</code>：在单词边界处开始匹配。</li>
<li><code>(?!un)</code>：确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。</li>
<li><code>\w+</code>：匹配一个或多个单词字符。</li>
<li><code>\b</code>：在单词边界处结束匹配。</li>
</ul>
<h4 id="匹配前面不是-exp-的位置"><a href="#匹配前面不是-exp-的位置" class="headerlink" title="匹配前面不是 exp 的位置"></a>匹配前面不是 exp 的位置</h4><p><code>(?&lt;!exp)</code> 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。</p>
<p>【示例】捕获任意工作日</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b 表示要捕获任意工作日（即周一到周五）</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b&quot;</span>, <span class="string">&quot;Monday February 1, 2010&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b&quot;</span>, <span class="string">&quot;Wednesday February 3, 2010&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">&quot;(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b&quot;</span>, <span class="string">&quot;Saturday February 6, 2010&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">&quot;(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b&quot;</span>, <span class="string">&quot;Sunday February 7, 2010&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b&quot;</span>, <span class="string">&quot;Monday, February 8, 2010&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday February 1, 2010</span></span><br><span class="line"><span class="comment">// [1th] start: 7, end: 23, group: February 1, 2010</span></span><br><span class="line"><span class="comment">// regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Wednesday February 3, 2010</span></span><br><span class="line"><span class="comment">// [1th] start: 10, end: 26, group: February 3, 2010</span></span><br><span class="line"><span class="comment">// regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Saturday February 6, 2010</span></span><br><span class="line"><span class="comment">// not found</span></span><br><span class="line"><span class="comment">// regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Sunday February 7, 2010</span></span><br><span class="line"><span class="comment">// not found</span></span><br><span class="line"><span class="comment">// regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday, February 8, 2010</span></span><br><span class="line"><span class="comment">// [1th] start: 8, end: 24, group: February 8, 2010</span></span><br></pre></td></tr></table></figure>

<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复 1 次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复 0 次或 1 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;?</code></td>
<td>重复 n 到 m 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,&#125;?</code></td>
<td>重复 n 次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<p>【示例】Java 正则中贪婪与懒惰的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w*b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w*?b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w+?b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w??b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w&#123;0,4&#125;?b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">&quot;a\\w&#123;3,&#125;?b&quot;</span>, <span class="string">&quot;abaabaaabaaaab&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// regex = a\w*b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 14, group: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// regex = a\w*?b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 2, group: ab</span></span><br><span class="line"><span class="comment">// [2th] start: 2, end: 5, group: aab</span></span><br><span class="line"><span class="comment">// [3th] start: 5, end: 9, group: aaab</span></span><br><span class="line"><span class="comment">// [4th] start: 9, end: 14, group: aaaab</span></span><br><span class="line"><span class="comment">// regex = a\w+?b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 5, group: abaab</span></span><br><span class="line"><span class="comment">// [2th] start: 5, end: 9, group: aaab</span></span><br><span class="line"><span class="comment">// [3th] start: 9, end: 14, group: aaaab</span></span><br><span class="line"><span class="comment">// regex = a\w??b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 2, group: ab</span></span><br><span class="line"><span class="comment">// [2th] start: 2, end: 5, group: aab</span></span><br><span class="line"><span class="comment">// [3th] start: 6, end: 9, group: aab</span></span><br><span class="line"><span class="comment">// [4th] start: 11, end: 14, group: aab</span></span><br><span class="line"><span class="comment">// regex = a\w&#123;0,4&#125;?b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 2, group: ab</span></span><br><span class="line"><span class="comment">// [2th] start: 2, end: 5, group: aab</span></span><br><span class="line"><span class="comment">// [3th] start: 5, end: 9, group: aaab</span></span><br><span class="line"><span class="comment">// [4th] start: 9, end: 14, group: aaaab</span></span><br><span class="line"><span class="comment">// regex = a\w&#123;3,&#125;?b, content: abaabaaabaaaab</span></span><br><span class="line"><span class="comment">// [1th] start: 0, end: 5, group: abaab</span></span><br><span class="line"><span class="comment">// [2th] start: 5, end: 14, group: aaabaaaab</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串 <code>abaabaaabaaaab</code> 中匹配<strong>以 <code>a</code> 开头，以 <code>b</code> 结尾的所有子字符串</strong>。请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。</p>
<h2 id="正则附录"><a href="#正则附录" class="headerlink" title="正则附录"></a>正则附录</h2><h3 id="匹配正则字符串的方法"><a href="#匹配正则字符串的方法" class="headerlink" title="匹配正则字符串的方法"></a>匹配正则字符串的方法</h3><p>由于正则表达式中很多元字符本身就是转义字符，在 Java 字符串的规则中不会被显示出来。</p>
<p>为此，可以使用一个工具类<code>org.apache.commons.lang3.StringEscapeUtils</code>来做特殊处理，使得转义字符可以打印。这个工具类提供的都是静态方法，从方法命名大致也可以猜出用法，这里不多做说明。</p>
<p>如果你了解 maven，可以直接引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>【示例】本文为了展示正则匹配规则用到的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkMatches</span><span class="params">(String regex, String content)</span> &#123;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> m.matches();</span><br><span class="line">	<span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">		System.out.println(StringEscapeUtils.escapeJava(content) + <span class="string">&quot;\tmatches： &quot;</span> + StringEscapeUtils.escapeJava(regex));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(StringEscapeUtils.escapeJava(content) + <span class="string">&quot;\tnot matches： &quot;</span> + StringEscapeUtils.escapeJava(regex));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findAll</span><span class="params">(String regex, String content)</span> &#123;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line">	System.out.println(<span class="string">&quot;regex = &quot;</span> + regex + <span class="string">&quot;, content: &quot;</span> + content);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">		count++;</span><br><span class="line">		System.out.println(<span class="string">&quot;[&quot;</span> + count + <span class="string">&quot;th] &quot;</span> + <span class="string">&quot;start: &quot;</span> + m.start() + <span class="string">&quot;, end: &quot;</span> + m.end()</span><br><span class="line">				+ <span class="string">&quot;, group: &quot;</span> + m.group());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;not found&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="速查元字符字典"><a href="#速查元字符字典" class="headerlink" title="速查元字符字典"></a>速查元字符字典</h3><p>为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。</p>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>n 是一个非负整数。至少匹配 n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*‘。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。</td>
</tr>
</tbody></table>
<h4 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h4><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\cx</code></td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式。()中的内容就是子表达式。</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的子表达式（反向引用）。</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置。</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置。</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置。</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置。</td>
</tr>
</tbody></table>
<h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td><code>|</code></td>
<td>指明两项之间的一个选择。</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配方括号范围内的任意一个字符。形式如：[xyz]、[^xyz]、[a-z]、[^a-z]、[x,y,z]</td>
</tr>
</tbody></table>
<h2 id="正则实战"><a href="#正则实战" class="headerlink" title="正则实战"></a>正则实战</h2><p>虽然本系列洋洋洒洒的大谈特谈正则表达式。但是我还是要在这里建议，如果一个正则表达式没有经过充分测试，还是要谨慎使用。</p>
<p>正则是把双刃剑，它可以为你节省大量的代码行。但是由于它不易阅读，维护起来可是头疼的哦（你需要一个字符一个字符的去理解）。</p>
<h3 id="最实用的正则"><a href="#最实用的正则" class="headerlink" title="最实用的正则"></a>最实用的正则</h3><h4 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h4><p>校验字符串中只能有中文字符（不包括中文标点符号）。中文字符的 Unicode 编码范围是 <code>\u4e00</code> 到 <code>\u9fa5</code>。</p>
<blockquote>
<p>如有兴趣，可以参考<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=3xi0vmvCIGKQLJZdn_BYhQ1IDFsoSJMrya6_eOjCBb7A6cRIW-zhZFLC9Yh8wjxU6A_HCfNuP8FBBXU9CN3Wcq"><strong>百度百科-Unicode</strong></a> 。</p>
</blockquote>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="symbol">\u4e00</span>-<span class="symbol">\u9fa5</span>]+$</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>匹配：</strong> 春眠不觉晓</li>
<li><strong>不匹配：</strong>春眠不觉晓，</li>
</ul>
<h4 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h4><p>身份证为 15 位或 18 位。15 位是第一代身份证。从 1999 年 10 月 1 日起，全国实行公民身份证号码制度，居民身份证编号由原 15 位升至 18 位。</p>
<ul>
<li><strong>15 位身份证</strong>：由 15 位数字组成。排列顺序从左至右依次为：六位数字地区码；六位数字出生日期；三位顺序号，其中 15 位男为单数，女为双数。</li>
<li><strong>18 位身份证</strong>：由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地区码；八位数字出生日期；三位数字顺序码和一位数字校验码（也可能是 X）。</li>
</ul>
<blockquote>
<p>身份证号含义详情请见：<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=5mYlYNE0RsSe2D4tydajtiaR8hAm4pPZ0FHSPuQ05N4f6H-i7qPuw7sY5KfNuiOVJWVWZvU4gf3IY-vIcKdP1CU4Fv-9pKmFQB50qGv_hZT2dkGbkd9--8_saY7omV80vEw9ixVeEwda37fHswfmtyU4QSiBG5s3K5K-JnYr1dqNlPu0f3t008UcLh5-wyID"><strong>百度百科-居民身份证号码</strong></a></p>
</blockquote>
<p><strong>地区码（6 位）</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1<span class="comment">[1-5]</span>|2<span class="comment">[1-3]</span>|3<span class="comment">[1-7]</span>|4<span class="comment">[1-3]</span>|5<span class="comment">[0-4]</span>|6<span class="comment">[1-5]</span>)\d&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出生日期（8 位）</strong></p>
<p>注：下面的是 18 位身份证的有效出生日期，如果是 15 位身份证，只要将第一个\d{4}改为\d{2}即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((\d&#123;<span class="number">4</span>&#125;((<span class="name">0</span>[<span class="name">13578</span>]|<span class="number">1</span>[<span class="name">02</span>])(<span class="name">0</span>[<span class="name">1-9</span>]|[<span class="name">12</span>]\d|<span class="number">3</span>[<span class="name">01</span>])|(<span class="name">0</span>[<span class="name">13456789</span>]|<span class="number">1</span>[<span class="name">012</span>])(<span class="name">0</span>[<span class="name">1-9</span>]|[<span class="name">12</span>]\d|<span class="number">30</span>)|<span class="number">02</span>(<span class="name">0</span>[<span class="name">1-9</span>]|<span class="number">1</span>\d|<span class="number">2</span>[<span class="name">0-8</span>])))|([<span class="name">02468</span>][<span class="name">048</span>]|[<span class="name">13579</span>][<span class="name">26</span>])<span class="number">0229</span>)</span><br></pre></td></tr></table></figure>

<p><strong>15 位有效身份证</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((1<span class="comment">[1-5]</span>|2<span class="comment">[1-3]</span>|3<span class="comment">[1-7]</span>|4<span class="comment">[1-3]</span>|5<span class="comment">[0-4]</span>|6<span class="comment">[1-5]</span>)\d&#123;4&#125;)((\d&#123;2&#125;((0<span class="comment">[13578]</span>|1<span class="comment">[02]</span>)(0<span class="comment">[1-9]</span>|<span class="comment">[12]</span>\d|3<span class="comment">[01]</span>)|(0<span class="comment">[13456789]</span>|1<span class="comment">[012]</span>)(0<span class="comment">[1-9]</span>|<span class="comment">[12]</span>\d|30)|02(0<span class="comment">[1-9]</span>|1\d|2<span class="comment">[0-8]</span>)))|(<span class="comment">[02468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)0229)(\d&#123;3&#125;)$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>110001700101031</p>
</li>
<li><p><strong>不匹配：</strong>110001701501031</p>
</li>
</ul>
<p><strong>18 位有效身份证</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((1<span class="comment">[1-5]</span>|2<span class="comment">[1-3]</span>|3<span class="comment">[1-7]</span>|4<span class="comment">[1-3]</span>|5<span class="comment">[0-4]</span>|6<span class="comment">[1-5]</span>)\d&#123;4&#125;)((\d&#123;4&#125;((0<span class="comment">[13578]</span>|1<span class="comment">[02]</span>)(0<span class="comment">[1-9]</span>|<span class="comment">[12]</span>\d|3<span class="comment">[01]</span>)|(0<span class="comment">[13456789]</span>|1<span class="comment">[012]</span>)(0<span class="comment">[1-9]</span>|<span class="comment">[12]</span>\d|30)|02(0<span class="comment">[1-9]</span>|1\d|2<span class="comment">[0-8]</span>)))|(<span class="comment">[02468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)0229)(\d&#123;3&#125;(\d|X))$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>110001199001010310 | 11000019900101015X</p>
</li>
<li><p><strong>不匹配：</strong>990000199001010310 | 110001199013010310</p>
</li>
</ul>
<h4 id="校验有效用户名、密码"><a href="#校验有效用户名、密码" class="headerlink" title="校验有效用户名、密码"></a>校验有效用户名、密码</h4><p><strong>描述：</strong>长度为 6-18 个字符，允许输入字母、数字、下划线，首字符必须为字母。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">^[a-zA-Z]\w</span><span class="template-variable">&#123;5,17&#125;</span><span class="language-xml">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong><a href="mailto:&#104;&#x65;&#95;&#x6c;&#108;&#111;&#64;&#119;&#x6f;&#114;&#x6c;&#x2e;&#x64;&#x2e;&#x63;&#x6f;&#x6d;">&#104;&#x65;&#95;&#x6c;&#108;&#111;&#64;&#119;&#x6f;&#114;&#x6c;&#x2e;&#x64;&#x2e;&#x63;&#x6f;&#x6d;</a> | <a href="mailto:&#104;&#101;&#x6c;&#46;&#108;&#x2d;&#111;&#64;&#119;&#111;&#x72;&#45;&#x6c;&#100;&#46;&#109;&#x75;&#115;&#x65;&#x75;&#109;">&#104;&#101;&#x6c;&#46;&#108;&#x2d;&#111;&#64;&#119;&#111;&#x72;&#45;&#x6c;&#100;&#46;&#109;&#x75;&#115;&#x65;&#x75;&#109;</a> | <a href="mailto:&#104;&#x31;&#x65;&#108;&#108;&#111;&#x40;&#x31;&#x32;&#x33;&#46;&#x63;&#111;&#109;">&#104;&#x31;&#x65;&#108;&#108;&#111;&#x40;&#x31;&#x32;&#x33;&#46;&#x63;&#111;&#109;</a></p>
</li>
<li><p><strong>不匹配：</strong><a href="mailto:&#104;&#x65;&#108;&#x6c;&#x6f;&#x40;&#119;&#111;&#114;&#x6c;&#x5f;&#x64;&#46;&#x63;&#x6f;&#109;">&#104;&#x65;&#108;&#x6c;&#x6f;&#x40;&#119;&#111;&#114;&#x6c;&#x5f;&#x64;&#46;&#x63;&#x6f;&#109;</a> | he&amp;<a href="mailto:&#108;&#x6c;&#x6f;&#x40;&#119;&#111;&#114;&#108;&#100;&#46;&#x63;&#111;&#x31;">&#108;&#x6c;&#x6f;&#x40;&#119;&#111;&#114;&#108;&#100;&#46;&#x63;&#111;&#x31;</a> | .hello@wor#.co.uk</p>
</li>
</ul>
<h4 id="校验邮箱"><a href="#校验邮箱" class="headerlink" title="校验邮箱"></a>校验邮箱</h4><p><strong>描述：</strong>不允许使用 IP 作为域名，如 : <a href="mailto:&#104;&#101;&#108;&#x6c;&#111;&#64;&#49;&#x35;&#x34;&#x2e;&#49;&#52;&#x35;&#x2e;&#54;&#x38;&#46;&#49;&#x32;">&#104;&#101;&#108;&#x6c;&#111;&#64;&#49;&#x35;&#x34;&#x2e;&#49;&#52;&#x35;&#x2e;&#54;&#x38;&#46;&#49;&#x32;</a></p>
<p><code>@</code>符号前的邮箱用户和<code>.</code>符号前的域名(domain)必须满足以下条件：</p>
<ul>
<li>字符只能是英文字母、数字、下划线<code>_</code>、<code>.</code>、<code>-</code> ；</li>
<li>首字符必须为字母或数字；</li>
<li><code>_</code>、<code>.</code>、<code>-</code> 不能连续出现。</li>
</ul>
<p>域名的根域只能为字母，且至少为两个字符。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="comment">[A-Za-z0-9]</span>((<span class="comment">[_\.\-]</span>?<span class="comment">[a-zA-Z0-9]</span>+)*)@(<span class="comment">[A-Za-z0-9]</span>+)((<span class="comment">[\.\-]</span>?<span class="comment">[a-zA-Z0-9]</span>+)*)\.(<span class="comment">[A-Za-z]</span>&#123;2,&#125;)$</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>匹配：</strong><a href="mailto:&#x68;&#x65;&#x5f;&#x6c;&#108;&#x6f;&#x40;&#x77;&#x6f;&#114;&#108;&#46;&#100;&#x2e;&#x63;&#x6f;&#109;">&#x68;&#x65;&#x5f;&#x6c;&#108;&#x6f;&#x40;&#x77;&#x6f;&#114;&#108;&#46;&#100;&#x2e;&#x63;&#x6f;&#109;</a> | <a href="mailto:&#104;&#101;&#x6c;&#x2e;&#108;&#x2d;&#x6f;&#x40;&#x77;&#x6f;&#x72;&#x2d;&#x6c;&#x64;&#x2e;&#109;&#x75;&#115;&#x65;&#x75;&#109;">&#104;&#101;&#x6c;&#x2e;&#108;&#x2d;&#x6f;&#x40;&#x77;&#x6f;&#x72;&#x2d;&#x6c;&#x64;&#x2e;&#109;&#x75;&#115;&#x65;&#x75;&#109;</a> | <a href="mailto:&#x68;&#49;&#x65;&#x6c;&#x6c;&#111;&#64;&#49;&#x32;&#x33;&#x2e;&#99;&#111;&#109;">&#x68;&#49;&#x65;&#x6c;&#x6c;&#111;&#64;&#49;&#x32;&#x33;&#x2e;&#99;&#111;&#109;</a></li>
<li><strong>不匹配：</strong><a href="mailto:&#x68;&#x65;&#108;&#108;&#111;&#64;&#x77;&#111;&#x72;&#108;&#x5f;&#x64;&#x2e;&#x63;&#111;&#109;">&#x68;&#x65;&#108;&#108;&#111;&#64;&#x77;&#111;&#x72;&#108;&#x5f;&#x64;&#x2e;&#x63;&#111;&#109;</a> | he&amp;<a href="mailto:&#108;&#108;&#x6f;&#x40;&#119;&#x6f;&#114;&#x6c;&#100;&#x2e;&#99;&#x6f;&#x31;">&#108;&#108;&#x6f;&#x40;&#119;&#x6f;&#114;&#x6c;&#100;&#x2e;&#99;&#x6f;&#x31;</a> | .hello@wor#.co.uk</li>
</ul>
<h4 id="校验-URL"><a href="#校验-URL" class="headerlink" title="校验 URL"></a>校验 URL</h4><p><strong>描述：</strong>校验 URL。支持 http、https、ftp、ftps。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(ht|<span class="params">f)(tp</span>|tps)\<span class="symbol">://</span>[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>\-\.]+\.([a-zA-Z]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;)<span class="string">?(</span>/\S*)<span class="string">?$</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong><a target="_blank" rel="noopener" href="http://google.com/help/me">http://google.com/help/me</a> | <a target="_blank" rel="noopener" href="http://www.google.com/help/me/">http://www.google.com/help/me/</a> | <a target="_blank" rel="noopener" href="https://www.google.com/help.asp">https://www.google.com/help.asp</a> | <a href="ftp://www.google.com/">ftp://www.google.com</a> | ftps:&#x2F;&#x2F;google.org</p>
</li>
<li><p><strong>不匹配：</strong><a target="_blank" rel="noopener" href="http://un/www.google.com/index.asp">http://un/www.google.com/index.asp</a></p>
</li>
</ul>
<h4 id="校验时间"><a href="#校验时间" class="headerlink" title="校验时间"></a>校验时间</h4><p><strong>描述：</strong>校验时间。时、分、秒必须是有效数字，如果数值不是两位数，十位需要补零。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="comment">[0-1]</span><span class="comment">[0-9]</span>|<span class="comment">[2]</span><span class="comment">[0-3]</span>):(<span class="comment">[0-5]</span><span class="comment">[0-9]</span>)$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>00:00:00 | 23:59:59 | 17:06:30</p>
</li>
<li><p><strong>不匹配：</strong>17:6:30 | 24:16:30</p>
</li>
</ul>
<h4 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h4><p><strong>描述：</strong>校验日期。日期满足以下条件：</p>
<ul>
<li>格式 yyyy-MM-dd 或 yyyy-M-d</li>
<li>连字符可以没有或是“-”、“&#x2F;”、“.”之一</li>
<li>闰年的二月可以有 29 日；而平年不可以。</li>
<li>一、三、五、七、八、十、十二月为 31 日。四、六、九、十一月为 30 日。</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!0000)<span class="comment">[0-9]</span>&#123;4&#125;(<span class="comment">[-/.]</span>?)(?:(?:0?<span class="comment">[1-9]</span>|1<span class="comment">[0-2]</span>)\1(?:0?<span class="comment">[1-9]</span>|1<span class="comment">[0-9]</span>|2<span class="comment">[0-8]</span>)|(?:0?<span class="comment">[13-9]</span>|1<span class="comment">[0-2]</span>)\1(?:29|30)|(?:0?<span class="comment">[13578]</span>|1<span class="comment">[02]</span>)\1(?:31))|(?:<span class="comment">[0-9]</span>&#123;2&#125;(?:0<span class="comment">[48]</span>|<span class="comment">[2468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)|(?:0<span class="comment">[48]</span>|<span class="comment">[2468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)00)(<span class="comment">[-/.]</span>?)0?2\2(?:29))$</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>匹配：</strong>2016&#x2F;1&#x2F;1 | 2016&#x2F;01&#x2F;01 | 20160101 | 2016-01-01 | 2016.01.01 | 2000-02-29</li>
<li><strong>不匹配：</strong>2001-02-29 | 2016&#x2F;12&#x2F;32 | 2016&#x2F;6&#x2F;31 | 2016&#x2F;13&#x2F;1 | 2016&#x2F;0&#x2F;1</li>
</ul>
<h4 id="校验中国手机号码"><a href="#校验中国手机号码" class="headerlink" title="校验中国手机号码"></a>校验中国手机号码</h4><p><strong>描述：</strong>中国手机号码正确格式：11 位数字。</p>
<blockquote>
<p>移动有 16 个号段：134、135、136、137、138、139、147、150、151、152、157、158、159、182、187、188。其中 147、157、188 是 3G 号段，其他都是 2G 号段。联通有 7 种号段：130、131、132、155、156、185、186。其中 186 是 3G（WCDMA）号段，其余为 2G 号段。电信有 4 个号段：133、153、180、189。其中 189 是 3G 号段（CDMA2000），133 号段主要用作无线网卡号。总结：13 开头手机号 0-9；15 开头手机号 0-3、5-9；18 开头手机号 0、2、5-9。</p>
<p>此外，中国在国际上的区号为 86，所以手机号开头有+86、86 也是合法的。</p>
<p>以上信息来源于 <a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=Bia2K_f8rGcakOlP4d9m_-DNSgXU5-0NDP0pPavS0ZbhRHQcUFUTbMERjdO4u7cvkpTJaIDeUXq_EXWnMqXMdSuMQDX3NAbZXAlZYl_V18KATWF7y1EFzUyJ62rf3bAN"><strong>百度百科-手机号</strong></a></p>
</blockquote>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((\+)?86\s*)?((13<span class="comment">[0-9]</span>)|(15(<span class="comment">[0-3]</span>|<span class="comment">[5-9]</span>))|(18<span class="comment">[0,2,5-9]</span>))\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>+86 18012345678 | 86 18012345678 | 15812345678</p>
</li>
<li><p><strong>不匹配：</strong>15412345678 | 12912345678 | 180123456789</p>
</li>
</ul>
<h4 id="校验中国固话号码"><a href="#校验中国固话号码" class="headerlink" title="校验中国固话号码"></a>校验中国固话号码</h4><p><strong>描述：</strong>固话号码，必须加区号（以 0 开头）。<br>3 位有效区号：010、020~029，固话位数为 8 位。<br>4 位有效区号：03xx 开头到 09xx，固话位数为 7。</p>
<blockquote>
<p>如果想了解更详细的信息，请参考 <a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=sX8JoxK1ja5uM5pDYvQe27_QsyqAZ_78DLSeEvwjqtG_uXqU6p5Oh7CPbImNbnwu1ClOmD8udgDIswZfYzQIw0z3BYZO3eTplvVDzieuowTYqt7yHGDAqyT7o4vvGhg4"><strong>百度百科-电话区号</strong></a> 。</p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="number">010</span>|<span class="type">02</span>[<span class="number">0</span><span class="number">-9</span>])(\s|<span class="type">-)\d</span>&#123;<span class="number">8</span>&#125;|<span class="type">(0</span>[<span class="number">3</span><span class="number">-9</span>]\d&#123;<span class="number">2</span>&#125;)(\s|<span class="type">-)\d</span>&#123;<span class="number">7</span>&#125;$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>010-12345678 | 010 12345678 | 0512-1234567 | 0512 1234567</p>
</li>
<li><p><strong>不匹配：</strong>1234567 | 12345678</p>
</li>
</ul>
<h4 id="校验-IPv4-地址"><a href="#校验-IPv4-地址" class="headerlink" title="校验 IPv4 地址"></a>校验 IPv4 地址</h4><p><strong>描述：</strong>IP 地址是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”（也就是 4 个字节）。IP 地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="comment">[01]</span>?\d\d?|2<span class="comment">[0-4]</span>\d|25<span class="comment">[0-5]</span>)\.(<span class="comment">[01]</span>?\d\d?|2<span class="comment">[0-4]</span>\d|25<span class="comment">[0-5]</span>)\.(<span class="comment">[01]</span>?\d\d?|2<span class="comment">[0-4]</span>\d|25<span class="comment">[0-5]</span>)\.(<span class="comment">[01]</span>?\d\d?|2<span class="comment">[0-4]</span>\d|25<span class="comment">[0-5]</span>)$</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>0.0.0.0 | 255.255.255.255 | 127.0.0.1</p>
</li>
<li><p><strong>不匹配：</strong>10.10.10 | 10.10.10.256</p>
</li>
</ul>
<h4 id="校验-IPv6-地址"><a href="#校验-IPv6-地址" class="headerlink" title="校验 IPv6 地址"></a>校验 IPv6 地址</h4><p><strong>描述：</strong>IPv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。</p>
<p>IPv6 地址可以表示为以下形式：</p>
<ul>
<li>IPv6 地址</li>
<li>零压缩 IPv6 地址(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5952#section-2.2">section 2.2 of rfc5952</a>)</li>
<li>带有本地链接区域索引的 IPv6 地址 (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4007#section-11">section 11 of rfc4007</a>)</li>
<li>嵌入 IPv4 的 IPv6 地址(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6052#section-2">section 2 of rfc6052</a></li>
<li>映射 IPv4 的 IPv6 地址 (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2765#section-2.1">section 2.1 of rfc2765</a>)</li>
<li>翻译 IPv4 的 IPv6 地址 (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2765#section-2.1">section 2.1 of rfc2765</a>)</li>
</ul>
<blockquote>
<p>显然，IPv6 地址的表示方式很复杂。你也可以参考：</p>
<p><a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=D3nmh0q_G_ZVmxXFG79mjjNfT4hs9fwjqUgygh-tvhq43KYqx88HV27WEXmoT4nA4iGzXwXMm5L-j50C2gSL5q"><strong>百度百科-IPv6</strong></a></p>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses"><strong>Stack overflow 上的 IPv6 正则表达高票答案</strong></a></p>
</blockquote>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|fe80:(<span class="name">:</span>[<span class="name">0-9a-fA-F</span>]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="name">0-9a-zA-Z</span>]&#123;<span class="number">1</span>,&#125;|::(<span class="name">ffff</span>(<span class="name">:0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="name">25</span>[<span class="name">0-5</span>]|(<span class="name">2</span>[<span class="name">0-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="name">25</span>[<span class="name">0-5</span>]|(<span class="name">2</span>[<span class="name">0-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])|([<span class="name">0-9a-fA-F</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="name">25</span>[<span class="name">0-5</span>]|(<span class="name">2</span>[<span class="name">0-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="name">25</span>[<span class="name">0-5</span>]|(<span class="name">2</span>[<span class="name">0-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="name">0-9</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>匹配：</strong>1:2:3:4:5:6:7:8 | 1:: | 1::8 | 1::6:7:8 | 1::5:6:7:8 | 1::4:5:6:7:8 | 1::3:4:5:6:7:8 | ::2:3:4:5:6:7:8 | 1:2:3:4:5:6:7:: | 1:2:3:4:5:6::8 | 1:2:3:4:5::8 | 1:2:3:4::8 | 1:2:3::8 | 1:2::8 | 1::8 | ::8 | fe80::7:8%1 | ::255.255.255.255 | 2001:db8:3:4::192.0.2.33 | 64:ff9b::192.0.2.33</p>
</li>
<li><p><strong>不匹配：</strong>1.2.3.4.5.6.7.8 | 1::2::3</p>
</li>
</ul>
<h3 id="特定字符"><a href="#特定字符" class="headerlink" title="特定字符"></a>特定字符</h3><ul>
<li>匹配长度为 3 的字符串：<code>^.&#123;3&#125;$</code>。</li>
<li>匹配由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code>。</li>
<li>匹配由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code>。</li>
<li>匹配由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code>。</li>
<li>匹配由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code>。</li>
<li>匹配由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$</code>。</li>
</ul>
<h3 id="特定数字"><a href="#特定数字" class="headerlink" title="特定数字"></a>特定数字</h3><ul>
<li>匹配正整数：<code>^[1-9]\d*$</code></li>
<li>匹配负整数：<code>^-[1-9]\d*$</code></li>
<li>匹配整数：<code>^(-?[1-9]\d*)|0$</code></li>
<li>匹配正浮点数：<code>^[1-9]\d*\.\d+|0\.\d+$</code></li>
<li>匹配负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></li>
<li>匹配浮点数：<code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li>
</ul>
<h2 id="正则表达式的性能"><a href="#正则表达式的性能" class="headerlink" title="正则表达式的性能"></a>正则表达式的性能</h2><p>目前实现正则表达式引擎的方式有两种：DFA 自动机（Deterministic Final Automata 确定有限状态自动机）和 NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。对比来看，构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机。</p>
<p>假设一个字符串的长度是 n，如果用 DFA 自动机作为正则表达式引擎，则匹配的时间复杂度为 O(n)；如果用 NFA 自动机作为正则表达式引擎，由于 NFA 自动机在匹配过程中存在大量的分支和回溯，假设 NFA 的状态数为 s，则该匹配算法的时间复杂度为 O（ns）。</p>
<p>NFA 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 NFA 实现的。</p>
<h3 id="NFA-自动机的回溯"><a href="#NFA-自动机的回溯" class="headerlink" title="NFA 自动机的回溯"></a>NFA 自动机的回溯</h3><p>用 NFA 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span>=“abbc”</span><br><span class="line"><span class="attr">regex</span>=“ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;c”</span><br></pre></td></tr></table></figure>

<p>这个例子匹配目的是：匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 自动机对其解析的过程是这样的：</p>
<ul>
<li>读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。</li>
<li>然后，读取正则表达式第二个匹配符 <code>b&#123;1,3&#125;</code> 和字符串的第二个字符 b 进行比较，匹配。但因为 <code>b&#123;1,3&#125;</code> 表示 1-3 个 b 字符串，NFA 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 <code>b&#123;1,3&#125;</code> 和字符串的第三个字符 b 进行比较，结果还是匹配。</li>
<li>接着继续使用 <code>b&#123;1,3&#125;</code> 和字符串的第四个字符 c 进行比较，发现不匹配了，此时就会发生回溯，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。</li>
<li>那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。</li>
</ul>
<h3 id="如何避免回溯"><a href="#如何避免回溯" class="headerlink" title="如何避免回溯"></a>如何避免回溯</h3><h4 id="贪婪模式（Greedy）"><a href="#贪婪模式（Greedy）" class="headerlink" title="贪婪模式（Greedy）"></a>贪婪模式（Greedy）</h4><p>顾名思义，就是在数量匹配中，如果单独使用 +、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。</p>
<p>例如，上边那个例子：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span>=“abbc”</span><br><span class="line"><span class="attr">regex</span>=“ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;c”</span><br></pre></td></tr></table></figure>

<p>就是在贪婪模式下，NFA 自动机读取了最大的匹配范围，即匹配 3 个 b 字符。匹配发生了一次失败，就引起了一次回溯。如果匹配结果是“abbbc”，就会匹配成功。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span>=“abbbc”</span><br><span class="line"><span class="attr">regex</span>=“ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;c”</span><br></pre></td></tr></table></figure>

<h4 id="懒惰模式（Reluctant）"><a href="#懒惰模式（Reluctant）" class="headerlink" title="懒惰模式（Reluctant）"></a>懒惰模式（Reluctant）</h4><p>在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。</p>
<p>例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span>=“abc”</span><br><span class="line"><span class="attr">regex</span>=“ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;?c”</span><br></pre></td></tr></table></figure>

<p>匹配结果是“abc”，该模式下 NFA 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。</p>
<h4 id="独占模式（Possessive）"><a href="#独占模式（Possessive）" class="headerlink" title="独占模式（Possessive）"></a>独占模式（Possessive）</h4><p>同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。</p>
<p>还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span>=“abbc”</span><br><span class="line"><span class="attr">regex</span>=“ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;+bc”</span><br></pre></td></tr></table></figure>

<p>结果是不匹配，结束匹配，不会发生回溯问题。</p>
<blockquote>
<p>讲到这里，你应该非常清楚了，<strong>避免回溯的方法就是：使用懒惰模式和独占模式。</strong></p>
</blockquote>
<h3 id="正则表达式的优化"><a href="#正则表达式的优化" class="headerlink" title="正则表达式的优化"></a>正则表达式的优化</h3><h4 id="少用贪婪模式，多用独占模式"><a href="#少用贪婪模式，多用独占模式" class="headerlink" title="少用贪婪模式，多用独占模式"></a>少用贪婪模式，多用独占模式</h4><p>贪婪模式会引起回溯问题，可以使用独占模式来避免回溯。</p>
<h4 id="减少分支选择"><a href="#减少分支选择" class="headerlink" title="减少分支选择"></a>减少分支选择</h4><p>分支选择类型 <code>(X|Y|Z)</code> 的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：</p>
<ul>
<li>首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；</li>
<li>其次，我们可以尝试提取共用模式，例如，将 <code>(abcd|abef)</code> 替换为 <code>ab(cd|ef)</code>，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；</li>
<li>最后，如果是简单的分支选择类型，我们可以用三次 index 代替 <code>(X|Y|Z)</code>，如果测试的话，你就会发现三次 index 的效率要比 <code>(X|Y|Z)</code> 高出一些。</li>
</ul>
<h4 id="减少捕获嵌套"><a href="#减少捕获嵌套" class="headerlink" title="减少捕获嵌套"></a>减少捕获嵌套</h4><ul>
<li>捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。</li>
<li>非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由 <code>(?:exp)</code> 组成。</li>
</ul>
<p>在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&lt;input high=\&quot;20\&quot; weight=\&quot;70\&quot;&gt;test&lt;/input&gt;&quot;</span>;</span><br><span class="line">	String reg=<span class="string">&quot;(&lt;input.*?&gt;)(.*?)(&lt;/input&gt;)&quot;</span>;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line">	<span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">		System.out.println(m.group(<span class="number">0</span>));<span class="comment">// 整个匹配到的内容</span></span><br><span class="line">		System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(&lt;input.*?&gt;)</span></span><br><span class="line">		System.out.println(m.group(<span class="number">2</span>));<span class="comment">//(.*?)</span></span><br><span class="line">		System.out.println(m.group(<span class="number">3</span>));<span class="comment">//(&lt;/input&gt;)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high=\&quot;20\&quot; weight=\&quot;70\&quot;&gt;<span class="built_in">test</span>&lt;/input&gt;</span><br><span class="line">&lt;input high=\&quot;20\&quot; weight=\&quot;70\&quot;&gt;</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">&lt;/input&gt;</span><br></pre></td></tr></table></figure>

<p>如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，我们再看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&lt;input high=\&quot;20\&quot; weight=\&quot;70\&quot;&gt;test&lt;/input&gt;&quot;</span>;</span><br><span class="line">	String reg=<span class="string">&quot;(?:&lt;input.*?&gt;)(.*?)(?:&lt;/input&gt;)&quot;</span>;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line">	<span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">		System.out.println(m.group(<span class="number">0</span>));<span class="comment">// 整个匹配到的内容</span></span><br><span class="line">		System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(.*?)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high=\&quot;20\&quot; weight=\&quot;70\&quot;&gt;<span class="built_in">test</span>&lt;/input&gt;</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>综上可知：减少不需要获取的分组，可以提高正则表达式的性能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式 30 分钟入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/d9eze55x(v=vs.80).aspx">msdn 正则表达式教程</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/lxcnn/article/details/4362500">正则应用之——日期正则表达式</a></li>
<li><a target="_blank" rel="noopener" href="http://www.regexlib.com/">http://www.regexlib.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">极客时间教程 - Java 性能调优实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e98ae9d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e98ae9d2/" class="post-title-link" itemprop="url">Java 并发之内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-25 18:43:11" itemprop="dateCreated datePublished" datetime="2020-12-25T18:43:11+08:00">2020-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发之内存模型"><a href="#Java-并发之内存模型" class="headerlink" title="Java 并发之内存模型"></a>Java 并发之内存模型</h1><p>Java 内存模型（Java Memory Model），简称 <strong>JMM</strong>。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 <strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>。</p>
<h2 id="物理内存模型"><a href="#物理内存模型" class="headerlink" title="物理内存模型"></a>物理内存模型</h2><p>物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>
<h3 id="硬件处理效率存在很大差异"><a href="#硬件处理效率存在很大差异" class="headerlink" title="硬件处理效率存在很大差异"></a>硬件处理效率存在很大差异</h3><p>技术在进步，CPU、内存、I&#x2F;O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：<strong>CPU、内存、I&#x2F;O 设备存在很大的速度差异</strong> - CPU 远快于内存，内存远快于 I&#x2F;O 设备。木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I&#x2F;O 操作），所以单方面提高 CPU、内存的性能是无效的。</p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li><strong>CPU 增加了缓存</strong>，以均衡与 CPU 内存的速度差异；</li>
<li><strong>编译程序优化指令执行次序</strong>，使得缓存能够得到更加合理地利用。</li>
<li><strong>操作系统增加了进程、线程</strong>，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 的速度差异；</li>
</ul>
<p><strong>缓存</strong>导致的可见性问题，<strong>编译优化</strong>带来的有序性问题，<strong>线程切换</strong>带来的原子性问题。</p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>高速缓存解决了 <strong>硬件效率问题</strong>，但是引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。</p>
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p>
<p>为了解决缓存一致性问题，<strong>需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408290755550.png"></p>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了使缓存得到更加合理地使用，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>
<p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术 (Instruction-Level Parallelism，ILP) 来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>对于编译器优化重排和处理器的指令重排序（指令并行重排和内存系统重排都属于是处理器级别的指令重排序），处理该问题的方式不一样。</p>
<ul>
<li>对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。</li>
<li>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。</li>
</ul>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>内存模型</strong> 这个概念。我们可以理解为：<strong>在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。不同架构的物理计算机可以有不一样的内存模型，JVM 也有自己的内存模型。</p>
<p>JVM 中试图定义一种 Java 内存模型（Java Memory Model, JMM）来<strong>屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序 <strong>在各种平台下都能达到一致的内存访问效果</strong>。</p>
<p>在 <a href="https://dunwu.github.io/waterdrop/pages/d63c0ffb/">Java 并发简介</a> 中已经介绍了，并发安全需要满足可见性、有序性、原子性。其中，导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong> 。但这么做，性能就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到呢？，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及 <strong>Happens-Before 规则</strong>。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>JMM 的主要目标是 <strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</strong>。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，JMM 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。</p>
<p>JMM 规定了<strong>所有的变量都存储在主内存（Main Memory）中</strong>。</p>
<p>每条线程还有自己的工作内存（Working Memory），<strong>工作内存中保留了该线程使用到的变量的主内存的副本</strong>。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<p>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p>
<blockquote>
<p>说明：</p>
<p>这里说的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等不是同一个层次的内存划分。</p>
</blockquote>
<h3 id="JMM-内存操作的问题"><a href="#JMM-内存操作的问题" class="headerlink" title="JMM 内存操作的问题"></a>JMM 内存操作的问题</h3><p>类似于物理内存模型面临的问题，JMM 存在以下两个问题：</p>
<ul>
<li><strong>工作内存数据一致性</strong> - 各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ Java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。</li>
<li><strong>指令重排序优化</strong> - Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：<strong>编译期重排序和运行期重排序</strong>，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：<ul>
<li>在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 <code>as-if-serial</code> 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</li>
<li>存在数据依赖关系的不允许重排序。</li>
<li>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。</li>
</ul>
</li>
</ul>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>JMM 定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 <strong>原子的</strong>（对于 double 和 long 型的变量来说，load、store、read、和 write 操作在某些平台上允许有例外 ）。</p>
<ul>
<li><code>lock</code> （锁定） - 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><code>unlock</code> （解锁） - 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><code>read</code> （读取） - 作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存<strong>传输</strong>到线程的工作内存中，以便随后的 <code>load</code> 动作使用。</li>
<li><code>write</code> （写入） - 作用于<strong>主内存</strong>的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
<li><code>load</code> （载入） - 作用于<strong>工作内存</strong>的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><code>use</code> （使用） - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。</li>
<li><code>assign</code> （赋值） - 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><code>store</code> （存储） - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 <code>write</code> 操作使用。</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就<strong>需要按序执行 <code>read</code> 和 <code>load</code> 操作</strong>；如果把变量从工作内存中同步回主内存中，就<strong>需要按序执行 <code>store</code> 和 <code>write</code> 操作</strong>。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p>
<p>JMM 还规定了上述 8 种基本操作，需要满足以下规则：</p>
<ul>
<li><strong>read 和 load 必须成对出现</strong>；<strong>store 和 write 必须成对出现</strong>。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。</li>
<li><strong>不允许一个线程丢弃它的最近 assign 的操作</strong>，即变量在工作内存中改变了之后必须把变化同步到主内存中。</li>
<li><strong>不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中</strong>。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 <strong>lock 和 unlock 必须成对出现</strong>。</li>
<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408290758072.png"></p>
<h3 id="并发安全特性"><a href="#并发安全特性" class="headerlink" title="并发安全特性"></a>并发安全特性</h3><p>并发最重要的问题是并发安全问题。所谓<strong>并发安全</strong>，是指保证程序的正确性，使得并发处理结果符合预期。</p>
<p>并发安全需要保证几个基本特性：</p>
<ul>
<li><strong>可见性</strong> - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code> 就是负责保证可见性的。</li>
<li><strong>有序性</strong> - 是保证线程内串行语义，避免指令重排等。</li>
<li><strong>原子性</strong> - 简单说就是相关操作不会中途被其他线程干扰，一般通过互斥机制（加锁：<code>sychronized</code>、<code>Lock</code>）实现。</li>
</ul>
<p>而这三大特性，归根结底，是为了实现多线程的 <strong>数据一致性</strong>，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。上文介绍了 Java 内存交互的 8 种基本操作，它们都保证可见性、有序性、原子性。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><strong>原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行</strong>。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>
<p>在 Java 中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>。这两个字节码，在 Java 中对应的关键字就是 <code>synchronized</code>。</p>
<p>因此，在 Java 中可以使用 <code>synchronized</code> 来保证方法和代码块内的操作是原子性的。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong>。</p>
<p>JMM 是通过 <strong>“变量修改后将新值同步回主内存</strong>， <strong>变量读取前从主内存刷新变量值”</strong> 这种依赖主内存作为传递媒介的方式来实现的。</p>
<p>Java 实现多线程可见性的方式有：</p>
<ul>
<li><code>volatile</code></li>
<li><code>synchronized</code></li>
<li><code>final</code></li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性规则表现在以下两种场景：线程内和线程间</p>
<ul>
<li>线程内 - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（<code>as-if-serial</code>）的方式执行，此种方式已经应用于顺序编程语言。</li>
<li>线程间 - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（<code>synchronized</code> 关键字修饰）以及 <code>volatile</code> 字段的操作仍维持相对有序。</li>
</ul>
<p>在 Java 中，可以使用 <code>synchronized</code> 和 <code>volatile</code> 来保证多线程之间操作的有序性。实现方式有所区别：</p>
<ul>
<li><code>volatile</code> 关键字会禁止指令重排序。</li>
<li><code>synchronized</code> 关键字通过互斥保证同一时刻只允许一条线程操作。</li>
</ul>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h2><p>JMM 为程序中所有的操作定义了一个偏序关系，称之为 <strong><code>先行发生原则（Happens-Before）</code><strong>。</strong>Happens-Before</strong> 是指 <strong>前面一个操作的结果对后续操作是可见的</strong>。</p>
<blockquote>
<p>1978 年，Lamport 在论文 <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a> （<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163428"><strong>译文</strong></a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56146800"><strong>解读</strong></a> ）中第一次提出了 Happens-Before，阐述了偏序关系（partial ordering）、逻辑时钟（Logical Clocks）概念，提出解决分布式系统中区分事件发生的时序问题的方法。Happens-Before 的语义是一种因果关系：如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的。</p>
</blockquote>
<p><strong>Happens-Before</strong> 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。</p>
<ul>
<li><strong>程序顺序规则</strong> - 在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</li>
<li><strong>锁定规则</strong> - 一个 <code>unLock</code> 操作 Happens-Before 于后面对同一个锁的 <code>lock</code> 操作。</li>
<li><strong>volatile 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作 Happens-Before 于后面对这个变量的读操作。</li>
<li><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法 Happens-Before 于此线程的每个一个动作。</li>
<li><strong>线程终止规则</strong> - 线程中所有的操作都 Happens-Before 于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法是否结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生。</li>
<li><strong>对象终结规则</strong> - 一个对象的初始化完成 Happens-Before 于它的 <code>finalize()</code> 方法的开始。</li>
<li><strong>传递性</strong> - 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
</ul>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障（memory barrier）。</p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。</p>
<p>举个例子：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Store1<span class="comment">;</span></span><br><span class="line">Store2<span class="comment">;</span></span><br><span class="line">Load1<span class="comment">;</span></span><br><span class="line">StoreLoad<span class="comment">;  //内存屏障</span></span><br><span class="line">Store3<span class="comment">;</span></span><br><span class="line">Load2<span class="comment">;</span></span><br><span class="line">Load3<span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于上面的一组 CPU 指令（Store 表示写入指令，Load 表示读取指令），StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p>
<p>常见有 4 种屏障</p>
<ul>
<li><code>LoadLoad</code> 屏障 - 对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li><code>StoreStore</code> 屏障 - 对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li><code>LoadStore</code> 屏障 - 对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作被执行前，保证 Load1 要读取的数据被读取完毕。</li>
<li><code>StoreLoad</code> 屏障 - 对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 <code>volatile</code> 和 <code>synchronized</code> 关键字修饰的代码块（后面再展开介绍），还可以通过 <code>Unsafe</code> 这个类来使用内存屏障。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzUwODViNjA2M2Q0NGY?x-oss-process=image/format,png" alt="img"></p>
<h2 id="Synchronized-内存语义"><a href="#Synchronized-内存语义" class="headerlink" title="Synchronized 内存语义"></a>Synchronized 内存语义</h2><p><code>synchronized</code> 是 Java 中的关键字，是 <strong>利用锁的机制来实现互斥同步的</strong>。</p>
<p><strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p>
<ul>
<li><strong>线程释放锁时内存语义：JMM 会把该线程对应的工作内存中的共享变量刷新到主内存中</strong></li>
<li><strong>线程获取锁时内存语义：JMM 会把该线程对应的工作内存置为无效</strong></li>
</ul>
<p>如果不需要 <code>Lock</code> 、<code>ReadWriteLock</code> 所提供的高级同步特性，应该优先考虑使用 <code>synchronized</code> ，理由如下：</p>
<ul>
<li>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。从趋势来看，Java 未来仍将继续优化 <code>synchronized</code> ，而不是 <code>ReentrantLock</code> 。</li>
<li><code>ReentrantLock</code> 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 <code>synchronized</code> 是 JVM 的内置特性，所有 JDK 版本都提供支持。</li>
</ul>
<h3 id="synchronized-的应用"><a href="#synchronized-的应用" class="headerlink" title="synchronized 的应用"></a>synchronized 的应用</h3><p><code>synchronized</code> 有 3 种应用方式：</p>
<ul>
<li><strong>同步实例方法</strong> - 对于普通同步方法，锁是当前实例对象</li>
<li><strong>同步静态方法</strong> - 对于静态同步方法，锁是当前类的 <code>Class</code> 对象</li>
<li><strong>同步代码块</strong> - 对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409090719904.png"></p>
<p>【示例】<code>synchronized</code> 的使用语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰成员方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sync2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象锁</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 修饰代码块，使用对象锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sync3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰代码块，使用类锁（Class）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sync4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            <span class="comment">//临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用-synchronized-实现线程安全的计数器"><a href="#用-synchronized-实现线程安全的计数器" class="headerlink" title="用 synchronized 实现线程安全的计数器"></a>用 synchronized 实现线程安全的计数器</h4><p>我们先来看一个简单的示例，这段代码维护了一个计数器变量 <code>count</code>，并通过 get() 和 add() 分别实现了读写方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotThreadSafeCounter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        <span class="type">NotThreadSafeCounter</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotThreadSafeCounter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">                instance.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">                instance.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + instance.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// count = 117626</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>启动两个线程并行执行，期望最终值为 200000，但实际值为小于 200000 的随机数字。显然，上面的示例是线程不安全的。究其原因，在于 count++ 不是原子操作，不满足并发安全的原子性要求。</p>
<p>要解决此问题，可以用 <code>synchronized</code> 修饰方法， <code>synchronized</code> 可以保证同一时刻只有一个线程执行临界区的代码。</p>
<p>我们针对上面的示例来进行改造，将 <code>add()</code> 方法用 <code>synchronized</code> 修饰，如下所示。这下是不是就可以高枕无忧了呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotThreadSafeCounter2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>add()</code> 方法本身是线程安全的。但是，这个示例忽略了 <code>get()</code> 方法。因为 <code>get()</code> 方法未加锁，一个线程调用 <code>add()</code> 方法后，无法保证另一个线程调用 <code>get()</code> 时能立刻获取到更新后的结果，不满足并发安全的可见性要求。</p>
<p>如何彻底解决 get() 并发不安全的问题呢？很简单，就是 <code>get()</code> 方法也用 <code>synchronized</code> 修饰一下。最终的线程安全示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeCounter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409090720289.png"></p>
<h4 id="静态-synchronized-方法和非静态-synchronized-是否互斥"><a href="#静态-synchronized-方法和非静态-synchronized-是否互斥" class="headerlink" title="静态 synchronized 方法和非静态 synchronized 是否互斥"></a>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 是否互斥</h4><p>静态方法的同步是指同步在该方法所在的类对象上。因为在 JVM 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p>
<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p>
<p>答案是：不互斥，但可能存在并发问题！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法；而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeCounter2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码实际上是用两个锁保护同一个资源。这个受保护的资源就是静态变量 count，两个锁分别是 this 和 ThreadSafeCounter2.class。我们可以用下面这幅图来形象描述这个关系。由于临界区 get() 和 add() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 add() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。</p>
<h4 id="用-synchronized-保护多个资源"><a href="#用-synchronized-保护多个资源" class="headerlink" title="用 synchronized 保护多个资源"></a>用 synchronized 保护多个资源</h4><p>【示例】错误示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(</span></span><br><span class="line"><span class="params">      Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？</p>
<p>问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409060808648.png"></p>
<p>应该保证使用的<strong>锁能覆盖所有受保护资源</strong>。</p>
<p>【示例】正确姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object lock；</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">// 创建 Account 时传入同一个 lock 对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 此处检查所有对象共享的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">        target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 Account 对象的时候必须传入同一个对象，如果创建 Account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 Account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。</p>
<p>上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是<strong>用 Account.class 作为共享的锁</strong>。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用 Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单。</p>
<p>【示例】正确姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Account.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">        target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-的原理"><a href="#synchronized-的原理" class="headerlink" title="synchronized 的原理"></a>synchronized 的原理</h3><p><strong><code>synchronized</code> 代码块是由一对 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，<code>Monitor</code> 对象是同步的基本实现单元</strong>。在 Java 6 之前，<code>Monitor</code> 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>如果 <code>synchronized</code> 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 <code>synchronized</code> 修饰的是实例方法还是静态方法，去对对应的对象实例或 <code>Class</code> 对象来作为锁对象。</p>
<p><code>synchronized</code> 同步块对同一线程来说是可重入的，不会出现锁死问题。</p>
<p><code>synchronized</code> 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      lock.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面的 Java 代码将编译为下面的字节码</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_2</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       <span class="number">5</span>: invokevirtual java/lang/Object.hashCode:()I</span><br><span class="line">       <span class="number">8</span>: pop</span><br><span class="line">       <span class="number">9</span>: aload_2</span><br><span class="line">      <span class="number">10</span>: monitorexit</span><br><span class="line">      <span class="number">11</span>: <span class="keyword">goto</span>          <span class="number">19</span></span><br><span class="line">      <span class="number">14</span>: astore_3</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: aload_3</span><br><span class="line">      <span class="number">18</span>: athrow</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">11</span>    <span class="number">14</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">17</span>    <span class="number">14</span>   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> 在修饰同步代码块时，是由 <code>monitorenter</code> 和 <code>monitorexit</code> 指令来实现同步的。进入 <code>monitorenter</code> 指令后，线程将持有 <code>Monitor</code> 对象，退出 <code>monitorenter</code> 指令后，线程将释放该 <code>Monitor</code> 对象。</p>
<p><code>synchronized</code> 修饰同步方法时，会设置一个 <code>ACC_SYNCHRONIZED</code> 标志。当方法调用时，调用指令将会检查该方法是否被设置 <code>ACC_SYNCHRONIZED</code> 访问标志。如果设置了该标志，执行线程将先持有 <code>Monitor</code> 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 <code>Mointor</code> 对象，当方法执行完成后，再释放该 <code>Monitor</code> 对象。</p>
<p>每个对象实例都会有一个 <code>Monitor</code>，<code>Monitor</code> 可以和对象一起创建、销毁。<code>Monitor</code> 是由 <code>ObjectMonitor</code> 实现，而 <code>ObjectMonitor</code> 是由 C++ 的 <code>ObjectMonitor.hpp</code> 文件实现。</p>
<p>当多个线程同时访问一段同步代码时，多个线程会先被存放在 EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。</p>
<p>如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入 WaitSet 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 Mutex。</p>
<h3 id="synchronized-的优化"><a href="#synchronized-的优化" class="headerlink" title="synchronized 的优化"></a>synchronized 的优化</h3><p><strong>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平</strong>。</p>
<p>在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。</p>
<p>Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200629191250.png" alt="img"></p>
<p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，<code>synchronized</code> 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</p>
<p>Java 1.6 引入了偏向锁和轻量级锁，从而让 <code>synchronized</code> 拥有了四个状态：</p>
<ul>
<li><strong>无锁状态（unlocked）</strong></li>
<li><strong>偏向锁状态（biasble）</strong></li>
<li><strong>轻量级锁状态（lightweight locked）</strong></li>
<li><strong>重量级锁状态（inflated）</strong></li>
</ul>
<p>当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现。</p>
<p>当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的思想是偏向于<strong>第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200604105151.png" alt="img"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><strong>轻量级锁</strong>是相对于传统的重量级锁而言，它 <strong>使用 CAS 操作来避免重量级锁使用互斥量的开销</strong>。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 <code>0|01</code>，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200604105248.png" alt="img"></p>
<h4 id="锁消除-锁粗化"><a href="#锁消除-锁粗化" class="headerlink" title="锁消除 &#x2F; 锁粗化"></a>锁消除 &#x2F; 锁粗化</h4><p>除了锁升级优化，Java 还使用了编译器对锁进行优化。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p><strong>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</strong>。</p>
<p>JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。</p>
<p>确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 是一个不可变的类，编译器会对 String 的拼接自动优化。在 Java 1.5 之前，会转化为 <code>StringBuffer</code> 对象的连续 <code>append()</code> 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 <code>append()</code> 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 <code>concatString()</code> 方法内部。也就是说，sb 的所有引用永远不会逃逸到 <code>concatString()</code> 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。</p>
<p>如果<strong>一系列的连续操作都对同一个对象反复加锁和解锁</strong>，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 <code>append()</code> 方法就属于这类情况。如果<strong>虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</strong>。对于上一节的示例代码就是扩展到第一个 <code>append()</code> 操作之前直至最后一个 <code>append()</code> 操作之后，这样只需要加锁一次就可以了。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="synchronized-的误区"><a href="#synchronized-的误区" class="headerlink" title="synchronized 的误区"></a>synchronized 的误区</h3><blockquote>
<p>示例摘自：<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100047701">极客时间教程 - Java 业务开发常见错误 100 例</a></p>
</blockquote>
<h4 id="synchronized-使用范围不当导致的错误"><a href="#synchronized-使用范围不当导致的错误" class="headerlink" title="synchronized 使用范围不当导致的错误"></a>synchronized 使用范围不当导致的错误</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interesting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Interesting</span> <span class="variable">interesting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interesting</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; interesting.add()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; interesting.compare()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;add start&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;add done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;compare start&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//a 始终等于 b 吗？</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;a:&#123;&#125;,b:&#123;&#125;,&#123;&#125;&quot;</span>, a, b, a &gt; b);</span><br><span class="line">                <span class="comment">//最后的 a&gt;b 应该始终是 false 吗？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;compare done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【输出】</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">05</span>:<span class="number">25.541</span> <span class="selector-attr">[Thread-0]</span> INFO io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.concurrent</span><span class="selector-class">.sync</span><span class="selector-class">.synchronized</span> 使用范围不当 - add start</span><br><span class="line"><span class="number">16</span>:<span class="number">05</span>:<span class="number">25.544</span> <span class="selector-attr">[Thread-0]</span> INFO io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.concurrent</span><span class="selector-class">.sync</span><span class="selector-class">.synchronized</span> 使用范围不当 - add done</span><br><span class="line"><span class="number">16</span>:<span class="number">05</span>:<span class="number">25.544</span> <span class="selector-attr">[Thread-1]</span> INFO io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.concurrent</span><span class="selector-class">.sync</span><span class="selector-class">.synchronized</span> 使用范围不当 - compare start</span><br><span class="line"><span class="number">16</span>:<span class="number">05</span>:<span class="number">25.544</span> <span class="selector-attr">[Thread-1]</span> INFO io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.concurrent</span><span class="selector-class">.sync</span><span class="selector-class">.synchronized</span> 使用范围不当 - compare done</span><br></pre></td></tr></table></figure>

<p>之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a&lt;b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。</p>
<p>所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。</p>
<h4 id="synchronized-保护对象不对导致的错误"><a href="#synchronized-保护对象不对导致的错误" class="headerlink" title="synchronized 保护对象不对导致的错误"></a>synchronized 保护对象不对导致的错误</h4><p>加锁前要清楚锁和被保护的对象是不是一个层面的。</p>
<p>静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">synchronized</span> 错误使用示例 <span class="number">2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> 错误使用示例 <span class="number">2</span> demo = <span class="keyword">new</span> <span class="title class_">synchronized</span> 错误使用示例 <span class="number">2</span>();</span><br><span class="line">        System.out.println(demo.wrong(<span class="number">1000000</span>));</span><br><span class="line">        System.out.println(demo.right(<span class="number">1000000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wrong</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        Data.reset();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, count).parallel().forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Data</span>().wrong());</span><br><span class="line">        <span class="keyword">return</span> Data.getCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        Data.reset();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, count).parallel().forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Data</span>().right());</span><br><span class="line">        <span class="keyword">return</span> Data.getCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">wrong</span><span class="params">()</span> &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrong 方法中试图对一个静态对象加对象级别的 synchronized 锁，并不能保证线程安全。</p>
<h4 id="锁粒度导致的问题"><a href="#锁粒度导致的问题" class="headerlink" title="锁粒度导致的问题"></a>锁粒度导致的问题</h4><p>要尽可能的缩小加锁的范围，这可以提高并发吞吐。</p>
<p>如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">synchronized</span> 锁粒度不当 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        demo.wrong();</span><br><span class="line">        demo.right();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">slow</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wrong</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).parallel().forEach(i -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    slow();</span><br><span class="line">                    data.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(<span class="string">&quot;took:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class="line">            <span class="keyword">return</span> data.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>).parallel().forEach(i -&gt; &#123;</span><br><span class="line">                slow();</span><br><span class="line">                <span class="keyword">synchronized</span> (data) &#123;</span><br><span class="line">                    data.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(<span class="string">&quot;took:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class="line">            <span class="keyword">return</span> data.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a>volatile 内存语义</h2><p><code>volatile</code> 是 JVM 提供的 <strong>最轻量级的同步机制</strong>。</p>
<p>被 <code>volatile</code> 修饰的变量，具备以下特性：</p>
<ul>
<li><strong>线程可见性</strong></li>
<li><strong>禁止指令重排序</strong></li>
<li><strong>不保证原子性</strong></li>
</ul>
<p>线程安全需要具备：可见性、有序性、原子性。然而，<code>volatile</code> 不保证原子性，因此它不能彻底地保证线程安全。这也正如其命名，<code>volatile</code> 的中文意思是不稳定的，易变的。</p>
<h3 id="保证线程可见性"><a href="#保证线程可见性" class="headerlink" title="保证线程可见性"></a>保证线程可见性</h3><p>这里的<strong>可见性是指当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的</strong>。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。</p>
<p><strong>线程写 volatile 变量的过程：</strong></p>
<ol>
<li>改变线程工作内存中 volatile 变量副本的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存</li>
</ol>
<p><strong>线程读 volatile 变量的过程：</strong></p>
<ol>
<li>从主内存中读取 volatile 变量的最新值到线程的工作内存中</li>
<li>从工作内存中读取 volatile 变量的副本</li>
</ol>
<blockquote>
<p>注意：<strong>保证可见性不等同于 volatile 变量保证并发操作的安全性</strong></p>
<p>在不符合以下两点的场景中，仍然要通过枷锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他状态变量共同参与不变约束。</li>
</ul>
</blockquote>
<p>但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：</p>
<p>举个例子： 定义 <code>volatile int count = 0</code>，2 个线程同时执行 count++ 操作，每个线程都执行 500 次，最终结果小于 1000，原因是每个线程执行 count++ 需要以下 3 个步骤：</p>
<ol>
<li>线程从主内存读取最新的 count 的值</li>
<li>执行引擎把 count 值加 1，并赋值给线程工作内存</li>
<li>线程工作内存把 count 值保存到主内存 有可能某一时刻 2 个线程在步骤 1 读取到的值都是 100，执行完步骤 2 得到的值都是 101，最后刷新了 2 次 101 保存到主内存。</li>
</ol>
<h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>观察加入 <code>volatile</code> 关键字和没有加入 <code>volatile</code> 关键字时所生成的汇编代码发现，<strong>加入 <code>volatile</code> 关键字时，会多出一个 <code>lock</code> 前缀指令</strong>。</p>
<p><strong><code>lock</code> 前缀指令实际上相当于一个内存屏障</strong>（也成内存栅栏），内存屏障会提供 3 个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>
</ul>
<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>理论上来说，你通过这个三个方法也可以实现和 <code>volatile</code> 禁止重排序一样的效果，只是会麻烦一些。</p>
<p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p>
<p>【示例】双重校验锁实现单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>instance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>instance</code> 分配内存空间</li>
<li>初始化 <code>instance</code></li>
<li>将 <code>instance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getInstance</code>() 后发现 <code>instance</code> 不为空，因此返回 <code>instance</code>，但此时 <code>instance</code> 还未被初始化。</p>
<h3 id="volatile-不保证原子性"><a href="#volatile-不保证原子性" class="headerlink" title="volatile 不保证原子性"></a>volatile 不保证原子性</h3><p>线程安全需要具备：可见性、有序性、原子性。然而，**<code>volatile</code> 不保证原子性，所以决定了它不能彻底地保证线程安全**。</p>
<p>我们通过下面的代码即可证明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatileAtomicityDemo</span> <span class="variable">volatileAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatileAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待 1.5 秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p>
<p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p>
<p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p>
<p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p>
<ol>
<li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code> 的值并对其进行修改（+1），再将 <code>inc</code> 的值写回内存。</li>
<li>线程 2 操作完毕后，线程 1 对 <code>inc</code> 的值进行修改（+1），再将 <code>inc</code> 的值写回内存。</li>
</ol>
<p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p>
<p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code>、<code>Lock</code> 或者 <code>AtomicInteger</code> 都可以。</p>
<p>::: tabs#线程安全的计数器</p>
<p>@tab <code>synchronized</code> 改进</p>
<p>使用 <code>synchronized</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <code>AtomicInteger</code> 改进</p>
<p>使用 <code>AtomicInteger</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab <code>ReentrantLock</code> 改进</p>
<p>使用 <code>ReentrantLock</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="volatile-的应用"><a href="#volatile-的应用" class="headerlink" title="volatile 的应用"></a>volatile 的应用</h3><p>如果 <code>volatile</code> 变量修饰符使用恰当的话，它比 <code>synchronized</code> 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但是，**<code>volatile</code> 无法替代 <code>synchronized</code> ，因为 <code>volatile</code> 无法保证操作的原子性**。</p>
<p><code>volatile</code> 和 <code>synchronized</code> 的区别在于：</p>
<ul>
<li><code>volatile</code> 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能修饰变量；<code>synchronized</code> 可以修饰方法和代码块。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性</li>
<li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化。</li>
</ul>
<p>通常来说，<strong>使用 <code>volatile</code> 必须具备以下 2 个条件</strong>：</p>
<ul>
<li><strong>对变量的写操作不依赖于当前值</strong></li>
<li><strong>该变量没有包含在具有其他变量的表达式中</strong></li>
</ul>
<p>::: tabs#volatile 的应用</p>
<p>@tab 状态标记量</p>
<p>【示例】状态标记量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@tab 双重锁实现线程安全的单例模式</p>
<p>【示例】双重锁实现线程安全的单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="final-内存语义"><a href="#final-内存语义" class="headerlink" title="final 内存语义"></a>final 内存语义</h2><p>我们知道，<code>final</code> 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 <code>final</code> 关键字的可见性是指：<strong>final 字段一旦在声明时或构造器中初始化完成，则其他线程无需同步就能正确看见字段值</strong>。这是因为一旦初始化完成，final 变量的值立刻回写到主内存。</p>
<h2 id="long-和-double-的特殊规则"><a href="#long-和-double-的特殊规则" class="headerlink" title="long 和 double 的特殊规则"></a>long 和 double 的特殊规则</h2><p>JMM 要求 <code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code> 这 8 种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义相对宽松的规定：<strong>允许虚拟机将没有被 <code>volatile</code> 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行</strong>，即允许虚拟机可选择不保证 64 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。</p>
<p>不过实际开发中，Java 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 <code>long</code> 和 <code>double</code> 变量专门声明为 <code>volatile</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100047701">极客时间教程 - Java 业务开发常见错误 100 例</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf2977751882505d840321d">理解 Java 内存模型</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Java 并发编程：volatile 关键字解析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3923737.html">Java 并发编程：synchronized</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">深入理解 Java 并发之 synchronized 实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://nicky-chen.github.io/2018/05/14/synchronized-principle/">synchronized 实现原理及锁优化</a></li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a>，<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1163428">译文</a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56146800">解读</a> - Lamport 介绍 happened before、偏序关系（partial ordering）、逻辑时钟（Logical Clocks）概念，提出解决分布式系统中区分事件发生的时序问题的方法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c7eb7d7d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c7eb7d7d/" class="post-title-link" itemprop="url">Java 容器之 Stream</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-05 18:30:22" itemprop="dateCreated datePublished" datetime="2020-12-05T18:30:22+08:00">2020-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-容器之-Stream"><a href="#Java-容器之-Stream" class="headerlink" title="Java 容器之 Stream"></a>Java 容器之 Stream</h1><h2 id="Stream-简介"><a href="#Stream-简介" class="headerlink" title="Stream 简介"></a>Stream 简介</h2><p>在 Java8 中，<code>Collection</code> 新增了两个流方法，分别是 <code>stream()</code> 和 <code>parallelStream()</code>。</p>
<p><code>Stream</code> 相当于高级版的 <code>Iterator</code>，他可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。</p>
<h2 id="Stream-操作分类"><a href="#Stream-操作分类" class="headerlink" title="Stream 操作分类"></a>Stream 操作分类</h2><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。</p>
<p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p>
<p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。</p>
<h2 id="Stream-源码实现"><a href="#Stream-源码实现" class="headerlink" title="Stream 源码实现"></a>Stream 源码实现</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201205174140.jpg" alt="img"></p>
<p><code>BaseStream</code> 和 <code>Stream</code> 是最顶层的接口类。<code>BaseStream</code> 主要定义了流的基本接口方法，例如，spliterator、isParallel 等；<code>Stream</code> 则定义了一些流的常用操作方法，例如，map、filter 等。</p>
<p><code>Sink</code> 接口是定义每个 <code>Stream</code> 操作之间关系的协议，他包含 <code>begin()</code>、<code>end()</code>、<code>cancellationRequested()</code>、<code>accpt()</code> 四个方法。<code>ReferencePipeline</code> 最终会将整个 <code>Stream</code> 流操作组装成一个调用链，而这条调用链上的各个 <code>Stream</code> 操作的上下关系就是通过 <code>Sink</code> 接口协议来定义实现的。</p>
<p><code>ReferencePipeline</code> 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 <code>Head</code>、<code>StatelessOp</code>、<code>StatefulOp</code> 三个内部类，实现了 <code>BaseStream</code> 与 <code>Stream</code> 的接口方法。Head 类主要用来定义数据源操作，在初次调用 names.stream() 方法时，会加载 Head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作 StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表；当我们调用终结操作时，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。</p>
<h2 id="Stream-并行处理"><a href="#Stream-并行处理" class="headerlink" title="Stream 并行处理"></a>Stream 并行处理</h2><p>Stream 处理数据的方式有两种，串行处理和并行处理。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/10058164.html">Java 编程思想（第 4 版）</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a1199302/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a1199302/" class="post-title-link" itemprop="url">Java I/O 之 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-21 16:36:40" itemprop="dateCreated datePublished" datetime="2020-11-21T16:36:40+08:00">2020-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-I-O-之-简介"><a href="#Java-I-O-之-简介" class="headerlink" title="Java I&#x2F;O 之 简介"></a>Java I&#x2F;O 之 简介</h1><p>IO 即 <code>Input/Output</code>（输入和输出），指的是：<strong>计算机内存与外部设备之间拷贝数据的过程</strong>。由于 CPU 访问内存的速度远远高于外部设备，因此 CPU 是先把外部设备的数据读到内存里，然后再进行处理。</p>
<h2 id="UNIX-I-O-模型"><a href="#UNIX-I-O-模型" class="headerlink" title="UNIX I&#x2F;O 模型"></a>UNIX I&#x2F;O 模型</h2><p>UNIX 系统下的 I&#x2F;O 模型有 5 种：</p>
<ul>
<li>同步阻塞 I&#x2F;O</li>
<li>同步非阻塞 I&#x2F;O</li>
<li>I&#x2F;O 多路复用</li>
<li>信号驱动 I&#x2F;O</li>
<li>异步 I&#x2F;O</li>
</ul>
<p>如何去理解 UNIX I&#x2F;O 模型，大致有以下两个维度：</p>
<ul>
<li>区分同步或异步（synchronous&#x2F;asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li>
<li>区分阻塞与非阻塞（blocking&#x2F;non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</li>
</ul>
<p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。</p>
<p>对于一个网络 I&#x2F;O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I&#x2F;O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p>
<p>当用户线程发起 I&#x2F;O 操作后，网络数据读取操作会经历两个步骤：</p>
<ul>
<li><strong>用户线程等待内核将数据从网卡拷贝到内核空间。</strong></li>
<li><strong>内核将数据从内核空间拷贝到用户空间。</strong></li>
</ul>
<p>各种 I&#x2F;O 模型的区别就是：它们实现这两个步骤的方式是不一样的。</p>
<h3 id="同步阻塞-I-O"><a href="#同步阻塞-I-O" class="headerlink" title="同步阻塞 I&#x2F;O"></a>同步阻塞 I&#x2F;O</h3><p>用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201121163321.jpg" alt="img"></p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I&#x2F;O"></a>同步非阻塞 I&#x2F;O</h3><p>用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201121163344.jpg" alt="img"></p>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I&#x2F;O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201121163408.jpg" alt="img"></p>
<h3 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I&#x2F;O"></a>信号驱动 I&#x2F;O</h3><p>首先开启 Socket 的信号驱动 I&#x2F;O 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I&#x2F;O 操作函数处理数据。<strong>信号驱动式 I&#x2F;O 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可</strong></p>
<h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I&#x2F;O"></a>异步 I&#x2F;O</h3><p>用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201121163428.jpg" alt="img"></p>
<h2 id="Java-I-O-模型"><a href="#Java-I-O-模型" class="headerlink" title="Java I&#x2F;O 模型"></a>Java I&#x2F;O 模型</h2><p>在 Java 中，主要支持三种 IO 模型：</p>
<ul>
<li>BIO（blocking IO）</li>
<li>NIO（non-blocking IO）</li>
<li>AIO（Asynchronous IO）</li>
</ul>
<h3 id="BIO（blocking-IO）"><a href="#BIO（blocking-IO）" class="headerlink" title="BIO（blocking IO）"></a>BIO（blocking IO）</h3><p>BIO（blocking IO） 是同步阻塞 IO 模型。指的主要是传统的 <code>java.io</code> 包，它基于流模型实现。BIO 的数据传输采用同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里。</p>
<p>如果要让 <strong>BIO 通信模型</strong> 能够同时处理多个客户端请求，就必须使用多线程（主要原因是<code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code> 涉及的三个主要函数都是同步阻塞的），但会造成不必要的线程开销。不过可以通过 <strong>线程池机制</strong> 改善，线程池还可以让线程的创建和回收成本相对较低。</p>
<p><strong>即使可以用线程池略微优化，但是会消耗宝贵的线程资源，并且在百万级并发场景下也撑不住</strong>。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<h3 id="NIO（non-blocking-IO）"><a href="#NIO（non-blocking-IO）" class="headerlink" title="NIO（non-blocking IO）"></a>NIO（non-blocking IO）</h3><p>JDK 4 引入了 NIO，源码在 <code>java.nio</code> 包中。NIO（non-blocking IO） 属于 I&#x2F;O 多路复用模型。NIO 提供了 <code>Channel</code>、<code>Selector</code>、<code>Buffer</code> 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>NIO 具有以下优点：</p>
<ul>
<li>使用缓冲区优化读写流 - NIO 与传统 I&#x2F;O 不同，它是基于块（Block）的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲区（<code>Buffer</code>）和通道（<code>Channel</code>）。<code>Buffer</code> 是一块连续的内存块，是 NIO 读写数据的缓冲。<code>Buffer</code> 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。<code>Channel</code> 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。</li>
<li>使用 DirectBuffer 减少内存复制 - NIO 还提供了一个可以直接访问物理内存的类 <code>DirectBuffer</code>。普通的 <code>Buffer</code> 分配的是 JVM 堆内存，而 <code>DirectBuffer</code> 是直接分配物理内存。数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 <code>DirectBuffer</code> 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。</li>
<li>优化 I&#x2F;O，避免阻塞 - 传统 I&#x2F;O 的数据读写是在用户空间和内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。NIO 的 <code>Channel</code> 有自己的处理器，可以完成内核空间和磁盘之间的 I&#x2F;O 操作。在 NIO 中，我们读取和写入数据都要通过 <code>Channel</code>，由于 <code>Channel</code> 是双向的，所以读、写可以同时进行。</li>
</ul>
<h3 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h3><p>AIO（Asynchronous IO） 即异步非阻塞 IO，指的是 JDK7 中，对 NIO 有了进一步的改进，也称为 NIO2，引入了异步非阻塞 IO 方式。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/82">极客时间教程 - Java 核心技术面试精讲</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/49aa0157/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/49aa0157/" class="post-title-link" itemprop="url">跳表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-23 09:21:13" itemprop="dateCreated datePublished" datetime="2020-10-23T09:21:13+08:00">2020-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h2><p>对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 <code>O(log n)</code>。</p>
<p>但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 <code>O(n)</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323113532.png" alt="img"></p>
<p>如何提高链表的查找效率呢？</p>
<p>我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作<strong>索引</strong>或<strong>索引层</strong>。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作<strong>跳表</strong>（Skip list）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155309.png" alt="img"></p>
<p>随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155346.png" alt="img"></p>
<p>随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323114408.png" alt="img"></p>
<h3 id="跳表的时间复杂度"><a href="#跳表的时间复杂度" class="headerlink" title="跳表的时间复杂度"></a>跳表的时间复杂度</h3><p>在一个具有多级索引的跳表中，第一级索引的结点个数大约就是 <code>n/2</code>，第二级索引的结点个数大约就是 <code>n/4</code>，第三级索引的结点个数大约就是 <code>n/8</code>，依次类推，也就是说，第 <code>k</code> 级索引的结点个数是第 <code>k-1</code> 级索引的结点个数的 <code>1/2</code>，那第 k 级索引结点的个数就是 <code>n/(2k)</code>。所以**跳表查询数据的时间复杂度就是 <code>O(logn)</code>**。</p>
<h3 id="跳表的空间复杂度"><a href="#跳表的空间复杂度" class="headerlink" title="跳表的空间复杂度"></a>跳表的空间复杂度</h3><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。</p>
<p>假设原始链表大小为 n，那第一级索引大约有 n&#x2F;2 个结点，第二级索引大约有 n&#x2F;4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引节点数 = <span class="built_in">n</span>/<span class="number">2</span> + <span class="built_in">n</span>/<span class="number">4</span> + <span class="built_in">n</span>/<span class="number">8</span> … + <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="built_in">n</span>-<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>所以，跳表的空间复杂度是 <code>O(n)</code>。</p>
<p>跳表的存储空间其实还有压缩空间。比如，我们增加索引节点的范围，由“每两个节点抽一个上级索引节点”改为“每五个节点抽一个上级索引节点”，可以显著节省存储空间。</p>
<p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p>
<h2 id="跳表的操作"><a href="#跳表的操作" class="headerlink" title="跳表的操作"></a>跳表的操作</h2><p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>（Red-black tree）。</p>
<h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p>跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 <code>O(logn)</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155933.png" alt="img"></p>
<ul>
<li><strong>插入操作</strong>：对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 <code>O(log n)</code>，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 <code>O(log n)</code>。</li>
<li><strong>删除操作</strong>：如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</li>
</ul>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323161942.png" alt="img"></p>
<p>如红黑树、AVL 树这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。</p>
<p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？可以通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<h2 id="为什么需要跳表"><a href="#为什么需要跳表" class="headerlink" title="为什么需要跳表"></a>为什么需要跳表</h2><p>跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 <code>O(logn)</code>。</p>
<p>跳表的空间复杂度是 <code>O(n)</code>。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>
<h2 id="跳表的应用场景"><a href="#跳表的应用场景" class="headerlink" title="跳表的应用场景"></a>跳表的应用场景</h2><p>经典实现：Redis 的 Sorted Set、JDK 的 <code>ConcurrentSkipListMap</code> 和 <code>ConcurrentSkipListSet</code> 都是基于跳表实现。</p>
<p>为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</p>
<p>Redis 中的有序集合支持的核心操作主要有下面这几个：</p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li>
<li>迭代输出有序序列。</li>
</ul>
<p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c318904e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c318904e/" class="post-title-link" itemprop="url">Java 控制语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 19:13:25" itemprop="dateCreated datePublished" datetime="2020-10-17T19:13:25+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-控制语句"><a href="#Java-控制语句" class="headerlink" title="Java 控制语句"></a>Java 控制语句</h1><blockquote>
<p>Java 控制语句大致可分为三大类：</p>
<ul>
<li>选择语句<ul>
<li>if, else-if, else</li>
<li>switch</li>
</ul>
</li>
<li>循环语句<ul>
<li>while</li>
<li>do…while</li>
<li>for</li>
<li>foreach</li>
</ul>
</li>
<li>中断语句<ul>
<li>break</li>
<li>continue</li>
<li>return</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if</code> 语句会判断括号中的条件是否成立，如果成立则执行 <code>if</code> 语句中的代码块，否则跳过代码块继续执行。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 if 语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 这是 if 语句</span></span><br></pre></td></tr></table></figure>

<h3 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p><code>if</code> 语句后面可以跟 <code>else</code> 语句，当 <code>if</code> 语句的布尔表达式值为 <code>false</code> 时，<code>else</code> 语句块会被执行。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 if 语句&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 else 语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 这是 else 语句</span></span><br></pre></td></tr></table></figure>

<h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><ul>
<li><code>if</code> 语句至多有 1 个 <code>else</code> 语句，<code>else</code> 语句在所有的 <code>else if</code> 语句之后。</li>
<li><code>If</code> 语句可以有若干个 <code>else if</code> 语句，它们必须在 <code>else</code> 语句之前。</li>
<li>一旦其中一个 <code>else if</code> 语句检测为 <code>true</code>，其他的 <code>else if</code> 以及 <code>else</code> 语句都将跳过执行。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式 <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式 <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式 <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 3的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//如果以上布尔表达式都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseifElseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;This is else statement&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Value of X is 3</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h3><p>使用嵌套的 <code>if else</code> 语句是合法的。也就是说你可以在另一个 <code>if</code> 或者 <code>else if</code> 语句中使用 <code>if</code> 或者 <code>else if</code> 语句。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式 <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">////如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">   <span class="keyword">if</span> (布尔表达式 <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">////如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfNestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;X = 30 and Y = 10&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// X = 30 and Y = 10</span></span><br></pre></td></tr></table></figure>

<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><code>switch</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p><code>switch</code> 语句有如下规则：</p>
<ul>
<li><code>switch</code> 语句中的变量类型只能为 <code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code> 或者 <code>String</code>。</li>
<li><code>switch</code> 语句可以拥有多个 <code>case</code> 语句。每个 <code>case</code> 后面跟一个要比较的值和冒号。</li>
<li><code>case</code> 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 <code>switch</code> 语句。</li>
<li>当遇到 <code>break</code> 语句时，<code>switch</code> 语句终止。程序跳转到 <code>switch</code> 语句后面的语句执行。<code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。</li>
<li><code>switch</code> 语句可以包含一个 <code>default</code> 分支，该分支必须是 <code>switch</code> 语句的最后一个分支。<code>default</code> 在没有 <code>case</code> 语句的值和变量值相等的时候执行。<code>default</code> 分支不需要 <code>break</code> 语句。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，但一般建议加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Excellent!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Well done&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;You passed&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Better try again&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid grade&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your grade is &quot;</span> + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Well done</span></span><br><span class="line"><span class="comment">// Your grade is C</span></span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>只要布尔表达式为 <code>true</code>，<code>while</code> 循环体会一直执行下去。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            x++;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x : 10</span></span><br><span class="line"><span class="comment">// value of x : 11</span></span><br><span class="line"><span class="comment">// value of x : 12</span></span><br><span class="line"><span class="comment">// value of x : 13</span></span><br><span class="line"><span class="comment">// value of x : 14</span></span><br><span class="line"><span class="comment">// value of x : 15</span></span><br><span class="line"><span class="comment">// value of x : 16</span></span><br><span class="line"><span class="comment">// value of x : 17</span></span><br><span class="line"><span class="comment">// value of x : 18</span></span><br><span class="line"><span class="comment">// value of x : 19</span></span><br></pre></td></tr></table></figure>

<h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h3><p>对于 <code>while</code> 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p><code>do while</code> 循环和 <code>while</code> 循环相似，不同的是，<code>do while</code> 循环至少会执行一次。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式);</span><br></pre></td></tr></table></figure>

<p>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            x++;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x &lt; <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x:10</span></span><br><span class="line"><span class="comment">// value of x:11</span></span><br><span class="line"><span class="comment">// value of x:12</span></span><br><span class="line"><span class="comment">// value of x:13</span></span><br><span class="line"><span class="comment">// value of x:14</span></span><br><span class="line"><span class="comment">// value of x:15</span></span><br><span class="line"><span class="comment">// value of x:16</span></span><br><span class="line"><span class="comment">// value of x:17</span></span><br><span class="line"><span class="comment">// value of x:18</span></span><br><span class="line"><span class="comment">// value of x:19</span></span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>虽然所有循环结构都可以用 <code>while</code> 或者 <code>do while</code> 表示，但 Java 提供了另一种语句 —— <code>for</code> 循环，使一些循环结构变得更加简单。<br><code>for</code> 循环执行的次数是在执行前就确定的。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; x &lt; <span class="number">20</span>; x = x + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x : 10</span></span><br><span class="line"><span class="comment">// value of x : 11</span></span><br><span class="line"><span class="comment">// value of x : 12</span></span><br><span class="line"><span class="comment">// value of x : 13</span></span><br><span class="line"><span class="comment">// value of x : 14</span></span><br><span class="line"><span class="comment">// value of x : 15</span></span><br><span class="line"><span class="comment">// value of x : 16</span></span><br><span class="line"><span class="comment">// value of x : 17</span></span><br><span class="line"><span class="comment">// value of x : 18</span></span><br><span class="line"><span class="comment">// value of x : 19</span></span><br></pre></td></tr></table></figure>

<h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (声明语句 : 表达式) &#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        String[] names = &#123; <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10,20,30,40,50,</span></span><br><span class="line"><span class="comment">// James,Larry,Tom,Lacy,</span></span><br></pre></td></tr></table></figure>

<h2 id="中断语句"><a href="#中断语句" class="headerlink" title="中断语句"></a>中断语句</h2><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p><code>break</code> 主要用在循环语句或者 <code>switch</code> 语句中，用来跳出整个语句块。</p>
<p><code>break</code> 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;break 示例结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// break 示例结束</span></span><br></pre></td></tr></table></figure>

<h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p><code>continue</code> 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 <code>for</code> 循环中，<code>continue</code> 语句使程序立即跳转到更新语句。在 <code>while</code> 或者 <code>do while</code> 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContinueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 40</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<h3 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h3><p>跳出整个函数体，函数体后面的部分不再执行。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;return 示例结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：请仔细体会一下 <code>return</code> 和 <code>break</code> 的区别。</p>
</blockquote>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>选择分支特别多的情况下，<code>switch</code> 语句优于 <code>if...else if...else</code> 语句。</li>
<li><code>switch</code> 语句不要吝啬使用 <code>default</code>。</li>
<li><code>switch</code> 语句中的 <code>default</code> 要放在最后。</li>
<li><code>foreach</code> 循环优先于传统的 <code>for</code> 循环</li>
<li>不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（<code>Iterator</code>），删除元素。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ff687d6e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ff687d6e/" class="post-title-link" itemprop="url">深入理解 Java 泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 19:13:25" itemprop="dateCreated datePublished" datetime="2020-10-17T19:13:25+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-泛型"><a href="#深入理解-Java-泛型" class="headerlink" title="深入理解 Java 泛型"></a>深入理解 Java 泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p><strong>Java 泛型（generics）是 JDK 5 中引入的特性</strong>。</p>
<p>为什么要引入泛型机制呢？</p>
<p>回答这个问题前，先让我们来看一个示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoGenericsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="number">18</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">double</span>[] &#123;<span class="number">1.0</span>, <span class="number">2.0</span>&#125;);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj3</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 = [&quot;</span> + obj1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj2 = [&quot;</span> + obj2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj3 = [&quot;</span> + obj3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> (<span class="type">int</span>)list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> (<span class="type">int</span>)list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> (<span class="type">int</span>)list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num1 = [&quot;</span> + num1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num2 = [&quot;</span> + num2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num3 = [&quot;</span> + num3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// obj1 = [abc]</span></span><br><span class="line"><span class="comment">// obj2 = [18]</span></span><br><span class="line"><span class="comment">// obj3 = [[D@47089e5f]</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span></span><br><span class="line"><span class="comment">// at io.github.dunwu.javacore.generics.NoGenericsDemo.main(NoGenericsDemo.java:23)</span></span><br></pre></td></tr></table></figure>

<p>示例说明：</p>
<p>在上面的示例中，<code>List</code> 容器没有指定存储数据类型，这种情况下，可以向 <code>List</code> 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 <code>Object</code>。</p>
<p>假设，最初我们希望向 <code>List</code> 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 <code>List</code> 当成 <code>Object</code> 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 <code>List</code> 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。</p>
<p>引入泛型机制，正是为了解决这种类型安全问题。<strong>“泛型”提供了编译时类型安全检测机制，该机制会在编译时检测到非法的类型</strong>。</p>
<p>泛型具有以下<strong>优点</strong>：</p>
<ul>
<li><p><strong>编译时的强类型检查</strong> - 泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。</p>
</li>
<li><p><strong>避免了类型转换</strong></p>
</li>
</ul>
<p>未使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型编程可以实现通用算法</strong> - 通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。</li>
</ul>
<h2 id="泛型声明"><a href="#泛型声明" class="headerlink" title="泛型声明"></a>泛型声明</h2><p><strong>“泛型类型”是被参数化的类或接口。</strong></p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的语法形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">name</span>&lt;T1, T2, ..., Tn&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<code>&lt;&gt;</code>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，…和 Tn。</p>
<p>一般将泛型中的类名称为<strong>原型</strong>，而将 <code>&lt;&gt;</code> 指定的参数称为<strong>类型参数</strong>。</p>
<ul>
<li>未应用泛型的类</li>
</ul>
<p>在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 <code>Object</code> 做类型转换。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单类型参数的泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Info&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Info&lt;Integer&gt; info = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;&gt;();</span><br><span class="line">        info.setValue(<span class="number">10</span>);</span><br><span class="line">        System.out.println(info.getValue());</span><br><span class="line"></span><br><span class="line">        Info&lt;String&gt; info2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;&gt;();</span><br><span class="line">        info2.setValue(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        System.out.println(info2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// xyz</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，在初始化一个泛型类时，使用 <code>&lt;&gt;</code> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。</p>
<p>实际上，不使用 <code>&lt;&gt;</code> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>();</span><br><span class="line">    info.setValue(<span class="number">10</span>);</span><br><span class="line">    System.out.println(info.getValue());</span><br><span class="line">    info.setValue(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(info.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。</p>
</blockquote>
<ul>
<li>多个类型参数的泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyMap</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyMap&#123;&quot;</span> + <span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClassDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">MyMap</span>&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// MyMap&#123;key=1, value=one&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型类的类型嵌套</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClassDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Info&lt;String&gt; info = <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        MyMap&lt;Integer, Info&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">MyMap</span>&lt;&gt;(<span class="number">1</span>, info);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// MyMap&#123;key=1, value=Info&#123;value=Hello&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口也可以声明泛型。</p>
<p>泛型接口语法形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Content</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">text</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口有两种实现方式：</p>
<ul>
<li>实现接口的子类明确声明泛型类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsInterfaceDemo01</span> <span class="keyword">implements</span> <span class="title class_">Content</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsInterfaceDemo01</span><span class="params">(<span class="type">int</span> text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">text</span><span class="params">()</span> &#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericsInterfaceDemo01</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsInterfaceDemo01</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.print(demo.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口的子类不明确声明泛型类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsInterfaceDemo02</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Content</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsInterfaceDemo02</span><span class="params">(T text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">text</span><span class="params">()</span> &#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericsInterfaceDemo02&lt;String&gt; gen = <span class="keyword">new</span> <span class="title class_">GenericsInterfaceDemo02</span>&lt;&gt;(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        System.out.print(gen.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ABC</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>泛型方法是引入其自己的类型参数的方法</strong>。泛型方法可以是普通方法、静态方法以及构造方法。</p>
<p>泛型方法语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">func</span><span class="params">(T obj)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>是否拥有泛型方法，与其所在的类是否是泛型没有关系。</strong></p>
<p>泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。</p>
<p><strong>使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型，这称为“类型参数推断（type argument inference）”</strong>。类型推断只对赋值操作有效，其他时候并不起作用。如果将一个返回类型为 <code>T</code> 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsMethodDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printClass</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        System.out.println(obj.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        printClass(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<p>泛型方法中也可以使用可变参数列表。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericVarargsMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">makeList</span><span class="params">(T... args)</span> &#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">        Collections.addAll(result, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [A]</span></span><br><span class="line"><span class="comment">// [A, B, C]</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型要点"><a href="#泛型要点" class="headerlink" title="泛型要点"></a>泛型要点</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，<strong>Java 泛型是使用“类型擦除”来实现的，使用泛型时，任何具体的类型信息都被擦除了</strong>。</p>
<p>那么，类型擦除做了什么呢？它做了以下工作：</p>
<ul>
<li>把泛型中的所有类型参数替换为 <code>Object</code>，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。</li>
<li>擦除出现的类型声明，即去掉 <code>&lt;&gt;</code> 的内容。比如 <code>T get()</code> 方法声明就变成了 <code>Object get()</code> ；<code>List&lt;String&gt;</code> 就变成了 <code>List</code>。如有必要，插入类型转换以保持类型安全。</li>
<li>生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。</li>
</ul>
<p>让我们来看一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsErasureTypeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        System.out.println(list1.getClass());</span><br><span class="line">        System.out.println(list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p>示例说明：</p>
<p>上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。</p>
<p>这是因为：<strong>使用泛型时，任何具体的类型信息都被擦除了</strong>。这意味着：<code>ArrayList&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 在运行时，JVM 将它们视为同一类型。</p>
<p>Java 泛型的实现方式不太优雅，但这是因为泛型是在 JDK5 时引入的，为了兼容老代码，必须在设计上做一定的折中。</p>
<h3 id="泛型和继承"><a href="#泛型和继承" class="headerlink" title="泛型和继承"></a>泛型和继承</h3><p><strong>泛型不能用于显式地引用运行时类型的操作之中</strong>（例如：转型、<code>instanceof</code> 操作和 <code>new</code> 表达式），因为所有关于参数的类型信息都丢失了。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。</p>
<p>正是由于泛型时基于类型擦除实现的，所以，<strong>泛型类型无法向上转型</strong>。</p>
<blockquote>
<p>向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553147778883.png" alt="img"></p>
<p><code>Integer</code> 继承了 <code>Object</code>；<code>ArrayList</code> 继承了 <code>List</code>；但是 <code>List&lt;Interger&gt;</code> 却并非继承了 <code>List&lt;Object&gt;</code>。</p>
<p>这是因为，泛型类并没有自己独有的 <code>Class</code> 类对象。比如：并不存在 <code>List&lt;Object&gt;.class</code> 或是 <code>List&lt;Interger&gt;.class</code>，Java 编译器会将二者都视为 <code>List.class</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; list2 = list; <span class="comment">// Erorr</span></span><br></pre></td></tr></table></figure>

<h3 id="类型边界"><a href="#类型边界" class="headerlink" title="类型边界"></a>类型边界</h3><p>有时您可能希望限制可在参数化类型中用作类型参数的类型。<strong>“类型边界”可以对泛型的类型参数设置限制条件</strong>。例如，对数字进行操作的方法可能只想接受 <code>Number</code> 或其子类的实例。</p>
<p>要声明有界类型参数，请列出类型参数的名称，然后是 <code>extends</code> 关键字，后跟其限制类或接口。</p>
<p>类型边界的语法形式如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">XXX</span>&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsExtendsDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T x, T y, T z)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> x; <span class="comment">// 假设x是初始最大值</span></span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = y; <span class="comment">//y 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = z; <span class="comment">// 现在 z 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">// 返回最大对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(max(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(max(<span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span>));</span><br><span class="line">        System.out.println(max(<span class="string">&quot;pear&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8.8</span></span><br><span class="line"><span class="comment">// pear</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>上面的示例声明了一个泛型方法，类型参数 <code>T extends Comparable&lt;T&gt;</code> 表明传入方法中的类型必须实现了 Comparable 接口。</p>
</blockquote>
<p>类型边界可以设置多个，语法形式如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends </span><span class="keyword">B1 </span>&amp; <span class="keyword">B2 </span>&amp; <span class="keyword">B3&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsExtendsDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">B</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">C</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">D1</span> &lt;T <span class="keyword">extends</span> <span class="title class_">A</span> &amp; B &amp; C&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">D2</span> &lt;T <span class="keyword">extends</span> <span class="title class_">B</span> &amp; A &amp; C&gt; &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        D1&lt;E&gt; demo1 = <span class="keyword">new</span> <span class="title class_">D1</span>&lt;&gt;();</span><br><span class="line">        System.out.println(demo1.getClass().toString());</span><br><span class="line">        D1&lt;String&gt; demo2 = <span class="keyword">new</span> <span class="title class_">D1</span>&lt;&gt;(); <span class="comment">// 编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p><strong>“类型通配符”一般使用 <code>?</code> 代替具体的类型参数</strong>。例如 <code>List&lt;?&gt;</code> 在逻辑上是 <code>List&lt;String&gt;</code> ，<code>List&lt;Integer&gt;</code> 等所有 <code>List&lt;具体类型实参&gt;</code> 的父类。</p>
<h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p>可以使用“上界通配符”来缩小类型参数的类型范围。</p>
<p>它的语法形式为：<code>&lt;? extends Number&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsUpperBoundedWildcardDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">            s += n.doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sumOfList(li));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// sum = 6.0</span></span><br></pre></td></tr></table></figure>

<h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><strong>“下界通配符”将未知类型限制为该类型的特定类型或超类类型</strong>。</p>
<blockquote>
<p>🔔 注意：<strong>上界通配符和下界通配符不能同时使用</strong>。</p>
</blockquote>
<p>它的语法形式为：<code>&lt;? super Number&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsLowerBoundedWildcardDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        addNumbers(list);</span><br><span class="line">        System.out.println(Arrays.deepToString(list.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符有两种应用场景：</p>
<ul>
<li>可以使用 Object 类中提供的功能来实现的方法。</li>
<li>使用不依赖于类型参数的泛型类中的方法。</li>
</ul>
<p>语法形式：<code>&lt;?&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsUnboundedWildcardDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object elem : list) &#123;</span><br><span class="line">            System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;String&gt; ls = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printList(li);</span><br><span class="line">        printList(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// one two three</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符和向上转型"><a href="#通配符和向上转型" class="headerlink" title="通配符和向上转型"></a>通配符和向上转型</h3><p>前面，我们提到：<strong>泛型不能直接向上转型；但是，我们可以通过使用通配符来间接向上转型</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsWildcardDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; numList = intList;  <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; intList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; numList2 = intList2;  <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Oracle 泛型文档</a></p>
</blockquote>
<h2 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#instantiate">泛型类型的类型参数不能是值类型</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjects">不能创建类型参数的实例</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">elem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();  <span class="comment">// 编译错误</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic">不能声明类型为类型参数的静态成员</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileDevice</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCast">类型参数不能使用类型转换或 <code>instanceof</code></a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">rtti</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// 编译错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays">不能创建类型参数的数组</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch">不能创建、catch 或 throw 参数化类型对象</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueFullException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Throwable</span> &#123; <span class="comment">/* ... */</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Exception</span>, J&gt; <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(List&lt;J&gt; jobs)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload">仅仅是泛型类相同，而类型参数不同的方法不能重载</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;String&gt; strSet)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> &#123; &#125; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型最佳实践"><a href="#泛型最佳实践" class="headerlink" title="泛型最佳实践"></a>泛型最佳实践</h2><h3 id="泛型命名"><a href="#泛型命名" class="headerlink" title="泛型命名"></a>泛型命名</h3><p>Java 泛型有一些约定俗成的命名：</p>
<ul>
<li><code>E</code> - Element</li>
<li><code>K</code> - Key</li>
<li><code>N</code> - Number</li>
<li><code>T</code> - Type</li>
<li><code>V</code> - Value</li>
<li><code>S</code>、<code>U</code>、<code>V</code> - 2nd, 3rd, 4th types</li>
</ul>
<h3 id="使用泛型的建议"><a href="#使用泛型的建议" class="headerlink" title="使用泛型的建议"></a>使用泛型的建议</h3><ul>
<li>消除类型检查告警</li>
<li>List 优先于数组</li>
<li>优先考虑使用泛型来提高代码通用性</li>
<li>优先考虑泛型方法来限定泛型的范围</li>
<li>利用有限制通配符来提升 API 的灵活性</li>
<li>优先考虑类型安全的异构容器</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective java</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Oracle 泛型文档</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/584d36f161ff4b006cccdb82">Java 泛型详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/517df6be/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/517df6be/" class="post-title-link" itemprop="url">ShardingSphere</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-08 20:30:30" itemprop="dateCreated datePublished" datetime="2020-10-08T20:30:30+08:00">2020-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库中间件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ShardingSphere-简介"><a href="#ShardingSphere-简介" class="headerlink" title="ShardingSphere 简介"></a>ShardingSphere 简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shardingsphere-jdbc 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>
<ul>
<li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li>
<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li>
<li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151213.png" alt="img"></p>
<h3 id="ShardingSphere-组件"><a href="#ShardingSphere-组件" class="headerlink" title="ShardingSphere 组件"></a>ShardingSphere 组件</h3><p>ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar（计划中）这 3 款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151613.png" alt="img"></p>
<h4 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h4><p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>
<ul>
<li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li>
<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li>
<li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151213.png" alt="img"></p>
<h4 id="Sharding-Proxy"><a href="#Sharding-Proxy" class="headerlink" title="Sharding-Proxy"></a>Sharding-Proxy</h4><p>定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供 MySQL 和 PostgreSQL 版本，它可以使用任何兼容 MySQL&#x2F;PostgreSQL 协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat 等)操作数据，对 DBA 更加友好。</p>
<ul>
<li>向应用程序完全透明，可直接当做 MySQL&#x2F;PostgreSQL 使用。</li>
<li>适用于任何兼容 MySQL&#x2F;PostgreSQL 协议的的客户端。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151434.png" alt="img"></p>
<h4 id="Sharding-Sidecar（TODO）"><a href="#Sharding-Sidecar（TODO）" class="headerlink" title="Sharding-Sidecar（TODO）"></a>Sharding-Sidecar（TODO）</h4><p>定位为 Kubernetes 的云原生数据库代理，以 Sidecar 的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即 <code>Database Mesh</code>，又可称数据库网格。</p>
<p>Database Mesh 的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互进行有效地梳理。 使用 Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151557.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"><em>Sharding-JDBC</em></th>
<th align="left"><em>Sharding-Proxy</em></th>
<th align="left"><em>Sharding-Sidecar</em></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据库</td>
<td align="left">任意</td>
<td align="left">MySQL</td>
<td>MySQL</td>
</tr>
<tr>
<td align="left">连接消耗数</td>
<td align="left">高</td>
<td align="left">低</td>
<td>高</td>
</tr>
<tr>
<td align="left">异构语言</td>
<td align="left">仅 Java</td>
<td align="left">任意</td>
<td>任意</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">损耗低</td>
<td align="left">损耗略高</td>
<td>损耗低</td>
</tr>
<tr>
<td align="left">无中心化</td>
<td align="left">是</td>
<td align="left">否</td>
<td>是</td>
</tr>
<tr>
<td align="left">静态入口</td>
<td align="left">无</td>
<td align="left">有</td>
<td>无</td>
</tr>
</tbody></table>
<h4 id="混合架构"><a href="#混合架构" class="headerlink" title="混合架构"></a>混合架构</h4><p>ShardingSphere-JDBC 采用无中心化架构，适用于 Java 开发的高性能的轻量级 OLTP 应用；ShardingSphere-Proxy 提供静态入口以及异构语言的支持，适用于 OLAP 应用以及对分片数据库进行管理和运维的场景。</p>
<p>Apache ShardingSphere 是多接入端共同组成的生态圈。 通过混合使用 ShardingSphere-JDBC 和 ShardingSphere-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由地调整适合与当前业务的最佳系统架构。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008151658.png" alt="img"></p>
<h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><ul>
<li>分库 &amp; 分表</li>
<li>读写分离</li>
<li>分片策略定制化</li>
<li>无中心化分布式主键</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul>
<li>标准化事务接口</li>
<li>XA 强一致事务</li>
<li>柔性事务</li>
</ul>
<h4 id="数据库治理"><a href="#数据库治理" class="headerlink" title="数据库治理"></a>数据库治理</h4><ul>
<li>分布式治理</li>
<li>弹性伸缩</li>
<li>可视化链路追踪</li>
<li>数据加密</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="引入-maven-依赖"><a href="#引入-maven-依赖" class="headerlink" title="引入 maven 依赖"></a>引入 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest.release.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：请将 <code>$&#123;latest.release.version&#125;</code> 更改为实际的版本号。</p>
<h3 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h3><p>ShardingSphere-JDBC 可以通过 <code>Java</code>，<code>YAML</code>，<code>Spring 命名空间</code>和 <code>Spring Boot Starter</code> 这 4 种方式进行配置，开发者可根据场景选择适合的配置方式。 详情请参见<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/configuration/">配置手册</a>。</p>
<h3 id="创建数据源"><a href="#创建数据源" class="headerlink" title="创建数据源"></a>创建数据源</h3><p>通过 <code>ShardingSphereDataSourceFactory</code> 工厂和规则配置对象获取 <code>ShardingSphereDataSource</code>。 该对象实现自 JDBC 的标准 DataSource 接口，可用于原生 JDBC 开发，或使用 JPA, MyBatis 等 ORM 类库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ShardingSphereDataSourceFactory.createDataSource(dataSourceMap, configurations, properties);</span><br></pre></td></tr></table></figure>

<h2 id="概念和功能"><a href="#概念和功能" class="headerlink" title="概念和功能"></a>概念和功能</h2><p>单一数据节点难于满足互联网的海量数据场景。</p>
<p>从性能方面来说，由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。</p>
<p>在传统的关系型数据库无法满足互联网场景需要的情况下，将数据存储至原生支持分布式的 NoSQL 的尝试越来越多。 但 NoSQL 对 SQL 的不兼容性以及生态圈的不完善，使得它们在与关系型数据库的博弈中始终无法完成致命一击，而关系型数据库的地位却依然不可撼动。</p>
<p><strong>数据分片</strong>指<strong>按照某个维度</strong>将存放在单一数据库中的<strong>数据分散地存放至多个数据库或表中</strong>以达到提升性能瓶颈以及可用性的效果。数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p>
<p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。</p>
<h3 id="垂直分片"><a href="#垂直分片" class="headerlink" title="垂直分片"></a>垂直分片</h3><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。 在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。 下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。</p>
<p><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/img/sharding/vertical_sharding.png"><img src="https://shardingsphere.apache.org/document/current/img/sharding/vertical_sharding.png" alt="垂直分片"></a></p>
<p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</p>
<h3 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h3><p>水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/img/sharding/horizontal_sharding.png"><img src="https://shardingsphere.apache.org/document/current/img/sharding/horizontal_sharding.png" alt="水平分片"></a></p>
<p>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。</p>
<h3 id="数据分片带来的问题"><a href="#数据分片带来的问题" class="headerlink" title="数据分片带来的问题"></a>数据分片带来的问题</h3><ul>
<li><strong>数据路由</strong>：需要知道数据需要从哪个具体的数据库的分表中获取。</li>
<li><strong>SQL 不兼容</strong>：分表导致表名称的修改，或者分页、排序、聚合、分组等操作的不正确处理。</li>
<li><strong>跨库事务</strong>：合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。 在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</li>
</ul>
<h2 id="ShardingSphere-内核剖析"><a href="#ShardingSphere-内核剖析" class="headerlink" title="ShardingSphere 内核剖析"></a>ShardingSphere 内核剖析</h2><p>ShardingSphere 的 3 个产品的数据分片主要流程是完全一致的。 核心由 <code>SQL 解析 =&gt; 执行器优化 =&gt; SQL 路由 =&gt; SQL 改写 =&gt; SQL 执行 =&gt; 结果归并</code>的流程组成。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201008153551.png" alt="img"></p>
<ul>
<li>QL 解析：分为词法解析和语法解析。 先通过词法解析器将 SQL 拆分为一个个不可再分的单词。再使用语法解析器对 SQL 进行理解，并最终提炼出解析上下文。 解析上下文包括表、选择项、排序项、分组项、聚合函数、分页信息、查询条件以及可能需要修改的占位符的标记。</li>
<li>执行器优化：合并和优化分片条件，如 OR 等。</li>
<li>SQL 路由：根据解析上下文匹配用户配置的分片策略，并生成路由路径。目前支持分片路由和广播路由。</li>
<li>SQL 改写：将 SQL 改写为在真实数据库中可以正确执行的语句。SQL 改写分为正确性改写和优化改写。</li>
<li>SQL 执行：通过多线程执行器异步执行。</li>
<li>结果归并：将多个执行结果集归并以便于通过统一的 JDBC 接口输出。结果归并包括流式归并、内存归并和使用装饰模式的追加归并这几种方式。</li>
</ul>
<h3 id="解析引擎"><a href="#解析引擎" class="headerlink" title="解析引擎"></a>解析引擎</h3><h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p>解析过程分为<strong>词法解析</strong>和<strong>语法解析</strong>。 词法解析器用于将 SQL 拆解为不可再分的原子符号，称为 Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将 SQL 转换为抽象语法树。</p>
<p>例如，以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;ACTIVE&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>解析之后的为抽象语法树见下图。</p>
<p><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/img/sharding/sql_ast.png"><img src="https://shardingsphere.apache.org/document/current/img/sharding/sql_ast.png" alt="SQL抽象语法树"></a></p>
<p>为了便于理解，抽象语法树中的关键字的 Token 用绿色表示，变量的 Token 用红色表示，灰色表示需要进一步拆分。</p>
<p>最后，通过对抽象语法树的遍历去提炼分片所需的上下文，并标记有可能需要改写的位置。 供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）。 SQL 的一次解析过程是不可逆的，一个个 Token 按 SQL 原本的顺序依次进行解析，性能很高。 考虑到各种数据库 SQL 方言的异同，在解析模块提供了各类数据库的 SQL 方言字典。</p>
<h4 id="SQL-解析引擎"><a href="#SQL-解析引擎" class="headerlink" title="SQL 解析引擎"></a>SQL 解析引擎</h4><p>SQL 解析作为分库分表类产品的核心，其性能和兼容性是最重要的衡量指标。 ShardingSphere 的 SQL 解析器经历了 3 代产品的更新迭代。</p>
<p>第一代 SQL 解析器为了追求性能与快速实现，在 1.4.x 之前的版本使用 Druid 作为 SQL 解析器。经实际测试，它的性能远超其它解析器。</p>
<p>第二代 SQL 解析器从 1.5.x 版本开始，ShardingSphere 采用完全自研的 SQL 解析引擎。 由于目的不同，ShardingSphere 并不需要将 SQL 转为一颗完全的抽象语法树，也无需通过访问器模式进行二次遍历。它采用对 SQL <code>半理解</code>的方式，仅提炼数据分片需要关注的上下文，因此 SQL 解析的性能和兼容性得到了进一步的提高。</p>
<p>第三代 SQL 解析器则从 3.0.x 版本开始，ShardingSphere 尝试使用 ANTLR 作为 SQL 解析的引擎，并计划根据 <code>DDL -&gt; TCL -&gt; DAL –&gt; DCL -&gt; DML –&gt;DQL</code> 这个顺序，依次替换原有的解析引擎，目前仍处于替换迭代中。 使用 ANTLR 的原因是希望 ShardingSphere 的解析引擎能够更好的对 SQL 进行兼容。对于复杂的表达式、递归、子查询等语句，虽然 ShardingSphere 的分片核心并不关注，但是会影响对于 SQL 理解的友好度。 经过实例测试，ANTLR 解析 SQL 的性能比自研的 SQL 解析引擎慢 3-10 倍左右。为了弥补这一差距，ShardingSphere 将使用 <code>PreparedStatement</code> 的 SQL 解析的语法树放入缓存。 因此建议采用 <code>PreparedStatement</code> 这种 SQL 预编译的方式提升性能。</p>
<p>第三代 SQL 解析引擎的整体结构划分如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/img/sharding/parsing_architecture_cn.png"><img src="https://shardingsphere.apache.org/document/current/img/sharding/parsing_architecture_cn.png" alt="解析引擎结构"></a></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-shardingsphere">shardingsphere Github</a></li>
<li><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/overview/">shardingsphere 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c43cd7f3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c43cd7f3/" class="post-title-link" itemprop="url">MongoDB CRUD</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-25 21:23:41" itemprop="dateCreated datePublished" datetime="2020-09-25T21:23:41+08:00">2020-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-CRUD"><a href="#MongoDB-CRUD" class="headerlink" title="MongoDB CRUD"></a>MongoDB CRUD</h1><p>::: info 概述</p>
<p><strong>CRUD</strong> 由英文单词 <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete 的首字母组成，即<strong>增删改查</strong>。</p>
<p>本文通过介绍基本的 MongoDB CRUD 方法，向读者呈现如何访问 MongoDB 数据。</p>
<p>:::</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/c43cd7f3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/24/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/blog/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/26/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"3df960435c182f30a53e1409017109d6"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
