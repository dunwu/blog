<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/12/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/12/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6b3a7519/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6b3a7519/" class="post-title-link" itemprop="url">认证设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 18:04:17" itemprop="dateCreated datePublished" datetime="2022-11-15T18:04:17+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="认证设计"><a href="#认证设计" class="headerlink" title="认证设计"></a>认证设计</h1><h2 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h2><h3 id="什么是认证"><a href="#什么是认证" class="headerlink" title="什么是认证"></a>什么是认证</h3><p><strong>认证 (Authentication)</strong> 是根据凭据验明访问者身份的流程。即验证“你是你所说的那个人”的过程。</p>
<p>身份认证，通常通过用户名&#x2F;邮箱&#x2F;手机号以及密码匹配来完成，也可以通过手机&#x2F;邮箱验证码或者生物特征（如：指纹、虹膜）等其他因素。在某些应用系统中，为了追求更高的安全性，往往会要求多种认证因素叠加使用，这就是我们经常说的多因素认证。</p>
<p>常见的认证方式</p>
<ul>
<li>用户名、密码认证</li>
<li>手机和短信验证码认证</li>
<li>邮箱和邮件验证码认证</li>
<li>人脸识别、指纹识别等生物因素认证</li>
<li>令牌认证</li>
<li>OTP 认证</li>
<li>Radius 网络认证</li>
</ul>
<h3 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h3><p><strong>授权 (Authorization)</strong> 是指向经过身份认证的访问者授予执行某项操作的权限（如访问资源，执行文件&#x2F;数据读写权限等）。 简言之，授权是验证“你被允许做你想做的事”的过程。</p>
<p>虽然授权通常在身份验证后立即发生（例如，登录计算机系统时），但这并不意味着授权以身份验证为前提：匿名代理可以被授权执行有限的操作集。</p>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
<p>Cookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。</p>
<p>Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<ul>
<li><a href="https://dunwu.github.io/waterdrop/pages/b535e4c0/">Cookie 和 Session</a></li>
<li><a href="https://dunwu.github.io/waterdrop/pages/16deae27/">分布式会话</a></li>
</ul>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p><strong>SSO(Single Sign On)，即单点登录</strong>。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。</p>
<p>SSO 需要解决多个异构系统之间的问题：</p>
<ul>
<li>Session 共享问题</li>
<li>跨域问题</li>
</ul>
<h3 id="Session-共享问题"><a href="#Session-共享问题" class="headerlink" title="Session 共享问题"></a>Session 共享问题</h3><p>分布式 Session 的几种实现策略：</p>
<ul>
<li>粘性 Session - 缺点：当<strong>服务器节点宕机时，将丢失该服务器节点上的所有 Session</strong>。</li>
<li>应用服务器间的 Session 复制共享 - 缺点：<strong>占用过多内存</strong>；<strong>同步过程占用网络带宽以及服务器处理器时间</strong>。</li>
<li>基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。</li>
</ul>
<h3 id="Cookie-跨域"><a href="#Cookie-跨域" class="headerlink" title="Cookie 跨域"></a>Cookie 跨域</h3><p><strong>Cookie 不能跨域</strong>！比如：浏览器不会把 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 的 cookie 传给 <a target="_blank" rel="noopener" href="http://www.baidu.com./">www.baidu.com。</a></p>
<p>这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。</p>
<p>针对 <strong>Cookie 不能跨域</strong> 的问题，有几种解决方案：</p>
<ul>
<li>服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。</li>
<li>多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。</li>
<li>将 Token 保存在 <strong><code>SessionStroage</code></strong> 中（不依赖 Cookie 就没有跨域的问题了）。</li>
</ul>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 是实现 SSO 的主流方式。</p>
<p>CAS 分为两部分，CAS Server 和 CAS Client</p>
<ul>
<li><strong><code>CAS Server</code></strong> - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。</li>
<li><strong><code>CAS Client</code></strong> - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。</li>
</ul>
<p>术语：</p>
<ul>
<li><strong><code>Ticket Granting Ticket (TGT)</code></strong> - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。</li>
<li><strong><code>Ticket Granting Cookie (TGC)</code></strong> - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。</li>
<li><strong><code>Service Ticket (ST)</code></strong> - 由 TGT 生成的一次性票据，用于验证，只能用一次。</li>
</ul>
<p>CAS 工作流程：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119195646.png" alt="img"></p>
<ol>
<li>用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。</li>
<li>用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。</li>
<li>浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。</li>
<li>CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。</li>
<li>此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。</li>
<li>重复类似 3、4 步骤。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119202448.png" alt="img"></p>
<p>以上了归纳总结如下：</p>
<ol>
<li><strong>访问服务</strong> - 用户访问 SSO Client 资源。</li>
<li><strong>定向认证</strong> - SSO Client 重定向用户请求到 SSO Server。</li>
<li><strong>用户认证</strong> - 用户身份认证。</li>
<li><strong>发放票据</strong> - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。</li>
<li><strong>验证票据</strong> - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。</li>
<li><strong>传输用户信息</strong> - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。</li>
</ol>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token (JWT，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519">RFC 7519 (opens new window)</a>)，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519)。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>
<p>详细内容可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT (opens new window)</a>。</p>
<h2 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> 是一个关于授权（Authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。</p>
<p>简单来说，<strong>OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p>OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li><strong>授权码模式（authorization code）</strong></li>
<li><strong>简化模式（implicit）</strong></li>
<li><strong>密码模式（resource owner password credentials）</strong></li>
<li><strong>客户端模式（client credentials）</strong></li>
</ul>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<h3 id="隐藏模式"><a href="#隐藏模式" class="headerlink" title="隐藏模式"></a>隐藏模式</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<h3 id="客户端凭证模式"><a href="#客户端凭证模式" class="headerlink" title="客户端凭证模式"></a>客户端凭证模式</h3><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h3 id="令牌的更新"><a href="#令牌的更新" class="headerlink" title="令牌的更新"></a>令牌的更新</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致</li>
</ul>
<h2 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h2><h3 id="ID-Token"><a href="#ID-Token" class="headerlink" title="ID Token"></a>ID Token</h3><p>ID Token 相当于用户的身份凭证，开发者的前端访问后端接口时可以携带 ID Token，开发者服务器可以校验用户的 ID Token 以确定用户身份，验证通过后返回相关资源。</p>
<p><strong>ID Token</strong> 本质上是一个 <a target="_blank" rel="noopener" href="https://docs.authing.cn/v2/concepts/jwt-token.html"><code>JWT Token</code></a>，包含了该用户身份信息相关的 key&#x2F;value 键值对，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://server.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24400320&quot;</span><span class="punctuation">,</span> <span class="comment">// subject 的缩写，为用户 ID</span></span><br><span class="line">   <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s6BhdRkqt3&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;n-0S6_WzA2Mj&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1311281970</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1311280970</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;auth_time&quot;</span><span class="punctuation">:</span> <span class="number">1311280969</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;acr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;urn:mace:incommon:iap:silver&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>ID Token 本质上是一个 JWT Token 意味着：</p>
<p>用户的身份信息直接被编码进了 id_token，你不需要额外请求其他的资源来获取用户信息；</p>
<p>id_token 可以验证其没有被篡改过，详情请见如何验证 ID Token。</p>
<h3 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h3><p>Access Token 用于基于 Token 的认证模式，允许应用访问一个资源 API。用户认证授权成功后，认证系统会签发 Access Token 给应用。应用需要<strong>携带 Access Token</strong> 访问资源 API，资源服务 API 会通过拦截器查验 Access Token 中的 <code>scope</code> 字段是否包含特定的权限项目，从而决定是否返回资源。</p>
<p>如果你的用户通过社交账号登录，例如微信登录，微信作为身份提供商会颁发自己的 Access Token，你的应用可以利用 Access Token 调用微信相关的 API。这些 Access Token 是由社交账号服务方控制的，格式也是任意的。</p>
<h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>AccessToken 和 IdToken 是 JSON Web Token (opens new window)，有效时间通常较短。通常用户在获取资源的时候需要携带 AccessToken，当 AccessToken 过期后，用户需要获取一个新的 AccessToken。</p>
<p>Refresh Token 用于获取新的 AccessToken。这样可以缩短 AccessToken 的过期时间保证安全，同时又不会因为频繁过期重新要求用户登录。</p>
<p>用户在初次认证时，Refresh Token 会和 AccessToken、IdToken 一起返回。你的应用必须安全地存储 Refresh Token，它的重要性和密码是一样的，因为 Refresh Token 能够一直让用户保持登录。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.rfcreader.com/#rfc6749">RFC 6749</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0</a></li>
<li><a target="_blank" rel="noopener" href="https://darutk.medium.com/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb">The Simplest Guide To OAuth 2.0</a></li>
<li><a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-core-1_0.html">OIDC 规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6aab33f7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/6aab33f7/" class="post-title-link" itemprop="url">授权设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-15 17:48:06" itemprop="dateCreated datePublished" datetime="2022-11-15T17:48:06+08:00">2022-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="授权设计"><a href="#授权设计" class="headerlink" title="授权设计"></a>授权设计</h1><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><p>最简单的授权形式可能是根据是否已对发出请求的实体进行身份验证来授予或拒绝访问权限。 如果请求者可证明自己是所自称的身份，则可访问受保护的资源或功能。</p>
<p>常见的授权模式有以下几种：</p>
<ul>
<li><strong>ACL</strong>：ACL 即 <strong>通过访问控制列表</strong>。ACL 进行的授权涉及到维护明确的特定实体列表，这些实体有权或无权访问资源或功能。 ACL 提供对身份验证即授权的精细控制，但管理工作会随着实体数量的增加而变得困难。</li>
<li><strong>RBAC</strong>：RBAC 即 <strong>基于角色的权限控制（Role-Based Access Control）</strong>。RBAC 应该是最常见的授权模式。 使用 RBAC 时，会对角色进行定义，以说明实体可执行的活动类型。 应用程序开发人员向角色而非单个实体授予访问权限。 然后，管理员可再将角色分配给不同的实体，从而控制哪些实体有权访问哪些资源和功能。在高级 RBAC 实现中，可将角色映射到权限集合，其中权限描述了可执行的细化操作或活动。 然后，会将角色配置为权限组合。 通过将授予给为实体分配的各种角色的权限进行相交，计算实体的总体权限集。</li>
<li><strong>ABAC</strong>：ABAC 即 <strong>基于属性的访问控制</strong> 是一种更精细的访问控制机制。在此方法中，规则应用于实体、所访问的资源和当前环境。 这些规则用于确定对资源和功能的访问级别。 例如，可能只允许拥有管理员身份的用户在工作日上午 9 点至下午 5 点期间访问使用元数据标记“仅限工作时间的管理员”标识的文件。 在这种情况下，通过检查用户的属性（状态为管理员）、资源属性（文件上的元数据标记）以及环境属性（当前时间）来确定访问权限。<ul>
<li>ABAC 的优点：可通过规则和条件评估实现更精细的动态访问控制，而无需创建大量特定的角色和 RBAC 分配。</li>
</ul>
</li>
</ul>
<h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p><strong>RBAC（Role-Based Access Control）即：基于角色的权限控制</strong>。通过角色关联用户，角色关联权限的方式间接赋予用户权限。</p>
<p>每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210359.png" alt="img"></p>
<p>角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200119210528.png" alt="img"></p>
<h3 id="职责分离-Separation-of-Duty"><a href="#职责分离-Separation-of-Duty" class="headerlink" title="职责分离(Separation of Duty)"></a>职责分离(Separation of Duty)</h3><p>为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。</p>
<p>职责分离有两种模式：</p>
<p>静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<p>动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp" alt="img"></p>
<p>讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。</p>
<h3 id="RBAC0-模型"><a href="#RBAC0-模型" class="headerlink" title="RBAC0 模型"></a>RBAC0 模型</h3><p>最简单的用户、角色、权限模型。这里面又包含了 2 种：</p>
<ol>
<li>用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。</li>
<li>用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。</li>
</ol>
<p>那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？</p>
<p>如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。</p>
<h3 id="RBAC1-模型"><a href="#RBAC1-模型" class="headerlink" title="RBAC1 模型"></a>RBAC1 模型</h3><p>相对于 RBAC0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/CN3L7POv7d8Ku1QMnXGU.png" alt="img"></p>
<p><strong>使用场景：</strong>如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。</p>
<p>而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。</p>
<h3 id="RBAC2-模型"><a href="#RBAC2-模型" class="headerlink" title="RBAC2 模型"></a>RBAC2 模型</h3><p>基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。</p>
<ul>
<li><strong>角色互斥：</strong>同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。</li>
<li><strong>基数约束：</strong>一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的。</li>
<li><strong>先决条件角色：</strong>指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。</li>
<li><strong>运行时互斥：</strong>例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li>
</ul>
<h3 id="RBAC3-模型"><a href="#RBAC3-模型" class="headerlink" title="RBAC3 模型"></a>RBAC3 模型</h3><p>称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内，综合了 RBAC0、RBAC1 和 RBAC2 的所有特点，这里就不在多描述了。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/7MEIhTRfnGmV0T5MBYoH.png" alt="img"></p>
<h3 id="什么是权限"><a href="#什么是权限" class="headerlink" title="什么是权限"></a>什么是权限</h3><p>说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？</p>
<p>权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：<strong>页面权限、操作权限和数据权限</strong>（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。</p>
<p><strong>页面权限：</strong>所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。</p>
<p>如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/zZMuljfwRvu8Be6oEFlV.png" alt="img"></p>
<p>客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。</p>
<p><strong>操作权限：</strong>用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。</p>
<p><strong>数据权限：</strong>一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。</p>
<p>简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。</p>
<p>如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/eQKuv1vmlhA7eNDvlb1t.png" alt="img"></p>
<p>按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。</p>
<p>换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。</p>
<p>要实现数据权限有多种方式：</p>
<ol>
<li>可以利用 RBAC1 模型，通过角色分级来实现。</li>
<li>在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。</li>
</ol>
<p>具体如何做呢？</p>
<p><strong>① 组织层级划分：</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/7OfSVWkovU90yPLCAYXl.png" alt="img"></p>
<p><strong>② 数据可视权限规则制定：</strong>上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。</p>
<p>通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。</p>
<h3 id="用户组的使用"><a href="#用户组的使用" class="headerlink" title="用户组的使用"></a>用户组的使用</h3><p>当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。</p>
<p>例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。</p>
<p>同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。</p>
<p>用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。</p>
<p>关于用户组的详细疑难解答，请查看<a target="_blank" rel="noopener" href="https://wen.woshipm.com/question/detail/88fues.html%E3%80%82%E5%9C%A8%E8%BF%99%E9%87%8C%E4%B9%9F%E5%8D%81%E5%88%86%E6%84%9F%E8%B0%A2%E4%B8%BA%E6%88%91%E8%A7%A3%E7%AD%94%E7%96%91%E6%83%91%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC%EF%BC%81">https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！</a></p>
<h3 id="实例分析一、如何设计-RBAC-权限系统"><a href="#实例分析一、如何设计-RBAC-权限系统" class="headerlink" title="实例分析一、如何设计 RBAC 权限系统"></a>实例分析一、如何设计 RBAC 权限系统</h3><p>首先，我们思考一下一个简单的权限系统应该具备哪些内容？</p>
<p>答案显而易见，RBAC 模型：<strong>用户-角色-权限</strong>。所以最基本的我们应该具备用户、角色、权限这三个内容。</p>
<p>接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 RBAC 模型下，我们应该：<strong>创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户</strong>。</p>
<p>将这个问题抽象为流程，如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/UGJGmWviv32mWGgEkYpC.png" alt="img"></p>
<p>现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？</p>
<ul>
<li>第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；</li>
<li>第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。</li>
</ul>
<p>简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。</p>
<h3 id="实例分析二、"><a href="#实例分析二、" class="headerlink" title="实例分析二、"></a>实例分析二、</h3><p><strong>① 创建角色列表</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/KHqjDiWnyZrOxgJnvjRX.png" alt="img"></p>
<p>在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/uPzZ1iOh0bQpKkYbWCAc.png" alt="img"></p>
<p><strong>② 创建用户列表</strong></p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/x1pHe9duvadzeUfoeOac.png" alt="img"></p>
<p>在用户列表快速创建一个用户：支持用户关联角色的功能。</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/VZLXACV2P72RTzJn0Us8.png" alt="img"></p>
<p>上述案例是基于最简单的 RBAC0 模型创建，适用于大部分常规的权限管理系统。</p>
<p>下面再分析一下 RBAC1 中角色分级具体如何设计。</p>
<ol>
<li><strong>在 RBAC0 的基础上，加上角色等级这个字段。</strong></li>
<li><strong>权限分配规则制定</strong>：低等级角色只能在高等级角色权限基础上进行删减权限。</li>
</ol>
<p>具体界面呈现如下图：</p>
<p><img src="http://image.woshipm.com/wp-files/2018/07/lGcyi0RJKsKmDI6C0bXy.png" alt="img"></p>
<p>以上就是简单的 RBAC 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 RBAC 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。</p>
<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><h3 id="OAuth2-0-简介"><a href="#OAuth2-0-简介" class="headerlink" title="OAuth2.0 简介"></a>OAuth2.0 简介</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> 是一个授权标准协议。OAuth 在全世界得到广泛应用，目前的版本是 2.0 版。</p>
<p>简单来说，<strong>OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p>根据 OAuth 2.0 协议规范，主要有<strong>四个主体</strong>：</p>
<ul>
<li><strong>授权服务器</strong>：负责颁发 Access Token。</li>
<li><strong>资源所有者</strong>：你的应用的用户是资源的所有者，授权其他人访问他的资源。</li>
<li><strong>调用方</strong>：调用方请求获取 Access Token，经过用户授权后，授权服务器为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。</li>
<li><strong>资源服务器</strong>：接受 Access Token，然后验证它的被赋予的权限项目，最后返回资源。</li>
</ul>
<p>其他重要概念：</p>
<ul>
<li>一次 OAuth 2.0 授权是指用户<strong>授权调用方</strong>相关的权限。</li>
<li><strong>Code 授权码</strong>是由授权服务器颁发的，用于调用方使用 Code 换取 Token。</li>
<li><strong>Access Token</strong> 由授权服务器颁发，持有 Access Token 说明完成了用户授权。</li>
<li><strong>Refresh Token</strong> 是一个可选的 Token，用于在 Access Token 过期后获取一个新的 Access Token。</li>
</ul>
<h3 id="OAuth-2-0-授权模式"><a href="#OAuth-2-0-授权模式" class="headerlink" title="OAuth 2.0 授权模式"></a>OAuth 2.0 授权模式</h3><p>OAuth 2.0 定义了四种授权方式。</p>
<ul>
<li><strong>授权码模式（authorization code）</strong></li>
<li><strong>简化模式（implicit）</strong></li>
<li><strong>密码模式（resource owner password credentials）</strong></li>
<li><strong>客户端模式（client credentials）</strong></li>
</ul>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<h4 id="隐藏模式"><a href="#隐藏模式" class="headerlink" title="隐藏模式"></a>隐藏模式</h4><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<h4 id="客户端凭证模式"><a href="#客户端凭证模式" class="headerlink" title="客户端凭证模式"></a>客户端凭证模式</h4><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h3 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/azure/active-directory/develop/authorization-basics">Microsoft Azure 中国技术文档 - 授权基础知识</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63769951">RBAC用户、角色、权限、组设计方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce0944b4a903">权限系统设计模型分析（DAC，MAC，RBAC，ABAC）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/pd/1150093.html">RBAC 模型：基于用户-角色-权限控制的一些思考</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/79ba0350/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/79ba0350/" class="post-title-link" itemprop="url">Spring 之事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-22 07:46:49" itemprop="dateCreated datePublished" datetime="2022-09-22T07:46:49+08:00">2022-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>39k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-之事务"><a href="#Spring-之事务" class="headerlink" title="Spring 之事务"></a>Spring 之事务</h1><p>Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 <code>@Transactional</code> 注解，即可一键开启方法的事务性配置。</p>
<h2 id="理解事务"><a href="#理解事务" class="headerlink" title="理解事务"></a>理解事务</h2><p>在软件开发领域，全有或全无的操作被称为<strong>事务（transaction）</strong>。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：<strong>全局事务</strong>或<strong>本地事务</strong>，两者都有很大的局限性。</p>
<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 <strong>ACID</strong>。</p>
<ul>
<li><strong>原子性（Atomic）</strong>：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li><strong>一致性（Consistent）</strong>：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li><strong>隔离性（Isolated）</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li><strong>持久性（Durable）</strong>：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因在于其异常模型）。此外，JTA UserTransaction 通常需要来自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用程序服务器环境中可用。</p>
<p>以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是一种声明式事务管理（不同于程序化事务管理）。 EJB CMT 消除了对与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身就需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。其明显的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，它仅在选择在 EJB 中实现业务逻辑（或至少在事务性 EJB 外观之后）时才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务是指定资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。</p>
<h3 id="Spring-对事务的支持"><a href="#Spring-对事务的支持" class="headerlink" title="Spring 对事务的支持"></a>Spring 对事务的支持</h3><p>Spring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。Spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。Spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。</p>
<ul>
<li>编码式事务允许用户在代码中精确定义事务的边界</li>
<li>声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦</li>
</ul>
<p>通过程序化事务管理，开发人员可以使用 Spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 Spring 事务 API 或任何其他事务 API。</p>
<h3 id="Spring-事务的优点"><a href="#Spring-事务的优点" class="headerlink" title="Spring 事务的优点"></a>Spring 事务的优点</h3><p>Spring 框架为事务管理提供了一致的抽象，具有以下好处：</p>
<ul>
<li>跨不同事务 API 的一致编程模型，例如 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA)。</li>
<li>支持声明式事务管理。</li>
<li>用于编程事务管理的 API 比复杂事务 API（如 JTA）更简单。</li>
<li>与 Spring 的数据访问抽象完美集成。</li>
</ul>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h3 id="TransactionManager"><a href="#TransactionManager" class="headerlink" title="TransactionManager"></a>TransactionManager</h3><p>Spring 事务抽象的关键是事务策略的概念。事务策略由 <code>TransactionManager</code> 定义，特别是用于命令式事务管理的 <code>org.springframework.transaction.PlatformTransactionManager</code> 接口和用于响应式事务管理的 <code>org.springframework.transaction.ReactiveTransactionManager</code> 接口。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220922073737.png"></p>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>以下清单显示了 <code>PlatformTransactionManager</code> API 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PlatformTransactionManager</code> 是一个 SPI 接口，所以使用者可以以编程方式使用它。因为 <code>PlatformTransactionManager</code> 是一个接口，所以可以根据需要轻松地 MOCK 或存根。它不依赖于查找策略，例如 JNDI。 <code>PlatformTransactionManager</code> 实现的定义与 Spring IoC 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 Spring 事务成为有价值的抽象，即使您使用 JTA 也是如此。与直接使用 JTA 相比，您可以更轻松地测试事务代码。</p>
<p>同样，为了与 Spring 的理念保持一致，任何 <code>PlatformTransactionManager</code> 接口的方法可以抛出的 <code>TransactionException</code> 都是未经检查的（也就是说，它扩展了 <code>java.lang.RuntimeException</code> 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 <code>TransactionException</code>。重点是开发人员并非被迫这样做。</p>
<p><code>getTransaction(..)</code> 方法根据 <code>TransactionDefinition</code> 参数返回一个 <code>TransactionStatus</code> 对象。如果当前调用堆栈中存在匹配的事务，则返回的 <code>TransactionStatus</code> 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 Java EE 事务上下文一样，<code>TransactionStatus</code> 与执行线程相关联。</p>
<p>从以上可以看出，具体的事务管理机制对 Spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 Spring 事务管理的一个优点就是为不同的事务 API 提供一致的编程模型，如 JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<h4 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h4><p>如果应用程序中直接使用 JDBC 来进行持久化，<code>DataSourceTransactionManager</code> 会为你处理事务边界。为了使用 <code>DataSourceTransactionManager</code>，你需要使用如下的 XML 将其装配到应用程序的上下文定义中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上，<code>DataSourceTransactionManager</code> 是通过调用 <code>java.sql.Connection</code> 来管理事务，而后者是通过 <code>DataSource</code> 获取到的。通过调用连接的 <code>commit()</code> 方法来提交事务，同样，事务失败则通过调用 <code>rollback()</code> 方法进行回滚。</p>
<h4 id="Hibernate-事务"><a href="#Hibernate-事务" class="headerlink" title="Hibernate 事务"></a>Hibernate 事务</h4><p>如果应用程序的持久化是通过 Hibernate 实现的，那么你需要使用 <code>HibernateTransactionManager</code>。对于 Hibernate3，需要在 Spring 上下文定义中添加如下的 <code>bean</code> 声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>sessionFactory</code> 属性需要装配一个 Hibernate 的 session 工厂，<code>HibernateTransactionManager</code> 的实现细节是它将事务管理的职责委托给 <code>org.hibernate.Transaction</code> 对象，而后者是从 Hibernate Session 中获取到的。当事务成功完成时，<code>HibernateTransactionManager</code> 将会调用 <code>Transaction</code> 对象的 <code>commit()</code> 方法，反之，将会调用 <code>rollback()</code> 方法。</p>
<h4 id="Java-持久化-API-事务（JPA）"><a href="#Java-持久化-API-事务（JPA）" class="headerlink" title="Java 持久化 API 事务（JPA）"></a>Java 持久化 API 事务（JPA）</h4><p>Hibernate 多年来一直是事实上的 Java 持久化标准，但是现在 Java 持久化 API 作为真正的 Java 持久化标准进入大家的视野。如果你计划使用 JPA 的话，那你需要使用 Spring 的 <code>JpaTransactionManager</code> 来处理事务。你需要在 Spring 中这样配置 <code>JpaTransactionManager</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>JpaTransactionManager</code> 只需要装配一个 JPA 实体管理工厂（<code>javax.persistence.EntityManagerFactory</code> 接口的任意实现）。<code>JpaTransactionManager</code> 将与由工厂所产生的 JPA EntityManager 合作来构建事务。</p>
<h4 id="Java-原生-API-事务（JTA）"><a href="#Java-原生-API-事务（JTA）" class="headerlink" title="Java 原生 API 事务（JTA）"></a>Java 原生 API 事务（JTA）</h4><p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用<code>JtaTransactionManager</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManagerName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java:/TransactionManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>JtaTransactionManager</code> 将事务管理的责任委托给 <code>javax.transaction.UserTransaction</code> 和 <code>javax.transaction.TransactionManager</code> 对象，其中事务成功完成通过 <code>UserTransaction.commit()</code> 方法提交，事务失败通过 <code>UserTransaction.rollback()</code> 方法回滚。</p>
<h4 id="ReactiveTransactionManager"><a href="#ReactiveTransactionManager" class="headerlink" title="ReactiveTransactionManager"></a>ReactiveTransactionManager</h4><p>Spring 还为使用响应式类型或 Kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 <code>org.springframework.transaction.ReactiveTransactionManager</code> 定义的事务策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReactiveTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    Mono&lt;ReactiveTransaction&gt; <span class="title function_">getReactiveTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">commit</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">rollback</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应式事务管理器主要是一个 SPI，所以使用者可以以编程方式使用它。因为 <code>ReactiveTransactionManager</code> 是一个接口，所以可以根据需要轻松地 MOCK 或存根。</p>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p><code>PlatformTransactionManager</code> 通过 <code>getTransaction(TransactionDefinition definition)</code> 方法来得到事务，这个方法里面的参数是 <code>TransactionDefinition</code> 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p>
<p><code>TransactionDefinition</code> 接口内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>; <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>; <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;  <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>; <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现 <code>TransactionDefinition</code> 正好用来定义事务属性，下面详细介绍一下各个事务属性。</p>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring 定义了七种传播行为：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>PROPAGATION_REQUIRED</code></td>
<td>表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td>
</tr>
<tr>
<td><code>PROPAGATION_SUPPORTS</code></td>
<td>表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
<tr>
<td><code>PROPAGATION_MANDATORY</code></td>
<td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td><code>PROPAGATION_REQUIRED_NEW</code></td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager</td>
</tr>
<tr>
<td><code>PROPAGATION_NOT_SUPPORTED</code></td>
<td>表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager</td>
</tr>
<tr>
<td><code>PROPAGATION_NEVER</code></td>
<td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td><code>PROPAGATION_NESTED</code></td>
<td>表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与 PROPAGATION_REQUIRED 一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td>
</tr>
</tbody></table>
<p><em>注：以下具体讲解传播行为的内容参考自 Spring 事务机制详解</em></p>
<ol>
<li>PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA &#123;</span><br><span class="line">    ……</span><br><span class="line">    methodB();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodB &#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 spring 声明式事务，spring 使用 AOP 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。</p>
<p>单独调用 methodB 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">    metodB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Main &#123;</span><br><span class="line">    Connection con=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        con = getConnection();</span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法调用</span></span><br><span class="line">        methodB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; Catch(RuntimeException ex) &#123;</span><br><span class="line">        <span class="comment">//回滚事务</span></span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        closeCon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 保证在 methodB 方法中所有的调用都获得到一个相同的连接。在调用 methodB 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。<br>单独调用 MethodA 时，在 MethodA 内又会调用 MethodB.</p>
<p>执行效果相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        con = getConnection();</span><br><span class="line">        methodA();</span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RuntimeException ex) &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeCon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 MethodA 时，环境中没有事务，所以开启一个新的事务.当在 MethodA 中调用 MethodB 时，环境中已经有了一个事务，所以 methodB 就加入当前事务。</p>
<ol start="2">
<li><code>PROPAGATION_SUPPORTS</code> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，<code>PROPAGATION_SUPPORTS</code> 与不使用事务有少许不同。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">  methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_SUPPORTS</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯的调用 methodB 时，methodB 方法是非事务的执行的。当调用 methdA 时,methodB 则加入了 methodA 的事务中,事务地执行。</p>
<ol start="3">
<li><code>PROPAGATION_MANDATORY</code> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="built_in">methodA</span>()&#123;</span><br><span class="line">    <span class="built_in">methodB</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_MANDATORY</span></span><br><span class="line">    <span class="built_in">methodB</span>()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当单独调用 methodB 时，因为当前没有一个活动的事务，则会抛出异常 throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methodA 时，methodB 则加入到 methodA 的事务中，事务地执行。</p>
<ol start="4">
<li><code>PROPAGATION_REQUIRES_NEW</code> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="built_in">methodA</span>()&#123;</span><br><span class="line">    <span class="built_in">doSomeThingA</span>();</span><br><span class="line">    <span class="built_in">methodB</span>();</span><br><span class="line">    <span class="built_in">doSomeThingB</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRES_NEW</span></span><br><span class="line"><span class="built_in">methodB</span>()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 A 方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span>()&#123;</span><br><span class="line">    <span class="built_in">methodA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获得一个JTA事务管理器</span></span><br><span class="line">        tm = getTransactionManager();</span><br><span class="line">        tm.begin();<span class="comment">//开启一个新的事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">ts1</span> <span class="operator">=</span> tm.getTransaction();</span><br><span class="line">        doSomeThing();</span><br><span class="line">        tm.suspend();<span class="comment">//挂起当前事务</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            tm.begin();<span class="comment">//重新开启第二个事务</span></span><br><span class="line">            <span class="type">Transaction</span> <span class="variable">ts2</span> <span class="operator">=</span> tm.getTransaction();</span><br><span class="line">            methodB();</span><br><span class="line">            ts2.commit();<span class="comment">//提交第二个事务</span></span><br><span class="line">        &#125; Catch(RunTimeException ex) &#123;</span><br><span class="line">            ts2.rollback();<span class="comment">//回滚第二个事务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//methodB执行完后，恢复第一个事务</span></span><br><span class="line">        tm.resume(ts1);</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        ts1.commit();<span class="comment">//提交第一个事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(RunTimeException ex) &#123;</span><br><span class="line">        ts1.rollback();<span class="comment">//回滚第一个事务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。Ts2 是否成功并不依赖于 ts1。如果 methodA 方法在调用 methodB 方法后的 doSomeThingB 方法失败了，而 methodB 方法所做的结果依然被提交。而除了 methodB 之外的其它代码导致的结果却被回滚了。使用 PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager 作为事务管理器。</p>
<ol start="5">
<li><code>PROPAGATION_NOT_SUPPORTED</code> 总是非事务地执行，并挂起任何存在的事务。使用 PROPAGATION_NOT_SUPPORTED,也需要使用 JtaTransactionManager 作为事务管理器。（代码示例同上，可同理推出）</li>
<li>PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。</li>
<li>PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用 JDBC 3.0 驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器。需要 JDBC 驱动的 java.sql.Savepoint 类。有一些 JTA 的事务管理器实现可能也提供了同样的功能。使用 PROPAGATION_NESTED，还需要把 PlatformTransactionManager 的 nestedTransactionAllowed 属性设为 true;而 nestedTransactionAllowed 属性值默认为 false。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="built_in">methodA</span>()&#123;</span><br><span class="line">    <span class="built_in">doSomeThingA</span>();</span><br><span class="line">    <span class="built_in">methodB</span>();</span><br><span class="line">    <span class="built_in">doSomeThingB</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_NESTED</span></span><br><span class="line"><span class="built_in">methodB</span>()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单独调用 methodB 方法，则按 REQUIRED 属性执行。如果调用 methodA 方法，相当于下面的效果：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    Connection con <span class="operator">=</span> null<span class="comment">;</span></span><br><span class="line">    Savepoint savepoint <span class="operator">=</span> null<span class="comment">;</span></span><br><span class="line">    try&#123;</span><br><span class="line">        con <span class="operator">=</span> getConnection()<span class="comment">;</span></span><br><span class="line">        con.setAutoCommit(false)<span class="comment">;</span></span><br><span class="line">        doSomeThingA()<span class="comment">;</span></span><br><span class="line">        savepoint <span class="operator">=</span> con2.setSavepoint()<span class="comment">;</span></span><br><span class="line">        try&#123;</span><br><span class="line">            methodB()<span class="comment">;</span></span><br><span class="line">        &#125; catch(RuntimeException ex) &#123;</span><br><span class="line">            con.rollback(savepoint)<span class="comment">;</span></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放资源</span><br><span class="line">        &#125;</span><br><span class="line">        doSomeThingB()<span class="comment">;</span></span><br><span class="line">        con.commit()<span class="comment">;</span></span><br><span class="line">    &#125; catch(RuntimeException ex) &#123;</span><br><span class="line">        con.rollback()<span class="comment">;</span></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 methodB 方法调用之前，调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括 methodB 方法的所有操作。</p>
<p>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p>PROPAGATION_NESTED 与 PROPAGATION_REQUIRES_NEW 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 JTA 事务管理器的支持。</p>
<p>使用 PROPAGATION_NESTED 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager 使用 savepoint 支持 PROPAGATION_NESTED 时，需要 JDBC 3.0 以上驱动及 1.4 以上的 JDK 版本支持。其它的 JTA TrasactionManager 实现可能有不同的支持方式。</p>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。</p>
<p>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.</p>
<p>PROPAGATION_REQUIRED 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。</p>
<ol>
<li>并发事务引起的问题</li>
</ol>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。</p>
<ul>
<li>脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li>
<li>不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li>
<li>幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li>
</ul>
<p><strong>不可重复读与幻读的区别</strong></p>
<p>不可重复读的重点是修改:<br>同样的条件, 你读取过的数据, 再次读取出来发现值不一样了<br>例如：在事务 1 中，Mary 读取了自己的工资为 1000,操作并没有完成</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">con1</span> <span class="operator">=</span> getConnection()<span class="comment">;</span></span><br><span class="line">select salary from employee empId <span class="operator">=</span><span class="string">&quot;Mary&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在事务 2 中，这时财务人员修改了 Mary 的工资为 2000,并提交了事务.</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">con2</span> <span class="operator">=</span> getConnection()<span class="comment">;</span></span><br><span class="line">update employee set salary <span class="operator">=</span> <span class="number">2000</span><span class="comment">;</span></span><br><span class="line">con2.commit()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在事务 1 中，Mary 再次读取自己的工资时，工资变为了 2000</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//con1</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> employee empId =<span class="string">&quot;Mary&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在一个事务中前后两次读取的结果并不一致，导致了不可重复读。</p>
<p>幻读的重点在于新增或者删除：<br>同样的条件, 第 1 次和第 2 次读出来的记录数不一样<br>例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">con1</span> <span class="operator">=</span> getConnection()<span class="comment">;</span></span><br><span class="line">Select * from employee where salary <span class="operator">=</span><span class="number">1000</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>共读取 10 条记录</p>
<p>这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">con2 = getConnection();</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> employee(empId,salary) <span class="keyword">values</span>(&quot;Lili&quot;,<span class="number">1000</span>);</span><br><span class="line">con2.<span class="keyword">commit</span>();</span><br></pre></td></tr></table></figure>

<p>事务 1 再次读取所有工资为 1000 的员工</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//con1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> salary =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>共读取到了 11 条记录，这就产生了幻像读。</p>
<p>从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。<br>对于前者, 只需要锁住满足条件的记录。<br>对于后者, 要锁住满足条件及其相近的记录。</p>
<ol start="2">
<li>隔离级别</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>最高的隔离级别，完全服从 ACID 的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
</tr>
</tbody></table>
<h4 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h4><p>事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><p>事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 EJB 的回滚行为是一致的）<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p><code>TransactionStatus</code> 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 API 都是通用的。以下清单显示了 <code>TransactionStatus</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span> <span class="keyword">extends</span> <span class="title class_">TransactionExecution</span>, SavepointManager, Flushable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCompleted</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。</p>
<h3 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h3><p>Spring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦。TransactionTemplate 就是用于支持编程式事务的核心 API。</p>
<p>采用 TransactionTemplate 和采用其他 Spring 模板，如 JdbcTempalte 和 HibernateTemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate 是线程安全的。代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionTemplate</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(); <span class="comment">// 新建一个TransactionTemplate</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> tt.execute(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">doTransaction</span><span class="params">(TransactionStatus status)</span>&#123;</span><br><span class="line">            updateOperation();</span><br><span class="line">            <span class="keyword">return</span> resultOfUpdateOperation();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;); <span class="comment">// 执行execute方法进行事务管理</span></span><br></pre></td></tr></table></figure>

<p>使用 TransactionCallback()可以返回一个值。如果使用 TransactionCallbackWithoutResult 则没有返回值。</p>
<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><blockquote>
<p>大多数 Spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。</p>
</blockquote>
<p>Spring 框架的声明式事务管理是通过 Spring AOP 实现的。然而，由于事务方面代码随 Spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 AOP 概念即可有效地使用此代码。</p>
<p>Spring 框架的声明式事务管理类似于 EJB CMT，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 <code>setRollbackOnly()</code> 调用。两种类型的事务管理之间的区别是：</p>
<ul>
<li>与绑定到 JTA 的 EJB CMT 不同，Spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 JDBC、JPA 或 Hibernate 处理 JTA 事务或本地事务。</li>
<li>您可以将 Spring 声明式事务管理应用于任何类，而不仅仅是诸如 EJB 之类的特殊类。</li>
<li>Spring 提供声明性回滚规则，这是一个没有 EJB 等效功能的特性。提供了对回滚规则的编程和声明性支持。</li>
<li>Spring 允许您使用 AOP 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 EJB CMT，您无法影响容器的事务管理，除非使用 <code>setRollbackOnly()</code>。</li>
<li>Spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 EJB。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。</li>
</ul>
<p>回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 Java 代码中。因此，尽管您仍然可以在 TransactionStatus 对象上调用 setRollbackOnly() 来回滚当前事务，但通常您可以指定 MyApplicationException 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 Spring 事务 API 或其他 Spring API。</p>
<p>尽管 EJB 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 EJB CMT 不会在应用程序异常（即除 java.rmi.RemoteException 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 Spring 默认行为遵循 EJB 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。</p>
<h3 id="Spring-声明式事务管理的实现"><a href="#Spring-声明式事务管理的实现" class="headerlink" title="Spring 声明式事务管理的实现"></a>Spring 声明式事务管理的实现</h3><p>关于 Spring 框架的声明式事务支持，最重要的概念是这种支持是通过 AOP 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 XML 或基于注释的）。 AOP 与事务元数据的结合产生了一个 AOP 代理，它使用 <code>TransactionInterceptor</code> 和适当的 <code>TransactionManager</code> 实现来驱动围绕方法调用的事务。</p>
<p>Spring 的 <code>TransactionInterceptor</code> 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 Publisher 或 Kotlin Flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。</p>
<p>事务管理风格会影响需要哪个事务管理器。命令式事务需要 <code>PlatformTransactionManager</code>，而响应式事务使用 <code>ReactiveTransactionManager</code> 实现。</p>
<blockquote>
<p><code>@Transactional</code> 通常与 <code>PlatformTransactionManager</code> 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。</p>
<p>由 <code>ReactiveTransactionManager</code> 管理的反应式事务使用 Reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 Reactor 上下文中执行。</p>
</blockquote>
<p>下图显示了在事务代理上调用方法的概念视图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220927093737.png"></p>
<h3 id="声明式事务示例"><a href="#声明式事务示例" class="headerlink" title="声明式事务示例"></a>声明式事务示例</h3><p>考虑以下接口及其伴随的实现。此示例使用 Foo 和 Bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，DefaultFooService 类在每个已实现方法的主体中抛出 <code>UnsupportedOperationException</code> 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 <code>UnsupportedOperationException</code> 实例。</p>
<p>以下清单显示了 FooService 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the service interface that we want to make transactional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> x.y.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span>;</span><br><span class="line"></span><br><span class="line">    Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了上述接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFooService</span> <span class="keyword">implements</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String, String) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertFoo(Foo) 和 updateFoo(Foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- the transactional advice (what &#x27;happens&#x27;; see the &lt;aop:advisor/&gt; bean below) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- all methods starting with &#x27;get&#x27; are read-only --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">        of an operation defined by the FooService interface --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.FooService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceOperation&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- don&#x27;t forget the DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scott&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tiger&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- similarly, don&#x27;t forget the TransactionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>检查前面的配置。它假定您要使服务对象 fooService bean 具有事务性。要应用的事务语义封装在 <code>&lt;tx:advice/&gt;</code> 定义中。<code>&lt;tx:advice/&gt;</code> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<code>&lt;tx:advice/&gt;</code> 标签的 <code>transaction-manager</code> 属性设置为将驱动事务的 TransactionManager bean 的名称（在本例中为 txManager bean）。</p>
<blockquote>
<p>如果要连接的 TransactionManager 的 bean 名称具有名称 transactionManager，则可以省略事务 advice (tx:advice&#x2F;) 中的 transaction-manager 属性。如果要连接的 TransactionManager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。</p>
</blockquote>
<p><code>&lt;aop:config/&gt;</code> 定义确保由 <code>txAdvice</code> bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 <code>FooService</code> 接口 (fooServiceOperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 <code>txAdvice</code> 相关联。结果表明，在执行 fooServiceOperation 时，会运行 <code>txAdvice</code> 定义的建议。</p>
<p>一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceMethods&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceMethods&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面显示的配置用于围绕从 fooService bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Boot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;context.xml&quot;</span>);</span><br><span class="line">        <span class="type">FooService</span> <span class="variable">fooService</span> <span class="operator">=</span> ctx.getBean(FooService.class);</span><br><span class="line">        fooService.insertFoo(<span class="keyword">new</span> <span class="title class_">Foo</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回滚一个声明性事务"><a href="#回滚一个声明性事务" class="headerlink" title="回滚一个声明性事务"></a>回滚一个声明性事务</h3><p>Spring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。Spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。</p>
<p>在其默认配置中，Spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 <code>RuntimeException</code> 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。</p>
<p>您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。</p>
<blockquote>
<p>回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 <code>Throwable</code> 的子类），目前不支持通配符。例如，<code>javax.servlet.ServletException</code> 或 <code>ServletException</code> 的值将匹配 <code>javax.servlet.ServletException</code> 及其子类。</p>
<p>回滚规则可以通过 <code>rollback-for</code> 和 <code>no-rollback-for</code> 属性在 XML 中配置，这允许将模式指定为字符串。使用 <code>@Transactional</code> 时，可以通过 <code>rollbackFor</code> &#x2F; <code>noRollbackFor</code> 和<code>rollbackForClassName</code> &#x2F; <code>noRollbackForClassName</code> 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，<code>@Transactional(rollbackFor = example.CustomException.class)</code> 等价于 <code>@Transactional(rollbackForClassName = &#39;example.CustomException&#39;)</code>。</p>
</blockquote>
<p>以下 XML 片段演示了如何通过 <code>rollback-for</code> 属性提供异常模式来为已检查的、特定的 <code>Exception</code> 类型配置回滚：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;NoProductInStockException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 Spring 事务框架，即使在面对未处理的 InstrumentNotFoundException 时也要提交伴随事务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;updateStock&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 Spring Framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 <code>InstrumentNotFoundException</code> 之外的任何异常都会导致伴随事务的回滚。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Throwable&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 Spring Framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resolvePosition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// some business logic...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoProductInStockException ex) &#123;</span><br><span class="line">        <span class="comment">// trigger rollback programmatically</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。</p>
<h3 id="为不同的-Bean-配置不同的事务语义"><a href="#为不同的-Bean-配置不同的事务语义" class="headerlink" title="为不同的 Bean 配置不同的事务语义"></a>为不同的 Bean 配置不同的事务语义</h3><p>考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <code>&lt;aop:advisor/&gt;</code> 元素和不同 <code>advice-ref</code> 属性值的切点来实现这一点。</p>
<p>作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 Service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service..*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- these two beans will be transactional... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.extras.SimpleBarService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... and these two beans won&#x27;t --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.SomeService&quot;</span>/&gt;</span> <span class="comment">&lt;!-- (not in the right package) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;barManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.SimpleBarManager&quot;</span>/&gt;</span> <span class="comment">&lt;!-- (doesn&#x27;t end in &#x27;Service&#x27;) --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;defaultServiceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;noTxServiceOperation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;defaultServiceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;defaultTxAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;noTxServiceOperation&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;noTxAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this bean will be transactional (see the &#x27;defaultServiceOperation&#x27; pointcut) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherFooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.ddl.DefaultDdlManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;defaultTxAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;noTxAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other transaction infrastructure beans such as a TransactionManager omitted... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="&lt;tx:advice/&gt; 配置"></a><code>&lt;tx:advice/&gt;</code> 配置</h3><p><code>&lt;tx:advice/&gt;</code> 的默认配置为：</p>
<ul>
<li><p>传播设置是 <code>REQUIRED</code></p>
</li>
<li><p>隔离级别为 <code>DEFAULT</code></p>
</li>
<li><p>事务是 read-write</p>
</li>
<li><p>事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。</p>
</li>
<li><p>任何 <code>RuntimeException</code> 都会触发回滚，而任何已检查的 <code>Exception</code> 都不会</p>
</li>
</ul>
<p><code>&lt;tx:advice/&gt;</code> 配置属性</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">是否必要</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">Yes</td>
<td align="left"></td>
<td align="left">与事务属性关联的方法名称。支持通配符，如：<code>get*</code>、<code>handle*</code>、<code>on*Event</code></td>
</tr>
<tr>
<td align="left"><code>propagation</code></td>
<td align="left">No</td>
<td align="left"><code>REQUIRED</code></td>
<td align="left">事务传播行为</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left">No</td>
<td align="left"><code>DEFAULT</code></td>
<td align="left">事务隔离级别。仅适用于 <code>REQUIRED</code> 或 <code>REQUIRES_NEW</code> 的传播设置。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">No</td>
<td align="left">-1</td>
<td align="left">事务超时时间（单位：秒）。仅适用于 <code>REQUIRED</code> 或 <code>REQUIRES_NEW</code> 的传播设置。</td>
</tr>
<tr>
<td align="left"><code>read-only</code></td>
<td align="left">No</td>
<td align="left">false</td>
<td align="left">read-write 或 read-only 事务。</td>
</tr>
<tr>
<td align="left"><code>rollback-for</code></td>
<td align="left">No</td>
<td align="left"></td>
<td align="left">触发回滚的 <code>Exception</code> 实例列表（通过逗号分隔）。</td>
</tr>
<tr>
<td align="left"><code>no-rollback-for</code></td>
<td align="left">No</td>
<td align="left"></td>
<td align="left">不触发回滚的 <code>Exception</code> 实例列表（通过逗号分隔）。</td>
</tr>
</tbody></table>
<h3 id="使用-Transactional-注解"><a href="#使用-Transactional-注解" class="headerlink" title="使用 @Transactional 注解"></a>使用 <code>@Transactional</code> 注解</h3><p>除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。</p>
<p>下面是一个使用 <code>@Transactional</code> 注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFooService</span> <span class="keyword">implements</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Foo <span class="title function_">getFoo</span><span class="params">(String fooName, String barName)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所述在类级别使用，<code>@Transactional</code> 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。</p>
<p>当上面的 POJO 类在 Spring 上下文中定义为 bean 时，您可以通过 <code>@Configuration</code> 类中的 <code>@EnableTransactionManagement</code> 注解使 bean 实例具有事务性。</p>
<p>在 XML 配置中， <code>&lt;tx:annotation-driven/&gt;</code> 标签提供了类似的便利：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- a TransactionManager is still required --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- (this dependency is defined somewhere else) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Transactional-配置"><a href="#Transactional-配置" class="headerlink" title="@Transactional 配置"></a><code>@Transactional</code> 配置</h4><table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-multiple-tx-mgrs-with-attransactional">value</a></td>
<td align="left"><code>String</code></td>
<td align="left">Optional qualifier that specifies the transaction manager to be used.</td>
</tr>
<tr>
<td align="left"><code>transactionManager</code></td>
<td align="left"><code>String</code></td>
<td align="left">Alias for <code>value</code>.</td>
</tr>
<tr>
<td align="left"><code>label</code></td>
<td align="left">Array of <code>String</code> labels to add an expressive description to the transaction.</td>
<td align="left">Labels may be evaluated by transaction managers to associate implementation-specific behavior with the actual transaction.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation">propagation</a></td>
<td align="left"><code>enum</code>: <code>Propagation</code></td>
<td align="left">Optional propagation setting.</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left"><code>enum</code>: <code>Isolation</code></td>
<td align="left">Optional isolation level. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left"><code>int</code> (in seconds of granularity)</td>
<td align="left">Optional transaction timeout. Applies only to propagation values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>timeoutString</code></td>
<td align="left"><code>String</code> (in seconds of granularity)</td>
<td align="left">Alternative for specifying the <code>timeout</code> in seconds as a <code>String</code> value — for example, as a placeholder.</td>
</tr>
<tr>
<td align="left"><code>readOnly</code></td>
<td align="left"><code>boolean</code></td>
<td align="left">Read-write versus read-only transaction. Only applicable to values of <code>REQUIRED</code> or <code>REQUIRES_NEW</code>.</td>
</tr>
<tr>
<td align="left"><code>rollbackFor</code></td>
<td align="left">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></td>
<td align="left">Optional array of exception types that must cause rollback.</td>
</tr>
<tr>
<td align="left"><code>rollbackForClassName</code></td>
<td align="left">Array of exception name patterns.</td>
<td align="left">Optional array of exception name patterns that must cause rollback.</td>
</tr>
<tr>
<td align="left"><code>noRollbackFor</code></td>
<td align="left">Array of <code>Class</code> objects, which must be derived from <code>Throwable.</code></td>
<td align="left">Optional array of exception types that must not cause rollback.</td>
</tr>
<tr>
<td align="left"><code>noRollbackForClassName</code></td>
<td align="left">Array of exception name patterns.</td>
<td align="left">Optional array of exception name patterns that must not cause rollback.</td>
</tr>
</tbody></table>
<h4 id="多事务管理器场景下使用-Transactional"><a href="#多事务管理器场景下使用-Transactional" class="headerlink" title="多事务管理器场景下使用 @Transactional"></a>多事务管理器场景下使用 <code>@Transactional</code></h4><p>某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 <code>@Transactional</code> 注释的 value 或 <code>transactionManager</code> 属性来选择性地指定要使用的 <code>TransactionManager</code> 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;order&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomething</span><span class="params">(String name)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;account&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;reactive-account&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">doSomethingReactive</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示如何定义 <code>TransactionManager</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;account&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;reactive-account&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>TransactionalService</code> 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 <code>TransactionManager</code> bean，则仍使用默认的 <code>&lt;tx:annotation-driven&gt;</code> 目标 bean 名称。</p>
<h4 id="自定义组合注解"><a href="#自定义组合注解" class="headerlink" title="自定义组合注解"></a>自定义组合注解</h4><p>如果您发现在许多不同的方法上重复使用 <code>@Transactional</code> 相同的属性，可以使用 Spring 的元注解自定义组合注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Transactional(transactionManager = &quot;order&quot;, label = &quot;causal-consistency&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Transactional(transactionManager = &quot;account&quot;, label = &quot;retryable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OrderTx</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AccountTx</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。</p>
<h4 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h4><p>在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220928114544.png"></p>
<p><code>PROPAGATION_REQUIRED</code> 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。</p>
<p>当传播设置为 PROPAGATION_REQUIRED 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 PROPAGATION_REQUIRED 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。</p>
<p>但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 <code>UnexpectedRollbackException</code>。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 <code>UnexpectedRollbackException</code> 以清楚地指示执行了回滚。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220928115243.png"></p>
<p>PROPAGATION_REQUIRES_NEW 与 PROPAGATION_REQUIRED 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。</p>
<h2 id="JDBC-异常抽象"><a href="#JDBC-异常抽象" class="headerlink" title="JDBC 异常抽象"></a>JDBC 异常抽象</h2><p>Spring 会将数据操作的异常转换为 <code>DataAccessException</code>。</p>
<p>Spring 是怎么认识那些错误码的</p>
<p>通过 SQLErrorCodeSQLExceptionTranslator 解析错误码</p>
<p>ErrorCode 定义（sql-error-codes.xml 文件）</p>
<h2 id="Spring-事务最佳实践"><a href="#Spring-事务最佳实践" class="headerlink" title="Spring 事务最佳实践"></a>Spring 事务最佳实践</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200805171418.png" alt="img"></p>
<h3 id="Spring-事务未生效"><a href="#Spring-事务未生效" class="headerlink" title="Spring 事务未生效"></a>Spring 事务未生效</h3><p>使用 <code>@Transactional</code> 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。</p>
<p><code>@Transactional</code> 生效原则：</p>
<h4 id="Transactional-方法必须是-public"><a href="#Transactional-方法必须是-public" class="headerlink" title="@Transactional 方法必须是 public"></a>@Transactional 方法必须是 public</h4><p>原则一：除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则<strong>只有定义在 <code>public</code> 方法上的 <code>@Transactional</code> 才能生效</strong>。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。</p>
<p>【示例】错误使用 <code>@Transactional</code> 案例一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createUserPrivate</span><span class="params">(UserEntity entity)</span> &#123;</span><br><span class="line">	userRepository.save(entity);</span><br><span class="line">	<span class="keyword">if</span> (entity.getName().contains(<span class="string">&quot;test&quot;</span>)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid username!&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createUserWrong1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.createUserPrivate(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		log.error(<span class="string">&quot;create user failed because &#123;&#125;&quot;</span>, ex.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> userRepository.findByName(name).size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传入名为 test 的用户实体，会抛出异常，但 <code>@Transactional</code> 未生效，不会触发回滚。</p>
<h4 id="必须通过-Spring-注入的-Bean-进行调用"><a href="#必须通过-Spring-注入的-Bean-进行调用" class="headerlink" title="必须通过 Spring 注入的 Bean 进行调用"></a>必须通过 Spring 注入的 Bean 进行调用</h4><p>原则二：<strong>必须通过代理过的类从外部调用目标方法才能生效</strong>。</p>
<p>【示例】错误使用 <code>@Transactional</code> 案例二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createUserWrong2</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.createUserPublic(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		log.error(<span class="string">&quot;create user failed because &#123;&#125;&quot;</span>, ex.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> userRepository.findByName(name).size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以传播出异常</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserPublic</span><span class="params">(UserEntity entity)</span> &#123;</span><br><span class="line">	userRepository.save(entity);</span><br><span class="line">	<span class="keyword">if</span> (entity.getName().contains(<span class="string">&quot;test&quot;</span>)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid username!&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传入名为 test 的用户实体，会抛出异常，但 <code>@Transactional</code> 未生效，不会触发回滚。</p>
<p>说明：Spring 通过 AOP 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。</p>
<h3 id="事务虽然生效但未回滚"><a href="#事务虽然生效但未回滚" class="headerlink" title="事务虽然生效但未回滚"></a>事务虽然生效但未回滚</h3><p>通过 AOP 实现事务处理可以理解为，使用 <code>try…catch…</code> 来包裹标记了 <code>@Transactional</code> 注解的方法，当方法出现了异常并且满足<strong>一定条件</strong>的时候，在 <code>catch</code> 里面我们可以设置事务回滚，没有异常则直接提交事务。</p>
<p>“一定条件”，主要包括两点：</p>
<p>第一，只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚。在 Spring 的 TransactionAspectSupport 里有个 invokeWithinTransaction 方法，里面就是处理事务的逻辑。</p>
<p>第二，默认情况下，<strong>出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常无法传播出方法，导致事务无法回滚</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserWrong1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			userRepository.save(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;create user failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//即使出了受检异常也无法让事务回滚</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserWrong2</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		userRepository.save(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">		otherTask();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为文件不存在，一定会抛出一个IOException</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">otherTask</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Files.readAllLines(Paths.get(<span class="string">&quot;file-that-not-exist&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createUserWrong1 方法中会抛出一个 RuntimeException，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。</p>
<p>在 createUserWrong2 方法中，注册用户的同时会有一次 otherTask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 otherTask 方法抛出的是受检异常，createUserWrong2 传播出去的也是受检异常，事务同样不会回滚。</p>
<p>【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，<strong>可以手动设置 <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</code> 让当前事务处于回滚状态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserRight1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      userRepository.save(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;create user failed&quot;</span>, ex);</span><br><span class="line">      TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解决方案二】在注解中声明 <code>@Transactional(rollbackFor = Exception.class)</code>，期望遇到所有的 Exception 都回滚事务（来突破默认不回滚受检异常的限制）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserRight2</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   userRepository.save(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(name));</span><br><span class="line">   otherTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细化事务传播方式"><a href="#细化事务传播方式" class="headerlink" title="细化事务传播方式"></a>细化事务传播方式</h3><p>如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么<br>我们需要考虑进一步细化配置事务传播方式，也就是 <code>@Transactional</code> 注解的 <code>Propagation</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Propagation#REQUIRES_NEW&#125; 表示执行到这个方法时需要开启新的事务，并挂起当前事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createSubUserWithExceptionRight</span><span class="params">(UserEntity entity)</span> &#123;</span><br><span class="line">   log.info(<span class="string">&quot;createSubUserWithExceptionRight start&quot;</span>);</span><br><span class="line">   userRepository.save(entity);</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid status&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/">Spring 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html">Spring 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/data.html">Spring Boot 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100047701">极客时间教程 - Java 业务开发常见错误 100 例</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/a48c4708/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/a48c4708/" class="post-title-link" itemprop="url">数据库连接池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-21 23:58:06" itemprop="dateCreated datePublished" datetime="2022-09-21T23:58:06+08:00">2022-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><blockquote>
<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。——摘自百度百科</p>
</blockquote>
<h2 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h2><p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
<h2 id="为什么需要数据库连接池"><a href="#为什么需要数据库连接池" class="headerlink" title="为什么需要数据库连接池"></a>为什么需要数据库连接池</h2><h3 id="不使用数据库连接池"><a href="#不使用数据库连接池" class="headerlink" title="不使用数据库连接池"></a>不使用数据库连接池</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220921231353.png"></p>
<p>不使用数据库连接池的<strong>步骤</strong>：</p>
<ol>
<li>TCP 建立连接的三次握手</li>
<li>MySQL 认证的三次握手</li>
<li>真正的 SQL 执行</li>
<li>MySQL 的关闭</li>
<li>TCP 的四次握手关闭</li>
</ol>
<p>不使用数据库连接池的特性：</p>
<ul>
<li><strong>优点</strong>：实现简单</li>
<li><strong>缺点</strong>：<ul>
<li>网络 IO 较多</li>
<li>数据库的负载较高</li>
<li>响应时间较长及 QPS 较低</li>
<li>应用频繁的创建连接和关闭连接，导致临时对象较多，GC 频繁</li>
<li>在关闭连接后，会出现大量 TIME_WAIT 的 TCP 状态（在 2 个 MSL 之后关闭）</li>
</ul>
</li>
</ul>
<h3 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220921231500.png"></p>
<p>使用数据库连接池的步骤：只有第一次访问的时候，需要建立连接。 但是之后的访问，均会<strong>复用</strong>之前创建的连接，直接执行 SQL 语句。</p>
<p>使用数据库连接池的<strong>优点</strong>：</p>
<ul>
<li>减少了网络开销</li>
<li>系统的性能会有一个实质的提升</li>
<li>没有了 TIME_WAIT 状态</li>
</ul>
<h2 id="数据库连接池如何工作"><a href="#数据库连接池如何工作" class="headerlink" title="数据库连接池如何工作"></a>数据库连接池如何工作</h2><p>数据库连接池工作的核心在于以下几点：</p>
<ol>
<li><p><strong>创建连接池</strong>：与线程池等池化对象类似，数据库连接池会在进程启动之初，根据配置初始化，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，以避免创建、关闭所带来的系统开销。</p>
</li>
<li><p><strong>使用、管理连接池中</strong>：连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。合理的策略可以保证数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。通常，数据库连接池的管理策略如下：</p>
<ol>
<li>当请求数据库连接时，首先查看连接池中是否有空闲连接。</li>
<li>如果存在空闲连接，则将连接分配给客户使用。</li>
<li>如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数。若未达到，就重新创建一个连接，并分配给请求的客户；如果达到，就按设定的最大等待时间进行等待，若超出最大等待时间，则抛出异常给客户。</li>
<li>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值。如果超过，就从连接池中删除该连接；否则保留为其他客户服务。</li>
</ol>
</li>
<li><p><strong>关闭连接池</strong>：当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
</li>
</ol>
<h2 id="数据库连接池的核心参数"><a href="#数据库连接池的核心参数" class="headerlink" title="数据库连接池的核心参数"></a>数据库连接池的核心参数</h2><p>使用数据库连接池，需要为其配置一些参数，以控制其工作。</p>
<p>通常，数据库连接池都会包含以下核心参数：</p>
<ul>
<li><strong>最小连接数</strong>：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.</li>
<li><strong>最大连接数</strong>：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作</li>
<li>最大空闲时间</li>
<li>获取连接超时时间</li>
<li>超时重试连接次数</li>
</ul>
<h2 id="数据库连接池的问题"><a href="#数据库连接池的问题" class="headerlink" title="数据库连接池的问题"></a>数据库连接池的问题</h2><p><strong>并发问题</strong>：为了保证连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。</p>
<p><strong>事务处理</strong>：我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。我们知道当 2 个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。</p>
<p><strong>连接池的分配与释放</strong>：连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户。</p>
<p><strong>连接池的配置与维护</strong>：连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>
<h2 id="数据库连接池技术选型"><a href="#数据库连接池技术选型" class="headerlink" title="数据库连接池技术选型"></a>数据库连接池技术选型</h2><p>常见的数据库连接池：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>：HiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/druid">Druid</a>：Druid 是阿里巴巴开源的数据库连接池。Druid 内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。</li>
<li><a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-dbcp/">DBCP</a>： 由 Apache 开发的一个 Java 数据库连接池。<code>commons-dbcp2</code> 基于 <code>commons-pool2</code> 来实现底层的对象池机制。单线程，性能较差，适用于小型系统。官方自 2021 年后没有再更新。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/swaldman/c3p0">C3P0</a>：开源的 JDBC 连接池，实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。单线程，性能较差，适用于小型系统。官方自 2019 年后再没有更新。</li>
<li>Tomcat-jdbc：Tomcat 在 7.0 以前使用 DBCP 做为连接池组件，从 7.0 后新增了 Tomcat jdbc pool 模块，基于 Tomcat JULI，使用 Tomcat 日志框架，完全兼容 dbcp，通过异步方式获取连接，支持高并发应用环境，超级简单核心文件只有 8 个，支持 JMX，支持 XA Connection。</li>
</ul>
<p>来自 Druid 的竞品对比（<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D%EF%BC%89%EF%BC%9A">https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D）：</a></p>
<table>
<thead>
<tr>
<th>功能类别</th>
<th>功能</th>
<th>Druid</th>
<th>HikariCP</th>
<th>DBCP</th>
<th>Tomcat-jdbc</th>
<th>C3P0</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>PSCache</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>LRU</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>SLB 负载均衡支持</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>稳定性</td>
<td>ExceptionSorter</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>扩展</td>
<td>扩展</td>
<td>Filter</td>
<td></td>
<td></td>
<td>JdbcIntercepter</td>
<td></td>
</tr>
<tr>
<td>监控</td>
<td>监控方式</td>
<td>jmx&#x2F;log&#x2F;http</td>
<td>jmx&#x2F;metrics</td>
<td>jmx</td>
<td>jmx</td>
<td>jmx</td>
</tr>
<tr>
<td>支持 SQL 级监控</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>Spring&#x2F;Web 关联监控</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td></td>
<td>诊断支持</td>
<td>LogFilter</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>连接泄露诊断</td>
<td>logAbandoned</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>安全</td>
<td>SQL 防注入</td>
<td>是</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>支持配置加密</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<p>从数据库连接池最重要的性能角度来看：HikariCP 应该性能最好；Druid 也不错，并且有更多、更久的生产实践，更为可靠；而其他常见的数据库连接池性能远远不如。</p>
<p>从功能角度来看：Druid 功能最全面，除基本的数据库连接池能力以外，还支持 sql 级监控、扩展、SQL 防注入以及监控等功能。</p>
<p>综合来看：HikariCP 是 Spring Boot 首选数据库连接池，对于 Spring Boot 项目来说，无疑适配性最好。而非 Spring Boot 项目，可以优先考虑 Druid，在国内有大规模应用，中文社区支持良好。</p>
<h2 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h2><p>HiKariCP 号称是跑的最快的连接池，并且是 SpringBoot 框架的默认连接池。</p>
<p>HiKariCP 为了提升性能，做了很多细节上的优化，例如：</p>
<ul>
<li>使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作</li>
<li>优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令</li>
<li>实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争</li>
</ul>
<p>HikariCP 关键配置：</p>
<ul>
<li><code>maximum-pool-size</code>：池中最大连接数（包括空闲和正在使用的连接）。默认值是 10，这个一般预估应用的最大连接数，后期根据监测得到一个最大值的一个平均值。要知道，最大连接并不是越多越好，一个 connection 会占用系统的带宽和存储。但是 当连接池没有空闲连接并且已经到达最大值，新来的连接池请求（HikariPool#getConnection）会被阻塞直到<code>connectionTimeout</code>（毫秒），超时后便抛出 SQLException。</li>
<li><code>minimum-idle</code>：池中最小空闲连接数量。默认值 10，小于池中最大连接数，一般根据系统大部分情况下的数据库连接情况取一个平均值。Hikari 会尽可能、尽快地将空闲连接数维持在这个数量上。如果为了获得最佳性能和对峰值需求的响应能力，我们也不妨让他和最大连接数保持一致，使得 HikariCP 成为一个固定大小的数据库连接池。</li>
<li><code>connection-timeout</code>：连接超时时间。默认值为 30s，可以接收的最小超时时间为 250ms。但是连接池请求也可以自定义超时时间（com.zaxxer.hikari.pool.HikariPool#getConnection(long)）。</li>
<li><code>idle-timeout</code>：空闲连接存活最大时间，默认 600000（十分钟）</li>
<li><code>max-lifetime</code>：连接池中连接的最大生命周期。当连接一致处于闲置状态时，超过 8 小时数据库会主动断开连接。为了防止大量的同一时间处于空闲连接因为数据库方的闲置超时策略断开连接（可以理解为连接雪崩），一般将这个值设置的比数据库的“闲置超时时间”小几秒，以便这些连接断开后，HikariCP 能迅速的创建新一轮的连接。</li>
<li><code>pool-name</code>：连接池的名字。一般会出现在日志和 JMX 控制台中。默认值：auto-genenrated。建议取一个合适的名字，便于监控。</li>
<li><code>auto-commit</code>：是否自动提交池中返回的连接。默认值为 true。一般是有必要自动提交上一个连接中的事物的。如果为 false，那么就需要应用层手动提交事物。</li>
</ul>
<p>参考配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接池名称</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span> = <span class="string">SpringTutorialHikariPool</span></span><br><span class="line"><span class="comment"># 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"># 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span> = <span class="string">10</span></span><br><span class="line"><span class="comment"># 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span> = <span class="string">60000</span></span><br><span class="line"><span class="comment"># 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime&gt;0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒</span></span><br><span class="line"><span class="comment"># 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span> = <span class="string">600000</span></span><br><span class="line"><span class="comment"># 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span> = <span class="string">1800000</span></span><br></pre></td></tr></table></figure>

<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p>Druid 是阿里巴巴开源的数据库连接池。Druid 连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防 SQL 注入，内置 Loging 能诊断 Hack 应用行为。</p>
<p>Druid 关键配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库访问配置</span></span><br><span class="line"><span class="comment"># 主数据源，默认的</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/druid</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 下面为连接池的补充设置，应用到上面所有数据源中</span></span><br><span class="line"><span class="comment"># 初始化大小，最小，最大</span></span><br><span class="line"><span class="attr">spring.datasource.initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line"><span class="attr">spring.datasource.maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="attr">spring.datasource.timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="attr">spring.datasource.minEvictableIdleTimeMillis</span>=<span class="string">300000</span></span><br><span class="line"><span class="attr">spring.datasource.validationQuery</span>=<span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line"><span class="attr">spring.datasource.testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.datasource.testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line"><span class="attr">spring.datasource.poolPreparedStatements</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.maxPoolPreparedStatementPerConnectionSize</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span></span><br><span class="line"><span class="attr">spring.datasource.filters</span>=<span class="string">stat,wall,log4j</span></span><br><span class="line"><span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line"><span class="attr">spring.datasource.connectionProperties</span>=<span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span></span><br><span class="line"><span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line"><span class="comment">#spring.datasource.useGlobalDataSourceStat=true</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crankz/article/details/82874158">数据库连接池学习笔记（一）：原理介绍+常用连接池介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&mid=2651814835&idx=1&sn=cb775d3926ce39d12fa420a292c1f83d&scene=0#wechat_redirect">高性能数据库连接池的内幕</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/druid">druid</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3db6a5fd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3db6a5fd/" class="post-title-link" itemprop="url">《MySQL 实战 45 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 19:20:08" itemprop="dateCreated datePublished" datetime="2022-07-20T19:20:08+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MySQL-实战-45-讲》笔记"><a href="#《MySQL-实战-45-讲》笔记" class="headerlink" title="《MySQL 实战 45 讲》笔记"></a>《MySQL 实战 45 讲》笔记</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a> 学习笔记</p>
<h2 id="01-基础架构：一条-SQL-查询语句是如何执行的？"><a href="#01-基础架构：一条-SQL-查询语句是如何执行的？" class="headerlink" title="01 基础架构：一条 SQL 查询语句是如何执行的？"></a>01 基础架构：一条 SQL 查询语句是如何执行的？</h2><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p><strong>Server 层包括连接器、查询缓存、解析器、优化器、执行器等</strong>，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><strong>存储引擎层负责数据的存储和提取</strong>。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720195101.png"></p>
<p>MySQL 整个查询执行过程，总的来说分为 6 个步骤：</p>
<ol>
<li><strong>连接器</strong>：连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li><strong>查询缓存</strong>：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li>
<li><strong>分析器</strong></li>
</ol>
<ul>
<li><strong>词法分析</strong>：解析 SQL 关键字</li>
<li><strong>语法分析</strong>：生成一颗对应的语法解析树</li>
</ul>
<ol start="4">
<li><strong>优化器</strong></li>
</ol>
<ul>
<li>根据语法树<strong>生成多种执行计划</strong></li>
<li><strong>索引选择</strong>：根据策略选择最优方式</li>
</ul>
<ol start="5">
<li><strong>执行器</strong></li>
</ol>
<ul>
<li>校验读写权限</li>
<li>根据执行计划，调用存储引擎的 API 来执行查询</li>
</ul>
<ol start="6">
<li><strong>存储引擎</strong>：存储数据，提供读写接口</li>
</ol>
<h2 id="02-日志系统：一条-SQL-更新语句是如何执行的？"><a href="#02-日志系统：一条-SQL-更新语句是如何执行的？" class="headerlink" title="02 日志系统：一条 SQL 更新语句是如何执行的？"></a>02 日志系统：一条 SQL 更新语句是如何执行的？</h2><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p>
<ul>
<li>redo log（重做日志）</li>
<li>binlog（归档日志）</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 采用了 WAL 技术（全程是 Write-Ahead Logging），它的关键点就是<strong>先写日志，再写磁盘</strong>。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720203348.png"></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为** crash-safe**。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>redo log 和 binlog 的差异：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>再来看一下：update 语句时的内部流程</p>
<ol>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720210120.png"></p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么日志需要“两阶段提交”</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。</p>
<ol>
<li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。</li>
</ol>
<ul>
<li>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li>
<li>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
</ul>
<ol start="2">
<li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<h2 id="03-事务隔离：为什么你改了我还看不见？"><a href="#03-事务隔离：为什么你改了我还看不见？" class="headerlink" title="03 事务隔离：为什么你改了我还看不见？"></a>03 事务隔离：为什么你改了我还看不见？</h2><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p>
<p>在 MySQL 中，事务支持是在引擎层实现的。并不是所有的引擎都支持事务。比如 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p>
<p>事务特性 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p>
<p>SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。隔离级别越高，效率越低。</p>
<ul>
<li>Oracle 的默认隔离级别是“读提交”</li>
<li>MySQL 的默认隔离级别是“可重复读”</li>
</ul>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200804325.png"></p>
<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的<strong>多版本并发控制（MVCC）</strong>。</p>
<h2 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 深入浅出索引（上）"></a>04 深入浅出索引（上）</h2><p><strong>索引的出现是为了提高数据查询的效率</strong>。对于数据库的表而言，索引就像是书的目录。</p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200804538.png"></p>
<p><strong>哈希索引适用于只有等值查询的场景</strong>。</p>
<p><strong>哈希索引的限制</strong>：</p>
<ul>
<li><strong>无法用于排序</strong>：因为哈希索引数据不是按照索引值顺序存储的。</li>
<li><strong>不支持部分索引匹配查找</strong>：因为哈希索引时使用索引列的全部内容来进行哈希计算的。</li>
<li><strong>不能用索引中的值来避免读取行</strong>：因为哈希索引只包含哈希值和行指针，不存储字段。</li>
<li><strong>只支持等值比较查询</strong>（包括 &#x3D;、IN()、&lt;&#x3D;&gt;）；不支持任何范围查询</li>
<li><strong>哈希索引非常快，除非有很多哈希冲突</strong>：<ul>
<li>出现哈希冲突时，必须遍历链表中所有行指针，逐行比较匹配</li>
<li>如果哈希冲突多的话，维护索引的代价会很高</li>
</ul>
</li>
</ul>
<p>哈希索引的应用：Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<h4 id="有序数组索引"><a href="#有序数组索引" class="headerlink" title="有序数组索引"></a>有序数组索引</h4><p><strong>有序数组索引在等值查询和范围查询场景中的性能都非常优秀</strong>。</p>
<p>可以应用二分查找法检索数据，时间复杂度为 <code>O(logN)</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200806244.png"></p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，更新数据的时候，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，<strong>有序数组索引只适用于静态存储引擎</strong>。</p>
<h4 id="N-叉搜索树"><a href="#N-叉搜索树" class="headerlink" title="N 叉搜索树"></a>N 叉搜索树</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200806491.png"></p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。检索数据时，可以采用二分查找法，这个时间复杂度是 <code>O(logN)</code>。为了维持二叉搜索树的有序，就需要保证这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 <code>O(logN)</code>。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>树的高度意味着机械磁盘的最大扫描次数。假设一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块，也就意味着需要磁盘扫描 20 次。磁盘扫描是比较耗时的，所以应尽量减少磁盘扫描次数。因此，通过使用 N 叉树，来减少树的高度，是一个行之有效的策略。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。</p>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>主键索引的叶子节点存的是整行数据</strong>。在 InnoDB 里，主键索引也被称为<strong>聚簇索引（clustered index）</strong>。</li>
<li><strong>非主键索引的叶子节点内容是主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary index）</strong>。</li>
</ul>
<p>基于非主键索引的查询需要多扫描一次主键索引树，这个过程称为<strong>回表</strong>。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<ul>
<li>为了保证有序，插入新值时，可能需要<strong>按序挪动已有数据</strong>。</li>
<li>此外，如果所在的数据页满了，需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。</li>
<li>当相邻两个页由于删除了数据，利用率很低之后，会将数据<strong>页合并</strong>。合并的过程，可以认为是分裂过程的逆过程。</li>
</ul>
<p>由于非主键索引的叶子节点内容是主键的值，因此<strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>适合用业务字段直接做主键的场景：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<h2 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 深入浅出索引（下）"></a>05 深入浅出索引（下）</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>能覆盖查询字段的索引，可以直接提供查询结果，无需回表，称为<strong>覆盖索引</strong>。<strong>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。<strong>这里的最左，可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p>
<p>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>LIKE</code>) 就<strong>不能进一步匹配</strong>了，后续退化为线性查找。因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p>
<p><strong>应该将选择性高的列或基数大的列优先排在多列索引最前列</strong>。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。<strong>“索引的选择性”是指不重复的索引值和记录总数的比值</strong>，最大值为 1，此时每个记录都有唯一的索引与其对应。索引的选择性越高，查询效率越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<h2 id="06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#06-全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="06 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>06 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p><strong>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p>
<h3 id="全局锁（FTWRL）"><a href="#全局锁（FTWRL）" class="headerlink" title="全局锁（FTWRL）"></a>全局锁（FTWRL）</h3><ul>
<li><strong>作用</strong>：对整个数据库加锁，使数据库进入<strong>只读状态</strong>（阻塞所有数据更新、DDL 操作和事务提交）。</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>全库逻辑备份</strong>（确保备份数据的一致性）。</li>
<li><strong>问题</strong>：<ul>
<li>主库备份会导致业务停摆（无法更新）。</li>
<li>从库备份会阻塞主从同步（binlog 延迟）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>替代方案</strong>：<ul>
<li>**<code>mysqldump --single-transaction</code>**（InnoDB 适用）：<ul>
<li>通过事务的<strong>可重复读隔离级别</strong>和 <strong>MVCC</strong> 实现一致性视图，备份期间允许数据更新。</li>
</ul>
</li>
<li><strong><code>readonly=true</code>的缺陷</strong>：<ul>
<li>影响主备库判断逻辑；异常时不会自动释放锁，风险更高。</li>
</ul>
</li>
</ul>
</li>
<li><strong>适用引擎</strong>：<ul>
<li><strong>InnoDB</strong>：优先用<code>--single-transaction</code>。</li>
<li><strong>MyISAM</strong>：必须用 FTWRL（不支持事务）。</li>
</ul>
</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁（LOCK-TABLES-READ-WRITE）"><a href="#表锁（LOCK-TABLES-READ-WRITE）" class="headerlink" title="表锁（LOCK TABLES ... READ/WRITE）"></a>表锁（<code>LOCK TABLES ... READ/WRITE</code>）</h4><ul>
<li><strong>行为</strong>：显式加锁，限制其他线程的读写，同时限制<strong>本线程</strong>的操作范围（如<code>LOCK TABLES t1 READ</code>后，本线程只能读<code>t1</code>）。</li>
<li><strong>应用场景</strong>：<ul>
<li>MyISAM 等不支持行锁的引擎。</li>
<li>InnoDB 一般不用（行锁更细粒度）。</li>
</ul>
</li>
</ul>
<h4 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h4><ul>
<li><p><strong>自动加锁</strong>：</p>
<ul>
<li><strong>读锁</strong>：增删改查时自动加（多个读锁不互斥）。</li>
<li><strong>写锁</strong>：修改表结构时加（与读锁&#x2F;其他写锁互斥）。</li>
</ul>
</li>
<li><p><strong>常见问题</strong>：</p>
<ul>
<li><strong>长事务阻塞 DDL</strong>：未提交的事务会持有 MDL 读锁，导致后续 DDL（如加字段）被阻塞，进而阻塞所有后续查询（线程爆满）。</li>
</ul>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p>监控长事务（<code>information_schema.innodb_trx</code>），必要时 kill。</p>
</li>
<li><p>使用 <strong>WAIT&#x2F;NOWAIT 语法</strong>（MariaDB&#x2F;AliSQL 支持）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> tbl_name WAIT <span class="number">10</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> ...;  <span class="comment">-- 等待 10 秒超时</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> tbl_name NOWAIT <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> ...;  <span class="comment">-- 立即放弃</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="关键实践建议"><a href="#关键实践建议" class="headerlink" title="关键实践建议"></a>关键实践建议</h3><ul>
<li><strong>备份策略</strong>：<ul>
<li>InnoDB 库：用<code>mysqldump --single-transaction</code>（非阻塞）。</li>
<li>含 MyISAM 的库：用 FTWRL（需业务低峰期）。</li>
</ul>
</li>
<li><strong>DDL 操作</strong>：<ul>
<li>避免在高峰期执行，优先检查长事务。</li>
<li>使用支持超时的 DDL 语法（如 MariaDB 的<code>WAIT N</code>）。</li>
</ul>
</li>
<li><strong>锁升级</strong>：将 MyISAM 表迁移到 InnoDB，避免使用表锁。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">命令&#x2F;机制</th>
<th align="left">适用场景</th>
<th align="left">风险与解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全局锁</strong></td>
<td align="left"><code>FTWRL</code></td>
<td align="left">MyISAM 备份</td>
<td align="left">业务阻塞 → 改用 InnoDB+事务</td>
</tr>
<tr>
<td align="left"><strong>表锁</strong></td>
<td align="left"><code>LOCK TABLES</code></td>
<td align="left">MyISAM 并发控制</td>
<td align="left">影响粒度大 → 升级 InnoDB</td>
</tr>
<tr>
<td align="left"><strong>MDL 锁</strong></td>
<td align="left">自动加锁（读&#x2F;写）</td>
<td align="left">防止表结构不一致</td>
<td align="left">长事务阻塞 DDL → 监控&#x2F;Kill</td>
</tr>
</tbody></table>
<p>通过合理选择锁机制和引擎，可以平衡数据一致性与并发性能。</p>
<h2 id="07-行锁功过：怎么减少行锁对性能的影响？"><a href="#07-行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="07 行锁功过：怎么减少行锁对性能的影响？"></a>07 行锁功过：怎么减少行锁对性能的影响？</h2><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的</strong>。但<strong>并不是所有的引擎都支持行锁</strong>，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</p>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200807895.jpeg"></p>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li><strong>进入等待，直到超时</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。<ul>
<li>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果此策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</li>
<li>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</li>
</ul>
</li>
<li><strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。<ul>
<li>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</li>
<li>极端情况下，如果所有事务都要更新同一行：每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</li>
</ul>
</li>
</ul>
<p>减少死锁的主要方向，就是控制访问相同资源的并发事务量。</p>
<h2 id="08-事务到底是隔离的还是不隔离的"><a href="#08-事务到底是隔离的还是不隔离的" class="headerlink" title="08 事务到底是隔离的还是不隔离的"></a>08 事务到底是隔离的还是不隔离的</h2><p><strong>事务的启动时机</strong>：</p>
<ul>
<li><code>begin/start transaction</code> 命令并不是事务的起点，事务的真正启动是在执行第一个操作 InnoDB 表的语句时。</li>
<li>使用 <code>start transaction with consistent snapshot</code> 可以立即启动事务并创建一致性视图。</li>
</ul>
<p><strong>一致性视图（Consistent Read View）</strong>：</p>
<ul>
<li>在可重复读隔离级别下，事务启动时会创建一个一致性视图，事务执行期间看到的数据与该视图一致。</li>
<li>一致性视图是基于事务 ID（transaction id）和数据版本（row trx_id）来实现的。</li>
</ul>
<h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>InnoDB 里面<strong>每个事务有一个唯一的事务 ID，叫作 transaction id</strong>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220726083656.png"></p>
<p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p>
<p>图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220726085300.png"></p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p><strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220726085703.png"></p>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220726090537.png"></p>
<p><strong>事务的可重复读的能力是怎么实现的？</strong></p>
<p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<hr>
<blockquote>
<p>以下为【实践篇】</p>
</blockquote>
<h2 id="09-普通索引和唯一索引，应该怎么选择？"><a href="#09-普通索引和唯一索引，应该怎么选择？" class="headerlink" title="09 普通索引和唯一索引，应该怎么选择？"></a>09 普通索引和唯一索引，应该怎么选择？</h2><p><strong>查询过程的性能差异</strong>：对于查询操作，普通索引和唯一索引的性能差异微乎其微。唯一索引在找到第一个满足条件的记录后会停止检索，而普通索引需要继续查找下一个记录，但由于数据页的读取方式，这种差异可以忽略不计。</p>
<p><strong>更新过程的性能差异</strong>：更新操作中，普通索引可以利用 <strong>change buffer</strong> 来优化性能，而唯一索引则不能使用 change buffer。</p>
<ul>
<li><strong>change buffer</strong> 是一种将更新操作缓存在内存中的机制，减少了对磁盘的随机读取，从而提升了更新操作的性能。</li>
<li>唯一索引在更新时需要检查唯一性约束，必须将数据页读入内存，增加了磁盘 I&#x2F;O 的开销。</li>
</ul>
<p><strong>change buffer 的应用</strong></p>
<ul>
<li>change buffer 的数据是持久化的，即使机器掉电重启，change buffer 中的数据也不会丢失，因为它会被写入磁盘。</li>
<li>change buffer 适用于写多读少的场景，如账单类、日志类系统，因为这些场景下数据页在写入后不会立即被访问，change buffer 可以显著减少磁盘 I&#x2F;O。</li>
<li>对于写后立即查询的场景，change buffer 的效果不明显，甚至可能增加维护成本。</li>
</ul>
<p><strong>change buffer vs. redo log</strong></p>
<ul>
<li><strong>redo log</strong> 主要减少随机写磁盘的 I&#x2F;O 消耗，将随机写转换为顺序写。</li>
<li><strong>change buffer</strong> 主要减少随机读磁盘的 I&#x2F;O 消耗，通过缓存更新操作来减少磁盘读取。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>唯一索引的主要作用是保证数据的唯一性，而普通索引则更灵活。在业务代码保证不会写入重复数据的情况下，普通索引和唯一索引在查询性能上几乎没有差别。</li>
<li><strong>普通索引</strong> 在更新操作中性能更优，尤其是在写多读少的场景下，能够利用 change buffer 减少磁盘 I&#x2F;O。</li>
<li><strong>唯一索引</strong> 适用于需要保证数据唯一性的场景，但在更新操作中性能较差，因为它无法使用 change buffer。</li>
<li>在业务允许的情况下，优先选择普通索引，因为它可以利用 change buffer 来提升更新性能。如果业务要求必须保证数据的唯一性，则必须使用唯一索引。</li>
</ul>
<h2 id="10-MySQL-为什么有时候会选错索引？"><a href="#10-MySQL-为什么有时候会选错索引？" class="headerlink" title="10 MySQL 为什么有时候会选错索引？"></a>10 MySQL 为什么有时候会选错索引？</h2><p>MySQL 优化器负责选择索引，但有时会选错索引，导致查询性能下降。</p>
<p><strong>优化器选择索引的依据是执行代价，主要考虑扫描行数、是否使用临时表、是否排序等因素</strong>。</p>
<ul>
<li>扫描行数的估计依赖于索引的“区分度”和“基数”（cardinality），基数越大，区分度越好。</li>
<li>MySQL <strong>通过采样统计来估算基数</strong>，但由于采样统计的不准确性，可能导致优化器误判。</li>
</ul>
<p>索引选择异常的处理方法：</p>
<ul>
<li><strong>analyze table</strong>：如果只是统计信息不对，可以使用 <code>analyze table</code> 命令重新统计索引信息，修正优化器的误判。</li>
<li><strong>force index</strong>：强制使用指定索引，但这种方法不够优雅且维护成本高。</li>
<li><strong>修改查询语句</strong>：通过改写 SQL 语句引导优化器选择正确的索引，例如调整 <code>order by</code> 条件。</li>
<li><strong>新建或删除索引</strong>：通过调整索引来影响优化器的选择。</li>
</ul>
<h2 id="11-怎么给字符串字段加索引？"><a href="#11-怎么给字符串字段加索引？" class="headerlink" title="11 怎么给字符串字段加索引？"></a>11 怎么给字符串字段加索引？</h2><p><strong>字符串字段索引的挑战</strong>：</p>
<ul>
<li>字符串字段（如邮箱、身份证号）通常较长，直接创建完整索引会占用大量存储空间。</li>
<li>使用前缀索引可以<strong>节省空间</strong>，但<strong>可能会增加查询时的扫描行数</strong>，影响查询性能，因为前缀相同的字符串可能会导致多次回表查询。选择合适的前缀长度是关键。</li>
<li>可以通过 <code>count(distinct left(column, length))</code> 来计算不同前缀长度的区分度，选择区分度足够高的前缀长度。</li>
</ul>
<p><strong>前缀索引对覆盖索引的影响</strong>：</p>
<ul>
<li>覆盖索引是指查询可以直接从索引中获取所需数据，而不需要回表查询。</li>
<li>使用前缀索引时，无法利用覆盖索引的优势，因为前缀索引可能无法完全覆盖查询所需的字段。</li>
</ul>
<p><strong>其他优化方式</strong>：</p>
<p>有些情况下，前缀的区分度不够好，如我国身份证前 6 位表示地区，即同一地区的身份证号前 6 位一般是相同的。对此，有以下优化方式：</p>
<ul>
<li><strong>倒序存储</strong>：将字符串倒序存储后创建前缀索引，适用于某些特定场景（如身份证号），可以提高区分度。</li>
<li><strong>hash 字段</strong>：在表中增加存储字符串 hash 值的字段并作为索引。hash 字段索引占用空间小，查询性能稳定，但不支持范围查询。</li>
</ul>
<p>倒序存储与 hash 字段的<strong>相同点</strong>是，<strong>都不支持范围查询</strong>。</p>
<p>倒序存储与 hash 字段的<strong>区别</strong>是：</p>
<ul>
<li><strong>倒序存储</strong>：不占用额外存储空间，但每次查询需要调用 <code>reverse</code> 函数，且仍然使用前缀索引，可能会增加扫描行数。</li>
<li><strong>hash 字段</strong>：需要额外存储空间，查询性能稳定，但需要调用 <code>crc32</code> 函数，且不支持范围查询。</li>
</ul>
<h2 id="12-为什么我的-MySQL-会“抖”一下？"><a href="#12-为什么我的-MySQL-会“抖”一下？" class="headerlink" title="12 为什么我的 MySQL 会“抖”一下？"></a>12 为什么我的 MySQL 会“抖”一下？</h2><p>有时 SQL 语句执行速度突然变慢，持续时间短且难以复现，这种现象称为 MySQL“抖动”。这种现象通常与 InnoDB 的刷脏页（flush）操作有关。</p>
<p>InnoDB 使用 WAL（Write-Ahead Logging）机制，更新操作先写 redo log，再写内存，最后刷到磁盘。当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“<strong>脏页</strong>”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。</p>
<p><strong>刷脏页的触发场景</strong>：</p>
<ul>
<li><strong>redo log 写满</strong>：当 redo log 写满时，系统会停止所有更新操作，推进 checkpoint，刷脏页以释放 redo log 空间。</li>
<li><strong>内存不足</strong>：当内存不足时，InnoDB 会淘汰一些数据页。如果淘汰的是脏页，则需要先将脏页刷到磁盘。</li>
<li><strong>系统空闲时</strong>：MySQL 在系统空闲时，会主动刷脏页。</li>
<li><strong>数据库关闭时</strong>：MySQL 正常关闭时，会将所有脏页刷到磁盘，以便下次启动时快速恢复。</li>
</ul>
<p><strong>刷脏页对性能的影响</strong>：</p>
<ul>
<li><strong>redo log 写满</strong>：这种情况会导致系统无法接受更新操作，更新数跌为 0，影响写性能。</li>
<li><strong>内存不足</strong>：查询需要淘汰脏页时，会导致查询响应时间变长。</li>
</ul>
<p><strong>InnoDB 刷脏页的控制策略</strong>：</p>
<ul>
<li><strong>innodb_io_capacity</strong>：该参数用于告诉 InnoDB 磁盘的 IO 能力，建议设置为磁盘的 IOPS。</li>
<li><strong>脏页比例控制</strong>：InnoDB 通过脏页比例和 redo log 写入速度来控制刷脏页的速度。脏页比例上限由 <code>innodb_max_dirty_pages_pct</code> 参数控制，默认值为 75%。</li>
<li><strong>刷脏页速度计算</strong>：InnoDB 根据脏页比例和 redo log 写入速度计算出刷脏页的速度，取两者中的较大值。</li>
</ul>
<p><strong>刷脏页的“连坐”机制</strong>：</p>
<ul>
<li>InnoDB 在刷脏页时，可能会连带刷掉相邻的脏页，以减少随机 IO。该行为由 <code>innodb_flush_neighbors</code> 参数控制。</li>
<li>对于 SSD 等高性能存储设备，建议将 <code>innodb_flush_neighbors</code> 设置为 0，以避免不必要的 IO 操作。</li>
</ul>
<p><strong>监控脏页比例</strong>：</p>
<ul>
<li>可以通过查询 <code>Innodb_buffer_pool_pages_dirty</code> 和 <code>Innodb_buffer_pool_pages_total</code> 来监控脏页比例，确保其不要经常接近 75%。</li>
</ul>
<h2 id="13-为什么表数据删掉一半，表文件大小不变？"><a href="#13-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13 为什么表数据删掉一半，表文件大小不变？"></a>13 为什么表数据删掉一半，表文件大小不变？</h2><p><strong>表数据删除后空间不回收的原因</strong>：</p>
<ul>
<li>当使用 <code>DELETE</code> 命令删除表中的数据时，InnoDB 引擎只是将数据标记为“可复用”，并不会立即释放磁盘空间。这些被标记为可复用的空间称为“空洞”。</li>
<li>空洞不仅由删除操作引起，插入和更新操作也可能导致空洞。例如，随机插入数据可能导致页分裂，从而产生空洞。</li>
</ul>
<p><strong>innodb_file_per_table 参数</strong>：</p>
<ul>
<li>该参数控制表数据的存储方式。设置为 <code>ON</code> 时，每个表的数据存储在一个单独的 <code>.ibd</code> 文件中；设置为 <code>OFF</code> 时，表数据存储在共享表空间中。</li>
<li>建议将该参数设置为 <code>ON</code>，因为单独存储表数据文件更容易管理，且在删除表时可以直接回收空间。</li>
</ul>
<p><strong>数据删除流程</strong>：</p>
<ul>
<li>删除操作只是标记数据为可复用，不会立即释放磁盘空间。数据页的复用与记录的复用不同，数据页可以被复用到任何位置，而记录的复用仅限于符合特定条件的数据。</li>
</ul>
<p><strong>重建表以回收空间</strong>：</p>
<ul>
<li>为了回收表空间，可以通过重建表来去除空洞。重建表的操作可以通过 <code>ALTER TABLE t ENGINE=InnoDB</code> 命令实现。</li>
<li>在 MySQL 5.5 及之前版本，重建表操作会阻塞表的增删改操作（非 Online DDL）。</li>
<li>从 MySQL 5.6 开始，引入了 Online DDL，允许在重建表的过程中继续对表进行增删改操作。</li>
</ul>
<p><strong>Online DDL 和 inplace 操作</strong>：</p>
<ul>
<li>Online DDL 允许在重建表的过程中继续对表进行增删改操作，减少了锁表时间。</li>
<li>inplace 操作指的是在 InnoDB 内部完成数据重建，不需要将数据移动到临时表。Online DDL 一定是 inplace 操作，但 inplace 操作不一定是 Online 的。</li>
</ul>
<p><strong>重建表的其他方式</strong>：</p>
<ul>
<li><code>ANALYZE TABLE</code>：重新统计表的索引信息，不修改数据。</li>
<li><code>OPTIMIZE TABLE</code>：相当于 <code>RECREATE</code> + <code>ANALYZE</code>，会重建表并重新统计索引信息。</li>
</ul>
<p><strong>思考题</strong>：</p>
<ul>
<li>文章最后提出了一个思考题：为什么在某些情况下，执行 <code>ALTER TABLE t ENGINE=InnoDB</code> 后，表空间不仅没有缩小，反而变大了？可能的原因包括数据页的重新排列、索引的重建等。</li>
</ul>
<h2 id="14-count-这么慢，我该怎么办？"><a href="#14-count-这么慢，我该怎么办？" class="headerlink" title="14 count(*) 这么慢，我该怎么办？"></a>14 count(*) 这么慢，我该怎么办？</h2><p><strong><code>COUNT(*)</code> 的实现方式</strong>：</p>
<ul>
<li><strong>MyISAM 引擎</strong>：将表的总行数存储在磁盘上，执行 <code>COUNT(*)</code> 时直接返回该值，效率很高。</li>
<li><strong>InnoDB 引擎</strong>：由于支持事务和 MVCC，<code>COUNT(*)</code> 需要逐行扫描数据并判断可见性，导致性能较差。</li>
</ul>
<p><strong>为什么 InnoDB 不存储行数</strong>：</p>
<ul>
<li>由于 MVCC 的存在，不同事务在同一时刻看到的行数可能不同，因此 InnoDB 无法像 MyISAM 那样直接存储行数。</li>
<li>InnoDB 在执行 <code>COUNT(*)</code> 时会选择最小的索引树进行遍历，以减少扫描的数据量。</li>
</ul>
<p><strong><code>SHOW TABLE STATUS</code> 的局限性</strong>：</p>
<ul>
<li><code>SHOW TABLE STATUS</code> 命令中的 <code>TABLE_ROWS</code> 是通过采样估算的，误差可能达到 40% 到 50%，因此不能替代 <code>COUNT(*)</code>。</li>
</ul>
<p><strong>不同 <code>COUNT</code> 用法的性能差异</strong>：</p>
<ul>
<li>**<code>COUNT（主键 id)</code>**：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</li>
<li>**<code>COUNT(1)</code>**：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</li>
<li>**<code>COUNT（字段）</code>**：<ul>
<li>如果这个“字段”是定义为 <code>not null</code> 的话，一行行地从记录里面读出这个字段，判断不能为 <code>null</code>，按行累加；</li>
<li>如果这个“字段”定义允许为 <code>null</code>，那么执行的时候，判断到有可能是 <code>null</code>，还要把值取出来再判断一下，不是 <code>null</code> 才累加。</li>
</ul>
</li>
<li>**<code>COUNT(*)</code>**：InnoDB 做了专门优化，不取值，直接按行累加，性能最好。</li>
</ul>
<blockquote>
<p>结论：按照效率排序的话，<code>COUNT（字段）</code> &lt; <code>COUNT（主键 id)</code> &lt; <code>COUNT(1)</code> ≈ <code>COUNT(*)</code>。<strong>推荐采用 <code>COUNT(*)</code></strong> 。</p>
</blockquote>
<p><strong>优化查询计数</strong>：</p>
<ul>
<li><p>可以使用 Redis 保存计数，但存在数据丢失和逻辑不一致的问题。</p>
</li>
<li><p>可以使用数据库其他表保存计数，利用事务的原子性和隔离性，可以避免数据丢失和逻辑不一致的问题。</p>
</li>
</ul>
<h2 id="15-答疑文章（一）：日志和索引相关问题"><a href="#15-答疑文章（一）：日志和索引相关问题" class="headerlink" title="15 答疑文章（一）：日志和索引相关问题"></a>15 答疑文章（一）：日志和索引相关问题</h2><p><strong>日志相关问题</strong></p>
<ul>
<li><strong>两阶段提交与崩溃恢复</strong>：MySQL 使用两阶段提交（2PC）来保证 binlog 和 redo log 的一致性。在两阶段提交的不同时刻，如果发生崩溃，MySQL 会根据 redo log 和 binlog 的状态来决定是提交事务还是回滚事务。</li>
<li><strong>崩溃恢复的判断规则</strong>：<ul>
<li>如果 redo log 中有 commit 标识，直接提交事务。</li>
<li>如果 redo log 处于 prepare 状态，检查 binlog 是否完整，完整则提交事务，否则回滚。</li>
</ul>
</li>
<li><strong>binlog 的完整性</strong>：binlog 有固定的格式（statement 格式有 COMMIT，row 格式有 XID event），并且可以通过 binlog-checksum 参数验证其完整性。</li>
<li><strong>redo log 和 binlog 的关联</strong>：通过 XID 字段关联 redo log 和 binlog。崩溃恢复时，MySQL 会扫描 redo log，并根据 XID 查找对应的 binlog。</li>
<li><strong>为什么需要两阶段提交</strong>：两阶段提交是为了保证事务的持久性和数据一致性。如果 redo log 直接提交，而 binlog 写入失败，会导致数据不一致。</li>
<li><strong>redo log 的大小设置</strong>：redo log 太小会导致频繁刷盘，建议设置为 4 个文件，每个文件 1GB。</li>
<li><strong>数据最终落盘</strong>：数据最终落盘是从 buffer pool 中的脏页写入磁盘，而不是从 redo log 更新过来。redo log 只用于崩溃恢复时恢复数据页。</li>
</ul>
<p><strong>互相关注的业务场景</strong></p>
<ul>
<li>在并发场景下，A 和 B 同时关注对方可能导致无法成为好友的问题。解决方案是通过在 <code>like</code> 表中增加 <code>relation_ship</code> 字段，并使用 <code>insert ... on duplicate key update</code> 语句来确保行锁的生效。</li>
<li>通过按位或操作和 <code>insert ignore</code> 语句，确保在并发场景下也能正确处理互相关注的逻辑。</li>
</ul>
<p><strong>更新操作的内部处理</strong>：</p>
<ul>
<li>当执行 <code>update t set a=2 where id=1</code> 时，MySQL 会先读取数据，发现 <code>a</code> 的值已经是 2，因此不会进行实际的更新操作，直接返回。</li>
<li>这种行为是为了减少不必要的写操作，提升性能。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/183a3fd4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/183a3fd4/" class="post-title-link" itemprop="url">《MySQL 实战 45 讲》笔记三</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 19:20:08" itemprop="dateCreated datePublished" datetime="2022-07-20T19:20:08+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MySQL-实战-45-讲》笔记三"><a href="#《MySQL-实战-45-讲》笔记三" class="headerlink" title="《MySQL 实战 45 讲》笔记三"></a>《MySQL 实战 45 讲》笔记三</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a> 学习笔记</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/pages/183a3fd4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ef9fb8a5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ef9fb8a5/" class="post-title-link" itemprop="url">《MySQL 实战 45 讲》笔记二</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 19:20:08" itemprop="dateCreated datePublished" datetime="2022-07-20T19:20:08+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《MySQL-实战-45-讲》笔记二"><a href="#《MySQL-实战-45-讲》笔记二" class="headerlink" title="《MySQL 实战 45 讲》笔记二"></a>《MySQL 实战 45 讲》笔记二</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a> 学习笔记</p>
<h2 id="16-order-by-是怎么工作的？"><a href="#16-order-by-是怎么工作的？" class="headerlink" title="16 order by 是怎么工作的？"></a>16 <code>order by</code> 是怎么工作的？</h2><p>用 explain 命令查看执行计划时，Extra 这个字段中的“Using filesort”表示的就是需要排序。</p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句执行流程如下所示 ：</p>
<p><strong>执行流程</strong>：</p>
<ul>
<li>初始化 <code>sort_buffer</code>，确定放入需要排序的字段（如 <code>name</code>、<code>city</code>、<code>age</code>）。</li>
<li>从索引中找到满足条件的记录，取出对应的字段值存入 <code>sort_buffer</code>。</li>
<li>对 <code>sort_buffer</code> 中的数据按照排序字段进行排序。</li>
<li>返回排序后的结果。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090300.png"></p>
<p><strong>内存与磁盘排序</strong>：</p>
<ul>
<li>如果排序数据量小于 <code>sort_buffer_size</code>，排序在内存中完成。</li>
<li>如果数据量过大，MySQL 会使用临时文件进行外部排序（归并排序）。<strong>MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</strong></li>
</ul>
<p><strong>优化器追踪</strong>：通过 <code>OPTIMIZER_TRACE</code> 可以查看排序过程中是否使用了临时文件（<code>number_of_tmp_files</code>）。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><ul>
<li><strong>执行流程</strong>：<ul>
<li>当单行数据过大时，MySQL 会采用 <code>rowid</code> 排序，只将排序字段（如 <code>name</code>）和主键 <code>id</code> 放入 <code>sort_buffer</code>。</li>
<li>排序完成后，根据 <code>id</code> 回表查询其他字段（如 <code>city</code>、<code>age</code>）。</li>
</ul>
</li>
<li><strong>性能影响</strong>：<code>rowid</code> 排序减少了 <code>sort_buffer</code> 的内存占用，但增加了回表操作，导致更多的磁盘 I&#x2F;O。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090919.png"></p>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><ul>
<li><strong>内存优先</strong>：<ul>
<li>如果内存足够大，MySQL 优先使用全字段排序，以减少磁盘访问。</li>
<li>只有在内存不足时，才会使用 <code>rowid</code> 排序。</li>
</ul>
</li>
<li><strong>设计思想</strong>：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></li>
</ul>
<p>并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的</strong>。如果查询的字段和排序字段可以通过联合索引覆盖，MySQL 可以直接利用索引的有序性，避免排序操作。</p>
<h2 id="17-如何正确地显示随机消息？"><a href="#17-如何正确地显示随机消息？" class="headerlink" title="17 如何正确地显示随机消息？"></a>17 如何正确地显示随机消息？</h2><p><strong><code>ORDER BY RAND()</code> 的执行流程</strong></p>
<ul>
<li>使用 <code>ORDER BY RAND()</code> 时，MySQL 会创建一个临时表，并为每一行生成一个随机数，然后对临时表进行排序。</li>
<li>排序过程可能使用内存临时表或磁盘临时表，具体取决于数据量和 <code>tmp_table_size</code> 的设置。</li>
</ul>
<p><strong><code>ORDER BY RAND()</code> 的性能问题</strong>：<code>ORDER BY RAND()</code> 需要扫描全表并生成随机数，排序过程消耗大量资源，尤其是在数据量大时，性能较差。</p>
<p><strong>内存临时表与磁盘临时表</strong></p>
<p><strong>内存临时表</strong>：当临时表大小小于 <code>tmp_table_size</code> 时，MySQL 使用内存临时表，排序过程使用 <code>rowid</code> 排序算法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200808843.png"></p>
<p><strong>磁盘临时表</strong>：当临时表大小超过 <code>tmp_table_size</code> 时，MySQL 会使用磁盘临时表，排序过程使用归并排序算法。</p>
<p><strong>优先队列排序</strong>：当只需要返回少量数据（如 <code>LIMIT 3</code>）时，MySQL 5.6 引入了优先队列排序算法，避免对整个数据集进行排序，减少计算量。</p>
<p><strong>随机排序的优化方法</strong></p>
<ul>
<li><p><strong>随机算法 1</strong>：通过 <code>max(id)</code> 和 <code>min(id)</code> 生成随机数，然后使用 <code>LIMIT</code> 获取随机行。问题是：ID 不连续时，某些行的概率不均匀。</p>
</li>
<li><p><strong>随机算法 2</strong>：先获取表的总行数 <code>C</code>，然后生成随机数 <code>Y</code>，使用 <code>LIMIT Y, 1</code> 获取随机行。<strong>优点</strong>：解决了概率不均匀的问题，但需要扫描 <code>C + Y + 1</code> 行。</p>
</li>
<li><p><strong>随机算法 3</strong>：扩展随机算法 2，生成多个随机数 <code>Y1, Y2, Y3</code>，分别使用 <code>LIMIT Y, 1</code> 获取多行随机数据。<strong>优点</strong>：适用于需要返回多行随机数据的场景。</p>
<p><strong>总结</strong></p>
</li>
<li><p>**避免使用 <code>ORDER BY RAND()</code>**：<code>ORDER BY RAND()</code> 的性能较差，尤其是在数据量大时，应尽量避免使用。</p>
</li>
<li><p><strong>应用层处理随机逻辑</strong>：将随机逻辑放在应用层处理，数据库只负责数据读取，减少数据库的计算压力。</p>
</li>
<li><p><strong>优化扫描行数</strong>：通过合理的随机算法，减少扫描行数，提升查询性能。</p>
</li>
</ul>
<h2 id="18-为什么这些-SQL-语句逻辑相同，性能却差异巨大？"><a href="#18-为什么这些-SQL-语句逻辑相同，性能却差异巨大？" class="headerlink" title="18 为什么这些 SQL 语句逻辑相同，性能却差异巨大？"></a>18 为什么这些 SQL 语句逻辑相同，性能却差异巨大？</h2><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p><strong>案例一：条件字段函数操作</strong></p>
<ul>
<li><strong>问题</strong>：在 <code>WHERE</code> 条件中对索引字段使用函数（如 <code>month(t_modified)</code>），会导致 MySQL 无法使用索引的快速定位功能，转而进行全索引扫描。</li>
<li><strong>原因</strong>：对索引字段进行函数操作会破坏索引值的有序性，优化器会放弃树搜索功能，转而进行全索引扫描。</li>
<li><strong>解决方案</strong>：避免在索引字段上使用函数操作，改为基于字段本身的范围查询。例如，将 <code>month(t_modified)=7</code> 改为 <code>t_modified</code> 的范围查询。</li>
</ul>
<p><strong>案例二：隐式类型转换</strong></p>
<ul>
<li><strong>问题</strong>：当查询条件中的字段类型与索引字段类型不一致时（如 <code>varchar</code> 和 <code>int</code>），MySQL 会进行隐式类型转换，导致无法使用索引。</li>
<li><strong>原因</strong>：隐式类型转换相当于对索引字段进行了函数操作（如 <code>CAST</code>），优化器会放弃树搜索功能，转而进行全表扫描。</li>
<li><strong>解决方案</strong>：确保查询条件中的字段类型与索引字段类型一致，避免隐式类型转换。</li>
</ul>
<p><strong>案例三：隐式字符编码转换</strong></p>
<ul>
<li><strong>问题</strong>：当两个表的字符集不同时（如 <code>utf8</code> 和 <code>utf8mb4</code>），在进行表连接查询时，MySQL 会对被驱动表的索引字段进行字符集转换，导致无法使用索引。</li>
<li><strong>原因</strong>：字符集转换相当于对索引字段进行了函数操作（如 <code>CONVERT</code>），优化器会放弃树搜索功能，转而进行全表扫描。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>统一字符集</strong>：将两个表的字符集统一为 <code>utf8mb4</code>，避免字符集转换。</li>
<li><strong>手动转换</strong>：在 SQL 语句中手动进行字符集转换，确保转换操作发生在驱动表上，而不是被驱动表的索引字段上。</li>
</ul>
</li>
</ul>
<h2 id="19-为什么我只查一行的语句，也执行这么慢？"><a href="#19-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19 为什么我只查一行的语句，也执行这么慢？"></a>19 为什么我只查一行的语句，也执行这么慢？</h2><p><strong>查询长时间不返回的可能原因</strong></p>
<ul>
<li><strong>等 MDL 锁</strong>：当查询需要获取表的 MDL 读锁，而其他线程持有 MDL 写锁时，查询会被阻塞。<ul>
<li><strong>解决方案</strong>：通过 <code>sys.schema_table_lock_waits</code> 表找到持有 MDL 写锁的线程，并 <code>KILL</code> 掉该线程。</li>
</ul>
</li>
<li><strong>等 flush</strong>：当有线程正在对表执行 <code>flush tables</code> 操作时，其他查询会被阻塞。<ul>
<li><strong>解决方案</strong>：找到阻塞 <code>flush</code> 操作的线程并 <code>KILL</code> 掉。</li>
</ul>
</li>
<li><strong>等行锁</strong>：当查询需要获取某行的读锁，而其他事务持有该行的写锁时，查询会被阻塞。<ul>
<li><strong>解决方案</strong>：通过 <code>sys.innodb_lock_waits</code> 表找到持有写锁的线程，并 <code>KILL</code> 掉该连接。</li>
</ul>
</li>
</ul>
<p><strong>查询慢的可能原因</strong></p>
<ul>
<li><strong>全表扫描</strong>：当查询条件中的字段没有索引时，MySQL 会进行全表扫描，导致查询缓慢。<ul>
<li><strong>解决方案</strong>：为查询条件中的字段添加索引。</li>
</ul>
</li>
<li><strong>一致性读与当前读</strong>：<ul>
<li><strong>一致性读</strong>：当查询使用一致性读时，如果该行有大量 undo log（如被频繁更新），MySQL 需要依次执行这些 undo log 才能返回结果，导致查询缓慢。</li>
<li><strong>当前读</strong>：使用 <code>lock in share mode</code> 或 <code>for update</code> 进行当前读时，MySQL 会直接读取最新的数据，因此速度较快。</li>
<li><strong>解决方案</strong>：理解一致性读和当前读的区别，根据业务需求选择合适的查询方式。</li>
</ul>
</li>
</ul>
<h2 id="20-幻读是什么，幻读有什么问题？"><a href="#20-幻读是什么，幻读有什么问题？" class="headerlink" title="20 幻读是什么，幻读有什么问题？"></a>20 幻读是什么，幻读有什么问题？</h2><p><strong>幻读的定义</strong></p>
<ul>
<li>幻读指的是一个事务在前后两次查询同一个范围时，后一次查询看到了前一次查询没有看到的行。</li>
<li>幻读仅在“当前读”（如<code>select ... for update</code>）时出现，普通的快照读不会出现幻读。</li>
</ul>
<p><strong>幻读的问题</strong></p>
<ul>
<li><strong>语义问题</strong>：事务 A 声明要锁住所有满足条件的行，但由于幻读的存在，其他事务可以插入或修改这些行，破坏了事务 A 的加锁声明。</li>
<li><strong>数据一致性问题</strong>：幻读可能导致数据和日志在逻辑上不一致，尤其是在使用 binlog 进行数据同步或恢复时，可能会导致数据不一致。</li>
</ul>
<p><strong>幻读的解决方案</strong></p>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<ul>
<li><strong>间隙锁（Gap Lock）</strong>：为了解决幻读问题，InnoDB 引入了间隙锁。间隙锁锁住的是索引记录之间的间隙，防止新记录的插入。</li>
<li><strong>Next-Key Lock</strong>：间隙锁和行锁合称 Next-Key Lock，它锁住的是一个前开后闭的区间，确保在锁定范围内无法插入新记录。</li>
</ul>
<p><strong>间隙锁的影响</strong>：</p>
<ul>
<li>间隙锁虽然解决了幻读问题，但也带来了并发度下降和死锁的风险。特别是在高并发场景下，间隙锁可能会导致更多的锁冲突和死锁。</li>
</ul>
<p><strong>隔离级别的选择</strong></p>
<ul>
<li>在<strong>可重复读</strong>隔离级别下，间隙锁生效，可以有效防止幻读。</li>
<li>在<strong>读提交</strong>隔离级别下，间隙锁不生效，幻读问题可能会出现，但可以通过将 binlog 格式设置为<code>row</code>来解决数据一致性问题。</li>
</ul>
<p><strong>实际应用中的考虑</strong></p>
<ul>
<li>业务开发人员在设计表结构和 SQL 语句时，不仅要考虑行锁，还要考虑间隙锁的影响，避免因间隙锁导致的死锁问题。</li>
<li>隔离级别的选择应根据业务需求来决定，如果业务不需要可重复读的保证，读提交隔离级别可能是一个更合适的选择。</li>
</ul>
<h2 id="21-为什么我只改一行的语句，锁这么多？"><a href="#21-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 为什么我只改一行的语句，锁这么多？"></a>21 为什么我只改一行的语句，锁这么多？</h2><p><strong>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li><strong>原则 1</strong>：加锁的基本单位是 Next-Key Lock，即前开后闭区间。</li>
<li><strong>原则 2</strong>：查找过程中访问到的对象才会加锁。</li>
<li><strong>优化 1</strong>：索引上的等值查询，给唯一索引加锁时，Next-Key Lock 退化为行锁。</li>
<li><strong>优化 2</strong>：索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，Next-Key Lock 退化为间隙锁。</li>
<li><strong>一个 bug</strong>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p><strong>锁的范围与隔离级别</strong>：</p>
<ul>
<li>在<strong>可重复读</strong>隔离级别下，Next-Key Lock 和间隙锁生效，防止幻读。</li>
<li>在<strong>读提交</strong>隔离级别下，间隙锁不生效，锁的范围更小，锁的时间更短。</li>
</ul>
<h2 id="22-MySQL-有哪些“饮鸩止渴”提高性能的方法？"><a href="#22-MySQL-有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22 MySQL 有哪些“饮鸩止渴”提高性能的方法？"></a>22 MySQL 有哪些“饮鸩止渴”提高性能的方法？</h2><h4 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h4><ul>
<li><strong>问题</strong>：短连接模式下，业务高峰期连接数暴涨，可能导致数据库连接数超过<code>max_connections</code>限制，进而拒绝新连接。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>方法一</strong>：主动断开空闲连接。优先断开事务外空闲的连接，再考虑断开事务内空闲的连接。可以通过<code>kill connection</code>命令手动断开连接。</li>
<li><strong>方法二</strong>：减少连接过程的消耗。通过<code>--skip-grant-tables</code>参数重启数据库，跳过权限验证，但这种方法风险极高，尤其是在外网可访问的情况下。</li>
</ul>
</li>
<li><strong>风险</strong>：断开连接可能导致应用端未正确处理连接丢失，进而引发更多问题。</li>
</ul>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><ul>
<li><strong>慢查询的三种可能原因</strong>：<ol>
<li><strong>索引没有设计好</strong>：通过紧急创建索引来解决，建议在备库先执行<code>alter table</code>语句，再进行主备切换。</li>
<li><strong>SQL 语句没写好</strong>：通过改写 SQL 语句来优化，MySQL 5.7 提供了<code>query_rewrite</code>功能，可以自动重写 SQL 语句。</li>
<li><strong>MySQL 选错了索引</strong>：通过<code>force index</code>强制使用正确的索引。</li>
</ol>
</li>
<li><strong>预防措施</strong>：在上线前，通过慢查询日志和回归测试，提前发现并解决潜在的慢查询问题。</li>
</ul>
<h3 id="QPS-突增问题"><a href="#QPS-突增问题" class="headerlink" title="QPS 突增问题"></a>QPS 突增问题</h3><ul>
<li><strong>问题</strong>：由于业务高峰或应用 bug，某个 SQL 语句的 QPS 突然暴涨，导致数据库压力过大。</li>
<li><strong>解决方案</strong>：<ol>
<li><strong>下掉新功能</strong>：如果新功能有 bug，可以直接从数据库端去掉白名单或删除相关用户。</li>
<li><strong>重写 SQL 语句</strong>：将高 QPS 的 SQL 语句重写为<code>select 1</code>，但这种方法风险较高，可能会误伤其他功能或导致业务逻辑失败。</li>
</ol>
</li>
<li><strong>风险</strong>：重写 SQL 语句可能导致业务逻辑错误，应作为最后的手段。</li>
</ul>
<h2 id="23-Mysql-是怎么保证数据不丢的"><a href="#23-Mysql-是怎么保证数据不丢的" class="headerlink" title="23 Mysql 是怎么保证数据不丢的"></a>23 Mysql 是怎么保证数据不丢的</h2><p><strong>binlog 的写入机制</strong></p>
<ul>
<li>事务执行过程中，日志先写入 binlog cache，事务提交时再将 binlog cache 写入 binlog 文件。</li>
<li>binlog cache 是每个线程独有的，而 binlog 文件是共享的。</li>
<li>写入操作分为 write（写入文件系统的 page cache）和 fsync（持久化到磁盘）。</li>
<li>参数 <code>sync_binlog</code> 控制 fsync 的时机：<ul>
<li><code>sync_binlog=0</code>：每次提交事务只 write，不 fsync。</li>
<li><code>sync_binlog=1</code>：每次提交事务都 fsync。</li>
<li><code>sync_binlog=N</code>：每 N 个事务提交后 fsync。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220802060429.png"></p>
<p><strong>redo log 的写入机制</strong></p>
<ul>
<li>事务执行过程中，redo log 先写入 redo log buffer。</li>
<li>redo log 的三种状态：<ul>
<li>在 redo log buffer 中（内存）。</li>
<li>写入文件系统的 page cache（write）。</li>
<li>持久化到磁盘（fsync）。</li>
</ul>
</li>
<li>参数 <code>innodb_flush_log_at_trx_commit</code> 控制 redo log 的写入策略：<ul>
<li><code>0</code>：事务提交时只写入 redo log buffer。</li>
<li><code>1</code>：事务提交时将 redo log 持久化到磁盘。</li>
<li><code>2</code>：事务提交时只写入 page cache。</li>
</ul>
</li>
</ul>
<p><strong>redo log 写入磁盘的触发时机</strong></p>
<ul>
<li>后台线程每秒会将 redo log buffer 中的日志写入磁盘。</li>
<li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</li>
<li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</li>
</ul>
<p><strong>组提交（Group Commit）机制</strong>：</p>
<ul>
<li>通过延迟 fsync 操作，将多个事务的 redo log 或 binlog 合并写入磁盘，减少磁盘 I&#x2F;O 操作。</li>
<li>组提交可以显著提升性能，尤其是在高并发场景下。</li>
</ul>
<p><strong>WAL 机制的优势</strong>：</p>
<ul>
<li>redo log 和 binlog 都是顺序写入，顺序写比随机写速度快。</li>
<li>组提交机制减少了磁盘 I&#x2F;O 操作的次数。</li>
</ul>
<p><strong>性能优化建议</strong>：</p>
<ul>
<li>设置 <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 参数，减少 binlog 的写盘次数。</li>
<li>将 <code>sync_binlog</code> 设置为大于 1 的值（如 100~1000），减少 fsync 次数，但主机掉电时会丢 binlog 日志。</li>
<li>将 <code>innodb_flush_log_at_trx_commit</code> 设置为 2，减少 redo log 的 fsync 次数，但主机掉电时会丢失数据。</li>
</ul>
<p><strong>数据一致性与可靠性</strong>：</p>
<ul>
<li>MySQL 通过 redo log 和 binlog 的持久化来保证 crash-safe。</li>
<li>即使事务未提交，redo log 和 binlog 的丢失也不会导致数据不一致，因为事务未提交的数据不会被应用到数据库中。</li>
</ul>
<p><strong>常见问题解答</strong>：</p>
<ul>
<li>解释了为什么 binlog cache 是线程独有，而 redo log buffer 是全局共享的。</li>
<li>讨论了事务执行期间发生 crash 时，redo log 和 binlog 的丢失不会导致主备不一致。</li>
<li>解释了 binlog 写入后发生 crash 的情况，客户端重连后事务已提交成功是正常现象。</li>
</ul>
<h2 id="24-Mysql-是怎么保证主备一致的"><a href="#24-Mysql-是怎么保证主备一致的" class="headerlink" title="24 Mysql 是怎么保证主备一致的"></a>24 Mysql 是怎么保证主备一致的</h2><p><strong>MySQL 主备同步的基本原理</strong>：</p>
<ul>
<li>主库（节点 A）负责处理客户端的读写请求，备库（节点 B）通过同步主库的 binlog 来保持数据一致。</li>
<li>主备切换时，客户端会从主库切换到备库，备库变为新的主库。</li>
<li>备库通常设置为只读模式，防止误操作和双写问题，但同步线程拥有超级权限，可以绕过只读限制。</li>
</ul>
<p><strong>主备同步的流程</strong>：</p>
<ul>
<li>备库通过 <code>change master</code> 命令设置主库的连接信息，并通过 <code>start slave</code> 命令启动两个线程：<code>io_thread</code> 和 <code>sql_thread</code>。</li>
<li><code>io_thread</code> 负责从主库读取 binlog 并写入备库的中转日志（relay log）。</li>
<li><code>sql_thread</code> 负责解析并执行中转日志中的命令，保持备库与主库的数据一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503200809203.png"></p>
<p><strong>binlog 的三种格式</strong>：</p>
<ul>
<li><strong>statement</strong>：记录 SQL 语句的原文。优点是日志量小，缺点是某些情况下可能导致主备数据不一致（如使用了 <code>LIMIT</code> 或 <code>NOW()</code> 函数）。</li>
<li><strong>row</strong>：记录每一行数据的变更。优点是保证主备数据一致，缺点是日志量大，尤其是批量操作时。</li>
<li><strong>mixed</strong>：MySQL 自动选择 statement 或 row 格式，结合两者的优点，避免数据不一致问题。</li>
</ul>
<p><strong>binlog 格式的选择</strong>：</p>
<ul>
<li><strong>statement</strong> 格式可能导致主备数据不一致，尤其是在使用不确定函数（如 <code>NOW()</code>）或 <code>LIMIT</code> 时。</li>
<li><strong>row</strong> 格式记录了每一行数据的变更，确保主备数据一致，但日志量较大。</li>
<li><strong>mixed</strong> 格式是 MySQL 的折中方案，自动选择 statement 或 row 格式，避免数据不一致问题。</li>
</ul>
<p><strong>binlog 的数据恢复</strong>：</p>
<ul>
<li><strong>row</strong> 格式的 binlog 记录了每一行数据的变更，可以用于数据恢复。例如，误删数据后可以通过 binlog 恢复删除的行。</li>
<li><strong>insert</strong>、<strong>update</strong> 和 <strong>delete</strong> 操作都可以通过 binlog 进行恢复，尤其是 row 格式的 binlog 记录了完整的行数据。</li>
</ul>
<p><strong>循环复制问题</strong>：</p>
<ul>
<li>在双 M 结构（主备互为主备）中，可能会出现循环复制问题，即主库和备库互相同步 binlog，导致无限循环。</li>
<li>MySQL 通过 server id 解决循环复制问题：每个库在收到 binlog 时，会检查 server id，如果与自己的相同，则丢弃该日志，避免循环复制。</li>
</ul>
<p><strong>binlog 的其他用途</strong>：</p>
<ul>
<li>binlog 不仅可以用于主备同步，还可以用于数据恢复、审计、数据同步等场景。</li>
<li>通过 <code>mysqlbinlog</code> 工具可以解析 binlog，并将其用于数据恢复或重放。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>binlog 是 MySQL 主备同步的核心机制，通过不同的格式（statement、row、mixed）来平衡日志大小和数据一致性。</li>
<li>主备同步通过 <code>io_thread</code> 和 <code>sql_thread</code> 实现，确保备库与主库的数据一致。</li>
<li>双 M 结构中的循环复制问题通过 server id 机制解决，避免无限循环。</li>
</ul>
<h2 id="25-Mysql-是怎么保证高可用的"><a href="#25-Mysql-是怎么保证高可用的" class="headerlink" title="25 Mysql 是怎么保证高可用的"></a>25 Mysql 是怎么保证高可用的</h2><p><strong>主备同步与最终一致性</strong>：</p>
<ul>
<li>MySQL 通过 binlog 实现主备同步，备库接收并执行主库的 binlog，最终达到与主库一致的状态。</li>
<li>最终一致性是主备同步的基础，但要实现高可用性，还需要解决主备延迟等问题。</li>
</ul>
<p><strong>主备延迟的来源</strong>：</p>
<ul>
<li><strong>备库性能不足</strong>：备库所在机器的性能较差，导致同步速度慢。</li>
<li><strong>备库压力大</strong>：备库承担了过多的读请求，消耗了大量 CPU 资源，影响了同步速度。</li>
<li><strong>大事务</strong>：主库上的大事务（如大量数据删除或大表 DDL）会导致备库延迟，因为备库需要等待主库的事务完成后才能同步。</li>
<li><strong>备库的并行复制能力</strong>：备库的并行复制能力不足也会导致延迟。</li>
</ul>
<p><strong>主备切换策略</strong>：</p>
<ul>
<li><strong>可靠性优先策略</strong>：<ul>
<li>在主备切换时，确保备库的数据与主库完全一致后再切换。</li>
<li>切换过程中会有短暂的不可用时间，但能保证数据的一致性。</li>
</ul>
</li>
<li><strong>可用性优先策略</strong>：<ul>
<li>在主备切换时，优先保证系统的可用性，允许短暂的数据不一致。</li>
<li>这种策略可能会导致数据不一致，尤其是在使用 statement 或 mixed 格式的 binlog 时。</li>
</ul>
</li>
</ul>
<p><strong>binlog 格式对数据一致性的影响</strong>：</p>
<ul>
<li><strong>statement 格式</strong>：记录 SQL 语句的原文，可能导致主备数据不一致（如使用 <code>LIMIT</code> 或 <code>NOW()</code> 函数时）。</li>
<li><strong>row 格式</strong>：记录每一行数据的变更，确保主备数据一致，但日志量较大。</li>
<li><strong>mixed 格式</strong>：MySQL 自动选择 statement 或 row 格式，结合两者的优点，避免数据不一致问题。</li>
</ul>
<p><strong>高可用性与数据一致性的权衡</strong>：</p>
<ul>
<li>大多数情况下，建议使用<strong>可靠性优先策略</strong>，确保数据的准确性。</li>
<li>在某些特殊场景下（如操作日志记录），<strong>可用性优先策略</strong>可能更为合适，因为短暂的数据不一致可以通过 binlog 修复，且不会对业务造成严重影响。</li>
</ul>
<p><strong>异常切换与主备延迟</strong>：</p>
<ul>
<li>在主库故障时，主备延迟会影响系统的可用性。延迟越小，系统恢复的时间越短，可用性越高。</li>
<li>如果主备延迟较大，切换时可能会导致系统不可用或数据不一致。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>MySQL 的高可用性依赖于主备同步机制，主备延迟是影响高可用性的关键因素。</li>
<li>通过优化备库性能、减少大事务、提升并行复制能力等手段，可以减少主备延迟。</li>
<li>在主备切换时，应根据业务需求选择<strong>可靠性优先</strong>或<strong>可用性优先</strong>策略，确保在数据一致性和系统可用性之间找到平衡。</li>
</ul>
<h2 id="26-备库为什么会延迟好几个小时"><a href="#26-备库为什么会延迟好几个小时" class="headerlink" title="26 备库为什么会延迟好几个小时"></a>26 备库为什么会延迟好几个小时</h2><p><strong>备库延迟的原因</strong>：</p>
<ul>
<li>备库执行日志的速度持续低于主库生成日志的速度，导致延迟可能达到小时级别。</li>
<li>单线程复制是备库延迟的主要原因之一，尤其是在主库并发高、TPS 高的情况下。</li>
</ul>
<p><strong>并行复制的核心原则</strong>：</p>
<ul>
<li><strong>不能造成更新覆盖</strong>：更新同一行的两个事务必须被分发到同一个 worker 中。</li>
<li><strong>同一个事务不能被拆开</strong>：同一个事务的多个更新语句必须放到同一个 worker 中执行。</li>
</ul>
<p><strong>多线程复制的演进</strong>：</p>
<ul>
<li><strong>MySQL 5.5 及之前版本</strong>：只支持单线程复制，导致备库延迟问题严重。</li>
<li><strong>MySQL 5.6 版本</strong>：支持了并行复制，允许不同数据库的事务在备库上并行执行。</li>
<li><strong>MariaDB 的并行复制策略</strong>：基于组提交（group commit）特性，相同 commit_id 的事务可以在备库上并行执行，但存在大事务拖后腿的问题。</li>
<li><strong>MySQL 5.7 版本</strong>：引入了基于 LOGICAL_CLOCK 的并行复制策略，允许处于 prepare 状态的事务在备库上并行执行，提升了并行度。</li>
<li><strong>MySQL 5.7.22 版本</strong>：引入了基于 WRITESET 的并行复制策略。算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
</ul>
<p><strong>不同并行复制策略的优缺点</strong>：</p>
<ul>
<li><strong>按库并行策略</strong>：适用于多数据库场景，但在单数据库或热点表场景下效果不佳。</li>
<li><strong>按表并行策略</strong>：适用于多表场景，但在热点场景下会退化为单线程复制。</li>
<li><strong>按行并行策略</strong>：并行度最高，但消耗更多的内存和 CPU 资源，适用于大事务较少的场景。</li>
<li><strong>MariaDB 的组提交策略</strong>：基于 commit_id 的并行复制，简单易实现，但容易受大事务影响。</li>
<li><strong>MySQL 5.7 的 LOGICAL_CLOCK 策略</strong>：基于 prepare 状态的并行复制，提升了并行度，但依赖于主库的 binlog 组提交机制。</li>
<li><strong>MySQL 5.7.22 的 WRITESET 策略</strong>：基于行 hash 值的并行复制，减少了计算量和内存消耗，支持 statement 格式的 binlog。</li>
</ul>
<p><strong>大事务对备库延迟的影响</strong>：</p>
<ul>
<li>大事务（如大表 DDL 或大量数据删除）会导致备库延迟增加，因为备库需要等待大事务完成后才能继续执行其他事务。</li>
<li>建议将大事务拆分为小事务，以减少对备库同步的影响。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>多线程复制是解决备库延迟问题的关键，MySQL 通过不同版本的演进逐步提升了并行复制的效率和灵活性。</li>
<li>不同的并行复制策略适用于不同的业务场景，DBA 需要根据实际情况选择合适的策略。</li>
<li>大事务是造成备库延迟的主要原因之一，开发人员应尽量避免大事务操作，将其拆分为小事务。</li>
</ul>
<h2 id="27-主库出问题了，从库怎么办？"><a href="#27-主库出问题了，从库怎么办？" class="headerlink" title="27 主库出问题了，从库怎么办？"></a>27 主库出问题了，从库怎么办？</h2><p><strong>一主多从架构</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220803070027.png"></p>
<ul>
<li>一主多从架构通常用于读写分离，主库负责写操作和部分读操作，从库分担读请求。</li>
<li>当主库发生故障时，需要进行主备切换，从库需要重新指向新的主库，增加了切换的复杂性。</li>
</ul>
<p><strong>基于位点的主备切换</strong>：</p>
<ul>
<li>在切换过程中，从库需要找到与新主库同步的位点（binlog 文件名和偏移量），以确保数据一致性。</li>
<li>位点的获取通常是通过解析新主库的 binlog 文件，找到故障时刻的大致位置。</li>
<li>由于位点不精确，可能会导致从库重复执行某些事务，出现主键冲突等问题。</li>
<li>解决方法包括：<ul>
<li>使用 <code>sql_slave_skip_counter</code> 跳过重复事务。</li>
<li>设置 <code>slave_skip_errors</code> 参数，跳过常见的错误（如 1062 主键冲突和 1032 删除数据找不到行）。</li>
</ul>
</li>
</ul>
<p><strong>GTID（全局事务标识符）</strong></p>
<ul>
<li>GTID 是 MySQL 5.6 引入的机制，用于唯一标识每个事务，格式为 <code>server_uuid:gno</code>。</li>
<li>GTID 模式简化了主备切换过程，不再需要手动指定位点，系统会自动处理同步问题。</li>
<li>GTID 的生成方式有两种：<ul>
<li>自动生成：事务提交时分配 GTID。</li>
<li>手动指定：通过 <code>set gtid_next</code> 指定 GTID，适用于跳过某些事务的场景。</li>
</ul>
</li>
</ul>
<p><strong>基于 GTID 的主备切换</strong>：</p>
<ul>
<li>在 GTID 模式下，从库只需要执行 <code>CHANGE MASTER TO</code> 命令，并设置 <code>master_auto_position=1</code>，系统会自动计算需要同步的事务。</li>
<li>新主库会计算自己与从库的 GTID 集合差集，确保从库获取到所有缺失的事务。</li>
<li>如果新主库缺少从库所需的事务，会直接报错，确保数据完整性。</li>
</ul>
<p><strong>GTID 与在线 DDL</strong>：</p>
<ul>
<li>在双 M 结构下，备库执行的 DDL 语句可以通过 GTID 机制确保不会在主库上重复执行。</li>
<li>通过手动设置 GTID，可以确保 DDL 操作的 binlog 记录不会影响主库。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>基于位点的主备切换复杂且容易出错，而 GTID 模式简化了这一过程，提升了主备切换的效率和可靠性。</li>
<li>如果 MySQL 版本支持 GTID，建议使用 GTID 模式进行主备切换。</li>
<li>GTID 模式不仅适用于主备切换，还可以用于在线 DDL 操作，确保数据一致性。</li>
</ul>
<h2 id="28-读写分离有哪些坑"><a href="#28-读写分离有哪些坑" class="headerlink" title="28 读写分离有哪些坑"></a>28 读写分离有哪些坑</h2><p><strong>读写分离的基本架构</strong>：</p>
<p>一主多从架构通常用于读写分离，主库负责写操作，从库分担读请求。</p>
<p>读写分离的两种常见架构：</p>
<ul>
<li><strong>客户端直连</strong>：客户端直接连接数据库，性能较好，但主备切换时客户端需要调整连接信息。</li>
<li><strong>带 Proxy 的架构</strong>：客户端连接 Proxy，由 Proxy 负责路由请求，对客户端友好，但架构复杂。</li>
</ul>
<p><strong>过期读问题</strong>：</p>
<p>由于<strong>主从延迟</strong>，客户端<strong>在从库上可能会读到过期的数据</strong>，这种现象称为“<strong>过期读</strong>”。过期读的常见场景是主库更新后，从库还未同步完成，客户端查询从库时读到旧数据。</p>
<p><strong>解决过期读的几种方案</strong>：</p>
<ul>
<li><strong>强制走主库</strong>：对于必须读到最新数据的请求，强制查询主库。适用于对数据实时性要求高的场景，但会增加主库的压力。</li>
<li><strong>Sleep 方案</strong>：在查询从库前先 sleep 一段时间，假设主从延迟在 1 秒内。虽然简单，但不精确，可能导致等待时间过长或仍然读到过期数据。</li>
<li><strong>判断主备无延迟</strong>：通过 <code>show slave status</code> 判断主从延迟，确保从库同步完成后再查询。可以通过 <code>seconds_behind_master</code>、位点对比或 GTID 集合对比来判断。</li>
<li><strong>配合 semi-sync</strong>：使用半同步复制（semi-sync），确保主库在事务提交后，至少有一个从库收到 binlog 后才返回确认。可以减少过期读的概率，但在多从库场景下仍可能有问题。semi-sync 流程：<ul>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ul>
</li>
<li><strong>等主库位点方案</strong>：使用 <code>select master_pos_wait(file, pos, timeout)</code> 命令，等待从库同步到指定位点后再查询。可以精确控制查询时机，避免过期读。</li>
<li><strong>等 GTID 方案</strong>：使用 <code>select wait_for_executed_gtid_set(gtid_set, timeout)</code> 命令，等待从库执行到指定 GTID 后再查询。适用于 GTID 模式，减少了查询主库位点的开销。</li>
</ul>
<p>不同的方案适用于不同的业务场景，需要根据业务需求选择。在实际应用中，可以混合使用多种方案，根据请求的类型选择不同的处理方式。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>过期读是读写分离架构中常见的问题，主从延迟是主要原因。</li>
<li>通过合理的方案选择，可以在保证读写分离的同时，尽量减少过期读的发生。</li>
<li>对于高一致性要求的场景，建议使用等主库位点或等 GTID 方案，确保查询结果的准确性。</li>
</ul>
<h2 id="29-如何判断一个数据库是不是出问题了"><a href="#29-如何判断一个数据库是不是出问题了" class="headerlink" title="29 如何判断一个数据库是不是出问题了"></a>29 如何判断一个数据库是不是出问题了</h2><p><strong>select 1 判断</strong>：</p>
<ul>
<li><code>select 1</code> 只能检测数据库进程是否存活，无法检测数据库内部的并发线程数是否过高或是否存在其他问题。</li>
<li>当并发线程数达到 <code>innodb_thread_concurrency</code> 设置的上限时，数据库可能无法处理新请求，但 <code>select 1</code> 仍然可以成功返回，导致误判。</li>
</ul>
<p><strong>查表判断</strong>：</p>
<ul>
<li>在系统库（如 <code>mysql</code> 库）中创建一个健康检查表（如 <code>health_check</code>），里面只放一行数据，然后定期执行 <code>select * from mysql.health_check</code>。</li>
<li>这种方法<strong>可以检测到由于并发线程过多导致的数据库不可用</strong>情况，但<strong>无法检测磁盘空间满等问题</strong>。</li>
</ul>
<p><strong>更新判断</strong>：</p>
<ul>
<li>在健康检查表中加入一个 <code>timestamp</code> 字段，定期执行更新操作（如 <code>update mysql.health_check set t_modified=now()</code>）。</li>
<li>这种方法可以检测到磁盘空间满等问题，因为更新操作需要写 binlog，如果磁盘空间满，更新操作会失败。为了避免主备冲突，可以在健康检查表中使用 <code>server_id</code> 作为主键，确保主库和备库的更新操作不会冲突。</li>
<li>更新判断的局限性：<ul>
<li>更新判断存在“判定慢”的问题，即在系统 IO 资源紧张时，更新操作可能仍然成功返回，导致误判。</li>
<li>外部检测的随机性可能导致问题无法及时被发现，尤其是在定时轮询的间隔期间。</li>
</ul>
</li>
</ul>
<p><strong>内部统计</strong>：</p>
<ul>
<li>MySQL 5.6 版本以后提供了 <code>performance_schema</code> 库，可以统计每次 IO 请求的时间。</li>
<li>通过监控 <code>performance_schema.file_summary_by_event_name</code> 表中的 IO 请求时间，可以更准确地判断数据库是否出现性能问题。</li>
<li>可以设置阈值，当单次 IO 请求时间超过一定值（如 200 毫秒）时，认为数据库出现异常。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>不同的检测方法各有优缺点，<code>select 1</code> 简单但不精确，查表和更新判断可以检测更多问题，但仍存在局限性。</li>
<li>内部统计方法（如 <code>performance_schema</code>）可以提供更精确的数据库状态信息，但会带来一定的性能损耗。</li>
<li>在实际应用中，可以根据业务需求选择合适的检测方法，通常建议结合更新判断和内部统计方法，以提高检测的准确性。</li>
</ul>
<h2 id="30-答疑文章（二）：用动态的观点看加锁"><a href="#30-答疑文章（二）：用动态的观点看加锁" class="headerlink" title="30 答疑文章（二）：用动态的观点看加锁"></a>30 答疑文章（二）：用动态的观点看加锁</h2><p><strong>加锁规则回顾</strong>：</p>
<ul>
<li><strong>原则 1</strong>：加锁的基本单位是 next-key lock，即前开后闭区间。</li>
<li><strong>原则 2</strong>：查找过程中访问到的对象才会加锁。</li>
<li><strong>优化 1</strong>：唯一索引上的等值查询，next-key lock 退化为行锁。</li>
<li><strong>优化 2</strong>：索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock 退化为间隙锁。</li>
<li><strong>一个 bug</strong>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<p><strong>不等号条件里的等值查询</strong>：</p>
<ul>
<li>在不等号查询中，虽然条件是不等号，但在索引树的搜索过程中，引擎内部会使用等值查询来定位记录。</li>
<li>例如，<code>select * from t where id&gt;9 and id&lt;12 order by id desc for update;</code> 的加锁范围是 (0,5]、(5,10] 和 (10,15)，其中 id&#x3D;15 不满足条件，next-key lock 退化为间隙锁 (10,15)。</li>
</ul>
<p><strong>等值查询的过程</strong>：</p>
<ul>
<li>对于 <code>select id from t where c in(5,20,10) lock in share mode;</code>，加锁过程是逐个进行的，先加 c&#x3D;5 的记录锁，再加 c&#x3D;10 的记录锁，最后加 c&#x3D;20 的记录锁。</li>
<li>如果并发执行 <code>select id from t where c in(5,20,10) order by c desc for update;</code>，加锁顺序相反，可能导致死锁。</li>
</ul>
<p><strong>死锁分析</strong>：</p>
<ul>
<li>死锁发生时，InnoDB 会选择回滚成本较小的事务来解除死锁。</li>
<li>通过 <code>show engine innodb status</code> 可以查看死锁信息，了解哪些事务持有锁、等待锁，以及最终回滚了哪个事务。</li>
</ul>
<p><strong>锁等待分析</strong>：</p>
<ul>
<li>通过 <code>show engine innodb status</code> 可以查看锁等待信息，了解哪些事务在等待锁，以及等待的锁类型（如间隙锁、插入意向锁等）。</li>
<li>间隙锁的范围是由间隙右边的记录定义的，删除记录后，间隙锁的范围可能会发生变化。</li>
</ul>
<p><strong>update 语句的加锁行为</strong>：</p>
<ul>
<li>update 语句的加锁范围可以通过语句的执行逻辑来分析。例如，<code>update t set c=1 where c=5</code> 会先插入新记录，再删除旧记录，可能会被间隙锁阻塞。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d5d0c1d8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d5d0c1d8/" class="post-title-link" itemprop="url">《极客时间教程 - SQL 必知必会》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-16 10:46:05" itemprop="dateCreated datePublished" datetime="2022-07-16T10:46:05+08:00">2022-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-SQL-必知必会》笔记"><a href="#《极客时间教程-SQL-必知必会》笔记" class="headerlink" title="《极客时间教程 - SQL 必知必会》笔记"></a>《极客时间教程 - SQL 必知必会》笔记</h1><h2 id="01-丨了解-SQL：一门半衰期很长的语言"><a href="#01-丨了解-SQL：一门半衰期很长的语言" class="headerlink" title="01 丨了解 SQL：一门半衰期很长的语言"></a>01 丨了解 SQL：一门半衰期很长的语言</h2><p>SQL 语言按照功能划分成以下的 4 个部分：</p>
<ul>
<li><strong>DDL</strong> 是 Data Definition Language 的缩写，即数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li>
<li><strong>DML</strong> 是 Data Manipulation Language 的缩写，即数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li>
<li><strong>DCL</strong> 是 Data Control Language 的缩写，即数据控制语言，我们用它来定义访问权限和安全级别。</li>
<li><strong>DQL</strong> 是 Data Query Language 的缩写，即数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li>
</ul>
<h2 id="02-丨-DBMS-的前世今生"><a href="#02-丨-DBMS-的前世今生" class="headerlink" title="02 丨 DBMS 的前世今生"></a>02 丨 DBMS 的前世今生</h2><p>DB、DBS 和 DBMS 的区别：</p>
<ul>
<li>DBMS 的英文全称是 DataBase Management System，数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS &#x3D; 多个数据库（DB） + 管理程序。</li>
<li>DB 的英文是 DataBase，也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。</li>
<li>DBS 的英文是 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。</li>
</ul>
<p>NoSql 不同时期的释义</p>
<ul>
<li>1970：NoSQL &#x3D; We have no SQL</li>
<li>1980：NoSQL &#x3D; Know SQL</li>
<li>2000：NoSQL &#x3D; No SQL!</li>
<li>2005：NoSQL &#x3D; Not only SQL</li>
<li>2013：NoSQL &#x3D; No, SQL!</li>
</ul>
<h2 id="03-丨学会用数据库的方式思考-SQL-是如何执行的"><a href="#03-丨学会用数据库的方式思考-SQL-是如何执行的" class="headerlink" title="03 丨学会用数据库的方式思考 SQL 是如何执行的"></a>03 丨学会用数据库的方式思考 SQL 是如何执行的</h2><h3 id="Oracle-中的-SQL-是如何执行的"><a href="#Oracle-中的-SQL-是如何执行的" class="headerlink" title="Oracle 中的 SQL 是如何执行的"></a>Oracle 中的 SQL 是如何执行的</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220716105947.png"></p>
<ol>
<li><strong>语法检查</strong>：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li>
<li><strong>语义检查</strong>：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li>
<li><strong>权限检查</strong>：看用户是否具备访问该数据的权限。</li>
<li><strong>共享池检查</strong>：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？<ul>
<li>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是<strong>软解析</strong>。</li>
<li>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是<strong>硬解析</strong>。</li>
</ul>
</li>
<li><strong>优化器</strong>：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li>
<li><strong>执行器</strong>：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</li>
</ol>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<h3 id="MySQL-中的-SQL-是如何执行的"><a href="#MySQL-中的-SQL-是如何执行的" class="headerlink" title="MySQL 中的 SQL 是如何执行的"></a>MySQL 中的 SQL 是如何执行的</h3><p>MySQL 是典型的 C&#x2F;S 架构，即 Client&#x2F;Server 架构，服务器端程序使用的 mysqld。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220716110905.png"></p>
<p>Mysql 可分为三层：</p>
<ol>
<li><strong>连接层</strong>：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li><strong>SQL 层</strong>：对 SQL 语句进行查询处理；</li>
<li><strong>存储引擎层</strong>：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220716111103.png"></p>
<p>SQL 层的结构</p>
<ol>
<li><strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li><strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li><strong>执行器</strong>：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ol>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ol>
<h2 id="04-丨使用-DDL-创建数据库-数据表时需要注意什么？"><a href="#04-丨使用-DDL-创建数据库-数据表时需要注意什么？" class="headerlink" title="04 丨使用 DDL 创建数据库&amp;数据表时需要注意什么？"></a>04 丨使用 DDL 创建数据库&amp;数据表时需要注意什么？</h2><p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p>
<p>执行 DDL 的时候，不需要 COMMIT，就可以完成执行任务。</p>
<p>设计数据表的原则</p>
<ul>
<li><strong>数据表的个数越少越好</strong> - RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图（Entity Relationship Diagram），数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</li>
<li><strong>数据表中的字段个数越少越好</strong> - 字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</li>
<li><strong>数据表中联合主键的字段个数越少越好</strong> - 设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</li>
<li><del><strong>使用主键和外键越多越好</strong> - 数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率</del>。——不同意</li>
</ul>
<h2 id="05-丨检索数据：你还在-SELECT-么？"><a href="#05-丨检索数据：你还在-SELECT-么？" class="headerlink" title="05 丨检索数据：你还在 SELECT 么？"></a>05 丨检索数据：你还在 SELECT 么？</h2><p>SELECT 的作用是从一个表或多个表中检索出想要的数据行。</p>
<ul>
<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>
<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>
<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<ul>
<li><code>ASC</code> ：升序（默认）</li>
<li><code>DESC</code> ：降序</li>
</ul>
</li>
</ul>
<h3 id="SELECT-查询的基础语法"><a href="#SELECT-查询的基础语法" class="headerlink" title="SELECT 查询的基础语法"></a>SELECT 查询的基础语法</h3><p>查询单列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询多列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, continent, region <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询所有列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>查询过滤重复值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span>(continent) <span class="keyword">FROM</span> world.country;</span><br></pre></td></tr></table></figure>

<p>限制查询数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> world.country LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="SELECT-的执行顺序"><a href="#SELECT-的执行顺序" class="headerlink" title="SELECT 的执行顺序"></a>SELECT 的执行顺序</h3><p>关键字的顺序是不能颠倒的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...</span><br></pre></td></tr></table></figure>

<p>SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> 的字段 <span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="comment">-- 顺序 5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id <span class="comment">-- 顺序 1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> <span class="comment">-- 顺序 2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id <span class="comment">-- 顺序 3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> <span class="comment">-- 顺序 4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> <span class="comment">-- 顺序 6</span></span><br><span class="line">LIMIT <span class="number">2</span> <span class="comment">-- 顺序 7</span></span><br></pre></td></tr></table></figure>

<h2 id="06-丨数据过滤：SQL-数据过滤都有哪些方法？"><a href="#06-丨数据过滤：SQL-数据过滤都有哪些方法？" class="headerlink" title="06 丨数据过滤：SQL 数据过滤都有哪些方法？"></a>06 丨数据过滤：SQL 数据过滤都有哪些方法？</h2><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<h3 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BETWEEN</code></td>
<td>在某个范围内</td>
</tr>
<tr>
<td><code>IN</code></td>
<td>指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>并且（与）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>或者（或）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>否定（非）</td>
</tr>
</tbody></table>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LIKE</code></td>
<td>搜索某种模式</td>
</tr>
<tr>
<td><code>%</code></td>
<td>表示任意字符出现任意次数</td>
</tr>
<tr>
<td><code>_</code></td>
<td>表示任意字符出现一次</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>必须匹配指定位置的一个字符</td>
</tr>
</tbody></table>
<h2 id="07-丨什么是-SQL-函数？为什么使用-SQL-函数可能会带来问题？"><a href="#07-丨什么是-SQL-函数？为什么使用-SQL-函数可能会带来问题？" class="headerlink" title="07 丨什么是 SQL 函数？为什么使用 SQL 函数可能会带来问题？"></a>07 丨什么是 SQL 函数？为什么使用 SQL 函数可能会带来问题？</h2><ul>
<li>数学函数</li>
<li>字符串函数</li>
<li>日期函数</li>
<li>转换函数</li>
<li>聚合函数</li>
</ul>
<h2 id="08-丨什么是-SQL-的聚集函数，如何利用它们汇总表的数据？"><a href="#08-丨什么是-SQL-的聚集函数，如何利用它们汇总表的数据？" class="headerlink" title="08 丨什么是 SQL 的聚集函数，如何利用它们汇总表的数据？"></a>08 丨什么是 SQL 的聚集函数，如何利用它们汇总表的数据？</h2><p>聚合函数</p>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>AVG()</code></td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center"><code>COUNT()</code></td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center"><code>MAX()</code></td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center"><code>MIN()</code></td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center"><code>SUM()</code></td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<h2 id="09-丨子查询：子查询的种类都有哪些，如何提高子查询的性能？"><a href="#09-丨子查询：子查询的种类都有哪些，如何提高子查询的性能？" class="headerlink" title="09 丨子查询：子查询的种类都有哪些，如何提高子查询的性能？"></a>09 丨子查询：子查询的种类都有哪些，如何提高子查询的性能？</h2><p>子查询可以分为关联子查询和非关联子查询。</p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做非关联子查询。</p>
<p>如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为关联子查询。</p>
<p>子查询关键词：EXISTS、IN、ANY、ALL、SOME</p>
<p>如果表 A 比表 B 大，那么 IN 子查询的效率要比 EXIST 子查询效率高，因为这时 B 表中如果对 cc 列进行了索引，那么 IN 子查询的效率就会比较高。</p>
<p>ANY 和 ALL 都需要使用比较符，比较符包括了（&gt;）（&#x3D;）（&lt;）（&gt;&#x3D;）（&lt;&#x3D;）和（&lt;&gt;）等。</p>
<p>子查询可以作为主查询的列</p>
<h2 id="10-丨常用的-SQL-标准有哪些，在-SQL92-中是如何使用连接的？"><a href="#10-丨常用的-SQL-标准有哪些，在-SQL92-中是如何使用连接的？" class="headerlink" title="10 丨常用的 SQL 标准有哪些，在 SQL92 中是如何使用连接的？"></a>10 丨常用的 SQL 标准有哪些，在 SQL92 中是如何使用连接的？</h2><p>内连接（INNER JOIN）</p>
<p>自连接（<code>=</code>）</p>
<p>自然连接（NATURAL JOIN）</p>
<p>外连接（OUTER JOIN）</p>
<p>左连接（LEFT JOIN）</p>
<p>右连接（RIGHT JOIN）</p>
<h2 id="11-丨-SQL99-是如何使用连接的，与-SQL92-的区别是什么？"><a href="#11-丨-SQL99-是如何使用连接的，与-SQL92-的区别是什么？" class="headerlink" title="11 丨 SQL99 是如何使用连接的，与 SQL92 的区别是什么？"></a>11 丨 SQL99 是如何使用连接的，与 SQL92 的区别是什么？</h2><h2 id="12-丨视图在-SQL-中的作用是什么，它是怎样工作的？"><a href="#12-丨视图在-SQL-中的作用是什么，它是怎样工作的？" class="headerlink" title="12 丨视图在 SQL 中的作用是什么，它是怎样工作的？"></a>12 丨视图在 SQL 中的作用是什么，它是怎样工作的？</h2><p>视图是基于 SQL 语句的结果集的可视化的表。<strong>视图是虚拟的表，本身不存储数据，也就不能对其进行索引操作</strong>。对视图的操作和对普通表的操作一样。</p>
<p>视图的作用：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接。</li>
<li>只使用实际表的一部分数据。</li>
<li>通过只给用户访问视图的权限，保证数据的安全性。</li>
<li>更改数据格式和表示。</li>
</ul>
<h2 id="13-丨什么是存储过程，在实际项目中用得多么？"><a href="#13-丨什么是存储过程，在实际项目中用得多么？" class="headerlink" title="13 丨什么是存储过程，在实际项目中用得多么？"></a>13 丨什么是存储过程，在实际项目中用得多么？</h2><p>存储过程的英文是 Stored Procedure。它可以视为一组 SQL 语句的批处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。</p>
<p>存储过程的优点：</p>
<ul>
<li><strong>执行效率高</strong>：一次编译多次使用。</li>
<li><strong>安全性强</strong>：在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li>
<li><strong>可复用</strong>：将代码封装，可以提高代码复用。</li>
<li><strong>性能好</strong><ul>
<li>由于是预先编译，因此具有很高的性能。</li>
<li>一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率。</li>
</ul>
</li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>可移植性差</strong>：存储过程不能跨数据库移植。由于不同数据库的存储过程语法几乎都不一样，十分难以维护（不通用）。</li>
<li><strong>调试困难</strong>：只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</li>
<li><strong>版本管理困难</strong>：比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li><strong>不适合高并发的场景</strong>：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li>
</ul>
<blockquote>
<p>_综上，存储过程的优缺点都非常突出，是否使用一定要慎重，需要根据具体应用场景来权衡_。</p>
</blockquote>
<h2 id="14-丨什么是事务处理，如何使用-COMMIT-和-ROLLBACK-进行操作？"><a href="#14-丨什么是事务处理，如何使用-COMMIT-和-ROLLBACK-进行操作？" class="headerlink" title="14 丨什么是事务处理，如何使用 COMMIT 和 ROLLBACK 进行操作？"></a>14 丨什么是事务处理，如何使用 COMMIT 和 ROLLBACK 进行操作？</h2><p>ACID：</p>
<ol>
<li>A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</li>
<li>C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</li>
<li>I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</li>
<li>最后一个 D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。</li>
</ol>
<p>事务的控制语句：</p>
<ol>
<li>START TRANSACTION 或者 BEGIN，作用是显式开启一个事务。</li>
<li>COMMIT：提交事务。当提交事务后，对数据库的修改是永久性的。</li>
<li>ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。</li>
<li>SAVEPOINT：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li>RELEASE SAVEPOINT：删除某个保存点。</li>
<li>SET TRANSACTION，设置事务的隔离级别。</li>
</ol>
<h2 id="15-丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？"><a href="#15-丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？" class="headerlink" title="15 丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？"></a>15 丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？</h2><p>事务隔离级别从低到高分别是：读未提交（READ UNCOMMITTED ）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）。</p>
<h2 id="16-丨游标：当我们需要逐条处理数据时，该怎么做？"><a href="#16-丨游标：当我们需要逐条处理数据时，该怎么做？" class="headerlink" title="16 丨游标：当我们需要逐条处理数据时，该怎么做？"></a>16 丨游标：当我们需要逐条处理数据时，该怎么做？</h2><h2 id="17-丨如何使用-Python-操作-MySQL？"><a href="#17-丨如何使用-Python-操作-MySQL？" class="headerlink" title="17 丨如何使用 Python 操作 MySQL？"></a>17 丨如何使用 Python 操作 MySQL？</h2><p>略</p>
<h2 id="18-丨-SQLAlchemy：如何使用-PythonORM-框架来操作-MySQL？"><a href="#18-丨-SQLAlchemy：如何使用-PythonORM-框架来操作-MySQL？" class="headerlink" title="18 丨 SQLAlchemy：如何使用 PythonORM 框架来操作 MySQL？"></a>18 丨 SQLAlchemy：如何使用 PythonORM 框架来操作 MySQL？</h2><p>略</p>
<h2 id="19-丨基础篇总结：如何理解查询优化、通配符以及存储过程？"><a href="#19-丨基础篇总结：如何理解查询优化、通配符以及存储过程？" class="headerlink" title="19 丨基础篇总结：如何理解查询优化、通配符以及存储过程？"></a>19 丨基础篇总结：如何理解查询优化、通配符以及存储过程？</h2><h2 id="20-丨当我们思考数据库调优的时候，都有哪些维度可以选择？"><a href="#20-丨当我们思考数据库调优的时候，都有哪些维度可以选择？" class="headerlink" title="20 丨当我们思考数据库调优的时候，都有哪些维度可以选择？"></a>20 丨当我们思考数据库调优的时候，都有哪些维度可以选择？</h2><p>我的理解：</p>
<ul>
<li>选择合适数据库</li>
<li>配置优化</li>
<li>硬件优化</li>
<li>优化表设计</li>
<li>优化查询</li>
<li>使用缓存</li>
<li>读写分离+分库分表</li>
</ul>
<h2 id="21-丨范式设计：数据表的范式有哪些，3NF-指的是什么？"><a href="#21-丨范式设计：数据表的范式有哪些，3NF-指的是什么？" class="headerlink" title="21 丨范式设计：数据表的范式有哪些，3NF 指的是什么？"></a>21 丨范式设计：数据表的范式有哪些，3NF 指的是什么？</h2><p>范式定义：</p>
<ul>
<li><strong>1NF</strong>：指的是数据库表中的任何属性都是原子性的，不可再分。</li>
<li><strong>2NF</strong>：指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。</li>
<li><strong>3NF</strong>：在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。</li>
<li><strong>BCNF</strong>：在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</li>
</ul>
<p><strong>范式化的目标是尽力减少冗余列，节省空间</strong>。</p>
<h2 id="22-丨反范式设计：3NF-有什么不足，为什么有时候需要反范式设计？"><a href="#22-丨反范式设计：3NF-有什么不足，为什么有时候需要反范式设计？" class="headerlink" title="22 丨反范式设计：3NF 有什么不足，为什么有时候需要反范式设计？"></a>22 丨反范式设计：3NF 有什么不足，为什么有时候需要反范式设计？</h2><p><strong>反范式化的目标是适当增加冗余列，以避免关联查询</strong>。</p>
<p>范式化优点</p>
<ul>
<li>更节省空间</li>
<li>更新操作更快</li>
<li>更少需要 <code>DISTINCT</code> 或 <code>GROUP BY</code> 语句</li>
</ul>
<p>范式化缺点</p>
<ul>
<li>增加了关联查询，而关联查询代价很高</li>
</ul>
<h2 id="23-丨索引的概览：用还是不用索引，这是一个问题"><a href="#23-丨索引的概览：用还是不用索引，这是一个问题" class="headerlink" title="23 丨索引的概览：用还是不用索引，这是一个问题"></a>23 丨索引的概览：用还是不用索引，这是一个问题</h2><blockquote>
<p>索引的优缺点</p>
</blockquote>
<p><strong>索引的优点</strong></p>
<ul>
<li>大大减少了服务器需要扫描的数据量</li>
<li>可以帮助服务器避免排序和临时表</li>
<li>可以将随机 I&#x2F;O 变为顺序 I&#x2F;O</li>
</ul>
<p><strong>索引的缺点</strong></p>
<ul>
<li>创建和维护索引要耗费时间，这会随着数据量的增加而增加。</li>
<li>占用额外物理空间</li>
<li>写操作时很可能需要更新索引，导致数据库的写操作性能降低</li>
</ul>
<blockquote>
<p>索引的适用场景</p>
</blockquote>
<p><strong>适用场景</strong></p>
<ul>
<li>频繁读操作（SELECT）</li>
<li>表的数据量比较大</li>
<li>列名经常出现在 WHERE 或连接（JOIN）条件中</li>
</ul>
<p><strong>不适用场景</strong></p>
<ul>
<li>频繁写操作（INSERT&#x2F;UPDATE&#x2F;DELETE）</li>
<li>列名不经常出现在 WHERE 或连接（JOIN）条件中</li>
<li>索引会经常无法命中，没有意义</li>
<li>非常小的表（比如不到 1000 行）：简单的全表扫描更高效</li>
<li>特大型的表：索引的代价很高昂，可以用分区或 Nosql</li>
</ul>
<h2 id="24-丨索引的原理：我们为什么用-B-树来做索引？"><a href="#24-丨索引的原理：我们为什么用-B-树来做索引？" class="headerlink" title="24 丨索引的原理：我们为什么用 B+树来做索引？"></a>24 丨索引的原理：我们为什么用 B+树来做索引？</h2><p>磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要。虽然传统的二叉树数据结构查找数据的效率高，但很容易增加磁盘 I&#x2F;O 操作的次数，影响索引使用的效率。因此在构造索引的时候，我们更倾向于采用“矮胖”的数据结构。</p>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树，B+ 树在查询性能上更稳定，在磁盘页大小相同的情况下，树的构造更加矮胖，所需要进行的磁盘 I&#x2F;O 次数更少，更适合进行关键字的范围查询。</p>
<h2 id="25-丨-Hash-索引的底层原理是什么？"><a href="#25-丨-Hash-索引的底层原理是什么？" class="headerlink" title="25 丨 Hash 索引的底层原理是什么？"></a>25 丨 Hash 索引的底层原理是什么？</h2><p>Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<p>✔️️️️️ 哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>❌ 哈希索引的<strong>缺点</strong>：</p>
<ul>
<li><strong>只支持等值比较查询</strong> - 包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>。<ul>
<li><strong>不支持范围查询</strong>，如 <code>WHERE price &gt; 100</code>。</li>
<li><strong>不支持模糊查询</strong>，如 <code>%</code> 开头。</li>
</ul>
</li>
<li><strong>无法用于排序</strong> - 因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用。</li>
<li><strong>不支持联合索引的最左侧原则</strong> - 对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。例如：在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li><strong>不能用索引中的值来避免读取行</strong> - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。</p>
</blockquote>
<h2 id="26-丨索引的使用原则：如何通过索引让-SQL-查询效率最大化？"><a href="#26-丨索引的使用原则：如何通过索引让-SQL-查询效率最大化？" class="headerlink" title="26 丨索引的使用原则：如何通过索引让 SQL 查询效率最大化？"></a>26 丨索引的使用原则：如何通过索引让 SQL 查询效率最大化？</h2><p>✔️️️️ 什么情况<strong>适用</strong>索引？</p>
<ul>
<li><strong>字段的数值有唯一性的限制</strong>，如用户名。</li>
<li><strong>频繁作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，尤其在数据表大的情况下</strong></li>
<li><strong>频繁用于 <code>GROUP BY</code> 或 <code>ORDER BY</code> 的字段</strong>。将该字段作为索引，查询时就无需再排序了，因为 B+ 树</li>
<li><strong>DISTINCT 字段需要创建索引</strong>。</li>
</ul>
<p>❌ 什么情况<strong>不适用</strong>索引？</p>
<ul>
<li><strong>频繁写操作</strong>（ <code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code> ），也就意味着需要更新索引。</li>
<li><strong>列名不经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</strong>，也就意味着索引会经常无法命中，没有意义，还增加空间开销。</li>
<li><strong>非常小的表</strong>，对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li><strong>特大型的表</strong>，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
</ul>
<p>索引失效的场景：</p>
<ul>
<li>对索引使用左模糊匹配</li>
<li>对索引使用表达式或函数</li>
<li>对索引隐式类型转换</li>
<li>联合索引不遵循最左匹配原则</li>
<li>索引列判空</li>
<li>WHERE 子句中的 OR 前后条件存在非索引列</li>
</ul>
<h2 id="27-丨从数据页的角度理解-B-树查询"><a href="#27-丨从数据页的角度理解-B-树查询" class="headerlink" title="27 丨从数据页的角度理解 B+树查询"></a>27 丨从数据页的角度理解 B+树查询</h2><p><strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720055715.png"></p>
<p>一个表空间包括了一个或多个段，一个段包括了一个或多个区，一个区包括了多个页，而一个页中可以有多行记录：</p>
<ul>
<li><p>页是数据库存储的最小单位。</p>
</li>
<li><p>区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。</p>
</li>
<li><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
</li>
<li><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
</li>
</ul>
<h2 id="28-丨从磁盘-I-O-的角度理解-SQL-查询的成本"><a href="#28-丨从磁盘-I-O-的角度理解-SQL-查询的成本" class="headerlink" title="28 丨从磁盘 I&#x2F;O 的角度理解 SQL 查询的成本"></a>28 丨从磁盘 I&#x2F;O 的角度理解 SQL 查询的成本</h2><p>磁盘 I&#x2F;O 耗时远大于内存，因此数据库会采用缓冲池的方式提升页的查找效率。</p>
<p>SQL 查询是一个动态的过程，从页加载的角度来看：</p>
<ol>
<li>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li>批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多 10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<h2 id="29-丨为什么没有理想的索引？"><a href="#29-丨为什么没有理想的索引？" class="headerlink" title="29 丨为什么没有理想的索引？"></a>29 丨为什么没有理想的索引？</h2><p>略</p>
<h2 id="30-丨锁：悲观锁和乐观锁是什么？"><a href="#30-丨锁：悲观锁和乐观锁是什么？" class="headerlink" title="30 丨锁：悲观锁和乐观锁是什么？"></a>30 丨锁：悲观锁和乐观锁是什么？</h2><p>基于加锁方式分类，Mysql 可以分为悲观锁和乐观锁。</p>
<ul>
<li><strong>悲观锁</strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul>
<li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li>
<li>实现方式：<strong>使用数据库中的锁机制</strong>。</li>
</ul>
</li>
<li><strong>乐观锁</strong> - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。<ul>
<li>实现方式：<strong>更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改</strong>。</li>
</ul>
</li>
</ul>
<h2 id="31-丨为什么大部分-RDBMS-都会支持-MVCC？"><a href="#31-丨为什么大部分-RDBMS-都会支持-MVCC？" class="headerlink" title="31 丨为什么大部分 RDBMS 都会支持 MVCC？"></a>31 丨为什么大部分 RDBMS 都会支持 MVCC？</h2><p>MVCC 的核心就是 Undo Log+ Read View</p>
<ul>
<li>Undo Log 保存数据的历史版本，实现多版本的管理；</li>
<li>通过 Read View 原则来决定数据是否显示；</li>
<li>时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别</li>
</ul>
<h2 id="32-丨查询优化器是如何工作的？"><a href="#32-丨查询优化器是如何工作的？" class="headerlink" title="32 丨查询优化器是如何工作的？"></a>32 丨查询优化器是如何工作的？</h2><p>MySQL 整个查询执行过程，总的来说分为 6 个步骤，分别对应 6 个组件：</p>
<ol>
<li><strong>连接器</strong> - 客户端和 MySQL 服务器建立连接；连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li><strong>查询缓存</strong> - MySQL 服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。</li>
<li><strong>分析器</strong> - MySQL 服务器进行 SQL 分析：语法分析、词法分析。</li>
<li><strong>优化器</strong> - MySQL 服务器用优化器生成对应的执行计划。</li>
<li><strong>执行器</strong> - MySQL 服务器根据执行计划，调用存储引擎的 API 来执行查询。</li>
<li><strong>返回结果</strong> - MySQL 服务器将结果返回给客户端，同时缓存查询结果。</li>
</ol>
<h2 id="33-丨如何使用性能分析工具定位-SQL-执行慢的原因？"><a href="#33-丨如何使用性能分析工具定位-SQL-执行慢的原因？" class="headerlink" title="33 丨如何使用性能分析工具定位 SQL 执行慢的原因？"></a>33 丨如何使用性能分析工具定位 SQL 执行慢的原因？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720093823.png"></p>
<h2 id="34-丨答疑篇：关于索引以及缓冲池的一些解惑"><a href="#34-丨答疑篇：关于索引以及缓冲池的一些解惑" class="headerlink" title="34 丨答疑篇：关于索引以及缓冲池的一些解惑"></a>34 丨答疑篇：关于索引以及缓冲池的一些解惑</h2><h2 id="35-丨数据库主从同步的作用是什么，如何解决数据不一致问题？"><a href="#35-丨数据库主从同步的作用是什么，如何解决数据不一致问题？" class="headerlink" title="35 丨数据库主从同步的作用是什么，如何解决数据不一致问题？"></a>35 丨数据库主从同步的作用是什么，如何解决数据不一致问题？</h2><p>Mysql 支持两种复制：基于行的复制和基于语句的复制。</p>
<p>这两种方式都是在主库上记录二进制日志，然后在从库重放日志的方式来实现异步的数据复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。</p>
<p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave.png" />
</div>

<p>如何解决主从同步时的数据一致性问题？</p>
<p><strong>异步复制</strong></p>
<p>异步模式就是客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而 Binlog 还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p>
<p><strong>半异步复制</strong></p>
<p>原理是在客户端提交 COMMIT 之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了 Binlog，并且写入到中继日志中，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。——其实是一种两阶段提交的思想。</p>
<p><strong>组复制</strong></p>
<p>这种复制技术是基于 Paxos 的状态机复制。</p>
<p>将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于（N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接 COMMIT 即可。</p>
<p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<h2 id="36-丨数据库没有备份，没有使用-Binlog-的情况下，如何恢复数据？"><a href="#36-丨数据库没有备份，没有使用-Binlog-的情况下，如何恢复数据？" class="headerlink" title="36 丨数据库没有备份，没有使用 Binlog 的情况下，如何恢复数据？"></a>36 丨数据库没有备份，没有使用 Binlog 的情况下，如何恢复数据？</h2><h2 id="37-丨-SQL-注入：你的-SQL-是如何被注入的？"><a href="#37-丨-SQL-注入：你的-SQL-是如何被注入的？" class="headerlink" title="37 丨 SQL 注入：你的 SQL 是如何被注入的？"></a>37 丨 SQL 注入：你的 SQL 是如何被注入的？</h2><p><strong>SQL 注入攻击（SQL injection）</strong>，是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p>
<p>攻击示例：</p>
<p>考虑以下简单的登录表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们的处理里面的 SQL 可能是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username:<span class="operator">=</span>r.Form.Get(&quot;username&quot;)</span><br><span class="line">password:<span class="operator">=</span>r.Form.Get(&quot;password&quot;)</span><br><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM user WHERE username=&#x27;&quot;<span class="operator">+</span>username<span class="operator">+</span>&quot;&#x27; AND password=&#x27;&quot;<span class="operator">+</span>password<span class="operator">+</span>&quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>如果用户的输入的用户名如下，密码任意</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myuser<span class="string">&#x27; or &#x27;</span>foo<span class="string">&#x27; = &#x27;</span>foo<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure>

<p>那么我们的 SQL 变成了如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;foo&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;foo&#x27;</span> <span class="comment">--&#x27;&#x27; AND password=&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 SQL 里面 <code>--</code> 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p>
<p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%&quot;<span class="operator">+</span>prod<span class="operator">+</span>&quot;%&#x27;&quot;</span><br><span class="line">Db.Exec(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure>

<p>如果攻击提交 <code>a%&#39; exec master..xp_cmdshell &#39;net user test testpass /ADD&#39; --</code> 作为变量 prod 的值，那么 sql 将会变成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>:<span class="operator">=</span>&quot;SELECT * FROM products WHERE name LIKE &#x27;%a%&#x27; exec master..xp_cmdshell &#x27;net user test testpass /ADD&#x27;--%&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p>
<p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p>
<blockquote>
<p>攻击手段和目的</p>
</blockquote>
<ul>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如 <code>SELECT * FROM sys.tables</code>）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如 <code>ALTER LOGIN sa WITH PASSWORD=&#39;xxxxxx&#39;</code>）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin”可停止服务器的 IIS 服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。</li>
</ul>
<blockquote>
<p>应对手段</p>
</blockquote>
<ul>
<li><strong>使用参数化查询</strong> - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database&#x2F;sql 里面的查询函数 <code>Prepare</code> 和 <code>Query</code> ，或者 <code>Exec(query string, args ...interface&#123;&#125;)</code>。</li>
<li><strong>单引号转换</strong> - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。</li>
</ul>
<h2 id="38-丨如何在-Excel-中使用-SQL-语言？"><a href="#38-丨如何在-Excel-中使用-SQL-语言？" class="headerlink" title="38 丨如何在 Excel 中使用 SQL 语言？"></a>38 丨如何在 Excel 中使用 SQL 语言？</h2><h2 id="39-丨-WebSQL：如何在-H5-中存储一个本地数据库？"><a href="#39-丨-WebSQL：如何在-H5-中存储一个本地数据库？" class="headerlink" title="39 丨 WebSQL：如何在 H5 中存储一个本地数据库？"></a>39 丨 WebSQL：如何在 H5 中存储一个本地数据库？</h2><h2 id="40-丨-SQLite：为什么微信用-SQLite-存储聊天记录？"><a href="#40-丨-SQLite：为什么微信用-SQLite-存储聊天记录？" class="headerlink" title="40 丨 SQLite：为什么微信用 SQLite 存储聊天记录？"></a>40 丨 SQLite：为什么微信用 SQLite 存储聊天记录？</h2><h2 id="41-丨初识-Redis：Redis-为什么会这么快？"><a href="#41-丨初识-Redis：Redis-为什么会这么快？" class="headerlink" title="41 丨初识 Redis：Redis 为什么会这么快？"></a>41 丨初识 Redis：Redis 为什么会这么快？</h2><h2 id="42-丨如何使用-Redis-来实现多用户抢票问题"><a href="#42-丨如何使用-Redis-来实现多用户抢票问题" class="headerlink" title="42 丨如何使用 Redis 来实现多用户抢票问题"></a>42 丨如何使用 Redis 来实现多用户抢票问题</h2><h2 id="43-丨如何使用-Redis-搭建玩家排行榜？"><a href="#43-丨如何使用-Redis-搭建玩家排行榜？" class="headerlink" title="43 丨如何使用 Redis 搭建玩家排行榜？"></a>43 丨如何使用 Redis 搭建玩家排行榜？</h2><h2 id="44-丨-DBMS-篇总结和答疑：用-SQLite-做词云"><a href="#44-丨-DBMS-篇总结和答疑：用-SQLite-做词云" class="headerlink" title="44 丨 DBMS 篇总结和答疑：用 SQLite 做词云"></a>44 丨 DBMS 篇总结和答疑：用 SQLite 做词云</h2><h2 id="45-丨数据清洗：如何使用-SQL-对数据进行清洗？"><a href="#45-丨数据清洗：如何使用-SQL-对数据进行清洗？" class="headerlink" title="45 丨数据清洗：如何使用 SQL 对数据进行清洗？"></a>45 丨数据清洗：如何使用 SQL 对数据进行清洗？</h2><p>SQL 可以帮我们进行数据处理，总的来说可以分成 OLTP 和 OLAP 两种方式。</p>
<ul>
<li><strong>OLTP</strong>：称之为<strong>联机事务处理</strong>。对数据进行增删改查，SQL 查询优化，事务处理等就属于 OLTP 的范畴。它对实时性要求高，需要将用户的数据有效地存储到数据库中，同时有时候针对互联网应用的需求，我们还需要设置数据库的主从架构保证数据库的高并发和高可用性。</li>
<li><strong>OLAP</strong>：称之为<strong>联机分析处理</strong>。它是对已经存储在数据库中的数据进行分析，帮我们得出报表，指导业务。它对数据的实时性要求不高，但数据量往往很大，存储在数据库（数据仓库）中的数据可能还存在数据质量的问题，比如数据重复、数据中有缺失值，或者单位不统一等，因此在进行数据分析之前，首要任务就是对收集的数据进行清洗，从而保证数据质量。</li>
</ul>
<h2 id="46-丨数据集成：如何对各种数据库进行集成和转换？"><a href="#46-丨数据集成：如何对各种数据库进行集成和转换？" class="headerlink" title="46 丨数据集成：如何对各种数据库进行集成和转换？"></a>46 丨数据集成：如何对各种数据库进行集成和转换？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720142031.png"></p>
<p>ETL 是英文 Extract、Transform 和 Load 的缩写，也就是将数据从不同的数据源进行抽取，然后通过交互转换，最终加载到目的地的过程。</p>
<ul>
<li>在 Extract 数据抽取这个过程中，需要做大量的工作，我们需要了解企业分散在不同地方的数据源都采用了哪种 DBMS，还需要了解这些数据源存放的数据结构等，是结构化数据，还是非结构化数据。在抽取中，我们也可以采用全量抽取和增量抽取两种方式。相比于全量抽取，增量抽取使用得更为广泛，它可以帮我们动态捕捉数据源的数据变化，并进行同步更新。</li>
<li>在 Transform 数据转换的过程中，我们可以使用一些数据转换的组件，比如说数据字段的映射、数据清洗、数据验证和数据过滤等，这些模块可以像是在流水线上进行作业一样，帮我们完成各种数据转换的需求，从而将不同质量，不同规范的数据进行统一。</li>
<li>在 Load 数据加载的过程中，我们可以将转换之后的数据加载到目的地，如果目标是 RDBMS，我们可以直接通过 SQL 进行加载，或者使用批量加载的方式进行加载。</li>
</ul>
<h2 id="47-丨如何利用-SQL-对零售数据进行分析？"><a href="#47-丨如何利用-SQL-对零售数据进行分析？" class="headerlink" title="47 丨如何利用 SQL 对零售数据进行分析？"></a>47 丨如何利用 SQL 对零售数据进行分析？</h2><p>略</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/192">SQL 必知必会</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/73fdf38a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/73fdf38a/" class="post-title-link" itemprop="url">《RocketMQ 技术内幕》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:58:58" itemprop="dateCreated datePublished" datetime="2022-07-12T16:58:58+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《RocketMQ-技术内幕》笔记"><a href="#《RocketMQ-技术内幕》笔记" class="headerlink" title="《RocketMQ 技术内幕》笔记"></a>《RocketMQ 技术内幕》笔记</h1><h2 id="读源代码前的准备"><a href="#读源代码前的准备" class="headerlink" title="读源代码前的准备"></a>读源代码前的准备</h2><h3 id="RocketMQ-源代码的目录结构"><a href="#RocketMQ-源代码的目录结构" class="headerlink" title="RocketMQ 源代码的目录结构"></a>RocketMQ 源代码的目录结构</h3><ul>
<li><code>broker</code>：broker 模块（broker 启动进程） 。</li>
<li><code>client</code>：消息客户端，包含生产者、消息消费者相关类。</li>
<li><code>common</code>：公共包。</li>
<li><code>dev</code>：开发者信息（非源代码） 。</li>
<li><code>distribution</code>：部署实例文件夹（非源代码） 。</li>
<li><code>example</code>：RocketMQ 示例代码。</li>
<li><code>filter</code>：消息过滤相关基础类。</li>
<li><code>filter</code>：消息过滤服务器实现相关类（Filter 启动进程） 。</li>
<li><code>logappender</code>：日志实现相关类。</li>
<li><code>namesrv</code>：N ameServer 实现相关类（Names 巳 rver 启动进程） 。</li>
<li><code>openmessaging</code>：消息开放标准，正在制定中。</li>
<li><code>remoting</code>：远程通信模块，基于 Netty 。</li>
<li><code>srvutil</code>：服务器工具类。</li>
<li><code>store</code>：消息存储实现相关类。</li>
<li><code>style</code>：checkstyle 相关实现。</li>
<li><code>test</code>：测试相关类。</li>
<li><code>tools</code>：工具类，监控命令相关实现类。</li>
</ul>
<h3 id="RocketMQ-的设计理念和目标"><a href="#RocketMQ-的设计理念和目标" class="headerlink" title="RocketMQ 的设计理念和目标"></a>RocketMQ 的设计理念和目标</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><p>RocketMQ 设计基于主题的订阅与发布模式， 其核心功能包括：消息发送、消息存储( Broker ）、消息消费。其整体设计追求简单与性能第一，主要体现在如下三个方面：</p>
<ul>
<li>自研 NameServer，而不是用 ZooKeeper 作为注册中心。因为 ZooKeeper 采用 CAP 模型中的 CP 模型，其实并不适用于注册中心的业务模式。</li>
<li>RocketMQ 的消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制，所有主<br>题的消息存储基于顺序写， 极大地提供了消息写性能，同时为了兼顾消息消费与消息查找，引入了消息消费队列文件与索引文件。</li>
<li>容忍存在设计缺陷，适当将某些工作下放给 RocketMQ 使用者。消息中间件的实现者经常会遇到一个难题：如何保证消息一定能被消息消费者消费，并且保证只消费一次。RocketMQ 的设计者给出的解决办法是不解决这个难题，而是退而求其次，只保证消息被消费者消费，但设计上允许消息被重复消费，这样极大地简化了消息中间件的内核，使得实现消息发送高可用变得非常简单与高效，消息重复问题由消费者在消息消费时实现幂等。</li>
</ul>
<h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><ul>
<li><strong>架构模式</strong>：RocketMQ 与大部分消息中间件一样，采用发布订阅模式，基本的参与组件主要包括：消息发送者、消息服务器（消息存储）、消息消费、路由发现。</li>
<li><strong>顺序消息</strong>：所谓顺序消息，就是消息消费者按照消息达到消息存储服务器的顺序消费。RocketMQ 可以严格保证消息有序。</li>
<li><strong>消息过滤</strong>：消息过滤是指在消息消费时，消息消费者可以对同一主题下的消息按照规则只消费自己感兴趣的消息。RocketMQ 消息过滤支持在服务端与消费端的消息过滤机制。</li>
<li>消息在 Broker 端过滤。Broker 只将消息消费者感兴趣的消息发送给消息消费者。</li>
<li>消息在消息消费端过滤，消息过滤方式完全由消息消费者自定义，但缺点是有很多无用的消息会从 Broker 传输到消费端。</li>
<li><strong>消息存储</strong>：消息中间件的一个核心实现是消息的存储，对消息存储一般有如下两个维度的考量：消息堆积能力和消息存储性能。RocketMQ 追求消息存储的高性能，引人内存映射机制，所有主题的消息顺序存储在同一个文件中。同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。</li>
<li><strong>消息高可用性</strong>：<ul>
<li>通常影响消息可靠性的有以下几种情况。<ol>
<li>Broker 正常关机。</li>
<li>Broker 异常 Crash 。</li>
<li>OS Crash 。</li>
<li>机器断电，但是能立即恢复供电情况。</li>
<li>机器无法开机（可能是 CPU 、主板、内存等关键设备损坏） 。</li>
<li>磁盘设备损坏。</li>
</ol>
</li>
<li>针对上述情况，情况 1~4 的 RocketMQ 在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息。情况 5-6 属于单点故障，一旦发生，该节点上的消息全部丢失，如果开启了异步复制机制， RoketMQ 能保证只丢失少量消息， RocketMQ 在后续版本中将引人双写机制，以满足消息可靠性要求极高的场合。</li>
</ul>
</li>
<li><strong>消息到达（ 消费）低延迟</strong>：RocketMQ 在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。</li>
<li><strong>确保消息必须被消费一次</strong>：RocketMQ 通过消息消费确认机制（ACK）来确保消息至少被消费一次，但由于 ACK 消息有可能丢失等其他原因， RocketMQ 无法做到消息只被消费一次，有重复消费的可能。</li>
<li><strong>回溯消息</strong>：回溯消息是指消息消费端已经消费成功的消息，由于业务要求需要重新消费消息。RocketMQ 支持按时间回溯消息，时间维度可精确到毫秒，可以向前或向后回溯。</li>
<li><strong>消息堆积</strong>：消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提高后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力。RocketMQ 消息存储使用磁盘文件（内存映射机制），并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。RocketMQ 消息存储文件并不是永久存储在消息服务器端，而是提供了过期机制，默认保留 3 天。</li>
<li><strong>定时消息</strong>：定时消息是指消息发送到 Broker 后， 不能被消息消费端立即消费，要到特定的时间点或者等待特定的时间后才能被消费。如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大的性能损耗，故 RocketMQ 不支持任意进度的定时消息，而只支持特定延迟级别。</li>
<li><strong>消息重试机制</strong>：消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ 支持消息重试机制。</li>
</ul>
<h2 id="RocketMQ-路由中心-NameServer"><a href="#RocketMQ-路由中心-NameServer" class="headerlink" title="RocketMQ 路由中心 NameServer"></a>RocketMQ 路由中心 NameServer</h2><h3 id="NameServer-架构设计"><a href="#NameServer-架构设计" class="headerlink" title="NameServer 架构设计"></a>NameServer 架构设计</h3><p>Broker 消息服务器在启动时向所有 NameServer 注册，生产者（Producer）在发送消息之前先从 NameServer 获取 Broker 服务器地址列表，然后根据负载算法从列表中选择一台消息服务器进行消息发送。NameServer 与每台 Broker 服务器保持长连接，并间隔 30s 检测 Broker 是否存活，如果检测到 Broker 宕机， 则从路由注册表中将其移除。但是路由变化不会马上通知生产者，为什么要这样设计呢？这是为了降低 NameServer 实现的复杂性，在消息发送端提供容错机制来保证消息发送的高可用性。</p>
<p>NameServer 本身的高可用可通过部署多台 NameServer 服务器来实现，但彼此之间互不通信，也就是说 NameServer 服务器之间在某一时刻的数据并不会完全相同，但这对消息发送不会造成任何影响。</p>
<h3 id="NameServer-启动流程"><a href="#NameServer-启动流程" class="headerlink" title="NameServer 启动流程"></a>NameServer 启动流程</h3><ol>
<li>加载配置，然后根据配置初始化 <code>NamesrvController</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException &#123;</span><br><span class="line">    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">    <span class="comment">//PackageConflictDetect.detectFastjson();</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> <span class="title class_">Options</span>());</span><br><span class="line">    commandLine = ServerUtil.parseCmdLine(<span class="string">&quot;mqnamesrv&quot;</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> <span class="title class_">PosixParser</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == commandLine) &#123;</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化 NamesrvConfig 配置和 NettyServerConfig 配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">    nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 加载配置文件中的配置</span></span><br><span class="line">    <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">            MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">            namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 加载启动命令中的配置</span></span><br><span class="line">    <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;p&#x27;</span>)) &#123;</span><br><span class="line">        <span class="type">InternalLogger</span> <span class="variable">console</span> <span class="operator">=</span> InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">        MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">        MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 强制必须设置环境变量 ROCKETMQ_HOME</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == namesrvConfig.getRocketmqHome()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;</span>, MixAll.ROCKETMQ_HOME_ENV);</span><br><span class="line">        System.exit(-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 打印配置项</span></span><br><span class="line">    <span class="type">LoggerContext</span> <span class="variable">lc</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">    <span class="type">JoranConfigurator</span> <span class="variable">configurator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoranConfigurator</span>();</span><br><span class="line">    configurator.setContext(lc);</span><br><span class="line">    lc.reset();</span><br><span class="line">    configurator.doConfigure(namesrvConfig.getRocketmqHome() + <span class="string">&quot;/conf/logback_namesrv.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    MixAll.printObjectProperties(log, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(log, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">    controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据启动属性创建 NamesrvController 实例，并初始化该实例， NameServerController 实例为 NameServer 核心控制器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载KV 配置</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 NettyRemotingServer 网络处理对象</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册进程</span></span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启两个定时任务（心跳检测）</span></span><br><span class="line">    <span class="comment">// 任务一：NameServer 每隔 1O 秒扫描一次 Broker，移除不活跃的 Broker</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 任务二：NameServer 每隔 1O 分钟打印一次 KV 配置</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 TLS 模式，加载证书，开启安全模式</span></span><br><span class="line">    <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">        <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWatchService = <span class="keyword">new</span> <span class="title class_">FileWatchService</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">                    TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">                    TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileWatchService</span>.Listener() &#123;</span><br><span class="line">                    <span class="type">boolean</span> certChanged, keyChanged = <span class="literal">false</span>;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(String path)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;The trust certificate changed, reload the ssl context&quot;</span>);</span><br><span class="line">                            reloadServerSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">                            certChanged = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">                            keyChanged = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;The certificate and private key changed, reload the ssl context&quot;</span>);</span><br><span class="line">                            certChanged = keyChanged = <span class="literal">false</span>;</span><br><span class="line">                            reloadServerSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reloadServerSslContext</span><span class="params">()</span> &#123;</span><br><span class="line">                        ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;FileWatchService created error, can&#x27;t load the certificate dynamically&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册 JVM 钩子函数并启动服务器，以便监昕 Broker 、生产者的网络请求。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 JVM 钩子函数并启动服务器，以便监昕Broker、 生产者的网络请求</span></span><br><span class="line"><span class="comment">// 如果代码中使用了线程池，一种优雅停机的方式就是注册一个 JVM 钩子函数，在 JVM 进程关闭之前，先将线程池关闭，及时释放资源</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHookThread</span>(log, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="NameServer-路由注册、故障剔除"><a href="#NameServer-路由注册、故障剔除" class="headerlink" title="NameServer 路由注册、故障剔除"></a>NameServer 路由注册、故障剔除</h3><p>NameServer 主要作用是为生产者和消息消费者提供关于主题 Topic 的路由信息，那么 NameServer 需要存储路由的基础信息，还要能够管理 Broker 节点，包括路由注册、路由删除等功能。</p>
<h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p>NameServer 路由实现类：org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager。它主要存储了以下信息：</p>
<ul>
<li><code>topicQueueTable</code>：Topic 消息队列路由信息，消息发送时根据路由表进行负载均衡。</li>
<li><code>brokerAddrTable</code>：Broker 基础信息， 包含 brokerName 、所属集群名称、主备 Broker 地址。</li>
<li><code>clusterAddrTable</code>：Broker 集群信息，存储集群中所有 Broker 名称。</li>
<li><code>brokerLiveTable</code>：Broker 状态信息。NameServer 每次收到心跳包时会替换该信息。</li>
<li><code>filterServerTable</code>：Broker 上的 FilterServer 列表，用于类模式消息过滤。</li>
</ul>
<p>RocketMQ 基于订阅发布机制，一个 Topic 拥有多个消息队列，一个 Broker 为每一主题默认创建 4 个读队列 4 个写队列。多个 Broker 组成一个集群，BrokerName 由相同的多台 Broker 组成 Master-Slave 架构， brokerId 为 0 代表 Master，大于 0 表示 Slave。BrokerLiveInfo 中的 lastUpdateTimestamp 存储上次收到 Broker 心跳包的时间。</p>
<h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>RocketMQ 路由注册是通过 Broker 与 NameServer 的心跳功能实现的。Broker 启动时向集群中所有的 NameServer 发送心跳语句，每隔 30s 向集群中所有 NameServer 发送心跳包， NameServer 收到 Broker 心跳包时会更新 brokerLiveTable 缓存中 BrokerLiveInfo 的 lastUpdateTimestamp ，然后 NameServer 每隔 10s 扫描 brokerLiveTable ，如果连续 120s 没有收到心跳包， NameServer 将移除该 Broker 的路由信息同时关闭 Socket 连接。</p>
<p>（1）Broker 发送心跳包</p>
<p>Broker 会遍历 NameServer 列表， 依次向所有 NameServer 发送心跳包。</p>
<p>（2）NameServer 处理心跳包</p>
<ul>
<li>路由注册需要加写锁，防止并发修改 RouteInfoManager 中的路由表。</li>
<li>判断 Broker 所属集群是否存在，如果不存在，则创建，然后将 broker 加入到 Broker 集群。</li>
<li>维护 BrokerData 信息，首先从 brokerAddrTable 根据 BrokerName 尝试获取 Broker 信息。<ul>
<li>如果不存在，则新建 BrokerData 并放入到 brokerAddrTable, registerFirst 设置为 true；</li>
<li>如果存在，直接将 registerFirst 设置为 false，表示非第一次注册。</li>
</ul>
</li>
<li>如果 Broker 为 Master，并且 Broker Topic 配置信息发生变化或者是初次注册，则需要创建或更新 Topic 路由元数据。填充 topicQueueTable，其实就是为默认主题自动注册路由信息，其中包含 MixAII.DEFAULT_TOPIC 的路由信息。当生产者发送主题时，如果该主题未创建并且 BrokerConfig 的 autoCreateTopicEnable 为 true 时，将返回 MixAII.DEFAULT_TOPIC 的路由信息。</li>
<li>更新 BrokerLiveInfo，存活 Broker 信息表，BrokeLiveInfo 是执行路由删除的重要依据。</li>
<li>注册 Broker 的过滤器 Server 地址列表，一个 Broker 上会关联多个 FilterServer 消息过滤服务器；如果此 Broker 为从节点，则需要查找该 Broker 的 Master 的节点信息，并更新对应的 masterAddr 属性。</li>
</ul>
<p>设计亮点： NameServe 与 Broker 保持长连接， Broker 状态存储在 brokerLiveTable 中，NameServer 每收到一个心跳包，将更新 brokerLiveTable 中关于 Broker 的状态信息以及路由表（topicQueueTable 、brokerAddrTable 、brokerLiveTable 、filterServerTable） 。更新上述路由表（HashTable）使用了锁粒度较少的读写锁，允许多个消息发送者（Producer ）并发读，保证消息发送时的高并发。但同一时刻 NameServer 只处理一个 Broker 心跳包，多个心跳包请求串行执行。</p>
<h4 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h4><p>Broker 每隔 30s 向 NameServe 发送一个心跳包，心跳包中包含 BrokerId 、Broker 地址、Broker 名称、Broker 所属集群名称、Broker 关联的 FilterServer 列表。但是如果 Broker 宕机，NameServer 无法收到心跳包，此时 NameServer 如何来剔除这些失效的 Broker 呢？ NameServer 会每隔 10s 扫描 brokerLiveTable 状态表，如果 BrokerLive 的 lastUpdateTimestamp 的时间戳距当前时间超过 120s ，则认为 Broker 失效，移除该 Broker，关闭与 Broker 连接，并同时更新 topicQueueTable 、brokerAddrTable 、brokerLiveTable 、filterServerTable 。</p>
<p>RocktMQ 有两个触发点来触发路由删除。</p>
<ul>
<li><p>NameServer 定时扫描 brokerLiveTable 检测上次心跳包与当前系统时间的时间差，如果时间戳大于 120s ，则需要移除该 Broker 信息。</p>
</li>
<li><p>Broker 在正常被关闭的情况下，会执行 unregisterBroker 指令。</p>
</li>
</ul>
<p>由于不管是何种方式触发的路由删除，路由删除的方法都是一样的，就是从 topicQueueTable 、rokerAddrTable 、brokerLiveTable 、filterServerTable 删除与该 Broker 相关的信息，但 RocketMQ 这两种方式维护路由信息时会抽取公共代码。</p>
<p>scanNotActiveBroker 在 NameServer 中每 10s 执行一次。逻辑很简单：遍历 brokerLiveInfo 路由表（HashMap），检测 BrokerLiveInfo 的 lastUpdateTimestamp。上次收到心跳包的时间如果超过当前时间 120s，NameServer 则认为该 Broker 已不可用，故需要将它移除，关闭 Channel，然后删除与该 Broker 相关的路由信息，路由表维护过程，需要申请写锁。</p>
<p>（1）申请写锁，根据 brokerAddress 从 brokerLiveTable 、filterServerTable 移除</p>
<p>（2）维护 brokerAddrTable 。遍历从 <code>HashMap&lt;String /* brokerName */, BrokerData&gt; brokerAddrTable</code>，从 BrokerData 的 <code>HashMap&lt;Long /* brokerId */, String /* broker address */&gt; brokerAddrs</code> 中，找到具体的 Broker ，从 BrokerData 中移除，如果移除后在 BrokerData 中不再包含其他 Broker，则在 brokerAddrTable 中移除该 brokerName 对应的条目。</p>
<p>（3）根据 brokerName，从 clusterAddrTable 中找到 Broker 并从集群中移除。如果移除后，集群中不包含任何 Broker，则将该集群从 clusterAddrTable 中移除。</p>
<p>（4）根据 brokerName，遍历所有主题的队列，如果队列中包含了当前 Broker 的队列， 则移除，如果 topic 只包含待移除 Broker 的队列的话，从路由表中删除该 topic。</p>
<h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ 路由发现是非实时的，当 Topic 路由出现变化后，NameServer 不主动推送给客户端，而是由客户端定时拉取主题最新的路由。根据主题名称拉取路由信息的命令编码为：GET_ROUTEINTO_BY_TOPIC 。</p>
<p>orderTopicConf ：顺序消息配置内容，来自于 kvConfig 。</p>
<p><code>List&lt;QueueData&gt; queueData</code>：topic 队列元数据。</p>
<p><code>List&lt;BrokerData&gt; brokerDatas</code>：topic 分布的 broker 元数据。</p>
<p><code>HashMap&lt;String/*brokerAdress*/,List&lt;String&gt; /*filterServer*/&gt;</code> ：broker 上过滤服务器地址列表。</p>
<p>NameServer 路由发现实现方法：<code>DefaultRequestProcessor#getRouteInfoByTopic</code></p>
<ol>
<li><p>调用 RouterlnfoManager 的方法，从路由表 topicQueueTable 、brokerAddrTable 、filterServerTable 中分别填充 TopicRouteData 中的 <code>List&lt;QueueData&gt;</code>、<code>List&lt;BrokerData&gt;</code> 和 filterServer 地址表。</p>
</li>
<li><p>如果找到主题对应的路由信息并且该主题为顺序消息，则从 NameServer KVconfig 中获取关于顺序消息相关的配置填充路由信息。</p>
</li>
</ol>
<p>如果找不到路由信息 CODE 则使用 TOPIC NOT_EXISTS ，表示没有找到对应的路由。</p>
<h2 id="RocketMQ-消息发送"><a href="#RocketMQ-消息发送" class="headerlink" title="RocketMQ 消息发送"></a>RocketMQ 消息发送</h2><h3 id="漫谈-RocketMQ-消息发送"><a href="#漫谈-RocketMQ-消息发送" class="headerlink" title="漫谈 RocketMQ 消息发送"></a>漫谈 RocketMQ 消息发送</h3><p>RocketMQ 支持 3 种消息发送方式：同步（sync） 、异步（async）、单向（oneway） 。</p>
<ul>
<li><strong>同步</strong>：发送者向 MQ 执行发送消息 API 时，同步等待， 直到消息服务器返回发送结果。</li>
<li><strong>异步</strong>：发送者向 MQ 执行发送消息 API 时，指定消息发送成功后的回掉函数，然后调用消息发送 API 后，立即返回，消息发送者线程不阻塞，直到运行结束，消息发送成功或失败的回调任务在一个新的线程中执行。</li>
<li><strong>单向</strong>：消息发送者向 MQ 执行发送消息 API 时，直接返回，不等待消息服务器的结果，也不注册回调函数，简单地说，就是只管发，不在乎消息是否成功存储在消息服务器上。</li>
</ul>
<p>RocketMQ 消息发送需要考虑以下几个问题。</p>
<ul>
<li>消息队列如何进行负载？</li>
<li>消息发送如何实现高可用？</li>
<li>批量消息发送如何实现一致性？</li>
</ul>
<h3 id="认识-RocketMQ-消息"><a href="#认识-RocketMQ-消息" class="headerlink" title="认识 RocketMQ 消息"></a>认识 RocketMQ 消息</h3><p>RocketMQ 消息的封装类是 <code>org.apache.rocketmq.common.message.Message</code>。其主要属性有：</p>
<ul>
<li><code>topic</code>：主题</li>
<li><code>properties</code>：属性容器。RocketMQ 会向其中添加一些扩展属性：<ul>
<li><code>tags</code>：消息标签，用于消息过滤。</li>
<li><code>keys</code>：消息索引，多个用空格隔开，RocketMQ 可以根据这些 key 快速检索到消息。</li>
<li><code>waitStoreMsgOK</code>：消息发送时是否等消息存储完成后再返回。</li>
<li><code>delayTimeLevel</code>：消息延迟级别，用于定时消息或消息重试。</li>
</ul>
</li>
<li><code>body</code>：消息体</li>
<li><code>transactionId</code>：事务 ID</li>
</ul>
<h3 id="生产者启动流程"><a href="#生产者启动流程" class="headerlink" title="生产者启动流程"></a>生产者启动流程</h3><p><code>DefaultMQProducer</code> 是默认的生产者实现类。它实现了 <code>MQAdmin</code> 的接口。</p>
<h4 id="初识-DefaultMQProducer-消息发送者"><a href="#初识-DefaultMQProducer-消息发送者" class="headerlink" title="初识 DefaultMQProducer 消息发送者"></a>初识 <code>DefaultMQProducer</code> 消息发送者</h4><h5 id="DefaultMQProducer-的主要方法"><a href="#DefaultMQProducer-的主要方法" class="headerlink" title="DefaultMQProducer 的主要方法"></a><code>DefaultMQProducer</code> 的主要方法</h5><ul>
<li><code>void createTopic(String key, String newTopic, int queueNum, int topicSysFlag)</code>：创建主题<ul>
<li><code>key</code>：目前未实际作用，可以与 newTopic 相同。</li>
<li><code>newTopic</code>：主题名称。</li>
<li><code>queueNum</code>：队列数量。</li>
<li><code>topicSysFlag</code>：主题系统标签，默认为 0 。</li>
</ul>
</li>
<li><code>long searchOffset(final MessageQueue mq, final long timestamp)</code>：根据时间戳从队列中查找其偏移量。</li>
<li><code>long maxOffset(final MessageQueue mq)</code>：查找该消息队列中最大的物理偏移量。</li>
<li><code>long minOffset(final MessageQueue mq)</code>：查找该消息队列中最小物理偏移量。</li>
<li><code>MessageExt viewMessage(final String offsetMsgld)</code>：根据消息偏移量查找消息。</li>
<li><code>QueryResult queryMessage(final String topic, final String key, final int maxNum, final long begin, final long end)</code>：根据条件查询消息。<ul>
<li><code>topic</code>：消息主题。</li>
<li><code>key</code>：消息索引字段。</li>
<li><code>maxNum</code>：本次最多取出消息条数。</li>
<li><code>begin</code>：开始时间。</li>
<li><code>end</code>：结束时间。</li>
</ul>
</li>
<li><code>MessageExt viewMessage(String topic,String msgld)</code>：根据主题与消息 ID 查找消息。</li>
<li><code>List&lt;MessageQueue&gt; fetchPublishMessageQueues(final String topic)</code>：查找该主题下所有的消息队列。</li>
<li><code>SendResult send(final Message msg)</code>：同步发送消息，具体发送到主题中的哪个消息队列由负载算法决定。</li>
<li><code>SendResult send(final Message msg, final long timeout)</code>：同步发送消息，如果发送超过 timeout 则抛出超时异常。</li>
<li><code>void send(final Message msg, final SendCallback sendCallback)</code>：异步发送消息， sendCallback 参数是消息发送成功后的回调方法。</li>
<li><code>void send(final Message msg, final SendCallback sendCallback, final long timeout)</code>：异步发送消息，如果发送超过 timeout 指定的值，则抛出超时异常。</li>
<li><code>void sendOneway(final Message msg)</code>：单向消息发送，就是不在乎发送结果，消息发送出去后该方法立即返回。</li>
<li><code>SendResult send(final Message msg, final MessageQueue mq)</code>：同步方式发送消息，发送到指定消息队列。</li>
<li><code>void send(final Message msg, final MessageQueue mq, final SendCallback sendCallback)</code>：异步方式发送消息，发送到指定消息队列。</li>
<li><code>void sendOneway(final Message msg, final MessageQueue mq)</code>：单向方式发送消息，发送到指定的消息队列。</li>
<li><code>SendResult send(final Message msg , final MessageQueueSelector selector, final Object arg)</code>：消息发送，指定消息选择算法，覆盖生产者默认的消息队列负载。</li>
<li><code>SendResult send(final Collection&lt;Message&gt; msgs, final MessageQueue mq, final long timeout)</code>：同步批量消息发送。</li>
</ul>
<h5 id="DefaultMQProducer-的核心属性"><a href="#DefaultMQProducer-的核心属性" class="headerlink" title="DefaultMQProducer 的核心属性"></a><code>DefaultMQProducer</code> 的核心属性</h5><ul>
<li><code>producerGroup</code>：生产者所属组，消息服务器在回查事务状态时会随机选择该组中任何一个生产者发起事务回查请求。</li>
<li><code>createTopicKey</code>：默认 topicKey 。</li>
<li><code>defaultTopicQueueNums</code>：默认主题在每一个 Broker 队列数量。</li>
<li><code>sendMsgTimeout</code>：发送消息默认超时时间， 默认 3s 。</li>
<li><code>compressMsgBodyOverHowmuch</code>：消息体超过该值则启用压缩，默认 4K。</li>
<li><code>retryTimesWhenSendFailed</code>：同步方式发送消息重试次数，默认为 2 ，总共执行 3 次。</li>
<li><code>retryTimesWhenSendAsyncFailed</code>：异步方式发送消息重试次数，默认为 2 。</li>
<li><code>retryAnotherBrokerWhenNotStoreOK</code>：消息重试时选择另外一个 Broker ，是否不等待存储结果就返回， 默认为 false 。</li>
<li><code>maxMessageSize</code>：允许发送的最大消息长度，默认为 4M ，眩值最大值为 2^32-1 。</li>
</ul>
<h4 id="生产者启动流程-1"><a href="#生产者启动流程-1" class="headerlink" title="生产者启动流程"></a>生产者启动流程</h4><p><code>DefaultMQProducerImpl#start()</code> 是生产者的启动方法，其主要工作流程如下：</p>
<ol>
<li>检查生产者组（<code>productGroup</code>）是否符合要求；并改变生产者的 <code>instanceName</code> 为进程 ID 。</li>
<li>获取或创建 <code>MQClientInstance</code> 实例。<ul>
<li>整个 JVM 实例中只存在一个 <code>MQClientManager</code> 实例（单例）。</li>
<li><code>MQClientManager</code> 中维护一个 <code>ConcurrentMap</code> 类型的缓存，用于保证同一个 <code>clientId</code> 只会创建一个 <code>MQClientInstance</code>。</li>
</ul>
</li>
<li>将当前生产者注册到 <code>MQClientInstance</code> 中，方便后续调用网络请求、进行心跳检测等。</li>
<li>启动 <code>MQClientInstance</code> ，如果 <code>MQClientInstance</code> 已经启动，则本次启动不会真正执行。</li>
<li>向所有 Broker 发送心跳。</li>
<li>启动一个定时任务，用于定期清理过时的发送请求。</li>
</ol>
<h3 id="消息发送基本流程"><a href="#消息发送基本流程" class="headerlink" title="消息发送基本流程"></a>消息发送基本流程</h3><p>消息发送的核心方法是 <code>DefaultMQProducerImpl#sendDefaultImpl</code>。</p>
<h4 id="消息长度验证"><a href="#消息长度验证" class="headerlink" title="消息长度验证"></a>消息长度验证</h4><p>消息发送之前，首先确保生产者处于运行状态，然后验证消息是否符合相应的规范，具体的规范要求是主题名称、消息体不能为空、消息长度不能等于 0 且默认不能超过允许发送消息的最大长度 4M（<code>maxMessageSize=l024 * 1024 * 4</code>） 。</p>
<h4 id="查找主题路由信息"><a href="#查找主题路由信息" class="headerlink" title="查找主题路由信息"></a>查找主题路由信息</h4><p>消息发送之前，首先需要获取主题的路由信息，只有获取了这些信息我们才知道消息要发送到具体的 Broker 节点。</p>
<p>tryToFindTopicPublishInfo 是查找主题的路由信息的方法。</p>
<p>如果生产者中缓存了 topic 的路由信息，或路由信息中包含了消息队列，则直接返回该路由信息。</p>
<p>如果没有缓存或没有包含消息队列， 则向 NameServer 查询该 topic 的路由信息。</p>
<p>如果最终未找到路由信息，则抛出异常：无法找到主题相关路由信息异常。</p>
<p><code>TopicPublishinfo</code> 的属性：</p>
<ul>
<li><code>orderTopic</code>：是否为顺序消息。</li>
<li><code>haveTopicRouterInfo</code>：是否有主题路由信息。</li>
<li><code>List&lt;MessageQueue&gt; messageQueueList</code>：Topic 的消息队列。</li>
<li><code>sendWhichQueue</code>：用于选择消息队列。每选择一次消息队列， 该值会自增 1。</li>
<li><code>topicRouteData</code>：主题路由数据。</li>
</ul>
<p><code>MQClientlnstance#updateTopicRouteInfoFromNameServer</code> 这个方法的功能是生产者更新和维护路由缓存。</p>
<ol>
<li>如果 <code>isDefault</code> 为 true，则使用默认主题去查询，如果查询到路由信息，则替换路由信息中读写队列个数为生产者默认的队列个数（<code>defaultTopicQueueNums</code>）；如果 <code>isDefault</code> 为 false，则使用参数 topic 去查询；如果未查询到路由信息，则返回 false ，表示路由信息未变化。</li>
<li>如果路由信息找到，与本地缓存中的路由信息进行对比，判断路由信息是否发生了改变，如果未发生变化，则直接返回 false 。</li>
<li>更新 <code>MQClientInstance</code> 的 Broker 地址缓存表。</li>
<li>根据 <code>topicRouteData</code> 中的 <code>List&lt;QueueData&gt;</code> 转换成 <code>topicPublishInfo</code> 的 <code>List&lt;MessageQueue&gt;</code> 列表。其具体实现在 <code>topicRouteData2TopicPublishInfo</code> 中， 然后会更新该 <code>MQClientInstance</code> 所管辖的所有消息，发送关于 topic 的路由信息。</li>
<li>循环遍历路由信息的 QueueData 信息，如果队列没有写权限，则继续遍历下一个 QueueData；根据 brokerName 找到 brokerData 信息，找不到或没有找到 Master 节点，则遍历下一个 QueueData；根据写队列个数，根据 topic ＋序号 创建 <code>MessageQueue</code> ，填充 <code>TopicPublishInfo</code> 的 <code>List&lt;QueueMessage&gt;</code>。</li>
</ol>
<h4 id="选择-Broker"><a href="#选择-Broker" class="headerlink" title="选择 Broker"></a>选择 Broker</h4><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h2 id="RocketMQ-消息存储"><a href="#RocketMQ-消息存储" class="headerlink" title="RocketMQ 消息存储"></a>RocketMQ 消息存储</h2><h2 id="RocketMQ-消息消费"><a href="#RocketMQ-消息消费" class="headerlink" title="RocketMQ 消息消费"></a>RocketMQ 消息消费</h2><h2 id="消息过滤-FilterServer"><a href="#消息过滤-FilterServer" class="headerlink" title="消息过滤 FilterServer"></a>消息过滤 FilterServer</h2><h2 id="RocketMQ-主从同步"><a href="#RocketMQ-主从同步" class="headerlink" title="RocketMQ 主从同步"></a>RocketMQ 主从同步</h2><h2 id="RocketMQ-事务消息"><a href="#RocketMQ-事务消息" class="headerlink" title="RocketMQ 事务消息"></a>RocketMQ 事务消息</h2><h2 id="RocketMQ-实战"><a href="#RocketMQ-实战" class="headerlink" title="RocketMQ 实战"></a>RocketMQ 实战</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35626441/">RocketMQ 技术内幕</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/620a8623/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/620a8623/" class="post-title-link" itemprop="url">《极客时间教程 - 软件工程之美》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 13:20:31" itemprop="dateCreated datePublished" datetime="2022-07-12T13:20:31+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《极客时间教程-软件工程之美》笔记"><a href="#《极客时间教程-软件工程之美》笔记" class="headerlink" title="《极客时间教程 - 软件工程之美》笔记"></a>《极客时间教程 - 软件工程之美》笔记</h1><h2 id="到底应该怎样理解软件工程？"><a href="#到底应该怎样理解软件工程？" class="headerlink" title="到底应该怎样理解软件工程？"></a>到底应该怎样理解软件工程？</h2><p><strong>软件产品危机</strong>：软件产品质量低劣、软件维护工作量大、成本不断上升、进度不可控、程序人员无限度地增加。</p>
<p>软件工程，它是为研究和克服软件危机而生。</p>
<p><strong>软件工程的本质</strong>：用工程化方法去规范软件开发，让项目可以按时完成、成本可控、质量有保证。</p>
<p><strong>软件工程的核心</strong>：是围绕软件项目开发，对开发过程的组织，对方法的运用，对工具的使用。</p>
<p><strong>软件工程 &#x3D; 过程 + 方法 + 工具。</strong></p>
<h2 id="工程思维：把每件事都当作一个项目来推进"><a href="#工程思维：把每件事都当作一个项目来推进" class="headerlink" title="工程思维：把每件事都当作一个项目来推进"></a>工程思维：把每件事都当作一个项目来推进</h2><p><strong>有目的、有计划、有步骤地解决问题的方法就是工程方法。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712132650.png"></p>
<p>工程方法通常会分成六个阶段：想法、概念、计划、设计、开发和发布。</p>
<ul>
<li><strong>想法：</strong>想法阶段通常是想要解决问题。最开始问题通常是模糊的，所以需要清晰地定义好问题，研究其可行性，检查是否有可行的解决方案。</li>
<li><strong>概念：</strong>概念阶段就是用图纸、草图、模型等方式，提出一些概念性的解决方案。这些方案可能有多个，最终会确定一个解决方案。</li>
<li><strong>计划：</strong>计划阶段是关于如何实施的计划，通常会包含人员、任务、任务持续时间、任务的依赖关系，以及完成项目所需要的预算。</li>
<li><strong>设计：</strong>设计阶段就是要针对产品需求，将解决方案进一步细化，设计整体架构和划分功能模块，作为分工合作和开发实施的一个依据和参考。</li>
<li><strong>开发：</strong>开发阶段就是根据设计方案，将解决方案构建实施。开发阶段通常是一个迭代的过程，这个阶段通常会有构建、测试、调试和重新设计的迭代。</li>
<li><strong>发布：</strong>将最终结果包括文档发布。</li>
</ul>
<h2 id="瀑布模型：像工厂流水线一样把软件开发分层化"><a href="#瀑布模型：像工厂流水线一样把软件开发分层化" class="headerlink" title="瀑布模型：像工厂流水线一样把软件开发分层化"></a>瀑布模型：像工厂流水线一样把软件开发分层化</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712133102.png"></p>
<p>瀑布模型把整个项目过程分成了六个主要阶段：</p>
<ul>
<li><strong>问题的定义及规划</strong>：这个阶段是需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</li>
<li><strong>需求分析</strong>：对需求方提出的所有需求，进行详细的分析。这个阶段一般需要和客户反复确认，以保证能充分理解客户需求。最终会形成需求分析文档。</li>
<li><strong>软件设计</strong>：根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最后会形成架构设计文档。</li>
<li><strong>程序编码</strong>：将架构设计和界面设计的结果转换成计算机能运行的程序代码。</li>
<li><strong>软件测试</strong>：在编码完成后，对可运行的结果对照需求分析文档进行严密的测试。如果测试发现问题，需要修复。最终测试完成后，形成测试报告。</li>
<li><strong>运行维护</strong>：在软件开发完成，正式运行投入使用。后续需要继续维护，修复错误和增加功能。交付时需要提供使用说明文档。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712133357.png"></p>
<h2 id="瀑布模型之外，还有哪些开发模型？"><a href="#瀑布模型之外，还有哪些开发模型？" class="headerlink" title="瀑布模型之外，还有哪些开发模型？"></a>瀑布模型之外，还有哪些开发模型？</h2><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p><strong>快速原型模型，就是为了要解决客户的需求不明确和需求多变的问题。</strong></p>
<p>先迅速建造一个可以运行的软件原型，然后收集用户反馈，再反复修改确认，使开发出的软件能真正反映用户需求，这种开发模型就叫快速原型模型，也叫原型模型。</p>
<p>原型模型因为能快速修改，所以能快速对用户的反馈和变更作出响应，同时原型模型注重和客户的沟通，所以最终开发出来的软件能够真正反映用户的需求。</p>
<p>但这种快速原型开发往往是以牺牲质量为代价的。</p>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型是把待开发的软件系统模块化，然后在每个小模块的开发过程中，应用一个小瀑布模型，对这个模块进行需求分析、设计、编码和测试。相对瀑布模型而言，增量模型周期更短，不需要一次性把整个软件产品交付给客户，而是分批次交付。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712134154.png"></p>
<p>因为增量模型的根基是模块化，所以，<strong>如果系统不能模块化，那么将很难采用增量模型的模式来开发。</strong>另外，对模块的划分很抽象，这本身对于系统架构的水平是要求很高的。</p>
<p>基于这样的特点，增量模型主要适用于：<strong>需求比较清楚，能模块化的软件系统，并且可以按模块分批次交付。</strong></p>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型每次只设计和实现产品的一部分，然后逐步完成更多功能。每次设计和实现一个阶段叫做一个迭代。</p>
<p>在迭代模型中，整个项目被拆分成一系列小的迭代。通常一个迭代的时间都是固定的，不会太长，例如 2-4 周。每次迭代只实现一部分功能，做能在这个周期内完成的功能。</p>
<p>在一个迭代中都会包括需求分析、设计、实现和测试，类似于一个小瀑布模型。<strong>迭代结束时要完成一个可以运行的交付版本。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712134329.png"></p>
<p><strong>增量模型是按照功能模块来拆分；而迭代模型则是按照时间来拆分，看单位时间内能完成多少功能。</strong></p>
<h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>V 模型适合外包项目。V 模型本质上还是瀑布模型，只不过它是更重视对每个阶段验收测试的过程模型。</p>
<p>针对从需求定义一直到编码阶段，每个阶段都有对应的测试验收。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712134518.png"></p>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>如果你现在要做一个风险很高的项目，客户可能随时不给你钱了。这种情况下，如果采用传统瀑布模型，无疑风险很高，可能做完的时候才发现客户给不了钱，损失就很大了！</p>
<p>这种情况，基于增量模型或者迭代模型进行开发，就可以有效降低风险。你需要注意的是，在每次交付的时候，要同时做一个风险评估，如果风险过大就不继续后续开发了，及时止损。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712134638.png"></p>
<p>这种强调风险，以风险驱动的方式完善项目的开发模型就是螺旋模型。</p>
<h2 id="敏捷开发到底是想解决什么问题？"><a href="#敏捷开发到底是想解决什么问题？" class="headerlink" title="敏捷开发到底是想解决什么问题？"></a>敏捷开发到底是想解决什么问题？</h2><p>敏捷开发是一套价值观和原则。</p>
<p>瀑布模型面向的是过程，而敏捷开发面向的是人。</p>
<h2 id="大厂都在用哪些敏捷方法？（上）"><a href="#大厂都在用哪些敏捷方法？（上）" class="headerlink" title="大厂都在用哪些敏捷方法？（上）"></a>大厂都在用哪些敏捷方法？（上）</h2><h3 id="一切工作任务围绕-Ticket-开展"><a href="#一切工作任务围绕-Ticket-开展" class="headerlink" title="一切工作任务围绕 Ticket 开展"></a>一切工作任务围绕 Ticket 开展</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712135814.png"></p>
<ul>
<li>每一个任务的状态都可以被跟踪起来：什么时候开始做的，谁在做，做完没有。</li>
<li>整个团队在做什么一目了然。</li>
<li>Ticket 和敏捷开发中的 Backlog（任务清单）正好结合起来，通过 Ticket 可以收集管理整个项目的 Backlog 和当前 Sprint（迭代）的 Backlog。</li>
</ul>
<h3 id="基于-Git-和-CI-的开发流程"><a href="#基于-Git-和-CI-的开发流程" class="headerlink" title="基于 Git 和 CI 的开发流程"></a>基于 Git 和 CI 的开发流程</h3><p>Git 本来只是源代码管理工具，但是其强大的分支管理和灵活的权限控制，结合一定的开发流程，却可以帮助你很好的控制代码质量。</p>
<h3 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h3><ul>
<li>每个人轮流介绍一下，昨天干了什么事情，今天计划做什么事情，工作上有没有障碍无法推进。有问题，记录到“问题停车场”。</li>
<li>检查最近的 Ticket，甄别一下优先级。有需要讨论的先收集到问题停车场。</li>
<li>针对未讨论的问题展开讨论，能在会议时间内解决的问题，就马上解决，不能解决的会后再私下讨论或者再组织会议。</li>
</ul>
<h2 id="大厂都在用哪些敏捷方法？（下）"><a href="#大厂都在用哪些敏捷方法？（下）" class="headerlink" title="大厂都在用哪些敏捷方法？（下）"></a>大厂都在用哪些敏捷方法？（下）</h2><p>在分工上：</p>
<ul>
<li>产品经理：写需求设计文档，将需求整理成 Ticket，随时和项目成员沟通确认需求；</li>
<li>开发人员：每天从看板上按照优先级从高到低领取 Ticket，完成日常开发任务；</li>
<li>测试人员：测试已经部署到测试环境的程序，如果发现 Bug，提交 Ticket；</li>
<li>项目经理：保障日常工作流程正常执行，让团队成员可以专注工作，提供必要的帮助，解决问题。</li>
</ul>
<p>如何完成需求和修复 Bug？</p>
<p>日常工作，是围绕 Ticket 来开展的。所有的需求、Bug、任务都作为 Ticket 提交到项目的 Backlog，每个 Sprint 的任务都以看板的形式展现出来。</p>
<p>每个人手头事情忙完后，就可以去看板上的“To Do”栏，按照优先级从高到低选取新的 Ticket。选取后移动到“In Progress”栏。</p>
<p>每周一部署生产环境</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023701">极客时间教程 - 软件工程之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/blog/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"203c89ed6dd6b0abeeeb1cd3c7b2fc89"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
