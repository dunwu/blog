<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/29/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/29/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/29/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d7fa17f4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d7fa17f4/" class="post-title-link" itemprop="url">Java 并发之分工工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-14 15:27:46" itemprop="dateCreated datePublished" datetime="2020-07-14T15:27:46+08:00">2020-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发之分工工具"><a href="#Java-并发之分工工具" class="headerlink" title="Java 并发之分工工具"></a>Java 并发之分工工具</h1><p><strong>对于简单的并行任务，你可以通过“线程池 + Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。</strong></p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask 有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable);</span><br><span class="line">FutureTask(Runnable runnable, V result);</span><br></pre></td></tr></table></figure>

<p><code>FutureTask</code> 实现了 <code>Runnable</code> 和 <code>Future</code> 接口。由于实现了 <code>Runnable</code> 接口，所以可以将 <code>FutureTask</code> 对象作为任务提交给 <code>ThreadPoolExecutor</code> 去执行，也可以直接被 <code>Thread</code> 执行；又因为实现了 <code>Future</code> 接口，所以也能用来获得任务的执行结果。</p>
<p>下面，通过一组示例来展示 FutureTask 如何分别交给线程池、线程执行。</p>
<p>::: tabs#创建 FutureTask 示例</p>
<p>@tab <code>FutureTask</code> 交给线程池执行</p>
<p>【示例】<code>FutureTask</code> 交给线程池执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 FutureTask</span></span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        executor.submit(f1);</span><br><span class="line">        executor.submit(f2);</span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot; 执行成功！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 执行成功！</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 执行成功！</span></span><br></pre></td></tr></table></figure>

<p>@tab <code>FutureTask</code> 交给线程执行</p>
<p>【示例】<code>FutureTask</code> 交给线程执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 FutureTask</span></span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f2).start();</span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot; 执行成功！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Thread-0 执行成功！</span></span><br><span class="line"><span class="comment">// Thread-1 执行成功！</span></span><br></pre></td></tr></table></figure>

<p>@tab 用 <code>FutureTask</code> 完成并行计算</p>
<p>【示例】用 <code>FutureTask</code> 完成并行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程池来执行任务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个 Callable 对象</span></span><br><span class="line">        Callable&lt;Integer&gt; t1 = () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;Integer&gt; t2 = () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">101</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个 FutureTask 对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(t1);</span><br><span class="line">        FutureTask&lt;Integer&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(t2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务到线程池执行</span></span><br><span class="line">        executor.execute(f1);</span><br><span class="line">        executor.execute(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务的结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;total = &quot;</span> + value1 + value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>JDK8 提供了 CompletableFuture 来支持异步编程。</p>
<p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123; <span class="comment">// 省略 &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123; <span class="comment">// 省略 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span> &#123; <span class="comment">// 省略 &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span> &#123; <span class="comment">// 省略 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的 4 个静态方法中，有 2 个 <code>runAsync</code> 方法，2 个 <code>supplyAsync</code> 方法，它们的区别是：</p>
<ul>
<li><code>runAsync</code> 方法没有返回值。</li>
<li><code>supplyAsync</code> 方法有返回值。</li>
</ul>
<p>默认情况下 <code>CompletableFuture</code> 会使用公共的 <code>ForkJoinPool</code> 线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVM option: <code>-Djava.util.concurrent.ForkJoinPool.common.parallelism</code> 来设置 <code>ForkJoinPool</code> 线程池的线程数）。如果所有 <code>CompletableFuture</code> 共享一个线程池，那么一旦有任务执行一些很慢的 I&#x2F;O 操作，就会导致线程池中所有线程都阻塞在 I&#x2F;O 操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要<strong>根据不同的业务类型创建不同的线程池，以避免互相干扰</strong>。</p>
<h2 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h2><p>CompletionStage 接口可以清晰地描述任务之间的时序关系，如<strong>串行关系、并行关系、汇聚关系</strong>等。</p>
<h3 id="串行关系"><a href="#串行关系" class="headerlink" title="串行关系"></a>串行关系</h3><p>CompletionStage 接口里面描述串行关系，主要是 <code>thenApply</code>、<code>thenAccept</code>、<code>thenRun</code> 和 <code>thenCompose</code> 这四个系列的接口。</p>
<p><code>thenApply</code> 系列函数里参数 <code>fn</code> 的类型是接口 <code>Function&lt;T, R&gt;</code>，这个接口里与 <code>CompletionStage</code> 相关的方法是 <code>R apply(T t)</code>，这个方法既能接收参数也支持返回值，所以 <code>thenApply</code> 系列方法返回的是<code>CompletionStage&lt;R&gt;</code>。</p>
<p><code>thenAccept</code> 系列方法里参数 <code>consumer</code> 的类型是接口 <code>Consumer&lt;T&gt;</code>，这个接口里与 <code>CompletionStage</code> 相关的方法是 <code>void accept(T t)</code>，这个方法虽然支持参数，但却不支持回值，所以 <code>thenAccept</code> 系列方法返回的是<code>CompletionStage&lt;Void&gt;</code>。</p>
<p><code>thenRun</code> 系列方法里 <code>action</code> 的参数是 <code>Runnable</code>，所以 <code>action</code> 既不能接收参数也不支持返回值，所以 thenRun 系列方法返回的也是 <code>CompletionStage&lt;Void&gt;</code>。</p>
<p>这些方法里面 Async 代表的是异步执行 <code>fn</code>、<code>consumer</code> 或者 <code>action</code>。其中，需要你注意的是 <code>thenCompose</code> 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 <code>thenApply</code> 系列是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenApply</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenApplyAsync</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(action)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(action)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCompose</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenComposeAsync</span><span class="params">(fn)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="描述-AND-汇聚关系"><a href="#描述-AND-汇聚关系" class="headerlink" title="描述 AND 汇聚关系"></a>描述 AND 汇聚关系</h3><p><code>CompletionStage</code> 接口里面描述 AND 汇聚关系，主要是 <code>thenCombine</code>、<code>thenAcceptBoth</code> 和 <code>runAfterBoth</code> 系列的接口，这些接口的区别也是源自 <code>fn</code>、<code>consumer</code>、<code>action</code> 这三个核心参数不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCombine</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">thenCombineAsync</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(other, action)</span>;</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(other, action)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="描述-OR-汇聚关系"><a href="#描述-OR-汇聚关系" class="headerlink" title="描述 OR 汇聚关系"></a>描述 OR 汇聚关系</h3><p><code>CompletionStage</code> 接口里面描述 OR 汇聚关系，主要是 <code>applyToEither</code>、<code>acceptEither</code> 和 <code>runAfterEither</code> 系列的接口，这些接口的区别也是源自 <code>fn</code>、<code>consumer</code>、<code>action</code> 这三个核心参数不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage <span class="title function_">applyToEither</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage <span class="title function_">applyToEitherAsync</span><span class="params">(other, fn)</span>;</span><br><span class="line">CompletionStage <span class="title function_">acceptEither</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage <span class="title function_">acceptEitherAsync</span><span class="params">(other, consumer)</span>;</span><br><span class="line">CompletionStage <span class="title function_">runAfterEither</span><span class="params">(other, action)</span>;</span><br><span class="line">CompletionStage <span class="title function_">runAfterEitherAsync</span><span class="params">(other, action)</span>;</span><br></pre></td></tr></table></figure>

<p>下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR 汇聚关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> getRandom(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    sleep(t, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(t);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> getRandom(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    sleep(t, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(t);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f3 = f1.applyToEither(f2, s -&gt; s);</span><br><span class="line">System.out.println(f3.join());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>虽然上面我们提到的 <code>fn</code>、<code>consumer</code>、<code>action</code> 它们的核心方法都<strong>不允许抛出可检查异常，但是却无法限制它们抛出运行时异常</strong>，例如下面的代码，执行 <code>7/0</code> 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 <code>try &#123;&#125; catch &#123;&#125;</code> 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(() -&gt; (<span class="number">7</span> / <span class="number">0</span>))</span><br><span class="line">                                                 .thenApply(r -&gt; r * <span class="number">10</span>);</span><br><span class="line">System.out.println(f.join());</span><br></pre></td></tr></table></figure>

<p><code>CompletionStage</code> 接口给我们提供的方案非常简单，比 <code>try &#123;&#125; catch &#123;&#125;</code> 还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage <span class="title function_">exceptionally</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">whenComplete</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(consumer)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">handle</span><span class="params">(fn)</span>;</span><br><span class="line">CompletionStage&lt;R&gt; <span class="title function_">handleAsync</span><span class="params">(fn)</span>;</span><br></pre></td></tr></table></figure>

<p>下面的示例代码展示了如何使用 <code>exceptionally()</code> 方法来处理异常，<code>exceptionally()</code> 的使用非常类似于 <code>try &#123;&#125; catch &#123;&#125;</code> 中的 <code>catch &#123;&#125;</code>，但是由于支持链式编程方式，所以相对更简单。既然有 <code>try &#123;&#125; catch &#123;&#125;</code>，那就一定还有 <code>try &#123;&#125; catch &#123;&#125;</code>，<code>whenComplete()</code> 和 <code>handle()</code> 系列方法就类似于 <code>try &#123;&#125; catch &#123;&#125;</code> 中的 <code>finally &#123;&#125;</code>，无论是否发生异常都会执行 <code>whenComplete()</code> 中的回调函数 <code>consumer</code> 和 <code>handle()</code> 中的回调函数 <code>fn</code>。<code>whenComplete()</code> 和 <code>handle()</code> 的区别在于 <code>whenComplete()</code> 不支持返回结果，而 <code>handle()</code> 是支持返回结果的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(() -&gt; <span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line">                                                .thenApply(r -&gt; r * <span class="number">10</span>)</span><br><span class="line">                                                .exceptionally(e -&gt; <span class="number">0</span>);</span><br><span class="line">System.out.println(f.join());</span><br></pre></td></tr></table></figure>

<h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p><code>CompletionService</code> 接口的实现类是 <code>ExecutorCompletionService</code>，这个实现类的构造方法有两个，分别是：</p>
<ol>
<li><code>ExecutorCompletionService(Executor executor)</code>；</li>
<li><code>ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</code>。</li>
</ol>
<p>这两个构造方法都需要传入一个线程池，如果不指定 <code>completionQueue</code>，那么默认会使用无界的 <code>LinkedBlockingQueue</code>。任务执行结果的 <code>Future</code> 对象就是加入到 <code>completionQueue</code> 中。</p>
<p>下面的示例代码完整地展示了如何利用 <code>CompletionService</code> 来实现高性能的询价系统。其中，我们没有指定 <code>completionQueue</code>，因此默认使用无界的 <code>LinkedBlockingQueue</code>。之后通过 <code>CompletionService</code> 接口提供的 <code>submit()</code> 方法提交了三个询价操作，这三个询价操作将会被 <code>CompletionService</code> 异步执行。最后，我们通过 CompletionService 接口提供的 <code>take()</code> 方法获取一个 <code>Future</code> 对象（前面我们提到过，加入到阻塞队列中的是任务执行结果的 <code>Future</code> 对象），调用 <code>Future</code> 对象的 <code>get()</code> 方法就能返回询价操作的执行结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建 CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商 S1 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商 S2 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商 S3 询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> cs.take().get();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompletionService 接口提供的方法有 5 个，这 5 个方法的方法签名如下所示。</p>
<p>其中，submit() 相关的方法有两个。一个方法参数是<code>Callable&lt;V&gt; task</code>，前面利用 CompletionService 实现询价系统的示例代码中，我们提交任务就是用的它。另外一个方法有两个参数，分别是<code>Runnable task</code>和<code>V result</code>，这个方法类似于 ThreadPoolExecutor 的 <code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code> ，这个方法在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/91292">《23 | Future：如何用多线程实现最优的“烧水泡茶”程序？》</a> 中我们已详细介绍过，这里不再赘述。</p>
<p>CompletionService 接口其余的 3 个方法，都是和阻塞队列相关的，take()、poll() 都是从阻塞队列中获取并移除一个元素；它们的区别在于如果阻塞队列是空的，那么调用 take() 方法的线程会被阻塞，而 poll() 方法会返回 null 值。 <code>poll(long timeout, TimeUnit unit)</code> 方法支持以超时的方式获取并移除阻塞队列头部的一个元素，如果等待了 timeout unit 时间，阻塞队列还是空的，那么该方法会返回 null 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;V&gt; task)</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Runnable task, V result)</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">Future&lt;V&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p>当需要批量提交异步任务的时候建议你使用 CompletionService。CompletionService 将线程池 Executor 和阻塞队列 BlockingQueue 的功能融合在了一起，能够让批量异步任务的管理更简单。除此之外，CompletionService 能够让异步任务的执行结果有序化，先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如 Forking Cluster 这样的需求。</p>
<p>CompletionService 的实现类 ExecutorCompletionService，需要你自己创建线程池，虽看上去有些啰嗦，但好处是你可以让多个 ExecutorCompletionService 的线程池隔离，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</p>
<h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>Fork&#x2F;Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的** Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并<strong>。Fork&#x2F;Join 计算框架主要包含两部分，一部分是</strong>分治任务的线程池 ForkJoinPool<strong>，另一部分是</strong>分治任务 ForkJoinTask**。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p>
<p>Fork&#x2F;Join 并行计算的核心组件是 ForkJoinPool，所以下面我们就来简单介绍一下 ForkJoinPool 的工作原理。</p>
<p>ForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智能，你可以参考下面的 ForkJoinPool 工作原理图来理解其原理。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p>
<p>如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“<strong>任务窃取</strong>”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。</p>
<p>ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200703141326.png" alt="img"></p>
<p>【示例】模拟 MapReduce 统计单词数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] fc = &#123; <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello me&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello fork&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hello join&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fork join in world&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建 ForkJoin 线程池</span></span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">fjp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//创建任务</span></span><br><span class="line">    <span class="type">MR</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(fc, <span class="number">0</span>, fc.length);</span><br><span class="line">    <span class="comment">//启动任务</span></span><br><span class="line">    Map&lt;String, Long&gt; result = fjp.invoke(mr);</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    result.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MR 模拟类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MR</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Map&lt;String, Long&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fc;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MR(String[] fc, <span class="type">int</span> fr, <span class="type">int</span> to) &#123;</span><br><span class="line">        <span class="built_in">this</span>.fc = fc;</span><br><span class="line">        <span class="built_in">this</span>.start = fr;</span><br><span class="line">        <span class="built_in">this</span>.end = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Long&gt; <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> calc(fc[start]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">MR</span> <span class="variable">mr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(fc, start, mid);</span><br><span class="line">            mr1.fork();</span><br><span class="line">            <span class="type">MR</span> <span class="variable">mr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MR</span>(fc, mid, end);</span><br><span class="line">            <span class="comment">//计算子任务，并返回合并的结果</span></span><br><span class="line">            <span class="keyword">return</span> merge(mr2.compute(),</span><br><span class="line">                mr1.join());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并结果</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Long&gt; <span class="title function_">merge</span><span class="params">(Map&lt;String, Long&gt; r1, Map&lt;String, Long&gt; r2)</span> &#123;</span><br><span class="line">        Map&lt;String, Long&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        result.putAll(r1);</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        r2.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">c</span> <span class="operator">=</span> result.get(k);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123; result.put(k, c + v); &#125; <span class="keyword">else</span> &#123; result.put(k, v); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计单词数量</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Long&gt; <span class="title function_">calc</span><span class="params">(String line)</span> &#123;</span><br><span class="line">        Map&lt;String, Long&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//分割单词</span></span><br><span class="line">        String[] words = line.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="comment">//统计单词数量</span></span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">v</span> <span class="operator">=</span> result.get(w);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123; result.put(w, v + <span class="number">1</span>); &#125; <span class="keyword">else</span> &#123; result.put(w, <span class="number">1L</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bac52527ca4">CompletableFuture 使用详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f18c87b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f18c87b0/" class="post-title-link" itemprop="url">Redis 面试之应用篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 17:03:42" itemprop="dateCreated datePublished" datetime="2020-07-13T17:03:42+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-面试之应用篇"><a href="#Redis-面试之应用篇" class="headerlink" title="Redis 面试之应用篇"></a>Redis 面试之应用篇</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="【中等】如何避免缓存雪崩、缓存击穿、缓存穿透？"><a href="#【中等】如何避免缓存雪崩、缓存击穿、缓存穿透？" class="headerlink" title="【中等】如何避免缓存雪崩、缓存击穿、缓存穿透？"></a>【中等】如何避免缓存雪崩、缓存击穿、缓存穿透？</h3><ul>
<li><strong>缓存击穿</strong>：指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。<ul>
<li>使用互斥锁，确保同一时间只有一个请求可以去数据库查询并更新缓存。</li>
<li>热点数据永不过期。</li>
</ul>
</li>
<li><strong>缓存穿透</strong>：指查询一个不存在的数据，缓存中没有相应的记录，每次请求都会去数据库查询，造成数据库负担加重。<ul>
<li>使用布隆过滤器，过滤掉不存在的请求，避免直接访问数据库。</li>
<li>对查询结果进行缓存，即使是不存在的数据，也可以缓存一个标识，以减少对数据库的请求。<br><img src="https://raw.githubusercontent.com/dunwu/images/master/202506151115189.png"></li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：指多个缓存数据在同一时间过期，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增。<ul>
<li>采用随机过期时间策略，避免多个数据同时过期。</li>
<li>使用双缓存策略，将数据同时存储在两层缓存中，减少数据库直接请求。</li>
</ul>
</li>
</ul>
<h3 id="【中等】如何保证缓存与数据库的数据一致性？"><a href="#【中等】如何保证缓存与数据库的数据一致性？" class="headerlink" title="【中等】如何保证缓存与数据库的数据一致性？"></a>【中等】如何保证缓存与数据库的数据一致性？</h3><p>一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将<strong>读请求和写请求串行化</strong>。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。</p>
<p>一般来说缓存的更新有两种情况：</p>
<ul>
<li>先删除缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<blockquote>
<p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p>
</blockquote>
<p>你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。</p>
<h3 id="【中等】有哪些常见的内存淘汰算法？"><a href="#【中等】有哪些常见的内存淘汰算法？" class="headerlink" title="【中等】有哪些常见的内存淘汰算法？"></a>【中等】有哪些常见的内存淘汰算法？</h3><p>缓存淘汰的类型：</p>
<ul>
<li><strong>基于空间</strong> - 设置缓存空间大小。</li>
<li><strong>基于容量</strong> - 设置缓存存储记录数。</li>
<li>基于时间<ul>
<li>TTL（Time To Live，即存活期）缓存数据从创建到过期的时间。</li>
<li>TTI（Time To Idle，即空闲期）缓存数据多久没被访问的时间。</li>
</ul>
</li>
</ul>
<p>缓存淘汰算法：</p>
<ul>
<li><strong>FIFO</strong> - <strong>先进先出</strong>。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</li>
<li><strong>LRU</strong> - <strong>最近最少使用算法</strong>。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次（可见这是个热点数据）, 再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</li>
<li><strong>LFU</strong> - <strong>最近最少频率使用</strong>。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。</li>
</ul>
<p>这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="【中等】实现分布式锁需要解决哪些问题？"><a href="#【中等】实现分布式锁需要解决哪些问题？" class="headerlink" title="【中等】实现分布式锁需要解决哪些问题？"></a>【中等】实现分布式锁需要解决哪些问题？</h3><p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（Redis，Memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<p>分布式锁的实现要点大同小异，仅在实现细节上有所不同。</p>
<p>实现分布式锁需要解决以下目标：</p>
<ul>
<li><strong>互斥</strong> - <strong>分布式锁必须是独一无二的</strong>，表现形式为：向数据存储插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。</li>
<li><strong>避免死锁</strong> - 在分布式锁的场景中，部分失败和异步网络这两个问题是同时存在的。如果一个进程获得了锁，但是这个进程与锁服务之间的网络出现了问题，导致无法通信，那么这个情况下，如果锁服务让它一直持有锁，就会导致死锁的发生。<ul>
<li>常见的解决思路是引入<strong>超时机制</strong>，即成功申请锁后，超过一定时间，锁失效（删除 key）。</li>
<li>超时机制解锁了死锁问题，但又引入了一个新问题：如果应用加锁时，对于操作共享资源的时长估计不足，可能会出现：操作尚未执行完，但是锁没了的尴尬情况。为了解决这个问题，需要引入<strong>锁续期</strong>机制：当持有锁的线程尚未执行完操作前，不断周期性检测锁的超时时间，一旦发现快要过期，就自动为锁续期。</li>
<li>ZooKeeper 分布式锁避免死锁采用了另外一种思路—— Watch 机制。</li>
</ul>
</li>
<li><strong>可重入</strong> - <strong>可重入</strong>指的是：<strong>同一个线程在没有释放锁之前，能否再次获得该锁</strong>。其实现方案是：只需在加锁的时候，<strong>记录好当前获取锁的节点 + 线程组合的唯一标识</strong>，然后在后续的加锁请求时，如果当前请求的节点 + 线程的唯一标识和当前持有锁的相同，那么就直接返回加锁成功；如果不相同，则按正常加锁流程处理。</li>
<li><strong>公平性</strong> - 当多个线程请求同一锁时，它们必须按照请求的顺序来获取锁，即先来先得的原则。锁的公平性的实现也非常简单，对于被阻塞的加锁请求，我们只要先记录好它们的顺序，在锁被释放后，按顺序颁发就可以了。</li>
<li><strong>重试</strong> - 有时候，加锁失败可能只是由于网络波动、请求超时等原因，稍候就可以成功获取锁。为了应对这种情况，加锁操作需要支持重试机制。常见的做法是，设置一个加锁超时时间，在该时间范围内，不断自旋重试加锁操作，超时后再判定加锁失败。</li>
<li><strong>容错</strong> - 分布式锁若存储在单一节点，一旦该节点宕机或失联，就会导致锁失效。将分布式锁存储在多数据库实例中，加锁时并发写入 <code>N</code> 个节点，只要 <code>N / 2 + 1</code> 个节点写入成功即视为加锁成功。代表有：Redis 官方提供的 RedLock。</li>
</ul>
<h3 id="【中等】Redis-中如何实现分布式锁？"><a href="#【中等】Redis-中如何实现分布式锁？" class="headerlink" title="【中等】Redis 中如何实现分布式锁？"></a>【中等】Redis 中如何实现分布式锁？</h3><p><strong>基础实现</strong></p>
<ul>
<li><strong>加锁</strong>：<code>SET key val NX PX 30000</code>（<code>NX</code>：仅当 key 不存在时写入，<code>PX</code>：超时时间，毫秒）。</li>
<li><strong>解锁</strong>：<code>DEL key</code>（直接删除 key 释放锁）。</li>
</ul>
<p><strong>避免死锁</strong></p>
<ul>
<li><strong>问题</strong>：节点宕机或异常导致锁无法释放。</li>
<li><strong>方案</strong>：加锁时设置<strong>超时时间</strong>（<code>PX/EX</code>），到期自动删除。</li>
<li><strong>原子性</strong>：使用 <code>SET key val NX PX</code> 替代 <code>setnx + expire</code>，避免组合命令非原子性问题。</li>
</ul>
<p><strong>超时续期（WatchDog）</strong></p>
<ul>
<li><strong>问题</strong>：业务未执行完，锁已过期。</li>
<li><strong>方案</strong>：启动<strong>定时任务</strong>检测锁剩余时间，自动续期（如 Redisson 的 WatchDog 机制）。</li>
</ul>
<p><strong>安全解锁</strong></p>
<ul>
<li><strong>问题</strong>：其他节点误删锁。</li>
<li><strong>方案</strong>：<ul>
<li>加锁时写入<strong>唯一标识</strong>（如 UUID）。</li>
<li>解锁时校验标识，<strong>匹配才删除</strong>（使用 Lua 脚本保证原子性）：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>自旋重试</strong></p>
<ul>
<li><strong>问题</strong>：网络波动导致加锁失败。</li>
<li><strong>方案</strong>：在超时时间内<strong>循环重试</strong>加锁（伪代码示例见原内容）。</li>
</ul>
<p><strong>其他问题</strong></p>
<ul>
<li><strong>不可重入</strong>：同一线程无法重复获取同一把锁（可通过 Redisson 等客户端支持）。</li>
<li><strong>单点问题</strong>：主从切换可能导致锁失效（可用 <strong>RedLock 算法</strong>，但存在争议）。</li>
</ul>
<h3 id="【中等】Red-Lock-分布式锁的原理是什么？"><a href="#【中等】Red-Lock-分布式锁的原理是什么？" class="headerlink" title="【中等】Red Lock 分布式锁的原理是什么？"></a>【中等】Red Lock 分布式锁的原理是什么？</h3><p><strong>核心机制</strong>：</p>
<ul>
<li><strong>多节点写入</strong>：同时向多个 Redis 主节点（≥5 个）加锁</li>
<li><strong>多数派原则</strong>：半数以上节点加锁成功才算成功</li>
<li><strong>耗时控制</strong>：总加锁时间必须小于锁的过期时间</li>
<li><strong>强制清理</strong>：解锁时向所有节点发起请求</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>网络延迟</strong>：多节点操作会增加耗时风险</li>
<li><strong>性能代价</strong>：相比单节点锁性能更低</li>
<li><strong>实现复杂度</strong>：需要精确控制时间和节点状态</li>
</ul>
<h3 id="【中等】Redisson-分布式锁的原理是什么？"><a href="#【中等】Redisson-分布式锁的原理是什么？" class="headerlink" title="【中等】Redisson 分布式锁的原理是什么？"></a>【中等】Redisson 分布式锁的原理是什么？</h3><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 是一个流行的 Redis Java 客户端，它基于 Netty 开发，并提供了丰富的扩展功能，如：<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/counters/">分布式计数器</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/collections/">分布式集合</a>、<a target="_blank" rel="noopener" href="https://redisson.org/docs/data-and-services/locks-and-synchronizers/">分布式锁</a> 等。</p>
<p>Redisson 支持的分布式锁有多种：Lock, FairLock, MultiLock, RedLock, ReadWriteLock, Semaphore, PermitExpirableSemaphore, CountDownLatch，可以根据场景需要去选择，非常方便。一般而言，使用 Redis 分布式锁，推荐直接使用 Redisson 提供的 API，功能全面且较为可靠。</p>
<p><strong>Redisson 分布式锁的实现要点</strong>：</p>
<ul>
<li><strong>锁的获取</strong>：Redisson 使用 Lua 脚本，利用 <code>exists + hexists + hincrby</code> 命令来保证只有一个线程能成功设置键（表示获得锁）。同时，Redisson 会通过 <code>pexpire</code> 命令为锁设置过期时间，防止因宕机等原因导致锁无法释放（即死锁问题）。</li>
<li><strong>锁的续期</strong>：为了防止锁在持有过程中过期导致其他线程抢占锁，Redisson 实现了一种叫做 <strong>Watch Dog（看门狗）</strong> 的锁自动续期的功能。持有锁的线程会定期续期，即更新锁的过期时间，确保任务没有完成时锁不会失效。</li>
<li><strong>锁的释放</strong>：锁释放时，Redisson 也是通过 Lua 脚本保证释放操作的原子性。利用 <code>hexists + del</code> 确保只有持有锁的线程才能释放锁，防止误释放锁的情况。Lua 脚本同时利用 publish 命令，广播唤醒其它等待的线程。</li>
<li><strong>可重入锁</strong>：Redisson 支持可重入锁，持有锁的线程可以多次获取同一把锁而不会被阻塞。具体是利用 Redis 中的哈希结构，哈希中的 key 为线程 ID，如果重入则 value +1，如果释放则 value -1，减到 0 说明锁被释放了，则 del 锁。</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="【中等】Redis-如何实现消息队列？"><a href="#【中等】Redis-如何实现消息队列？" class="headerlink" title="【中等】Redis 如何实现消息队列？"></a>【中等】Redis 如何实现消息队列？</h3><blockquote>
<p>Redis 可以做消息队列吗？</p>
<p>Redis 有哪些实现消息队列的方式？</p>
</blockquote>
<p>先说结论：<strong>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</strong></p>
<h4 id="基于-List-实现消息队列"><a href="#基于-List-实现消息队列" class="headerlink" title="基于 List 实现消息队列"></a>基于 List 实现消息队列</h4><p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产者生产消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPUSH myList msg1 msg2</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPUSH myList msg3</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">消费者消费消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPOP myList</span></span><br><span class="line">&quot;msg1&quot;</span><br></pre></td></tr></table></figure>

<p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Blocking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后再返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">超时时间为 10s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有数据立刻返回，否则最多等待 10 秒</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BRPOP myList 10</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<h4 id="基于发布订阅功能实现消息队列"><a href="#基于发布订阅功能实现消息队列" class="headerlink" title="基于发布订阅功能实现消息队列"></a>基于发布订阅功能实现消息队列</h4><p><strong>Redis 2.0 引入了发布订阅 (pub&#x2F;sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503272225857.png"></p>
<p>Redis 发布订阅 (pub&#x2F;sub) 功能</p>
<p>pub&#x2F;sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub&#x2F;sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<h4 id="基于-Stream-实现消息队列"><a href="#基于-Stream-实现消息队列" class="headerlink" title="基于 Stream 实现消息队列"></a>基于 Stream 实现消息队列</h4><p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 &#x2F; 订阅模式</li>
<li>按照消费者组进行消费（借鉴了 Kafka 消费者组的概念）</li>
<li>消息持久化（ RDB 和 AOF）</li>
<li>ACK 机制（通过确认机制来告知已经成功处理了消息）</li>
<li>阻塞式获取消息</li>
</ul>
<p><code>Stream</code> 的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503270823833.png"></p>
<p>这是一个有序的消息链表，每个消息都有一个唯一的 ID 和对应的内容。ID 是一个时间戳和序列号的组合，用来保证消息的唯一性和递增性。内容是一个或多个键值对（类似 Hash 基本数据类型），用来存储消息的数据。</p>
<p>这里再对图中涉及到的一些概念，进行简单解释：</p>
<ul>
<li><code>Consumer Group</code>：消费者组用于组织和管理多个消费者。消费者组本身不处理消息，而是再将消息分发给消费者，由消费者进行真正的消费</li>
<li><code>last_delivered_id</code>：标识消费者组当前消费位置的游标，消费者组中任意一个消费者读取了消息都会使 last_delivered_id 往前移动。</li>
<li><code>pending_ids</code>：记录已经被客户端消费但没有 ack 的消息的 ID。</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。</p>
<p>总的来说，<code>Stream</code> 已经可以满足一个消息队列的基本要求了。不过，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。不过，如果你就是想要用 Redis 来做消息队列的话，那我建议你优先考虑 <code>Stream</code>，这是目前相对最优的 Redis 消息队列实现。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022</a></p>
<h2 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h2><h3 id="【中等】如何基于-Redis-实现延时任务？"><a href="#【中等】如何基于-Redis-实现延时任务？" class="headerlink" title="【中等】如何基于 Redis 实现延时任务？"></a>【中等】如何基于 Redis 实现延时任务？</h3><p>基于 Redis 实现延时任务的功能无非就下面两种方案：</p>
<ol>
<li>Redis 过期事件监听</li>
<li>Redisson 内置的延时队列</li>
</ol>
<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。</p>
<p>Redisson 内置的延时队列具备下面这些优势：</p>
<ol>
<li><strong>减少了丢消息的可能</strong>：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</li>
<li><strong>消息不存在重复消费问题</strong>：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66">面试中关于 Redis 的问题看这篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98">advanced-java</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ce594f11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ce594f11/" class="post-title-link" itemprop="url">Redis 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 17:03:42" itemprop="dateCreated datePublished" datetime="2020-07-13T17:03:42+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-面试"><a href="#Redis-面试" class="headerlink" title="Redis 面试"></a>Redis 面试</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><h3 id="【简单】什么是-Redis？"><a href="#【简单】什么是-Redis？" class="headerlink" title="【简单】什么是 Redis？"></a>【简单】什么是 Redis？</h3><blockquote>
<p>什么是 Redis？</p>
</blockquote>
<p><strong>Redis 是一个开源的、数据存于内存中的 K-V 数据库</strong>。由于，Redis 的读写操作都是在内存中完成，因此其<strong>读写速度非常快</strong>。</p>
<ul>
<li><strong>高性能</strong> - 由于，Redis 的读写操作都是在内存中完成，因此性能极高。</li>
<li><strong>高并发</strong> - Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。</li>
</ul>
<p>Redis 常被用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p>
<blockquote>
<p>Redis 有什么功能和特性？</p>
</blockquote>
<p>Redis 的功能和特性：</p>
<ul>
<li><strong>Redis 支持多种数据类型</strong>。如：String（字符串）、Hash（哈希）、 List （列表）、Set（集合）、Zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理空间）、Stream（流）。</li>
<li><strong>Redis 的读写采用“单线程”模型</strong>，因此，其操作天然就具有<strong>原子性</strong>。需要注意的是，Redis 6.0 后在其网络模块中引入了多线程 I&#x2F;O 机制。</li>
<li>Redis 支持两种持久化策略：RDB 和 AOF。</li>
<li>Redis 有多种高可用方案：<strong>主从复制</strong>模式、<strong>哨兵</strong>模式、<strong>集群</strong>模式。</li>
<li>Redis 支持很多丰富的特性，如：<strong>事务</strong> 、<strong>Lua 脚本</strong>、<strong>发布订阅</strong>、<strong>过期删除</strong>、<strong>内存淘汰</strong>等等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202411231010326.png"></p>
<p><em>图来自 <a target="_blank" rel="noopener" href="https://architecturenotes.co/p/redis">Redis Explained</a></em></p>
<h3 id="【简单】Redis-有哪些应用场景？"><a href="#【简单】Redis-有哪些应用场景？" class="headerlink" title="【简单】Redis 有哪些应用场景？"></a>【简单】Redis 有哪些应用场景？</h3><p>Redis 常见应用场景如下：</p>
<ul>
<li><strong>缓存</strong> - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</li>
<li><strong>计数器</strong> - Redis 这种内存数据库能支持计数器频繁的读写操作。</li>
<li><strong>应用限流</strong> - 限制一个网站访问流量。</li>
<li><strong>消息队列</strong> - 使用 List 数据类型，它是双向链表。</li>
<li><strong>查找表</strong> - 使用 HASH 数据类型。</li>
<li><strong>聚合运算</strong> - 使用 SET 类型，例如求两个用户的共同好友。</li>
<li><strong>排行榜</strong> - 使用 ZSET 数据类型。</li>
<li><strong>分布式 Session</strong> - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</li>
<li><strong>分布式锁</strong> - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
</ul>
<h3 id="【简单】Redis-有哪些里程碑版本？"><a href="#【简单】Redis-有哪些里程碑版本？" class="headerlink" title="【简单】Redis 有哪些里程碑版本？"></a>【简单】Redis 有哪些里程碑版本？</h3><p>Redis 里程碑版本如下：</p>
<ul>
<li>Redis 1.0（2010 年） - Redis 1.0 发布，采用单机架构，一般作为业务应用的缓存。但是 Redis 的数据是存在内存中的，重启 Redis 时，数据会全部丢失，流量直接打到数据库。</li>
<li>Redis 2.8（2013 年）<ul>
<li>持久化 - Redis 引入了 RDB 内存快照来持久化数据。它还支持 AOF（仅追加文件），其中每个写入命令都写入 AOF 文件。</li>
<li>复制 - 添加了复制功能以提高可用性。主实例处理实时读写请求，而副本同步主实例的数据。</li>
<li>哨兵 - 引入了 Sentinel 来实时监控 Redis 实例。Sentinel 是一个旨在帮助管理 Redis 实例的系统。它执行以下四个任务：监控、通知、自动故障转移和共享配置。</li>
</ul>
</li>
<li>Redis 3.0（2015 年） - 官方提供了 redis-cluster。redis-cluster 是一种分布式数据库解决方案，通过分片管理数据。数据被分成 16384 个槽，每个节点负责槽的一部分。</li>
<li>Redis 5.0（2017 年） - 新增 Stream 数据类型。</li>
<li>Redis 6.0（2020 年） - 在网络模块中引入了多线程 I&#x2F;O。Redis 模型分为网络模块和主处理模块。特别注意：Redis 不再完全是单线程架构。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503270820508.gif"></p>
<h3 id="【简单】对比一下-Redis-和-Memcached？"><a href="#【简单】对比一下-Redis-和-Memcached？" class="headerlink" title="【简单】对比一下 Redis 和 Memcached？"></a>【简单】对比一下 Redis 和 Memcached？</h3><blockquote>
<ul>
<li>Redis 和 Memcached 有什么相同点？</li>
<li>Redis 和 Memcached 有什么差异？</li>
<li>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</li>
</ul>
</blockquote>
<p>Redis 与 Memcached 的<strong>共性</strong>：</p>
<ul>
<li>都是内存数据库，因此性能都很高。</li>
<li>都有过期策略。</li>
</ul>
<p>因为以上两点，所以常被作为缓存使用。</p>
<p>Redis 与 Memcached 的<strong>差异</strong>：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202504010716308.jpg"></p>
<p>核心差异对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>Memcached</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>只支持 String 类型</td>
<td>支持多种数据类型：String、Hash、List、Set、ZSet 等</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持持久化，一旦重启或宕机就会丢失数据</td>
<td>支持两种持久化策略：RDB 和 AOF</td>
</tr>
<tr>
<td>分布式</td>
<td>本身不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</td>
<td>支持分布式</td>
</tr>
<tr>
<td>线程模型</td>
<td>采用多线程+IO 多路复用。在 100k 以上的数据中，Memcached 性能要高于 Redis</td>
<td>读写采用单线程+IO 多路复用。因此存储小数据时比 Memcached 性能更高</td>
</tr>
<tr>
<td>其他功能</td>
<td>不支持</td>
<td>支持发布订阅模型、Lua 脚本、事务等功能</td>
</tr>
</tbody></table>
<p>通过以上分析，可以看出，Redis 在很多方面都占有优势。因此，绝大多数情况下，优先选择 Redis 作为分布式缓存。</p>
<blockquote>
<p><strong>扩展</strong>：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/23549">《脚踏两只船的困惑 - Memcached 与 Redis》</a></p>
</blockquote>
<h3 id="【简单】Redis-有哪些-Java-客户端？各有什么优劣？"><a href="#【简单】Redis-有哪些-Java-客户端？各有什么优劣？" class="headerlink" title="【简单】Redis 有哪些 Java 客户端？各有什么优劣？"></a>【简单】Redis 有哪些 Java 客户端？各有什么优劣？</h3><p>Redis 的主流 Java 客户端有三种，对比如下：</p>
<table>
<thead>
<tr>
<th align="left">客户端</th>
<th align="left">线程安全</th>
<th align="left">自动重连</th>
<th align="left">编程模型</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Jedis</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">同步</td>
<td align="left">简单应用、快速开发</td>
</tr>
<tr>
<td align="left"><strong>Lettuce</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">同步&#x2F;异步&#x2F;响应式</td>
<td align="left">高并发、Spring Boot 项目</td>
</tr>
<tr>
<td align="left"><strong>Redisson</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">同步&#x2F;异步</td>
<td align="left">分布式系统、高级功能需求</td>
</tr>
</tbody></table>
<p><strong>推荐选择</strong>：</p>
<ul>
<li><strong>基础需求</strong> → Jedis（简单直接）。</li>
<li><strong>高并发&#x2F;Spring 项目</strong> → Lettuce（默认选择）。</li>
<li><strong>分布式锁&#x2F;队列等</strong> → Redisson（功能强大）。</li>
</ul>
<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p><strong>✅ 优点</strong></p>
<ul>
<li><strong>简单易用</strong>：API 直观，适合快速上手。</li>
<li><strong>广泛使用</strong>：社区支持丰富，文档齐全。</li>
<li><strong>性能良好</strong>：常规操作高效。</li>
<li><strong>功能全面</strong>：支持字符串、哈希、列表等基础数据结构。</li>
</ul>
<p><strong>❌ 缺点</strong></p>
<ul>
<li><strong>非线程安全</strong>：需为每个线程创建独立实例。</li>
<li><strong>无自动重连</strong>：网络异常需手动处理。</li>
<li><strong>同步阻塞</strong>：高并发时可能成为性能瓶颈。</li>
</ul>
<h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>✅ 优点</strong></p>
<ul>
<li><strong>线程安全</strong>：多线程共享同一连接。</li>
<li><strong>高性能</strong>：基于 Netty 实现，支持高并发。</li>
<li><strong>自动重连</strong>：网络中断后自动恢复。</li>
<li><strong>多编程模型</strong>：支持同步、异步、响应式（如 Reactive API）。</li>
</ul>
<p><strong>❌ 缺点</strong></p>
<ul>
<li><strong>API 较复杂</strong>：学习成本高于 Jedis。</li>
<li><strong>资源消耗</strong>：异步模式可能占用更多内存&#x2F;CPU。</li>
</ul>
<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p><strong>✅ 优点</strong></p>
<ul>
<li><strong>分布式支持</strong>：内置分布式锁、队列、缓存等高级功能。</li>
<li><strong>线程安全</strong>：天然适配多线程场景。</li>
<li><strong>集群友好</strong>：完善支持 Redis 集群模式。</li>
<li><strong>稳定性高</strong>：企业级应用验证。</li>
</ul>
<p><strong>❌ 缺点</strong></p>
<ul>
<li><strong>学习曲线陡峭</strong>：需掌握分布式概念。</li>
<li><strong>依赖兼容性</strong>：可能与其他库冲突需调优。</li>
</ul>
<h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h2><h3 id="【中等】Redis-支持哪些过期删除策略？"><a href="#【中等】Redis-支持哪些过期删除策略？" class="headerlink" title="【中等】Redis 支持哪些过期删除策略？"></a>【中等】Redis 支持哪些过期删除策略？</h3><blockquote>
<ul>
<li>Redis 支持哪些过期删除策略？</li>
<li>常见的过期策略有哪些，Redis 的选择考量是什么？</li>
</ul>
</blockquote>
<p>Redis 采用的过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li><strong>定时删除</strong> - 在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行 key 的删除操作。<ul>
<li><strong>优点</strong> - 保证过期 key 被尽可能快的删除，释放内存。</li>
<li><strong>缺点</strong> - <strong>如果过期 key 较多，可能会占用相当一部分的 CPU，从而影响服务器的吞吐量和响应时延</strong>。</li>
</ul>
</li>
<li><strong>惰性删除</strong> - 放任 key 过期不管，但是每次访问 key 时，都检查 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。<ul>
<li><strong>优点</strong> - 占用 CPU 最少。程序只会在读写键时，对当前键进行过期检查，因此不会有额外的 CPU 开销。</li>
<li><strong>缺点</strong> - <strong>过期的 key 可能因为没有被访问，而一直无法释放，造成内存的浪费，有内存泄漏的风险</strong>。</li>
</ul>
</li>
<li><strong>定期删除</strong> - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。定期删除策略的难点是删除操作执行的时长和频率。<ul>
<li>执行太频或执行时间过长，就会出现和定时删除相同的问题；</li>
<li>执行太少或执行时间过短，就会出现和惰性删除相同的问题；</li>
</ul>
</li>
</ul>
<h3 id="【中等】Redis-有哪些内存淘汰策略？"><a href="#【中等】Redis-有哪些内存淘汰策略？" class="headerlink" title="【中等】Redis 有哪些内存淘汰策略？"></a>【中等】Redis 有哪些内存淘汰策略？</h3><blockquote>
<ul>
<li>Redis 内存不足时，怎么办？</li>
<li>Redis 有哪些内存淘汰策略？</li>
<li>如何选择内存淘汰策略？</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Redis 内存淘汰要点</strong></p>
</blockquote>
<ul>
<li><strong>失效时间</strong> - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，<code>EXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIRE</code>、<code>PEXPIREAT</code> 以及 <code>SETEX</code> 和 <code>PSETEX</code> 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。</li>
<li><strong>最大缓存</strong> - Redis 允许通过 <code>maxmemory</code> 参数来设置内存最大值。当内存达设定的阀值，就会触发<strong>内存淘汰</strong>。</li>
<li><strong>内存淘汰</strong> - 内存淘汰是为了更好的利用内存——清理部分缓存，以此换取内存的利用率，即尽量保证 Redis 缓存中存储的是热点数据。</li>
</ul>
<blockquote>
<p><strong>Redis 内存淘汰策略</strong></p>
</blockquote>
<ul>
<li><strong>不淘汰</strong><ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
</ul>
</li>
<li><strong>在过期键中进行淘汰</strong><ul>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-lfu</code></strong> （Redis 4.0 新增）- 淘汰所有设置了过期时间的键值中，最少使用的键值。</li>
</ul>
</li>
<li><strong>在所有键中进行淘汰</strong><ul>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-lfu</code></strong> (Redis 4.0 新增） - 淘汰整个键值中最少使用的键值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何选择内存淘汰策略</p>
</blockquote>
<ul>
<li>如果数据呈现正态分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>。</li>
<li>如果数据呈现平均分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li>若 Redis 既用于缓存，也用于持久化存储时，适用 <code>volatile-lru</code> 、<code>volatile-lfu</code>、<code>volatile-random</code>。但是，这种情况下，也可以部署两个 Redis 集群来达到同样目的。</li>
<li>为 key 设置过期时间实际上会消耗更多的内存。因此，如果条件允许，建议使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>，从而更高效的使用内存。</li>
</ul>
<h3 id="【中等】Redis-持久化时，对过期键会如何处理？"><a href="#【中等】Redis-持久化时，对过期键会如何处理？" class="headerlink" title="【中等】Redis 持久化时，对过期键会如何处理？"></a>【中等】Redis 持久化时，对过期键会如何处理？</h3><p><strong>RDB 持久化</strong></p>
<ul>
<li><strong>RDB 文件生成阶段</strong> - 从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键“不会”被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li>
<li><strong>RDB 加载阶段</strong> - RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul>
<li><strong>如果 Redis 是“主服务器”运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键“不会”被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li><strong>如果 Redis 是“从服务器”运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p><strong>AOF 持久化</strong></p>
<ul>
<li><strong>AOF 文件写入阶段</strong> - 当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li>
<li><strong>AOF 重写阶段</strong> - 执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li>
</ul>
<h3 id="【中等】Redis-主从复制时，对过期键会如何处理？"><a href="#【中等】Redis-主从复制时，对过期键会如何处理？" class="headerlink" title="【中等】Redis 主从复制时，对过期键会如何处理？"></a>【中等】Redis 主从复制时，对过期键会如何处理？</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="【中等】Redis-中的内存碎片化是什么？如何进行优化？"><a href="#【中等】Redis-中的内存碎片化是什么？如何进行优化？" class="headerlink" title="【中等】Redis 中的内存碎片化是什么？如何进行优化？"></a>【中等】Redis 中的内存碎片化是什么？如何进行优化？</h3><p>Redis 内存碎片化是指已分配的内存无法被有效利用，导致内存浪费的现象。</p>
<p>可以通过 Redis 的 <code>INFO memory</code> 命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_fragmentation_ratio: 1.86  # 大于 1.5 表示碎片较多</span><br></pre></td></tr></table></figure>

<p><strong>内存碎片的原因</strong>：</p>
<ul>
<li><strong>内存分配器机制</strong> - Redis 使用 Jemalloc 或 glibc 的 malloc 等内存分配器，这些分配器为了性能不会总是精确分配请求的大小，可能分配稍大的块。</li>
<li><strong>键值对频繁修改</strong> - 当键值对被频繁修改（特别是大小变化时），旧的内存空间可能无法重用。例如：字符串值从 128B 改为 256B，原空间不够需要新分配。</li>
<li><strong>键过期&#x2F;删除</strong> - 删除键释放的内存块可能无法与相邻空闲块合并，这些碎片空间可能无法满足新的大内存请求。</li>
<li><strong>不同大小的数据混合存储</strong> - Redis 存储各种大小的键值对，导致内存中出现大小不一的空闲块。</li>
</ul>
<p><strong>内存碎片的影响</strong>：</p>
<ul>
<li><strong>内存分配策略</strong>：不同的分配器 (Jemalloc&#x2F;libc 等）碎片率不同</li>
<li><strong>工作负载模式</strong>：频繁修改和删除操作会增加碎片</li>
<li><strong>数据大小分布</strong>：大小差异大的数据混合存储更容易产生碎片</li>
</ul>
<p><strong>内存碎片的解决</strong>：</p>
<ul>
<li>重启 Redis（会丢失数据）</li>
<li>使用 <code>MEMORY PURGE</code> 命令（需要特定分配器支持）</li>
<li>配置合理的 maxmemory 和淘汰策略</li>
<li>对于高碎片环境，可考虑使用 Redis 4.0+ 的主动碎片整理功能</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="【中等】Redis-支持哪些持久化方式？"><a href="#【中等】Redis-支持哪些持久化方式？" class="headerlink" title="【中等】Redis 支持哪些持久化方式？"></a>【中等】Redis 支持哪些持久化方式？</h3><p>为了追求性能，Redis 的读写都是在内存中完成的。一旦重启，内存中的数据就会清空，为了保证数据不丢失，Redis 支持持久化机制。</p>
<p>Redis 有三种持久化方式</p>
<ul>
<li>RDB 快照</li>
<li>AOF 日志</li>
<li>混合持久化</li>
</ul>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><blockquote>
<ul>
<li>RDB 的实现原理是什么？</li>
<li>生成 RDB 快照时，Redis 可以响应请求吗？</li>
</ul>
</blockquote>
<p>有两个 Redis 命令可以用于生成 RDB 文件：<a target="_blank" rel="noopener" href="https://redis.io/commands/save"><strong><code>SAVE</code></strong></a> 和 <a target="_blank" rel="noopener" href="https://redis.io/commands/bgsave"><strong><code>BGSAVE</code></strong></a>。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/save"><strong><code>SAVE</code></strong></a> 命令由服务器进程直接执行保存操作，直到 RDB 创建完成为止。所以<strong>该命令“会阻塞”服务器</strong>，在阻塞期间，服务器不能响应任何命令请求。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/bgsave"><strong><code>BGSAVE</code></strong></a> 命令会<strong>派生</strong>（fork）一个子进程，由子进程负责创建 RDB 文件，服务器进程继续处理命令请求，所以<strong>该命令“不会阻塞”服务器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503272238061.png"></p>
<blockquote>
<p>🔔 <strong>【注意】</strong></p>
<p><code>BGSAVE</code> 命令的实现采用的是写时复制技术（Copy-On-Write，缩写为 CoW）。</p>
<p><code>BGSAVE</code> 命令执行期间，<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code> 三个命令会被拒绝，以免与当前的 <code>BGSAVE</code> 操作产生竞态条件，降低性能。</p>
</blockquote>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><blockquote>
<ul>
<li>AOF 的实现原理是什么？</li>
<li>为什么先执行命令，再把数据写入日志呢？</li>
</ul>
</blockquote>
<p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p>AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><strong>命令追加</strong> - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。</li>
<li><strong>文件写入</strong>和<strong>文件同步</strong><ul>
<li>Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行想 <code>serverCron</code> 这样的定时运行的函数。</li>
<li>因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 <code>appendfsync</code> 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。</li>
</ul>
</li>
</ul>
<p>先执行命令，再把数据写入 AOF 日志有两个好处：</p>
<ul>
<li><strong>避免额外的检查开销</strong></li>
<li><strong>不会阻塞当前写操作命令的执行</strong></li>
</ul>
<p>当然，这样做也会有弊端：</p>
<ul>
<li><strong>数据可能会丢失：</strong></li>
<li><strong>可能阻塞其他操作：</strong></li>
</ul>
<p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p><code>appendfsync</code> 不同选项决定了不同的持久化行为：</p>
<ul>
<li><strong><code>always</code></strong> - 将 AOF 缓冲区中所有内容写入并同步到 AOF 文件。这种方式是最数据最安全的，但也是性能最差的。</li>
<li><strong><code>no</code></strong> - 将 AOF 缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。这种方式是数据最不安全的，一旦出现故障，未来得及同步的所有数据都会丢失。</li>
<li><strong><code>everysec</code></strong> - <code>appendfsync</code> 默认选项。将 AOF 缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。这张方式是前面两种的这种方案——性能足够好，且即使出现故障，仅丢失一秒钟内的数据。</li>
</ul>
<p><code>appendfsync</code> 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。</p>
<h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p>Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p><strong>混合持久化的工作机制</strong></p>
<ul>
<li><strong>触发时机</strong>：在 AOF 重写过程中启用。</li>
<li><strong>执行流程</strong>：<ol>
<li><strong>子进程</strong>将共享内存数据以 <strong>RDB 格式</strong>写入 AOF 文件（全量数据）。</li>
<li><strong>主线程</strong>将操作命令记录到重写缓冲区，再以 <strong>AOF 格式</strong>追加到 AOF 文件（增量数据）。</li>
<li>替换旧 AOF 文件，新文件包含 <strong>RDB（前半部分） + AOF（后半部分）</strong>。</li>
</ol>
</li>
</ul>
<p><strong>混合持久化的优点</strong></p>
<ul>
<li><strong>重启速度快</strong>：优先加载 RDB 部分（全量数据恢复快）。</li>
<li><strong>数据丢失少</strong>：后续加载 AOF 部分（增量数据补充）。</li>
</ul>
<p><strong>混合持久化的缺点</strong></p>
<ul>
<li><strong>可读性差</strong>：AOF 文件包含二进制 RDB 数据，不易阅读。</li>
<li><strong>兼容性差</strong>：仅支持 Redis 4.0+ 版本，旧版本无法识别。</li>
</ul>
<h3 id="【中等】AOF-的重写机制是怎样的？"><a href="#【中等】AOF-的重写机制是怎样的？" class="headerlink" title="【中等】AOF 的重写机制是怎样的？"></a>【中等】AOF 的重写机制是怎样的？</h3><ul>
<li>AOF 日志过大时，怎么办？</li>
<li>AOF 重写流程是怎样的？</li>
<li>AOF 重写时，可以处理请求吗？</li>
</ul>
<p><strong>知识点</strong></p>
<p>当 AOF 日志过大时，恢复过程就会很久。为了避免此问题，Redis 提供了 AOF 重写机制，即 AOF 日志大小超过所设阈值后，启动 AOF 重写，压缩 AOF 文件。</p>
<p>AOF 重写机制是，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 日志中，等到全部记录完成后，就使用新的 AOF 日志替换现有的 AOF 日志。</p>
<p>作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 <code>BGREWRITEAOF</code> 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 <code>BGSAVE</code> 原理类似。</p>
<ul>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</li>
<li>由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503272248959.png"></p>
<h2 id="Redis-批处理"><a href="#Redis-批处理" class="headerlink" title="Redis 批处理"></a>Redis 批处理</h2><h3 id="【中等】Redis-支持事务吗？"><a href="#【中等】Redis-支持事务吗？" class="headerlink" title="【中等】Redis 支持事务吗？"></a>【中等】Redis 支持事务吗？</h3><p>::: info Redis 支持事务吗？</p>
<p>:::</p>
<p>Redis 支持事务。<a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a>、<a target="_blank" rel="noopener" href="https://redis.io/commands/exec"><code>EXEC</code></a>、<a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code></a> 和 <a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code></a> 是 Redis 事务相关的命令。</p>
<p><strong><a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令用于开启一个事务，它总是返回 OK。</strong><code>MULTI</code> 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</p>
<p><strong><a target="_blank" rel="noopener" href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令负责触发并执行事务中的所有命令。</strong></p>
<ul>
<li>如果客户端在使用 <code>MULTI</code> 开启了一个事务之后，却因为断线而没有成功执行 <code>EXEC</code> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <code>EXEC</code> ，那么事务中的所有命令都会被执行。</li>
</ul>
<p><strong>当执行 <a target="_blank" rel="noopener" href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令时，事务会被放弃，事务队列会被清空，并且客户端会从事务状态中退出。</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令可以为 Redis 事务提供 check-and-set （CAS）行为</strong>。被 <code>WATCH</code> 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 <code>EXEC</code> 执行之前被修改了，那么整个事务都会被取消，<code>EXEC</code> 返回 <code>nil-reply</code> 来表示事务已经失败。</p>
<p><code>WATCH</code> 可以用于创建 Redis 没有内置的原子操作。</p>
<p>举个例子，以下代码实现了原创的 <code>ZPOP</code> 命令，它可以原子地弹出有序集合中分值（<code>score</code>）最小的元素：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset 0 0</span><br><span class="line">MULTI</span><br><span class="line">ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>::: info Redis 事务是严格意义的事务吗？</p>
<p>:::</p>
<p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作<strong>要么全部提交成功，要么全部失败回滚</strong>。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p><strong>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</strong></p>
<p><strong>Redis 仅支持“非严格”的事务</strong>。所谓“非严格”是指：</p>
<ul>
<li><strong>Redis 事务保证全部执行命令</strong> - Redis 事务中的多个命令会被打包到事务队列中，然后按先进先出（FIFO）的顺序执行。事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li>
<li><strong>Redis 事务不支持回滚</strong> - 如果命令执行失败不会回滚，而是会继续执行下去。</li>
</ul>
<p>Redis 官方的 <a target="_blank" rel="noopener" href="https://redis.io/docs/interact/transactions/">事务特性文档</a> 给出的不支持回滚的理由是：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<h3 id="【中等】Redis-Pipeline-能保证原子性吗？"><a href="#【中等】Redis-Pipeline-能保证原子性吗？" class="headerlink" title="【中等】Redis Pipeline 能保证原子性吗？"></a>【中等】Redis Pipeline 能保证原子性吗？</h3><p>先说结论：<strong>Redis Pipeline 不保证原子性</strong>。</p>
<p>Redis Pipeline（管道）是一种<strong>客户端技术</strong>，用于将多个 Redis 命令批量发送到服务器，减少网络往返时间（RTT），提高吞吐量。</p>
<ul>
<li><strong>传统模式</strong>：客户端发送一条命令 → 等待响应 → 再发送下一条（高延迟）。</li>
<li><strong>Pipeline 模式</strong>：客户端一次性发送多条命令 → 服务器按顺序执行 → 一次性返回所有结果（低延迟）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503272224006.jpg"></p>
<p><strong>核心特性</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>批量发送</strong></td>
<td align="left">客户端打包多条命令，一次性发送，减少网络开销</td>
</tr>
<tr>
<td align="left"><strong>非原子性</strong></td>
<td align="left">Pipeline 只是批量发送，不保证所有命令连续执行（可能被其他客户端命令打断）</td>
</tr>
<tr>
<td align="left"><strong>高性能</strong></td>
<td align="left">相比单条命令模式，吞吐量可提升 5~10 倍</td>
</tr>
<tr>
<td align="left"><strong>无回滚</strong></td>
<td align="left">如果某条命令失败，不会影响其他命令的执行</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>命令数量控制</strong>：避免单次 Pipeline 发送过多命令（建议每批 ≤ 1 万条），否则可能阻塞 Redis。</li>
<li><strong>集群模式限制</strong>：Redis Cluster 要求 Pipeline 的所有 Key 必须在<strong>同一个 Slot</strong>（可用 <code>&#123;hash_tag&#125;</code> 确保，如 <code>user:&#123;123&#125;:name</code>）。</li>
<li><strong>错误处理</strong>：Pipeline 返回的是一个列表，需逐条检查命令是否成功。</li>
<li><strong>与事务的区别</strong>：Pipeline 不保证原子性。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>✅ <strong>适合</strong>：</p>
<ul>
<li>批量写入（如日志上报、缓存预热）</li>
<li>批量查询（如获取多个 Key 的值）</li>
<li>对原子性无要求的高并发场景</li>
</ul>
<p>❌ <strong>不适合</strong>：</p>
<ul>
<li>需要事务保证原子性的操作（改用 <code>MULTI/EXEC</code>）</li>
<li>命令之间有依赖关系（如后一条命令依赖前一条的结果）</li>
</ul>
<h3 id="【中等】Redis-Lua-脚本有什么用？"><a href="#【中等】Redis-Lua-脚本有什么用？" class="headerlink" title="【中等】Redis Lua 脚本有什么用？"></a>【中等】Redis Lua 脚本有什么用？</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。Redis 的 Lua 脚本提供了一种<strong>原子性执行多个命令</strong>的方式。也就是说，一段 <strong>Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行</strong>，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>
<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>
<p>不过， Lua 脚本依然存在下面这些缺陷：</p>
<ul>
<li><strong>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销</strong>，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>
<li><strong>Redis Cluster 下 Lua 脚本的原子操作也无法保证</strong>，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。</li>
</ul>
<p>另外，Redis 7.0 新增了 <a target="_blank" rel="noopener" href="https://redis.io/docs/manual/programmability/functions-intro/">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>
<h2 id="Redis-高可用"><a href="#Redis-高可用" class="headerlink" title="Redis 高可用"></a>Redis 高可用</h2><h3 id="【中等】Redis-如何实现主从复制？"><a href="#【中等】Redis-如何实现主从复制？" class="headerlink" title="【中等】Redis 如何实现主从复制？"></a>【中等】Redis 如何实现主从复制？</h3><blockquote>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
</blockquote>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> 用于断线后重复制。<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
</li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ol>
<li>设置主从服务器</li>
<li>主从服务器建立 TCP 连接。</li>
<li>发送 PING 检查通信状态。</li>
<li>身份验证。</li>
<li>发送端口信息。</li>
<li>同步。</li>
<li>命令传播。</li>
</ol>
<p>（4）由于主从复制是<strong>异步</strong>的，具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p>
<h3 id="【中等】Redis-哨兵是如何工作的？"><a href="#【中等】Redis-哨兵是如何工作的？" class="headerlink" title="【中等】Redis 哨兵是如何工作的？"></a>【中等】Redis 哨兵是如何工作的？</h3><blockquote>
<ul>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
</blockquote>
<p>（1）Redis 主从复制模式无法自动故障转移，也就是说，一旦主服务器宕机，需要手动恢复。为了解决此问题，Redis 增加了哨兵模式（Sentinel）。</p>
<p>（2）由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282134261.png"></p>
<h3 id="【中等】Redis-集群是如何工作的？"><a href="#【中等】Redis-集群是如何工作的？" class="headerlink" title="【中等】Redis 集群是如何工作的？"></a>【中等】Redis 集群是如何工作的？</h3><p><strong>集群架构</strong></p>
<ul>
<li><strong>节点类型</strong>：<ul>
<li>主节点 (master)：负责处理槽</li>
<li>从节点 (slave)：复制主节点，主节点下线时可接管</li>
</ul>
</li>
<li><strong>节点通信</strong>：使用 Gossip 协议 (PING&#x2F;PONG&#x2F;MEET&#x2F;FAIL&#x2F;PUBLISH 消息）</li>
<li><strong>数据分区</strong>：<ul>
<li>哈希槽分配：CRC16(key) mod 16384</li>
<li>槽指派命令：CLUSTER ADDSLOTS</li>
<li>所有槽必须分配，否则集群下线</li>
</ul>
</li>
</ul>
<p><strong>关键机制</strong></p>
<ul>
<li><strong>请求路由</strong>：<ul>
<li>计算 key 所属槽</li>
<li>MOVED 错误重定向（永久重定向）</li>
<li>ASK 错误重定向（临时重定向，迁移过程中使用）</li>
</ul>
</li>
<li><strong>故障转移</strong>：<ul>
<li>故障检测：PING 消息+半数以上主节点确认为 FAIL 状态</li>
<li>选主流程：基于 Raft 协议，需要获得 N&#x2F;2+1 票</li>
<li>转移步骤：从节点升级为主节点并接管槽</li>
</ul>
</li>
<li><strong>重新分区</strong>：<ul>
<li>在线迁移槽和键值对</li>
<li>使用 redis-trib 工具操作</li>
</ul>
</li>
</ul>
<p><strong>使用限制</strong></p>
<ul>
<li><strong>功能限制</strong>：<ul>
<li>批量操作&#x2F;事务&#x2F;Pipeline&#x2F;lua 仅支持相同 slot 的 key</li>
<li>不支持多数据库（仅 db0)</li>
<li>复制结构只支持一层</li>
</ul>
</li>
<li><strong>规模限制</strong>：<ul>
<li>适合中小规模集群（几个到几十个节点）</li>
<li>Gossip 协议在大规模集群中传播效率低</li>
</ul>
</li>
</ul>
<h3 id="【困难】Redis-中的脑裂问题是如何产生的？"><a href="#【困难】Redis-中的脑裂问题是如何产生的？" class="headerlink" title="【困难】Redis 中的脑裂问题是如何产生的？"></a>【困难】Redis 中的脑裂问题是如何产生的？</h3><p>在 Redis 主从架构中，部署方式一般是“一主多从”，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程 A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在“从节点”中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
<p>总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<p>分布式系统的脑裂问题（Split-Brain Problem）是一个严重的一致性问题，通常发生在分布式系统中的节点之间失去通信或部分通信时。这个问题的名称源自脑裂的比喻，就像一个分布式系统被分成多个部分的”脑”，每个部分独立运行，而没有协调一致的方式。</p>
<p>脑裂问题通常发生在以下情况下：</p>
<ol>
<li><strong>网络分区</strong>：当分布式系统中的网络发生问题，导致节点之间无法互相通信或只能部分通信时。这可能是由于网络故障、硬件故障、防火墙配置问题等原因引起的。</li>
<li><strong>节点故障</strong>：当分布式系统的某个节点崩溃或出现故障，但其他节点无法确定该节点的状态，可能导致脑裂问题。</li>
</ol>
<p>脑裂问题的典型情况是，在网络分区或节点故障后，分布式系统的一部分节点认为另一部分节点已经不可用，因此开始采取某种措施，比如选举新的领袖或切换到备份模式。然而，在某些情况下，网络分区可能会解除，或者节点故障可能会自行修复，导致系统中存在多个独立运行的子系统，每个子系统都认为自己是正确的。</p>
<p>这种情况下，脑裂问题可能导致以下问题：</p>
<ol>
<li><strong>数据不一致性</strong>：不同子系统可能具有不同的数据状态，这可能会导致数据不一致性和冲突。</li>
<li><strong>资源冲突</strong>：如果不同的子系统尝试访问相同的资源，可能会发生资源冲突和竞争条件。</li>
<li><strong>性能问题</strong>：系统中的资源可能被多次分配，从而浪费了资源并降低了性能。</li>
</ol>
<p>为了解决脑裂问题，分布式系统通常需要采用一些机制，如投票算法、选举协议、心跳检测等，以确保在出现网络分区或节点故障时，系统能够正确地识别和处理问题，并维护一致性。这些机制可以帮助系统中的节点协同工作，避免脑裂问题的发生。然而，脑裂问题是分布式系统设计和管理中的复杂挑战之一，需要细致的规划和测试来确保系统的可靠性和稳定性。</p>
<h3 id="【困难】如何解决-Redis-中的脑裂问题？"><a href="#【困难】如何解决-Redis-中的脑裂问题？" class="headerlink" title="【困难】如何解决 Redis 中的脑裂问题？"></a>【困难】如何解决 Redis 中的脑裂问题？</h3><p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ul>
<li><code>min-slaves-to-write x</code>，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li><code>min-slaves-max-lag x</code>，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p>
<p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p>
<p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p>
<p>再来举个例子。</p>
<p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p>
<p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p>
<p>这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
<h2 id="Redis-架构"><a href="#Redis-架构" class="headerlink" title="Redis 架构"></a>Redis 架构</h2><h3 id="【中等】Redis-为什么快？"><a href="#【中等】Redis-为什么快？" class="headerlink" title="【中等】Redis 为什么快？"></a>【中等】Redis 为什么快？</h3><p>根据 <a target="_blank" rel="noopener" href="https://redis.io/docs/management/optimization/benchmarks/">Redis 官方 Benchmark</a> 文档的描述，Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503270821660.png" alt="Redis 官方 Benchmark QPS 图"></p>
<p>Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？</p>
<ul>
<li><strong>Redis 读写基于内存</strong></li>
<li><strong>IO 多路复用</strong> + <strong>读写单线程模型</strong><ul>
<li>IO 多路复用是利用 select、poll、epoll 可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</li>
<li>单线程模型避免了由于并发而产生的线程切换、锁竞争等开销。</li>
<li>由于，Redis 读写基于内存，性能很高，所以 CPU 并不是制约 Redis 性能表现的瓶颈所在。更多情况下是受到内存大小和网络 I&#x2F;O 的限制，所以 Redis 核心网络模型使用单线程并没有什么问题。</li>
</ul>
</li>
<li><strong>高效的数据结构</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503272229177.jpg"></p>
<p>图来自 <a target="_blank" rel="noopener" href="https://blog.bytebytego.com/p/why-is-redis-so-fast">Why is redis so fast?</a></p>
<blockquote>
<p><strong>扩展</strong>：<a target="_blank" rel="noopener" href="https://www.youtube.com/shorts/x8lcdDbKZto">【视频】Why is Redis so FAST</a></p>
</blockquote>
<h3 id="【中等】Redis-单线程模式是怎样的？"><a href="#【中等】Redis-单线程模式是怎样的？" class="headerlink" title="【中等】Redis 单线程模式是怎样的？"></a>【中等】Redis 单线程模式是怎样的？</h3><p>Redis 单线程模式指的是其核心网络模型为单线程模式。这个模式为 IO 多路复用+单线程读写请求，其中，IO 多路复用使得 Redis 可以同时处理多个客户端连接。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309241133046.png"></p>
<blockquote>
<p>Redis 真的只有单线程吗？</p>
</blockquote>
<p>Redis 并非真的只有单线。</p>
<ul>
<li>Redis 的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是常说 Redis 是单线程程序的原因。</li>
<li>Redis 还启动了 3 个线程来执行<strong>文件关闭</strong>、<strong>AOF 同步写</strong>和<strong>惰性删除</strong>等操作。</li>
<li>此外，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</li>
</ul>
<h3 id="【中等】Redis-6-0-之后为什么引入了多线程？"><a href="#【中等】Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="【中等】Redis 6.0 之后为什么引入了多线程？"></a>【中等】Redis 6.0 之后为什么引入了多线程？</h3><p>随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，<strong>单个主线程处理网络请求的速度跟不上底层网络硬件的速度。</strong></p>
<p>为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。但是，对于命令的执行，Redis 仍然使用单线程来处理。</p>
<p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309241148273.png"></p>
<h3 id="【中等】什么是-Redis-模块？有什么用？"><a href="#【中等】什么是-Redis-模块？有什么用？" class="headerlink" title="【中等】什么是 Redis 模块？有什么用？"></a>【中等】什么是 Redis 模块？有什么用？</h3><p>Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！</p>
<p>我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。</p>
<p>目前，被 Redis 官方推荐的 Module 有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/RediSearch/RediSearch">RediSearch</a>：用于实现搜索引擎的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RedisJSON/RedisJSON">RedisJSON</a>：用于处理 JSON 数据的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RedisGraph/RedisGraph">RedisGraph</a>：用于实现图形数据库的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RedisTimeSeries/RedisTimeSeries">RedisTimeSeries</a>：用于处理时间序列数据的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a>：用于实现布隆过滤器的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RedisAI/RedisAI">RedisAI</a>：用于执行深度学习&#x2F;机器学习模型并管理其数据的模块。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/brandur/redis-cell">RedisCell</a>：用于实现分布式限流的模块。</li>
</ul>
<p>关于 Redis 模块的详细介绍，可以查看官方文档：<a target="_blank" rel="noopener" href="https://redis.io/modules%E3%80%82">https://redis.io/modules。</a></p>
<h3 id="【困难】Redis-有哪些巧妙的设计？"><a href="#【困难】Redis-有哪些巧妙的设计？" class="headerlink" title="【困难】Redis 有哪些巧妙的设计？"></a>【困难】Redis 有哪些巧妙的设计？</h3><p>Redis 的巧妙设计体现在：</p>
<ul>
<li><strong>单线程 + 非阻塞 I&#x2F;O</strong> → 高吞吐、低延迟。</li>
<li><strong>精细优化的数据结构</strong> → 节省内存，提升访问速度。</li>
<li><strong>异步化处理</strong>（持久化、删除、复制）→ 减少主线程阻塞。</li>
<li><strong>扩展性设计</strong>（模块化、集群）→ 适应不同场景需求。</li>
</ul>
<p>Redis 作为高性能的内存数据库，有许多巧妙的设计理念和实现细节，使其在性能、简洁性和功能性之间取得平衡。以下是 Redis 的一些巧妙设计：</p>
<h4 id="单线程模型（核心命令处理）"><a href="#单线程模型（核心命令处理）" class="headerlink" title="单线程模型（核心命令处理）"></a>单线程模型（核心命令处理）</h4><p>Redis 采用<strong>单线程处理命令</strong>（6.0+ 后支持多线程 I&#x2F;O，但核心逻辑仍单线程），避免了锁竞争和上下文切换的开销，同时利用以下优化：</p>
<ul>
<li><strong>非阻塞 I&#x2F;O</strong>：基于 <code>epoll/kqueue</code> 实现高效事件驱动模型。</li>
<li><strong>纯内存操作</strong>：绝大多数操作在内存中完成，单线程即可高效处理。</li>
<li><strong>原子性保证</strong>：单线程天然支持原子操作，简化了事务、Lua 脚本等实现。</li>
</ul>
<p><strong>巧妙点</strong>：牺牲多线程并行性换取无锁设计的简单性和高性能。</p>
<h4 id="高效数据结构实现"><a href="#高效数据结构实现" class="headerlink" title="高效数据结构实现"></a>高效数据结构实现</h4><p>Redis 的核心数据结构经过高度优化：</p>
<ul>
<li>**SDS (Simple Dynamic String)**：<ul>
<li>预分配内存、惰性释放，减少内存重分配。</li>
<li>二进制安全（可存储任意数据，不像 C 字符串以 <code>\0</code> 结尾）。</li>
</ul>
</li>
<li>**压缩列表 (ziplist)**：<ul>
<li>对小数据（如短列表、小哈希）使用紧凑存储，节省内存。</li>
</ul>
</li>
<li>**快速列表 (quicklist)**：<ul>
<li>结合 <code>ziplist</code> 和双向链表，优化 <code>List</code> 的内存和访问效率。</li>
</ul>
</li>
<li>**跳跃表 (skiplist)**：<ul>
<li>实现 <code>ZSET</code>，支持 <code>O(logN)</code> 范围查询和高效插入。</li>
</ul>
</li>
<li><strong>渐进式 Rehash</strong>：<ul>
<li><code>Hash</code> 扩容时不阻塞服务，分批次迁移数据。</li>
</ul>
</li>
</ul>
<p><strong>巧妙点</strong>：针对不同场景选择最优底层结构，平衡内存和速度。</p>
<h4 id="异步持久化"><a href="#异步持久化" class="headerlink" title="异步持久化"></a>异步持久化</h4><p>Redis 提供两种持久化方式：</p>
<ul>
<li><strong>RDB （快照）</strong>：<ul>
<li><code>fork()</code> 子进程生成快照，主进程继续服务。</li>
<li>使用 <code>Copy-On-Write (COW)</code> 机制减少内存开销。</li>
</ul>
</li>
<li><strong>AOF （日志追加）</strong>：<ul>
<li>先执行命令再记录日志，避免日志错误影响数据。</li>
<li>支持 <code>AOF Rewrite</code> 压缩日志（类似 RDB 的快照逻辑）。</li>
</ul>
</li>
</ul>
<p><strong>巧妙点</strong>：通过 <code>fork()</code> + <code>COW</code> 实现后台持久化，避免阻塞主线程。</p>
<h4 id="多路复用-零拷贝"><a href="#多路复用-零拷贝" class="headerlink" title="多路复用+零拷贝"></a>多路复用+零拷贝</h4><ul>
<li><strong>I&#x2F;O 多路复用</strong>：<ul>
<li>使用 <code>epoll/kqueue</code> 监听大量连接，避免线程&#x2F;进程切换。</li>
</ul>
</li>
<li><strong>零拷贝优化</strong>：<ul>
<li>网络发送数据时，直接引用内存缓冲区，减少拷贝（如 <code>sendfile</code>）。</li>
</ul>
</li>
</ul>
<p><strong>巧妙点</strong>：最大化利用系统调用，减少 CPU 和内存开销。</p>
<h4 id="惰性删除-Lazy-Free"><a href="#惰性删除-Lazy-Free" class="headerlink" title="惰性删除 (Lazy Free)"></a>惰性删除 (Lazy Free)</h4><ul>
<li><strong>DEL 命令不立即释放内存</strong>，而是异步回收（避免大 Key 删除卡住主线程）。</li>
<li>适用于 <code>UNLINK</code>、<code>FLUSHDB ASYNC</code> 等场景。</li>
</ul>
<p><strong>巧妙点</strong>：用空间换时间，避免同步删除导致服务延迟。</p>
<h4 id="过期键的混合淘汰策略"><a href="#过期键的混合淘汰策略" class="headerlink" title="过期键的混合淘汰策略"></a>过期键的混合淘汰策略</h4><ul>
<li><strong>定期删除</strong>：随机抽查部分 Key，清理已过期的。</li>
<li><strong>惰性删除</strong>：访问 Key 时检查是否过期，再决定删除。</li>
</ul>
<p><strong>巧妙点</strong>：平衡 CPU 和内存，避免全局扫描影响性能。</p>
<h4 id="模块化设计-Redis-Modules"><a href="#模块化设计-Redis-Modules" class="headerlink" title="模块化设计 (Redis Modules)"></a>模块化设计 (Redis Modules)</h4><ul>
<li>支持动态加载模块（如 <code>RedisSearch</code>、<code>RedisGraph</code>），扩展功能而不改核心代码。</li>
</ul>
<p><strong>巧妙点</strong>：保持核心精简，通过插件机制扩展能力。</p>
<h4 id="集群分片的无中心化设计"><a href="#集群分片的无中心化设计" class="headerlink" title="集群分片的无中心化设计"></a>集群分片的无中心化设计</h4><ul>
<li><strong>Gossip 协议</strong>：节点间自动发现和状态同步。</li>
<li>**哈希槽 (Hash Slot)**：数据分片到 16384 个槽，而非一致性哈希，简化迁移。</li>
</ul>
<p><strong>巧妙点</strong>：去中心化设计，避免单点瓶颈，支持动态扩缩容。</p>
<h2 id="Redis-优化"><a href="#Redis-优化" class="headerlink" title="Redis 优化"></a>Redis 优化</h2><h3 id="【中等】为什么会有慢查询命令？"><a href="#【中等】为什么会有慢查询命令？" class="headerlink" title="【中等】为什么会有慢查询命令？"></a>【中等】为什么会有慢查询命令？</h3><p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
<p>Redis 为什么会有慢查询命令呢？</p>
<p>Redis 中的大部分命令都是 O(1) 时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</li>
<li>……</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过，这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n) 时间复杂度的命令可能会导致慢查询之外，还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>&#x2F;<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>&#x2F;<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量，m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>……</li>
</ul>
<h3 id="【中等】如何找到慢查询命令？"><a href="#【中等】如何找到慢查询命令？" class="headerlink" title="【中等】如何找到慢查询命令？"></a>【中等】如何找到慢查询命令？</h3><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志 (slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下（可以自行修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following <span class="keyword">time</span> is expressed <span class="keyword">in</span> microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to one second. Note that a negative number disables the slow <span class="built_in">log</span>, <span class="keyword">while</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a value of zero forces the logging of every <span class="built_in">command</span>.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">There is no <span class="built_in">limit</span> to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can reclaim memory used by the slow <span class="built_in">log</span> with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure>

<p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令执行耗时超过 10000 微妙（即 10 毫秒）就会被记录</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 10000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只保留最近 128 条耗时命令</span></span><br><span class="line">CONFIG SET slowlog-max-len 128</span><br></pre></td></tr></table></figure>

<p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG GET #慢日志查询</span><br><span class="line"> 1) 1) (integer) 5</span><br><span class="line">   2) (integer) 1684326682</span><br><span class="line">   3) (integer) 12000</span><br><span class="line">   4) 1) &quot;KEYS&quot;</span><br><span class="line">      2) &quot;*&quot;</span><br><span class="line">   5) &quot;172.17.0.1:61152&quot;</span><br><span class="line">   6) &quot;&quot;</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure>

<p>慢查询日志中的每个条目都由以下六个值组成：</p>
<ol>
<li>唯一渐进的日志标识符。</li>
<li>处理记录命令的 Unix 时间戳。</li>
<li>执行所需的时间量，以微秒为单位。</li>
<li>组成命令参数的数组。</li>
<li>客户端 IP 地址和端口。</li>
<li>客户端名称。</li>
</ol>
<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p>下面是其他比较常用的慢查询相关的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回慢查询命令的数量</span></span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG LEN</span><br><span class="line">(integer) 128</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空慢查询命令</span></span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG RESET</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="【中等】Redis-中的-Big-Key-问题是什么？如何解决？"><a href="#【中等】Redis-中的-Big-Key-问题是什么？如何解决？" class="headerlink" title="【中等】Redis 中的 Big Key 问题是什么？如何解决？"></a>【中等】Redis 中的 Big Key 问题是什么？如何解决？</h3><blockquote>
<p>什么是 Redis Big Key？</p>
</blockquote>
<p>Big Key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为 Big Key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000 个，或总大小超过 10MB</li>
</ul>
<blockquote>
<p>Big Key 会造成什么问题？</p>
</blockquote>
<p>Big Key 会带来以下四种影响：</p>
<ul>
<li><strong>内存分布不均</strong>：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有 Big Key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
<li><strong>命令阻塞</strong>：Redis 单线程模型，操作大 Key 耗时，阻塞其他命令。</li>
<li><strong>网络传输压力</strong>：每次获取 Big Key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>客户端超时</strong>：由于 Redis 执行命令是单线程处理，然后在操作 Big Key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
</ul>
<p><strong>解决方案</strong></p>
<p><strong>（1）开发优化</strong></p>
<ul>
<li><strong>数据压缩</strong>：存储前压缩 Value（如 Gzip、Snappy）。</li>
<li><strong>拆分大对象</strong>：将单个大 Key 拆分为多个小 Key（如 <code>user:1000:info</code> → <code>user:1000:basic</code> + <code>user:1000:details</code>）。</li>
<li><strong>优化数据结构</strong>：<ul>
<li>避免巨型 String，改用 Hash、List 等分片存储。</li>
<li>使用 <code>ziplist</code>、<code>quicklist</code> 等紧凑结构。</li>
</ul>
</li>
</ul>
<p><strong>（2）业务调整</strong></p>
<ul>
<li><strong>精简存储数据</strong>：仅保留高频访问字段（如不存用户全部信息，只存 ID + 核心字段）。</li>
<li><strong>逻辑优化</strong>：避免业务层生成大 Key（如限制缓存数据大小、分页查询）。</li>
</ul>
<p><strong>（3）数据分布优化</strong></p>
<ul>
<li><strong>集群分片</strong>：通过 Redis Cluster 分散大 Key 到不同节点。</li>
<li><strong>本地缓存</strong>：对冷数据使用本地缓存（如 Caffeine），减少 Redis 压力。</li>
</ul>
<p><strong>关键点</strong></p>
<ul>
<li><strong>预防优于治理</strong>：在设计和开发阶段规避大 Key。</li>
<li><strong>监控与巡检</strong>：通过 <code>redis-cli --bigkeys</code> 或自定义脚本定期检测大 Key。</li>
</ul>
<blockquote>
<p><strong>如何查找 Redis Big Key？</strong></p>
</blockquote>
<p><strong>（1）使用 <code>redis-cli --bigkeys</code></strong></p>
<p><strong>命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">&quot;password&quot;</span> --bigkeys</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>推荐在从节点执行</strong>（主节点执行可能阻塞业务）</li>
<li><strong>低峰期执行</strong> 或 <strong>加 <code>-i</code> 参数控制扫描间隔</strong>（如 <code>-i 0.1</code> 表示每 100ms 扫描一次）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>只能返回<strong>每种数据类型最大的 1 个 Key</strong>（无法获取 Top N）</li>
<li>对集合类型<strong>只统计元素个数</strong>，而非实际内存占用</li>
</ul>
<p><strong>（2）使用 <code>SCAN</code> + 内存分析命令</strong></p>
<p><strong>遍历所有 Key</strong>（避免 <code>KEYS *</code> 阻塞 Redis）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --scan --pattern <span class="string">&quot;*&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> key; <span class="keyword">do</span> ...; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>分析 Key 大小</strong>：</p>
<ul>
<li><strong>String</strong>：<code>STRLEN $key</code>（字节数）</li>
<li><strong>集合类型</strong>（List&#x2F;Hash&#x2F;Set&#x2F;ZSet）：<ul>
<li><strong>方法 1</strong>：<code>LLEN</code>&#x2F;<code>HLEN</code>&#x2F;<code>SCARD</code>&#x2F;<code>ZCARD</code>（元素个数 × 预估元素大小）</li>
<li><strong>方法 2</strong>（Redis 4.0+）：<code>MEMORY USAGE $key</code>（精确内存占用）</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可自定义筛选条件（如大小 Top 10）</li>
<li>精确计算内存占用</li>
</ul>
<p><strong>（3）使用 <code>RdbTools</code> 分析 RDB 文件</strong></p>
<p><strong>命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f redis.csv  <span class="comment"># 导出 &gt;10KB 的 Key 到 CSV</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>离线分析，不影响线上 Redis</li>
<li>精准统计<strong>所有 Key 的内存分布</strong></li>
</ul>
<p><strong>缺点</strong>：需要 Redis 生成 RDB 快照</p>
<p><strong>总结：3 种方法对比</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>--bigkeys</code></strong></td>
<td>快速找出最大 Key</td>
<td>简单易用</td>
<td>结果不全面</td>
</tr>
<tr>
<td><strong><code>SCAN</code>+命令</strong></td>
<td>精确分析内存</td>
<td>可定制化</td>
<td>需脚本支持</td>
</tr>
<tr>
<td><strong><code>RdbTools</code></strong></td>
<td>离线全面分析</td>
<td>精准无遗漏</td>
<td>依赖 RDB 文件</td>
</tr>
</tbody></table>
<p><strong>推荐组合</strong>：</p>
<ul>
<li>日常监控用 <code>--bigkeys</code>（低峰期执行）</li>
<li>深度分析用 <code>RdbTools</code>（定期检查 RDB）</li>
<li>排查问题时用 <code>SCAN</code>+<code>MEMORY USAGE</code>（实时精准定位）</li>
</ul>
<h3 id="【中等】如何解决-Redis-中的热点-key-问题？"><a href="#【中等】如何解决-Redis-中的热点-key-问题？" class="headerlink" title="【中等】如何解决 Redis 中的热点 key 问题？"></a>【中等】如何解决 Redis 中的热点 key 问题？</h3><p>解决 Redis 中的热点 key 问题的方法：</p>
<ul>
<li><p><strong>热点 Key 拆分</strong></p>
<ul>
<li><strong>垂直分片</strong>：<code>user:123</code> → <code>user:123:base</code> + <code>user:123:detail</code></li>
<li><strong>水平分片</strong>：<code>product:views</code> → <code>product:views:shard1</code>&#x2F;<code>shard2</code></li>
</ul>
</li>
<li><p><strong>多级缓存</strong>：CDN → 本地缓存（Caffeine&#x2F;Guava） → Redis → DB</p>
</li>
<li><p><strong>读写分离</strong>：读请求分流到从节点（配置 <code>replica-read-only yes</code>）</p>
</li>
<li><p><strong>流量控制</strong>：</p>
<ul>
<li><strong>Sentinel &#x2F; Hystrix 等流控中间件</strong></li>
<li><strong>Redis + Lua 限流</strong></li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例：每秒限 100 次访问</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;INCR&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">then</span> redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">1</span>) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> count &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据预热</strong>：定时任务提前加载热点数据到缓存</p>
</li>
<li><p><strong>负载均衡</strong>：</p>
<ul>
<li><strong>Redis Cluster</strong>：分散热点 Key 到不同节点</li>
<li><strong>代理层</strong>：Twemproxy &#x2F; Redis Proxy &#x2F; Nginx 实现负载均衡</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66">面试中关于 Redis 的问题看这篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98">advanced-java</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/bc315f0e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/bc315f0e/" class="post-title-link" itemprop="url">Redis 面试之数据类型篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 17:03:42" itemprop="dateCreated datePublished" datetime="2020-07-13T17:03:42+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-面试之数据类型篇"><a href="#Redis-面试之数据类型篇" class="headerlink" title="Redis 面试之数据类型篇"></a>Redis 面试之数据类型篇</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="【简单】Redis-支持哪些数据类型？"><a href="#【简单】Redis-支持哪些数据类型？" class="headerlink" title="【简单】Redis 支持哪些数据类型？"></a>【简单】Redis 支持哪些数据类型？</h3><ul>
<li>Redis 支持五种基本数据类型：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。</li>
<li>随着 Redis 版本升级，又陆续支持以下数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506152022430.png"></p>
<blockquote>
<p><strong>扩展</strong>：<a target="_blank" rel="noopener" href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h3 id="【简单】Redis-基础数据类型的常见命令有哪些？"><a href="#【简单】Redis-基础数据类型的常见命令有哪些？" class="headerlink" title="【简单】Redis 基础数据类型的常见命令有哪些？"></a>【简单】Redis 基础数据类型的常见命令有哪些？</h3><h4 id="String-命令"><a href="#String-命令" class="headerlink" title="String 命令"></a>String 命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET</code></td>
<td>存储一个字符串值</td>
</tr>
<tr>
<td><code>SETNX</code></td>
<td>仅当键不存在时，才存储字符串值</td>
</tr>
<tr>
<td><code>GET</code></td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td><code>MGET</code></td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td><code>INCRBY</code></td>
<td>将 key 中储存的数字加上指定的增量值</td>
</tr>
<tr>
<td><code>DECRBY</code></td>
<td>将 key 中储存的数字减去指定的减量值</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>扩展</strong>；<a target="_blank" rel="noopener" href="https://redis.io/commands#string">Redis String 类型官方命令文档</a></p>
</blockquote>
<h4 id="Hash-命令"><a href="#Hash-命令" class="headerlink" title="Hash 命令"></a>Hash 命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET</code></td>
<td>将指定字段的值设为 value</td>
</tr>
<tr>
<td><code>HGET</code></td>
<td>获取指定字段的值</td>
</tr>
<tr>
<td><code>HGETALL</code></td>
<td>获取所有键值对</td>
</tr>
<tr>
<td><code>HMSET</code></td>
<td>设置多个键值对</td>
</tr>
<tr>
<td><code>HMGET</code></td>
<td>获取所有指定字段的值</td>
</tr>
<tr>
<td><code>HDEL</code></td>
<td>删除指定字段</td>
</tr>
<tr>
<td><code>HINCRBY</code></td>
<td>为指定字段的整数值加上增量</td>
</tr>
<tr>
<td><code>HKEYS</code></td>
<td>获取所有字段</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>扩展</strong>；<a target="_blank" rel="noopener" href="https://redis.io/commands#hash">Redis Hash 类型官方命令文档</a></p>
</blockquote>
<h4 id="List-命令"><a href="#List-命令" class="headerlink" title="List 命令"></a>List 命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>RPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>LPOP</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>RPOP</code></td>
<td>从列表的右端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LRANGE</code></td>
<td>获取列表在给定范围上的所有值。</td>
</tr>
<tr>
<td><code>LINDEX</code></td>
<td>获取列表在给定位置上的单个元素。</td>
</tr>
<tr>
<td><code>LREM</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LTRIM</code></td>
<td>只保留指定区间内的元素，删除其他元素。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>扩展</strong>；<a target="_blank" rel="noopener" href="https://redis.io/commands#list">Redis List 类型官方命令文档</a></p>
</blockquote>
<h4 id="Set-命令"><a href="#Set-命令" class="headerlink" title="Set 命令"></a>Set 命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD</code></td>
<td>将给定元素添加到集合。</td>
</tr>
<tr>
<td><code>SMEMBERS</code></td>
<td>返回集合包含的所有元素。</td>
</tr>
<tr>
<td><code>SISMEMBER</code></td>
<td>检查给定元素是否存在于集合中。</td>
</tr>
<tr>
<td><code>SREM</code></td>
<td>如果给定的元素存在于集合中，那么移除这个元素。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>扩展</strong>；<a target="_blank" rel="noopener" href="https://redis.io/commands#set">Redis Set 类型官方命令文档</a></p>
</blockquote>
<h4 id="Zset-命令"><a href="#Zset-命令" class="headerlink" title="Zset 命令"></a>Zset 命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD</code></td>
<td>将一个带有给定分值的成员添加到有序集合里面</td>
</tr>
<tr>
<td><code>ZRANGE</code></td>
<td>顺序排序，并返回指定排名区间的成员</td>
</tr>
<tr>
<td><code>ZREVRANGE</code></td>
<td>反序排序，并返回指定排名区间的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE</code></td>
<td>顺序排序，并返回指定排名区间的成员及其分值</td>
</tr>
<tr>
<td><code>ZREVRANGEBYSCORE</code></td>
<td>反序排序，并返回指定排名区间的成员及其分值</td>
</tr>
<tr>
<td><code>ZREM</code></td>
<td>移除指定的成员</td>
</tr>
<tr>
<td><code>ZSCORE</code></td>
<td>返回指定成员的分值</td>
</tr>
<tr>
<td><code>ZCARD</code></td>
<td>返回所有成员数</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>扩展</strong>；<a target="_blank" rel="noopener" href="https://redis.io/commands#sorted_set">Redis ZSet 类型官方命令文档</a></p>
</blockquote>
<h3 id="【中等】Redis-各数据类型的应用场景？"><a href="#【中等】Redis-各数据类型的应用场景？" class="headerlink" title="【中等】Redis 各数据类型的应用场景？"></a>【中等】Redis 各数据类型的应用场景？</h3><ul>
<li><strong>String（字符串）</strong> - 缓存对象、分布式 Session、分布式锁、计数器、限流器、分布式 ID 等。</li>
<li><strong>Hash（哈希）</strong> - 缓存对象、购物车等。</li>
<li><strong>List（列表）</strong> - 消息队列</li>
<li><strong>Set（集合）</strong> - 聚合计算（并集、交集、差集），如点赞、共同关注、抽奖活动等。</li>
<li><strong>Zset（有序集合）</strong> - 排序场景，如排行榜、电话和姓名排序等。</li>
<li><strong>BitMap</strong>（2.2 版新增） - 二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li><strong>HyperLogLog</strong>（2.8 版新增） - 海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li><strong>GEO</strong>（3.2 版新增） - 存储地理位置信息的场景，比如滴滴叫车；</li>
<li><strong>Stream</strong>（5.0 版新增） - 消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309232144470.jpg"></p>
<h3 id="【困难】Redis-基础数据类型的底层实现是怎样的？"><a href="#【困难】Redis-基础数据类型的底层实现是怎样的？" class="headerlink" title="【困难】Redis 基础数据类型的底层实现是怎样的？"></a>【困难】Redis 基础数据类型的底层实现是怎样的？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/202506152022257.png"></p>
<ul>
<li><strong>String 类型</strong> - String 类型的底层数据结构是 SDS。SDS 是 Redis 针对字符串类型的优化，具有以下特性：<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
</ul>
</li>
<li><strong>List 类型</strong> - 列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code>。当列表对象可以同时满足以下两个条件时，列表对象使用 <code>ziplist</code> 编码；否则，使用 <code>linkedlist</code> 编码。<ul>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Hash 类型</strong> - 哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code>。当哈希对象同时满足以下两个条件时，使用 <code>ziplist</code> 编码；否则，使用 <code>hashtable</code> 编码。<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Set 类型</strong> - 集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code>。当集合对象可以同时满足以下两个条件时，集合对象使用 <code>intset</code> 编码；否则，使用 <code>hashtable</code> 编码。<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Zset 类型</strong> - 有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code>。当有序集合对象可以同时满足以下两个条件时，有序集合对象使用 <code>ziplist</code> 编码；否则，使用 <code>skiplist</code> 编码。<ul>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ul>
</li>
</ul>
<h3 id="【困难】Redis-为什么用-listpack-替代-ziplist？"><a href="#【困难】Redis-为什么用-listpack-替代-ziplist？" class="headerlink" title="【困难】Redis 为什么用 listpack 替代 ziplist？"></a>【困难】Redis 为什么用 <code>listpack</code> 替代 <code>ziplist</code>？</h3><p>**<code>listpack</code> 是 Redis 5.0 引入的优化结构，用来替代 <code>ziplist</code>**，作为 <code>hash</code>、<code>list</code>、<code>zset</code> 数据类型的实现编码之一。</p>
<p>二者对比如下：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ziplist</code></th>
<th align="left"><code>listpack</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>级联更新</strong></td>
<td align="left">可能发生（最坏 <code>O(n)</code>）</td>
<td align="left">完全避免（稳定 <code>O(1)</code>）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">预留空间可能浪费</td>
<td align="left">按需分配，更紧凑</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">需手动校验边界</td>
<td align="left">内置长度校验，防溢出</td>
</tr>
<tr>
<td align="left"><strong>版本</strong></td>
<td align="left">Redis 旧版本</td>
<td align="left">Redis 5.0+ 的 Hash、ZSet 等</td>
</tr>
</tbody></table>
<p><strong><code>ziplist</code> 的缺陷</strong></p>
<ul>
<li><strong>级联更新问题</strong> - 当修改或删除中间某个元素时，可能引发后续所有节点的内存重分配（因为 <code>ziplist</code> 用 <strong>前驱节点长度</strong> 定位数据）。最坏情况下时间复杂度从 <code>O(1)</code> 退化到 <code>O(n)</code>，影响性能。</li>
<li><strong>内存浪费</strong> - <code>ziplist</code> 为每个节点预留 <strong>1~5 字节</strong> 存储前驱节点长度（即使实际不需要这么多空间）。对于短小的数据（如小整数），存储开销比例过高。</li>
<li><strong>安全性风险</strong> - <code>ziplist</code> 对内存布局的强依赖可能导致 <strong>缓冲区溢出</strong>（需严格校验边界）。</li>
</ul>
<p><strong><code>listpack</code> 的改进</strong></p>
<ul>
<li><strong>消除级联更新</strong> - 每个节点 <strong>独立存储自身长度</strong>（不再依赖前驱节点）。修改任意节点仅影响当前节点，时间复杂度稳定为 <code>O(1)</code>。</li>
<li><strong>更紧凑的内存布局</strong> - 节点长度字段采用 <strong>变长编码</strong>（类似 Protobuf 的 Varint），根据实际需求分配 1~5 字节。存储小整数时，长度字段仅需 1 字节。</li>
<li><strong>更强的安全性</strong> - 每个节点记录 <strong>总长度</strong> 和 <strong>校验字段</strong>，避免解析越界。</li>
<li><strong>兼容性与平滑替换</strong> - <code>listpack</code> 的 API 设计兼容 <code>ziplist</code>，Redis 内部可无缝迁移（如 Hash、ZSet 的底层实现）。</li>
</ul>
<h3 id="【困难】为什么-Zset-用跳表实现而不是红黑树、B-树？"><a href="#【困难】为什么-Zset-用跳表实现而不是红黑树、B-树？" class="headerlink" title="【困难】为什么 Zset 用跳表实现而不是红黑树、B+树？"></a>【困难】为什么 Zset 用跳表实现而不是红黑树、B+树？</h3><ul>
<li><strong>实现简单性</strong><ul>
<li>跳表的实现比红黑树简单得多，代码更易于维护和调试。</li>
<li>红黑树需要处理复杂的旋转和重新平衡操作，而跳表的平衡是通过概率实现的。</li>
</ul>
</li>
<li><strong>范围查询效率</strong><ul>
<li>跳表在范围查询（如 <code>zrange</code>）上表现优异，因为它是基于链表的结构，可以线性遍历。</li>
<li>红黑树进行范围查询需要中序遍历，相对复杂。</li>
<li>B+树虽然也擅长范围查询，但实现复杂度更高。</li>
</ul>
</li>
<li><strong>并发性能</strong><ul>
<li>跳表更容易实现<strong>无锁并发</strong>操作 (Redis 虽然是单线程，但考虑未来扩展）</li>
<li>红黑树的平衡操作涉及大量指针修改，难以实现高效的并发控制</li>
</ul>
</li>
<li><strong>内存效率</strong><ul>
<li>跳表不需要像 B+ 树那样维护严格的树形结构，内存使用更灵活</li>
<li>B+树的节点通常设计为填满一定比例，可能造成内存浪费</li>
</ul>
</li>
<li><strong>性能平衡</strong><ul>
<li>跳表的查询、插入、删除操作时间复杂度都是 O(logN)，与红黑树相当</li>
<li>跳表的实际性能在实践中表现良好，特别是对于内存数据结构</li>
</ul>
</li>
<li>Redis 的特殊需求<ul>
<li>Redis 的 Zset 需要同时支持按 score 和按 member 查询，跳表+哈希表的组合完美满足这一需求</li>
<li>Redis 是内存数据库，不需要考虑 B+树针对磁盘 I&#x2F;O 优化的特性</li>
</ul>
</li>
</ul>
<h3 id="【困难】跳表的实现原理是什么？"><a href="#【困难】跳表的实现原理是什么？" class="headerlink" title="【困难】跳表的实现原理是什么？"></a>【困难】跳表的实现原理是什么？</h3><p>跳表是一种可以实现二分查找的有序链表，通过多级索引提升查找效率。跳表的查找、插入、删除操作的时间复杂度均为 O(log n)，与平衡二叉树（如红黑树）接近。</p>
<p>对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 <code>O(log n)</code>。</p>
<p>但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 <code>O(n)</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323113532.png"></p>
<p>如何提高链表的查找效率呢？</p>
<p>我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作<strong>索引</strong>或<strong>索引层</strong>。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作<strong>跳表</strong>（Skip list）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155309.png"></p>
<p>随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155346.png"></p>
<p>随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323114408.png"></p>
<p><strong>跳表的时间复杂度</strong></p>
<ul>
<li><strong>查找</strong>：从最高级索引开始逐层下沉，每层最多遍历 3 个节点，时间复杂度为 <code>O(log n)</code>。</li>
<li><strong>插入</strong>：先查找插入位置（<code>O(log n)</code>），再随机生成索引层级（<code>O(log n)</code>），总时间复杂度为 <code>O(log n)</code>。</li>
<li><strong>删除</strong>：类似查找过程，删除节点及其索引（<code>O(log n)</code>）。</li>
</ul>
<p><strong>跳表的空间复杂度</strong></p>
<ul>
<li>索引节点总数为 <code>n/2 + n/4 + n/8 + … ≈ n</code>，空间复杂度为 **O(n)**。</li>
<li>可通过调整索引密度（如每 3 个节点抽 1 个）减少空间占用，但会牺牲部分查找效率。</li>
</ul>
<h3 id="【困难】Redis-利用什么机制来实现各种数据结构？"><a href="#【困难】Redis-利用什么机制来实现各种数据结构？" class="headerlink" title="【困难】Redis 利用什么机制来实现各种数据结构？"></a>【困难】Redis 利用什么机制来实现各种数据结构？</h3><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。</p>
<p>Redis 数据库中的每个键值对的键和值都是一个对象。Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</p>
<p>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</p>
<h4 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h4><p><strong>Redis 使用对象来表示数据库中的键和值</strong>。每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>Redis 中的每个对象都由一个 <code>redisObject</code> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的 <code>type</code> 属性记录了对象的类型，有以下类型：</p>
<table>
<thead>
<tr>
<th align="left">对象</th>
<th align="left">对象 <code>type</code> 属性的值</th>
<th align="left">TYPE 命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串对象</td>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td align="left">列表对象</td>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>&quot;list&quot;</code></td>
</tr>
<tr>
<td align="left">哈希对象</td>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>&quot;hash&quot;</code></td>
</tr>
<tr>
<td align="left">集合对象</td>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>&quot;set&quot;</code></td>
</tr>
<tr>
<td align="left">有序集合对象</td>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>&quot;zset&quot;</code></td>
</tr>
</tbody></table>
<p>Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<h4 id="对象的编码"><a href="#对象的编码" class="headerlink" title="对象的编码"></a>对象的编码</h4><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现。</p>
<p>Redis 中每种类型的对象都至少使用了两种不同的编码，<strong>不同的编码可以在不同的使用场景上优化对象的使用效率</strong>。</p>
<p>Redis 支持的编码如下所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码</th>
<th align="left">对象</th>
<th><strong>OBJECT ENCODING</strong> <strong>命令输出</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_INT</code></td>
<td align="left">使用整数值实现的字符串对象。</td>
<td>“int”</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td align="left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
<td>“embstr”</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_RAW</code></td>
<td align="left">使用简单动态字符串实现的字符串对象。</td>
<td>“raw”</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的列表对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td align="left">使用双端链表实现的列表对象。</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的哈希对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的哈希对象。</td>
<td>“hashtable”</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_INTSET</code></td>
<td align="left">使用整数集合实现的集合对象。</td>
<td>“intset”</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的集合对象。</td>
<td>“hashtable”</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的有序集合对象。</td>
<td>“ziplist”</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td align="left">使用跳表和字典实现的有序集合对象。</td>
<td>“skiplist”</td>
</tr>
</tbody></table>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>由于 C 语言不支持内存回收，Redis 内部实现了一套基于引用计数的内存回收机制。</p>
<p>每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录。当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</p>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>Redis 会在初始化服务器时， 共享值为 <code>0</code> 到 <code>9999</code></p>
<h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p><code>redisObject</code> 的 <code>lru</code> 属性记录了对象最后一次被命令程序访问的时间。</p>
<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<h3 id="【中等】如何使用-Redis-实现排行榜？"><a href="#【中等】如何使用-Redis-实现排行榜？" class="headerlink" title="【中等】如何使用 Redis 实现排行榜？"></a>【中等】如何使用 Redis 实现排行榜？</h3><p>各种排行榜，如：内容平台（视频、歌曲、文章）的播放量&#x2F;收藏量&#x2F;评分排行榜；电商网站的销售排行榜等等，都可以基于 Redis zset 类型来实现。</p>
<p>我们以博文点赞排名为例，dunwu 发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">article:1 文章获得了 200 个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:dunwu:ranking 200 article:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">article:2 文章获得了 40 个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:dunwu:ranking 40 article:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">article:3 文章获得了 100 个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:dunwu:ranking 100 article:3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">article:4 文章获得了 50 个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:dunwu:ranking 50 article:4</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">article:5 文章获得了 150 个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:dunwu:ranking 150 article:5</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>文章 article:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合 key 中元素 member 的分值加上 increment）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:dunwu:ranking 1 article:4</span></span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure>

<p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合 key 中元素个数）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:dunwu:ranking article:4</span></span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure>

<p>获取 dunwu 文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从 start 下标到 stop 下标的元素）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORES 表示把 score 也显示出来</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:dunwu:ranking 0 2 WITHSCORES</span></span><br><span class="line">1) &quot;article:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;article:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;article:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>获取 dunwu 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:dunwu:ranking 100 200 WITHSCORES</span></span><br><span class="line">1) &quot;article:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;article:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;article:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="【中等】如何使用-Redis-实现百万级网页-UV-计数？"><a href="#【中等】如何使用-Redis-实现百万级网页-UV-计数？" class="headerlink" title="【中等】如何使用 Redis 实现百万级网页 UV 计数？"></a>【中等】如何使用 Redis 实现百万级网页 UV 计数？</h3><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种<strong>用于“统计基数”的数据集合类型</strong>，基数统计就是指统计一个集合中不重复的元素个数。但要注意，**HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%**（统计结果为 100 万时，实际可能在 99.19 万~100.81 万之间）。</p>
<p><strong>核心优势</strong></p>
<ul>
<li><strong>极低内存占用</strong>：仅需 <strong>12 KB</strong> 内存，即可统计接近 <strong>2^64</strong> 个元素的基数（如 UV 统计）。</li>
<li><strong>适合海量数据</strong>：相比 <code>Set</code>&#x2F;<code>Hash</code>（元素越多内存消耗越大），HyperLogLog 在<strong>百万级以上数据</strong>场景中优势显著。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>网页 UV 统计</strong>：统计独立访客数（如 <code>page1:uv</code>），尤其适合高并发、大数据量场景。</li>
<li><strong>容忍误差的基数统计</strong>：如热门活动页面访问量、广告点击去重等。</li>
</ul>
<p>如果需要精确统计，则需要转用 <code>Set</code> &#x2F; <code>Hash</code>，并且不得不消耗</p>
<p><strong>基本命令</strong></p>
<ul>
<li><p><strong>添加元素</strong>：<code>PFADD key element [element...]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD page1:uv user1 user2 user3  # 将用户添加到 UV 统计</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取统计值</strong>：<code>PFCOUNT key</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT page1:uv  # 返回近似 UV 数（如 100 万）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="【中等】如何使用-Redis-实现布隆过滤器？"><a href="#【中等】如何使用-Redis-实现布隆过滤器？" class="headerlink" title="【中等】如何使用 Redis 实现布隆过滤器？"></a>【中等】如何使用 Redis 实现布隆过滤器？</h3><p>布隆过滤器是一种高效的概率数据结构，常用于检测一个元素是否在一个集合中，可以有效减少数据库的查询次数，解决缓存穿透等问题。</p>
<p>可以通过以下两种方式实现布隆过滤器：</p>
<p><strong>使用位图（Bitmap）实现布隆过滤器：</strong></p>
<ul>
<li>使用 Redis 的位图结构 <code>SETBIT</code> 和 <code>GETBIT</code> 操作来实现布隆过滤器。位图本质上是一个比特数组，用于标识元素是否存在。</li>
<li>对于给定的数据，通过多个哈希函数计算位置索引，将位图中的相应位置设置为 1，表示该元素可能存在。</li>
</ul>
<p><strong>使用 RedisBloom 模块：</strong></p>
<ul>
<li>Redis 提供了一个官方模块 RedisBloom，封装了哈希函数、位图大小等操作，可以直接用于创建和管理布隆过滤器。</li>
<li>使用 <code>BF.ADD</code> 来向布隆过滤器添加元素，使用 <code>BF.EXISTS</code> 来检查某个元素是否可能存在。</li>
</ul>
<h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>Bitmap，<strong>即位图，是一串连续的二进制数组（0 和 1）</strong>，可以通过偏移量（offset）定位元素。由于 bit 是计算机中最小的单位，使用它进行储存将<strong>非常节省空间</strong>，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。例如在一个系统中，不同的用户使用单调递增的用户 ID 表示。40 亿（$$2^{32}$$ &#x3D; $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种状态，例如用户是否已登录。</p>
<p>实际上，<strong>BitMap 不是真实的数据结构，而是针对 String 实现的一组位操作</strong>。</p>
<p>由于 STRING 是二进制安全的，并且其最大长度是 512 MB，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p>
<p>【示例】判断用户是否登录</p>
<p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据，将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。</p>
<p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure>

<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>

<h4 id="RedisBloom"><a href="#RedisBloom" class="headerlink" title="RedisBloom"></a>RedisBloom</h4><p>RedisBloom 是 Redis 官方提供的模块，是一种简化的布隆过滤器实现。它提供了<strong>更高性能</strong>和<strong>更低误判率</strong>控制。</p>
<p><strong>RedisBloom 常用命令</strong></p>
<ul>
<li><code>BF.RESERVE key error_rate capacity</code>：创建布隆过滤器（指定误判率、容量）</li>
<li><code>BF.ADD key item</code>：添加元素</li>
<li><code>BF.EXISTS key item</code>：检查元素是否存在（可能误判）</li>
<li><strong>自动扩容</strong>：可动态调整数据结构以适应数据增长</li>
</ul>
<p><strong>RedisBloom 操作示例</strong></p>
<p><strong>创建</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE myBloomFilter 0.01 1000000  # 误判率 1%，容量 100 万</span><br></pre></td></tr></table></figure>

<p><strong>添加元素</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD myBloomFilter &quot;item1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>检查元素</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS myBloomFilter &quot;item1&quot;  # 返回 1（可能存在）</span><br><span class="line">BF.EXISTS myBloomFilter &quot;item2&quot;  # 返回 0（一定不存在）</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<p>RedisBloom 适合<strong>海量数据判断</strong>，且<strong>允许误判</strong>的场景：</p>
<ol>
<li><strong>爬虫</strong>：URL 去重</li>
<li><strong>黑名单</strong>：反垃圾邮件（可能误杀）</li>
<li><strong>分布式系统</strong>：优化数据查找（如 Hadoop、Cassandra）</li>
<li><strong>推荐系统</strong>：避免重复推荐</li>
</ol>
<p><strong>核心特点</strong></p>
<ul>
<li><strong>空间高效</strong>：节省存储空间</li>
<li><strong>快速查询</strong>：O(1) 时间复杂度</li>
<li><strong>误判率可控</strong>：通过参数调整</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66">面试中关于 Redis 的问题看这篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98">advanced-java</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/eea26076/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/eea26076/" class="post-title-link" itemprop="url">MySQL 存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 10:08:37" itemprop="dateCreated datePublished" datetime="2020-07-13T10:08:37+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><p>::: info 概述</p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p><strong>Server 层包括连接器、查询缓存、解析器、优化器、执行器等</strong>，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><strong>存储引擎层负责数据的存储和提取</strong>。MySQL 的存储引擎采用了插拔式架构，可以根据需要替换。MySQL 内置了 InnoDB、MyISAM、Memory 等多个存储引擎，现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p>:::</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>在文件系统中，MySQL 将每个数据库（也可以成为 schema）保存为数据目录下的一个子目录。创建表示，MySQL 会在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体平台密切相关。Windows 中大小写不敏感；类 Unix 中大小写敏感。<strong>不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 MySQL 服务层统一处理的。</strong></p>
<p>MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p>
<h3 id="MySQL-内置的存储引擎"><a href="#MySQL-内置的存储引擎" class="headerlink" title="MySQL 内置的存储引擎"></a>MySQL 内置的存储引擎</h3><p>MySQL 内置了以下存储引擎：</p>
<ul>
<li><strong>InnoDB</strong> - InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。<ul>
<li>优点：支持<strong>事务</strong>，支持<strong>行级锁</strong>，支持<strong>外键约束</strong>等，<strong>并发性能不错</strong>且支持<strong>自动故障恢复</strong>。</li>
</ul>
</li>
<li><strong>MyISAM</strong> - MyISAM 是 MySQL 5.5 版本以前的默认存储引擎。<ul>
<li>优点：速度快，占用资源少。</li>
<li>缺点：不支持事务，不支持行级锁，不支持外键约束，也不支持自动故障恢复功能。</li>
</ul>
</li>
<li><strong>Memory</strong> - 使用系统内存作为存储介质，以便得到更快的响应速度。不过，如果 mysqld 进程崩溃，则会导致所有的数据丢失。因此，Memory 引擎常用于临时表。</li>
<li><strong>NDB</strong> - 也被称为 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li><strong>Archive</strong> - Archive 存储引擎有很好的压缩机制，非常适合用于归档数据。<ul>
<li>Archive 存储引擎只支持 <code>INSERT</code> 和 <code>SELECT</code> 操作。</li>
<li>Archive 存储引擎采用 zlib 算法压缩数据，压缩比可达到 1: 10。</li>
</ul>
</li>
<li><strong>CSV</strong> - 可以将 CSV 文件作为 MySQL 的表来处理，但这种表不支持索引。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503210712752.png"></p>
<h3 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h3><p>大多数情况下，InnoDB 都是正确的选择，除非需要用到 InnoDB 不具备的特性。</p>
<p>如果应用需要选择 InnoDB 以外的存储引擎，可以考虑以下因素：</p>
<ul>
<li>事务：如果业务场景是 OLTP，则 InnoDB 是首选存储引擎。如果不需要支持事务，且主要是 SELECT 和 INSERT 操作，MyISAM 是不错的选择。所以，如果 MySQL 部署方式为主备模式，并进行读写分离。那么可以这么做：主节点只支持写操作，默认引擎为 InnoDB；备节点只支持读操作，默认引擎为 MyISAM。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。所以，InnoDB 并发性能更高。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h2 id="存储引擎相关操作"><a href="#存储引擎相关操作" class="headerlink" title="存储引擎相关操作"></a>存储引擎相关操作</h2><h3 id="查看存储引擎命令"><a href="#查看存储引擎命令" class="headerlink" title="查看存储引擎命令"></a>查看存储引擎命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看默认的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;storage_engine&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> `table_name`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某数据库中的某表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">FROM</span> `database_name` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="设置存储引擎命令"><a href="#设置存储引擎命令" class="headerlink" title="设置存储引擎命令"></a>设置存储引擎命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎，如果不显示指定，默认是 INNODB</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> t1 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t2 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> CSV;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t3 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> MEMORY;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> t ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件 my.cnf 中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine<span class="operator">=</span>NDBCLUSTER;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="InnoDB-简介"><a href="#InnoDB-简介" class="headerlink" title="InnoDB 简介"></a>InnoDB 简介</h3><p>InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。</p>
<p>InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而<strong>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构</strong>，这棵树的叶节点 data 域保存了完整的数据记录。这个<strong>索引的 key 是数据表的主键</strong>，因此<strong>InnoDB 表数据文件本身就是主索引</strong>。</p>
<p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）防止幻读。</p>
<p>InnoDB 是基于聚簇索引建立的，与其他存储引擎有很大不同。在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p>InnoDB 物理文件结构为：</p>
<ul>
<li><code>.frm</code> 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li>
<li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。<ul>
<li>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件</li>
<li>共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li>
</ul>
</li>
</ul>
<h3 id="InnoDB-存储架构"><a href="#InnoDB-存储架构" class="headerlink" title="InnoDB 存储架构"></a>InnoDB 存储架构</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070640589.png"></p>
<p>InnoDB 存储架构分为内存结构和磁盘结构。</p>
<p>InnoDB 内存结构的核心组件有：</p>
<ul>
<li>Buffer Pool</li>
<li>Change Buffer</li>
<li>Adaptive Hash Index</li>
<li>Log Buffer</li>
</ul>
<p>InnoDB 磁盘结构的核心组件有：</p>
<ul>
<li>Tablespace</li>
<li>Doublewrite Buffer</li>
<li>redo log</li>
<li>undo log</li>
</ul>
<h3 id="InnoDB-表空间"><a href="#InnoDB-表空间" class="headerlink" title="InnoDB 表空间"></a>InnoDB 表空间</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070708733.png"></p>
<h4 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。</p>
<h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html">换一个角度看 B+ 树(opens new window)</a></p>
<p>总之知道表中的记录存储在「数据页」里面就行。</p>
<h4 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h4><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p>
<p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机 I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p>
<p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p>那具体怎么解决呢？</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合。</li>
</ul>
<p>好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。</p>
<p>之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。</p>
<h3 id="InnoDB-内存结构"><a href="#InnoDB-内存结构" class="headerlink" title="InnoDB 内存结构"></a>InnoDB 内存结构</h3><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641009.png"></p>
<p>Buffer Pool 用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，最大限度地减少磁盘 IO，加速热点数据的读和写。</p>
<p>Buffer Pool 中数据<strong>以页为存储单位</strong>，其实现数据结构是<strong>以页为单位的单链表</strong>。</p>
<p>由于内存的空间限制，Buffer Pool 仅能容纳最热点的数据。Buffer Pool 使用最近最少使用算法（Least Recent Used，LRU）算法淘汰非热点数据页。</p>
<p>依据时间局部性原理与空间局部性原理，Buffer Pool 在存储当前活动数据页的时候，会以预读 Read-ahead 的方式缓存目标数据页临近的数据页。</p>
<p>预读机制带来预读失败的问题，InnoDB <strong>采用分代机制解决预读失败问题</strong>：将 Buffer Pool 分为 New SubList 和 Old SubList 两部分，将最新读取的数据页置于 Old SubList 头部，Old SubList 中的数据再次被访问到才会置于 New SubList 头部；预读失败的冷数据将更快地从 Old SubList 中淘汰，而不会影响到 New SubList 中原有的热数据。</p>
<p>预读失败问题可以引申到缓冲池污染问题，InnoDB <strong>采用时间窗口（Time Window）机制解决缓冲池污染问题</strong>：对于 Old SubList 中的数据页，必须在 Old SubList 中停留到达指定时间之后再次被访问到，才能转移到 New SubList 中，默认窗口大小是 1s。</p>
<p>对于 Buffer Pool 中数据的查询，InnoDB 直接读取返回；对于 Buffer Pool 中数据的修改，InnoDB 直接在 Buffer Pool 中修改，并将修改写入 redo Log 中，当数据页被 LRU 算法淘汰时写入磁盘，若持久化前系统崩溃，则在重启后使用 redo Log 进行恢复。</p>
<h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641668.png"></p>
<p>Change Buffer 用于加速非热点数据中二级索引的写入操作。由于二级索引数据的不连续性，导致修改二级索引时需要进行频繁的磁盘 IO 消耗大量性能，Change Buffer 缓冲对二级索引的修改操作，同时将写操作录入 redo log 中，在缓冲到一定量或系统较空闲时进行 <code>ibuf merge</code> 操作将修改写入磁盘中。Change Buffer 在系统表空间中有相应的持久化区域。</p>
<p>Change Buffer 大小默认占 Buffer Pool 的 25%，在引擎启动时便初始化完成。其物理结构为一棵名为 <code>ibuf</code> 的 B Tree。Change Buffer 的使用条件为：</p>
<ul>
<li>InnoDB 开启 <code>innodb_change_buffering</code>，且该表当前没有 <code>flush</code> 操作。</li>
<li>仅对二级索引树的叶子节点进行修改，且该索引页不在 Buffer Pool 中。</li>
<li>对于 Unique 二级索引，仅删除操作可以缓冲。</li>
</ul>
<p>其 <code>ibuf merge</code> 时机为：</p>
<ul>
<li>用户使用该二级索引进行查询时。</li>
<li>缓存插入操作时，预估到 page 空间不足可能导致索引页分裂时。</li>
<li>本次缓存操作将导致 ibuf btree 页分裂，且分类后 Change Buffer 大小将超出限制时。</li>
<li>master 线程发起 <code>merge</code> 命令时。</li>
<li>用户对该表进行 <code>flush</code> 操作时。</li>
</ul>
<h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><p>自适应哈希索引（Adaptive Hash Index）用于实现对于热数据页的一次查询。使用聚簇索引进行数据页定位的时候需要根据索引树的高度从根节点走到叶子节点，通常需要 3 到 4 次查询才能定位数据。InnoDB 根据对索引使用情况的分析和索引字段的分析，通过自调优 Self-tuning 的方式为索引页建立或者删除哈希索引。</p>
<p>AHI 所作用的目标是频繁查询的数据页和索引页，而由于数据页是聚簇索引的一部分，因此 AHI 是建立在索引之上的索引，<strong>对于二级索引，若命中 AHI，则将直接从 AHI 获取二级索引页的记录指针，再根据主键沿着聚簇索引查找数据；若聚簇索引查询同样命中 AHI，则直接返回目标数据页的记录指针，此时就可以根据记录指针直接定位数据页</strong>。</p>
<p>AHI 的大小为 Buffer Pool 的 1&#x2F;64，再 MySql 5.7 之后支持分区，以减少对于全局 AHI 锁的竞争，默认分区数为 8。</p>
<h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><p>Log Buffer 是用于缓冲待写入磁盘日志文件的数据。InnoDB 的所有修改操作都会被写入 redo log、undo log 等日志文件，如果每次都直接写入磁盘，会引发大量 IO。Log Buffer 正是针对此进行了优化：先将修改操作缓冲于此内存区域，然后定期批量 刷新到磁盘。</p>
<p>日志缓冲区大小可以由配置 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_buffer_size"><code>innodb_log_buffer_size</code></a> 控制，默认大小为 16MB。</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 是 MySQL 5.5 版本以前的默认存储引擎。</p>
<p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。</p>
<p>MyISAM 引擎使用 B+Tree 作为索引结构，<strong>叶节点的 data 域存放的是数据记录的地址</strong>。</p>
<p>MyISAM 提供了大量的特性，包括：全文索引、压缩表、空间函数等。但是，MyISAM 不支持事务和行级锁。并且 MyISAM 不支持崩溃后的安全恢复。</p>
<p>MyISAM 物理文件结构为：</p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据。</li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。</li>
</ul>
<h2 id="InnoDB-vs-MyISAM"><a href="#InnoDB-vs-MyISAM" class="headerlink" title="InnoDB vs. MyISAM"></a>InnoDB vs. MyISAM</h2><p>InnoDB 和 MyISAM 的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持四种事务隔离级别</td>
</tr>
<tr>
<td>锁粒度</td>
<td>支持表级锁</td>
<td>支持表级锁、行级锁</td>
</tr>
<tr>
<td>索引</td>
<td>采用 B+ 树索引（非聚簇索引）</td>
<td>采用 B+ 树索引（聚簇索引）</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>计数器</td>
<td>维护了计数器，<code>SELECT COUNT(*)</code> 效率为 <code>O(1)</code></td>
<td>没有维护计数器，需要全表扫描</td>
</tr>
<tr>
<td>自动故障恢复</td>
<td>不支持</td>
<td>支持（依赖于 redo log）</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html">MySQL 官方文档之 InnoDB 存储引擎</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/storage-engines.html">MySQL 官方文档之可选的存储引擎</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/eba7ad38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/eba7ad38/" class="post-title-link" itemprop="url">Java I/O 之工具类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-30 21:34:59" itemprop="dateCreated datePublished" datetime="2020-06-30T21:34:59+08:00">2020-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-I-O-之-BIO"><a href="#Java-I-O-之-BIO" class="headerlink" title="Java I&#x2F;O 之 BIO"></a>Java I&#x2F;O 之 BIO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO（blocking IO） 即阻塞 IO。指的主要是传统的 <code>java.io</code> 包，它基于流模型实现。流从概念上来说是一个连续的数据流。当程序需要读数据的时候就需要使用输入流读取数据，当需要往外写数据的时候就需要输出流。</p>
<p><code>java.io</code> 包提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。很多时候，人们也把 java.net 下面提供的部分网络 API，比如 <code>Socket</code>、<code>ServerSocket</code>、<code>HttpURLConnection</code> 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>BIO 中操作的流主要有两大类，字节流和字符流，两类根据流的方向都可以分为输入流和输出流。</p>
<ul>
<li><strong>字节流</strong><ul>
<li>输入字节流：<code>InputStream</code></li>
<li>输出字节流：<code>OutputStream</code></li>
</ul>
</li>
<li><strong>字符流</strong><ul>
<li>输入字符流：<code>Reader</code></li>
<li>输出字符流：<code>Writer</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200219130627.png" alt="img"></p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>字节流主要操作字节数据或二进制对象。</p>
<p>字节流有两个核心抽象类：<code>InputStream</code> 和 <code>OutputStream</code>。所有的字节流类都继承自这两个抽象类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200219133627.png" alt="img"></p>
<h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p><code>InputStream</code> 常用方法：</p>
<ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 , 返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p><code>OutputStream</code> 用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<p><code>OutputStream</code> 常用方法：</p>
<ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<h4 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h4><p><code>FileOutputStream</code> 和 <code>FileInputStream</code> 提供了读写字节到文件的能力。</p>
<p>文件流操作一般步骤：</p>
<ol>
<li>使用 <code>File</code> 类绑定一个文件。</li>
<li>把 <code>File</code> 对象绑定到流对象上。</li>
<li>进行读或写操作。</li>
<li>关闭流</li>
</ol>
<p><code>FileOutputStream</code> 和 <code>FileInputStream</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILEPATH</span> <span class="operator">=</span> <span class="string">&quot;temp.log&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        write(FILEPATH);</span><br><span class="line">        read(FILEPATH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 第 1 步、使用 File 类找到一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步、通过子类实例化父类对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">        <span class="comment">// 实例化时，默认为覆盖原文件内容方式；如果添加 true 参数，则变为对原文件追加内容的方式。</span></span><br><span class="line">        <span class="comment">// OutputStream out = new FileOutputStream(f, true);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步、进行写操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        out.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步、关闭输出流</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 第 1 步、使用 File 类找到一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步、通过子类实例化父类对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步、进行读操作</span></span><br><span class="line">        <span class="comment">// 有三种读取方式，体会其差异</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.read(bytes); <span class="comment">// 读取内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读入数据的长度：&quot;</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步、关闭输入流</span></span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;内容为：\n&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存字节流"><a href="#内存字节流" class="headerlink" title="内存字节流"></a>内存字节流</h4><p><code>ByteArrayInputStream</code> 和 <code>ByteArrayOutputStream</code> 是用来完成内存的输入和输出功能。</p>
<p>内存操作流一般在生成一些临时信息时才使用。 如果临时信息保存在文件中，还需要在有效期过后删除文件，这样比较麻烦。</p>
<p><code>ByteArrayInputStream</code> 和 <code>ByteArrayOutputStream</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteArrayStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HELLOWORLD&quot;</span>; <span class="comment">// 定义一个字符串，全部由大写字母组成</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(str.getBytes());</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="comment">// 准备从内存 ByteArrayInputStream 中读取内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) temp; <span class="comment">// 读取的数字变为字符</span></span><br><span class="line">            bos.write(Character.toLowerCase(c)); <span class="comment">// 将字符变为小写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有的数据就全部都在 ByteArrayOutputStream 中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> bos.toString(); <span class="comment">// 取出内容</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h4><p>管道流的主要作用是可以进行两个线程间的通信。</p>
<p>如果要进行管道通信，则必须把 <code>PipedOutputStream</code> 连接在 <code>PipedInputStream</code> 上。为此，<code>PipedOutputStream</code> 中提供了 <code>connect()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Send</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Send</span>();</span><br><span class="line">        <span class="type">Receive</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receive</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.getPos().connect(r.getPis()); <span class="comment">// 连接管道</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(s).start(); <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Send</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">PipedOutputStream</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Send() &#123;</span><br><span class="line">            pos = <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>(); <span class="comment">// 实例化输出流</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pos.write(str.getBytes());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 得到此线程的管道输出流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PipedOutputStream <span class="title function_">getPos</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Receive</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">PipedInputStream</span> <span class="variable">pis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Receive() &#123;</span><br><span class="line">            pis = <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                len = pis.read(b);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的内容为：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 得到此线程的管道输入流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PipedInputStream <span class="title function_">getPis</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象字节流"><a href="#对象字节流" class="headerlink" title="对象字节流"></a>对象字节流</h4><p><strong>ObjectInputStream 和 ObjectOutputStream 是对象输入输出流，一般用于对象序列化。</strong></p>
<p>这里不展开叙述，想了解详细内容和示例可以参考：[Java 序列化](03.Java 序列化。md)</p>
<h4 id="数据操作流"><a href="#数据操作流" class="headerlink" title="数据操作流"></a>数据操作流</h4><p>数据操作流提供了格式化读入和输出数据的方法，分别为 <code>DataInputStream</code> 和 <code>DataOutputStream</code>。</p>
<p><code>DataInputStream</code> 和 <code>DataOutputStream</code> 格式化读写数据示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILEPATH</span> <span class="operator">=</span> <span class="string">&quot;temp.log&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        write(FILEPATH);</span><br><span class="line">        read(FILEPATH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 File 对象绑定到流对象上</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行读或写操作</span></span><br><span class="line">        String[] names = &#123; <span class="string">&quot;衬衣&quot;</span>, <span class="string">&quot;手套&quot;</span>, <span class="string">&quot;围巾&quot;</span> &#125;;</span><br><span class="line">        <span class="type">float</span>[] prices = &#123; <span class="number">98.3f</span>, <span class="number">30.3f</span>, <span class="number">50.5f</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            dos.writeChars(names[i]);</span><br><span class="line">            dos.writeChar(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            dos.writeFloat(prices[i]);</span><br><span class="line">            dos.writeChar(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            dos.writeInt(nums[i]);</span><br><span class="line">            dos.writeChar(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭流</span></span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 File 对象绑定到流对象上</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行读或写操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 接收名称</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="comment">// 接收价格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 接收数量</span></span><br><span class="line">        <span class="type">char</span>[] temp = <span class="literal">null</span>; <span class="comment">// 接收商品名称</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 保存读取数据的个数</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// &#x27;\u0000&#x27;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">200</span>]; <span class="comment">// 开辟空间</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((c = dis.readChar()) != <span class="string">&#x27;\t&#x27;</span>) &#123; <span class="comment">// 接收内容</span></span><br><span class="line">                    temp[len] = c;</span><br><span class="line">                    len++; <span class="comment">// 读取长度加 1</span></span><br><span class="line">                &#125;</span><br><span class="line">                name = <span class="keyword">new</span> <span class="title class_">String</span>(temp, <span class="number">0</span>, len); <span class="comment">// 将字符数组变为 String</span></span><br><span class="line">                price = dis.readFloat(); <span class="comment">// 读取价格</span></span><br><span class="line">                dis.readChar(); <span class="comment">// 读取、t</span></span><br><span class="line">                num = dis.readInt(); <span class="comment">// 读取 int</span></span><br><span class="line">                dis.readChar(); <span class="comment">// 读取、n</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;名称：%s；价格：%5.2f；数量：%d\n&quot;</span>, name, price, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭流</span></span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并流"><a href="#合并流" class="headerlink" title="合并流"></a>合并流</h4><p>合并流的主要功能是将多个 <code>InputStream</code> 合并为一个 <code>InputStream</code> 流。合并流的功能由 <code>SequenceInputStream</code> 完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceInputStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;temp1.log&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;temp2.log&quot;</span>);</span><br><span class="line">        <span class="type">SequenceInputStream</span> <span class="variable">sis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(is1, is2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 接收内容</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;temp3.logt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((temp = sis.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 循环输出</span></span><br><span class="line">            os.write(temp); <span class="comment">// 保存内容</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sis.close(); <span class="comment">// 关闭合并流</span></span><br><span class="line">        is1.close(); <span class="comment">// 关闭输入流 1</span></span><br><span class="line">        is2.close(); <span class="comment">// 关闭输入流 2</span></span><br><span class="line">        os.close(); <span class="comment">// 关闭输出流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流主要操作字符，一般用于处理文本数据。</p>
<p>字符流有两个核心类：<code>Reader</code> 类和 <code>Writer</code> 。所有的字符流类都继承自这两个抽象类。</p>
<h4 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h4><p>文件字符流 <code>FileReader</code> 和 <code>FileWriter</code> 可以向文件读写文本数据。</p>
<p><code>FileReader</code> 和 <code>FileWriter</code> 读写文件示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReadWriteDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILEPATH</span> <span class="operator">=</span> <span class="string">&quot;temp.log&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        write(FILEPATH);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容为：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(read(FILEPATH)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 File 对象绑定到流对象上</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);</span><br><span class="line">        <span class="comment">// Writer out = new FileWriter(f, true); // 追加内容方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行读或写操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!!!\r\n&quot;</span>;</span><br><span class="line">        out.write(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭流</span></span><br><span class="line">        <span class="comment">// 字符流操作时使用了缓冲区，并在关闭字符流时会强制将缓冲区内容输出</span></span><br><span class="line">        <span class="comment">// 如果不关闭流，则缓冲区的内容是无法输出的</span></span><br><span class="line">        <span class="comment">// 如果想在不关闭流时，将缓冲区内容输出，可以使用 flush 强制清空缓冲区</span></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] read(String filepath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 使用 File 类绑定一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 File 对象绑定到流对象上</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行读或写操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 接收每一个内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 读取内容</span></span><br><span class="line">        <span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不是-1 就表示还有内容，可以继续读取</span></span><br><span class="line">            c[len] = (<span class="type">char</span>) temp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件字符数为：&quot;</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭流</span></span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节流转换字符流"><a href="#字节流转换字符流" class="headerlink" title="字节流转换字符流"></a>字节流转换字符流</h4><p>我们可以在程序中通过 <code>InputStream</code> 和 <code>Reader</code> 从数据源中读取数据，然后也可以在程序中将数据通过 <code>OutputStream</code> 和 <code>Writer</code> 输出到目标媒介中</p>
<p>使用 <code>InputStreamReader</code> 可以将输入字节流转化为输入字符流；使用<code>OutputStreamWriter</code>可以将输出字节流转化为输出字符流。</p>
<p><code>OutputStreamWriter</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;temp.log&quot;</span>);</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f));</span><br><span class="line">        out.write(<span class="string">&quot;hello world!!&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InputStreamReader</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;temp.log&quot;</span>);</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line">        <span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> reader.read(c);</span><br><span class="line">        reader.close();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(c, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流-vs-字符流"><a href="#字节流-vs-字符流" class="headerlink" title="字节流 vs. 字符流"></a>字节流 vs. 字符流</h3><p>相同点：</p>
<p>字节流和字符流都有 <code>read()</code>、<code>write()</code>、<code>flush()</code>、<code>close()</code> 这样的方法，这决定了它们的操作方式近似。</p>
<p>不同点：</p>
<ul>
<li><strong>数据类型</strong><ul>
<li>字节流的数据是字节（二进制对象）。主要核心类是 <code>InputStream</code> 类和 <code>OutputStream</code> 类。</li>
<li>字符流的数据是字符。主要核心类是 <code>Reader</code> 类和 <code>Writer</code> 类。</li>
</ul>
</li>
<li><strong>缓冲区</strong><ul>
<li>字节流在操作时本身不会用到缓冲区（内存），是文件直接操作的。</li>
<li>字符流在操作时是使用了缓冲区，通过缓冲区再操作文件。</li>
</ul>
</li>
</ul>
<p>选择：</p>
<p>所有的文件在硬盘或传输时都是以字节方式保存的，例如图片，影音文件等都是按字节方式存储的。字符流无法读写这些文件。</p>
<p>所以，除了纯文本数据文件使用字符流以外，其他文件类型都应该使用字节流方式。</p>
<h2 id="I-O-工具类"><a href="#I-O-工具类" class="headerlink" title="I&#x2F;O 工具类"></a>I&#x2F;O 工具类</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p><code>File</code> 类是 <code>java.io</code> 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。</p>
<h4 id="createNewFille"><a href="#createNewFille" class="headerlink" title="createNewFille"></a>createNewFille</h4><p><strong>可以使用 <code>createNewFille()</code> 方法创建一个新文件</strong>。</p>
<p>注：</p>
<p>Windows 中使用反斜杠表示目录的分隔符 <code>\</code>。~~~~~~~~</p>
<p>Linux 中使用正斜杠表示目录的分隔符 <code>/</code>。</p>
<p>最好的做法是使用 <code>File.separator</code> 静态常量，可以根据所在操作系统选取对应的分隔符。</p>
<p>【示例】创建文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.createNewFile();</span><br></pre></td></tr></table></figure>

<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p><strong>可以使用 <code>mkdir()</code> 来创建文件夹</strong>，但是如果要创建的目录的父路径不存在，则无法创建成功。</p>
<p>如果要解决这个问题，可以使用 <code>mkdirs()</code>，当父路径不存在时，会连同上级目录都一并创建。</p>
<p>【示例】创建目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.mkdir();</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><strong>可以使用 <code>delete()</code> 来删除文件或目录</strong>。</p>
<p>需要注意的是，如果删除的是目录，且目录不为空，直接用 <code>delete()</code> 删除会失败。</p>
<p>【示例】删除文件或目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.delete();</span><br></pre></td></tr></table></figure>

<h4 id="list-和-listFiles"><a href="#list-和-listFiles" class="headerlink" title="list 和 listFiles"></a>list 和 listFiles</h4><p><code>File</code> 中给出了两种列出文件夹内容的方法：</p>
<ul>
<li><strong><code>list()</code>: 列出全部名称，返回一个字符串数组</strong>。</li>
<li><strong><code>listFiles()</code>: 列出完整的路径，返回一个 <code>File</code> 对象数组</strong>。</li>
</ul>
<p><code>list()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">String str[] = f.list();</span><br></pre></td></tr></table></figure>

<p><code>listFiles()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">File files[] = f.listFiles();</span><br></pre></td></tr></table></figure>

<h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><blockquote>
<p>注：<code>RandomAccessFile</code> 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。</p>
</blockquote>
<p><code>RandomAccessFile</code> 类是随机读取类，它是一个完全独立的类。</p>
<p>它适用于由大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或者修改记录。</p>
<p>文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。</p>
<h4 id="RandomAccessFile-写操作"><a href="#RandomAccessFile-写操作" class="headerlink" title="RandomAccessFile 写操作"></a>RandomAccessFile 写操作</h4><p>当用 <code>rw</code> 方式声明 <code>RandomAccessFile</code> 对象时，如果要写入的文件不存在，系统将自行创建。</p>
<p><code>r</code> 为只读；<code>w</code> 为只写；<code>rw</code> 为读写。</p>
<p>【示例】文件随机读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明 RandomAccessFile 类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 字符串长度为 8</span></span><br><span class="line">        age = <span class="number">30</span>; <span class="comment">// 数字的长度为 4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;lisi    &quot;</span>; <span class="comment">// 字符串长度为 8</span></span><br><span class="line">        age = <span class="number">31</span>; <span class="comment">// 数字的长度为 4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;wangwu  &quot;</span>; <span class="comment">// 字符串长度为 8</span></span><br><span class="line">        age = <span class="number">32</span>; <span class="comment">// 数字的长度为 4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        rdf.close(); <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RandomAccessFile-读操作"><a href="#RandomAccessFile-读操作" class="headerlink" title="RandomAccessFile 读操作"></a>RandomAccessFile 读操作</h4><p>读取是直接使用 <code>r</code> 的模式即可，以只读的方式打开文件。</p>
<p>读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);    <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="comment">// 声明 RandomAccessFile 类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;r&quot;</span>);<span class="comment">// 以只读的方式打开文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];    <span class="comment">// 开辟 byte 数组</span></span><br><span class="line">        <span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);        <span class="comment">// 跳过第一个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的 byte 数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        <span class="comment">// 读取第一个人的信息</span></span><br><span class="line">        rdf.seek(<span class="number">0</span>);    <span class="comment">// 指针回到文件的开头</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的 byte 数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);    <span class="comment">// 空出第二个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的 byte 数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第三个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.close();                <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p><code>System</code> 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 IO 的静态成员：</p>
<ul>
<li><code>System.out</code> - 一个 PrintStream 流。System.out 一般会把你写到其中的数据输出到控制台上。System.out 通常仅用在类似命令行工具的控制台程序上。System.out 也经常用于打印程序的调试信息（尽管它可能并不是获取程序调试信息的最佳方式）。</li>
<li><code>System.err</code> - 一个 PrintStream 流。System.err 与 System.out 的运行方式类似，但它更多的是用于打印错误文本。一些类似 Eclipse 的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 System.err 输出到控制台上。</li>
<li><code>System.in</code> - 一个典型的连接控制台程序和键盘输入的 InputStream 流。通常当数据通过命令行参数或者配置文件传递给命令行 Java 程序的时候，System.in 并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的 Java IO 输入机制。</li>
</ul>
<p>【示例】重定向 <code>System.out</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemOutDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;人生若只如初见，何事秋风悲画扇&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】重定向 <code>System.err</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemErrDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();        <span class="comment">// 实例化</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(bos);        <span class="comment">// 实例化</span></span><br><span class="line">        System.setErr(ps);    <span class="comment">// 输出重定向</span></span><br><span class="line">        System.err.print(<span class="string">&quot;此处有误&quot;</span>);</span><br><span class="line">        System.out.println(bos);    <span class="comment">// 输出内存中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】<code>System.in</code> 接受控制台输入信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> System.in;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) temp;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的内容为：&quot;</span> + buf);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p><strong><code>Scanner</code> 可以获取用户的输入，并对数据进行校验</strong>。</p>
<p>【示例】校验输入数据是否格式正确</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);    <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;    <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.nextInt();    <span class="comment">// 接收整数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;    <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.nextFloat();    <span class="comment">// 接收小数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入日期（yyyy-MM-dd）：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>)) &#123;    <span class="comment">// 判断</span></span><br><span class="line">            str = scan.next(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>);    <span class="comment">// 接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                date = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的日期格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入整数：20</span><br><span class="line">整数数据：20</span><br><span class="line">输入小数：3.2</span><br><span class="line">小数数据：3.2</span><br><span class="line">输入日期（yyyy-MM-dd）：1988<span class="string">-13</span><span class="string">-1</span></span><br><span class="line">输入的日期格式错误！</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><blockquote>
<p><strong><em>关键词：<code>Socket</code>、<code>ServerSocket</code>、<code>DatagramPacket</code>、<code>DatagramSocket</code></em></strong></p>
<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p>
<p><code>java.net</code> 包中提供了低层次的网络通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<p>java.net 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><strong>TCP</strong> - TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP&#x2F; IP。</li>
<li><strong>UDP</strong> - UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li>
</ul>
</blockquote>
<h3 id="Socket-和-ServerSocket"><a href="#Socket-和-ServerSocket" class="headerlink" title="Socket 和 ServerSocket"></a>Socket 和 ServerSocket</h3><p>套接字（Socket）使用 TCP 提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p><strong>Java 通过 Socket 和 ServerSocket 实现对 TCP 的支持</strong>。Java 中的 Socket 通信可以简单理解为：**<code>java.net.Socket</code> 代表客户端，<code>java.net.ServerSocket</code> 代表服务端**，二者可以建立连接，然后通信。</p>
<p>以下为 Socket 通信中建立建立的基本流程：</p>
<ul>
<li>服务器实例化一个 <code>ServerSocket</code> 对象，表示服务器绑定一个端口。</li>
<li>服务器调用 <code>ServerSocket</code> 的 <code>accept()</code> 方法，该方法将一直等待，直到客户端连接到服务器的绑定端口（即监听端口）。</li>
<li>服务器监听端口时，客户端实例化一个 <code>Socket</code> 对象，指定服务器名称和端口号来请求连接。</li>
<li><code>Socket</code> 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，<code>accept()</code> 方法返回服务器上一个新的 <code>Socket</code> 引用，该引用连接到客户端的 <code>Socket</code> 。</li>
</ul>
<p>连接建立后，可以通过使用 IO 流进行通信。每一个 <code>Socket</code> 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送，以下是一些类提供的一套完整的有用的方法来实现 sockets。</p>
<h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><p>服务器程序通过使用 <code>java.net.ServerSocket</code> 类以获取一个端口，并且监听客户端请求连接此端口的请求。</p>
<h5 id="ServerSocket-构造方法"><a href="#ServerSocket-构造方法" class="headerlink" title="ServerSocket 构造方法"></a>ServerSocket 构造方法</h5><p><code>ServerSocket</code> 有多个构造方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ServerSocket()</code></td>
<td>创建非绑定服务器套接字。</td>
</tr>
<tr>
<td><code>ServerSocket(int port)</code></td>
<td>创建绑定到特定端口的服务器套接字。</td>
</tr>
<tr>
<td><code>ServerSocket(int port, int backlog)</code></td>
<td>利用指定的 <code>backlog</code> 创建服务器套接字并将其绑定到指定的本地端口号。</td>
</tr>
<tr>
<td><code>ServerSocket(int port, int backlog, InetAddress address)</code></td>
<td>使用指定的端口、监听 <code>backlog</code> 和要绑定到的本地 IP 地址创建服务器。</td>
</tr>
</tbody></table>
<h5 id="ServerSocket-常用方法"><a href="#ServerSocket-常用方法" class="headerlink" title="ServerSocket 常用方法"></a>ServerSocket 常用方法</h5><p>创建非绑定服务器套接字。 如果 <code>ServerSocket</code> 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<p>这里有一些 <code>ServerSocket</code> 类的常用方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int getLocalPort()</code></td>
<td>返回此套接字在其上侦听的端口。</td>
</tr>
<tr>
<td><code>Socket accept()</code></td>
<td>监听并接受到此套接字的连接。</td>
</tr>
<tr>
<td><code>void setSoTimeout(int timeout)</code></td>
<td>通过指定超时值启用&#x2F;禁用 <code>SO_TIMEOUT</code>，以毫秒为单位。</td>
</tr>
<tr>
<td><code>void bind(SocketAddress host, int backlog)</code></td>
<td>将 <code>ServerSocket</code> 绑定到特定地址（IP 地址和端口号）。</td>
</tr>
</tbody></table>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p><code>java.net.Socket</code> 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 <code>Socket</code> 对象通过实例化 ，而 服务器获得一个 <code>Socket</code> 对象则通过 <code>accept()</code> 方法 a 的返回值。</p>
<h5 id="Socket-构造方法"><a href="#Socket-构造方法" class="headerlink" title="Socket 构造方法"></a>Socket 构造方法</h5><p><code>Socket</code> 类有 5 个构造方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Socket()</code></td>
<td>通过系统默认类型的 <code>SocketImpl</code> 创建未连接套接字</td>
</tr>
<tr>
<td><code>Socket(String host, int port)</code></td>
<td>创建一个流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr>
<td><code>Socket(InetAddress host, int port)</code></td>
<td>创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</td>
</tr>
<tr>
<td><code>Socket(String host, int port, InetAddress localAddress, int localPort)</code></td>
<td>创建一个套接字并将其连接到指定远程主机上的指定远程端口。</td>
</tr>
<tr>
<td><code>Socket(InetAddress host, int port, InetAddress localAddress, int localPort)</code></td>
<td>创建一个套接字并将其连接到指定远程地址上的指定远程端口。</td>
</tr>
</tbody></table>
<p>当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<h5 id="Socket-常用方法"><a href="#Socket-常用方法" class="headerlink" title="Socket 常用方法"></a>Socket 常用方法</h5><p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>void connect(SocketAddress host, int timeout)</code></td>
<td>将此套接字连接到服务器，并指定一个超时值。</td>
</tr>
<tr>
<td><code>InetAddress getInetAddress()</code></td>
<td>返回套接字连接的地址。</td>
</tr>
<tr>
<td><code>int getPort()</code></td>
<td>返回此套接字连接到的远程端口。</td>
</tr>
<tr>
<td><code>int getLocalPort()</code></td>
<td>返回此套接字绑定到的本地端口。</td>
</tr>
<tr>
<td><code>SocketAddress getRemoteSocketAddress()</code></td>
<td>返回此套接字连接的端点的地址，如果未连接则返回 null。</td>
</tr>
<tr>
<td><code>InputStream getInputStream()</code></td>
<td>返回此套接字的输入流。</td>
</tr>
<tr>
<td><code>OutputStream getOutputStream()</code></td>
<td>返回此套接字的输出流。</td>
</tr>
<tr>
<td><code>void close()</code></td>
<td>关闭此套接字。</td>
</tr>
</tbody></table>
<h4 id="Socket-通信示例"><a href="#Socket-通信示例" class="headerlink" title="Socket 通信示例"></a>Socket 通信示例</h4><p>服务端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Socket 服务端</span></span><br><span class="line">        <span class="comment">// 服务器在 8888 端口上监听</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器运行中，等待客户端连接。&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到连接，程序进入到阻塞状态</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 打印流输出最方便</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(client.getOutputStream());</span><br><span class="line">        <span class="comment">// 向客户端输出信息</span></span><br><span class="line">        out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        client.close();</span><br><span class="line">        server.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已向客户端发送消息，退出。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Socket 客户端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream());</span><br><span class="line">        <span class="comment">// 一次性接收完成</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> buf.readLine();</span><br><span class="line">        buf.close();</span><br><span class="line">        client.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到服务器消息：&quot;</span> + str + <span class="string">&quot;，退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DatagramSocket-和-DatagramPacket"><a href="#DatagramSocket-和-DatagramPacket" class="headerlink" title="DatagramSocket 和 DatagramPacket"></a>DatagramSocket 和 DatagramPacket</h3><p>Java 通过 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 实现对 UDP 协议的支持。</p>
<ul>
<li><code>DatagramPacket</code>：数据包类</li>
<li><code>DatagramSocket</code>：通信类</li>
</ul>
<p>UDP 服务端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 所有异常抛出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello World!!!&quot;</span>;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">3000</span>); <span class="comment">// 服务端在 3000 端口上等待服务器发送信息</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(str.getBytes(), str.length(), InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9000</span>); <span class="comment">// 所有的信息使用 buf 保存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送信息。&quot;</span>);</span><br><span class="line">        ds.send(dp); <span class="comment">// 发送信息出去</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP 客户端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 所有异常抛出</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 开辟空间，以接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9000</span>); <span class="comment">// 客户端在 9000 端口上等待服务器发送信息</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, <span class="number">1024</span>); <span class="comment">// 所有的信息使用 buf 保存</span></span><br><span class="line">        ds.receive(dp); <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength()) + <span class="string">&quot;from &quot;</span> + dp.getAddress().getHostAddress() + <span class="string">&quot;：&quot;</span></span><br><span class="line">            + dp.getPort();</span><br><span class="line">        System.out.println(str); <span class="comment">// 输出内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p><code>InetAddress</code> 类表示互联网协议 (IP) 地址。</p>
<p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="type">byte</span>[] address);</span><br></pre></td></tr></table></figure>

<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>可以直接从 URL 中读取字节流数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html">System 官方 API 手册</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-networking.html">Java 网络编程</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/ce17fc18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/ce17fc18/" class="post-title-link" itemprop="url">Java 虚拟机之内存区域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-28 16:19:00" itemprop="dateCreated datePublished" datetime="2020-06-28T16:19:00+08:00">2020-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-虚拟机之内存区域"><a href="#Java-虚拟机之内存区域" class="headerlink" title="Java 虚拟机之内存区域"></a>Java 虚拟机之内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202505070632861.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong> 是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p>
<blockquote>
<p>🔔 注意：程序计数器是 JVM 中没有规定任何 <code>OutOfMemoryError</code> 情况的唯一区域。</p>
</blockquote>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）</strong> 也是线程私有的，它的生命周期与线程相同。<strong>Java 虚拟机栈以方法作为最基本的执行单元，描述的是 Java 方法执行的线程内存模型</strong>。<strong>每个方法被执行的时候，JVM 都会同步创建一个栈帧（Stack Frame），栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了局部变量表、操作数栈、动态连接、方法返回地址等信息</strong>。每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>一个线程中的方法调用链可能会很长，以 Java 程序的角度来看，同一时刻、同一条线程里面，在 调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方 法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与 这个栈帧所关联的方法被称为“当前方法”（Current Method）。执行引擎所运行的所有字节码指令都只 针对当前栈帧进行操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408130821241.png"></p>
<ul>
<li><strong>局部变量表</strong> - 用于存放方法参数和方法内部定义的局部变量。</li>
<li><strong>操作数栈</strong> - 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</li>
<li><strong>动态连接</strong> - 用于一个方法调用其他方法的场景。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>；另一部分将在每一次的运行期间转化为直接应用，这部分称为<strong>动态连接</strong>。</li>
<li><strong>方法返回地址</strong> - 用于返回方法被调用的位置，恢复上层方法的局部变量和操作数栈。Java 方法有两种返回方式，一种是 <code>return</code> 语句正常返回，一种是抛出异常。无论采用何种退出方式，都会导致栈帧被弹出。也就是说，栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</li>
</ul>
<blockquote>
<p>🔔 注意：</p>
<p>该区域可能抛出以下异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>💡 提示：</p>
<p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss=512M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><strong>局部变量表（Local Variables Table）</strong>是一组变量值的存储空间，<strong>用于存放方法参数和方法内部定义的局部变量</strong>。在 Java 程序被编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
<p>局部变量表存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用（<code>reference</code> 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 <code>returnAddress</code> 类型（指向了一条字节码指令的地址）。这些数据类型在局部变量表中的存储空间以局部变量槽（Variable Slot）来表示，其中 64 位长度的 <code>long</code> 和 <code>double</code> 类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p><strong>操作数栈（Operand Stack）</strong>也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。<strong>操作数栈主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果</strong>。另外，计算过程中产生的临时变量也会放在操作数栈中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408130822600.png"></p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器 必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p>
<p>另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>用于一个方法调用其他方法的场景。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>；另一部分将在每一次的运行期间转化为直接应用，这部分称为<strong>动态连接</strong>。</p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方 法调用过程中的<strong>动态连接（Dynamic Linking）</strong>。通过第 6 章的讲解，我们知道 Class 文件的常量池中存 有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号 引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。关于这两个转化过程的 具体过程，将在 8.3 节中再详细讲解。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>方法返回地址用于返回方法被调用的位置，恢复上层方法的局部变量和操作数栈。</p>
<p>Java 方法有两种返回方式，一种是 <code>return</code> 语句正常返回，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定；一种是遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论采用何种退出方式，都会导致栈帧被弹出。也就是说，栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</p>
<p>方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。 一般来说，方法正常退出时，主调方法的 PC 计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>本地方法栈（Native Method Stack）</strong> 与虚拟机栈的作用非常相似，二者区别仅在于：<strong>虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务</strong>。</p>
<blockquote>
<p>🔔 注意：本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p><strong>Java 堆（Java Heap） 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存</strong>。</p>
<blockquote>
<p>注：由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了。</p>
</blockquote>
<p>Java 堆是垃圾收集器管理的内存区域（因此也被叫做”GC 堆”）。现代的垃圾收集器大部分都是采用<strong>分代收集理论</strong>设计的，该力量的思想是针对不同的对象采取不同的垃圾回收算法。</p>
<p>在 JDK 7 及之前版本，堆内存被通常分为下面三部分：</p>
<ul>
<li><strong><code>新生代（Young Generation）</code></strong></li>
<li><strong><code>老年代（Old Generation）</code></strong></li>
<li><strong><code>永久代（Permanent Generation）</code></strong></li>
</ul>
<p><strong>JDK 8 版本之后 PermGen（永久代） 已被 Metaspace（元空间） 取代，元空间使用的是本地内存</strong>。</p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxTenuringThreshold of 20 is invalid; must be between 0 and 15</span><br></pre></td></tr></table></figure>

<p><strong>为什么年龄只能是 0-15?</strong></p>
<p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p>
<p>这里我们简单结合对象布局来详细介绍一下。</p>
<p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。其中，对象头包括两部分：标记字段（Mark Word）和类型指针（Klass Word）。关于对象内存布局的详细介绍，后文会介绍到，这里就不重复提了。</p>
<p>这个年龄信息就是在标记字段中存放的（标记字段还存放了对象自身的其他信息比如哈希码、锁状态信息等等）。</p>
<p>如果从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配效率。不过无论从什么角度，无论如何划分，都不会改变 Java 堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将 Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<blockquote>
<p>🔔 注意：Java 堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的 Java 虚拟机都是按照可扩展来实现的，扩展失败会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms=1M -Xmx=2M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）是各个线程共享的内存区域。<strong>方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。</p>
<p>在 JDK8 以前，方法区常被称为<strong>永久代</strong>，但这种说法是不准确的：仅仅是因为当时的 HotSpot 虚拟机使用永久代来实现方法区而已。对于其他虚拟机而言，是不存在永久代概念的。<strong>永久代这种设计，导致了 Java 应用更容易遇到内存溢出的问题</strong>（永久代有 <code>-XX:MaxPermSize</code> 的上限，即使不设置也有默认大小）。</p>
<ul>
<li>JDK7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，可通过参数 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置。</li>
<li>JDK8 之后，取消了永久代，用 **<code>metaspace（元空间）</code>**替代，可通过参数 <code>-XX:MaxMetaspaceSize</code> 设置。</li>
</ul>
<p>方法区的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。</p>
<blockquote>
<p>🔔 注意：方法区和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong><code>运行时常量池（Runtime Constant Pool）</code> 是方法区的一部分</strong>，Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池表（Constant Pool Table），<strong>用于存放编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后写入。</p>
<ul>
<li><strong>字面量</strong> - 文本字符串、声明为 <code>final</code> 的常量值等。</li>
<li><strong>符号引用</strong> - 类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ul>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</p>
<blockquote>
<p>🔔 注意：当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。</p>
<p>JDK4 中新加入了 NIO，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>直接内存容量可通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，则默认与 Java 堆最大值（<code>-Xmx</code> 指定）一样。</p>
<blockquote>
<p>🔔 注意：直接内存这部分也被频繁的使用，且也可能导致 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="Java-内存区域对比"><a href="#Java-内存区域对比" class="headerlink" title="Java 内存区域对比"></a>Java 内存区域对比</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th>内存作用范围</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>线程私有</td>
<td>无</td>
</tr>
<tr>
<td>Java 虚拟机栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>本地方法栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>Java 堆</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>运行时常量池</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>直接内存</td>
<td>非运行时数据区</td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当 Java 虚拟机<strong>遇到一条字节码 <code>new</code> 指令时，首先在常量池中尝试定位类的符号引用，并检查这个类是否已被类加载，如果没有，则必须先执行相应的类加载过程</strong>。</p>
<p>在类加载检查通过后，<strong>接下来虚拟机将为新生对象分配内存</strong>。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来。分配对象内存有两种方式：</p>
<p><strong>指针碰撞（Bump The Pointer）</strong> - 如果 Java 堆中<strong>内存是规整的</strong>，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408140753480.png"></p>
<p><strong>空闲列表（Free List）</strong> - 如果 Java 堆中的<strong>内存是不规整的</strong>，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202408140753926.png"></p>
<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否采用<strong>标记-压缩算法</strong>决定。因此，当使用 Serial、ParNew 等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用 CMS 这种基于清除 （Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p>
<p>对象创建在虚拟机中是非常频繁的行为，因此还需要考虑分配内存空间的并发安全问题。一般有两种方案：</p>
<ul>
<li>CAS 同步 - 对分配内存空间的动作进行同步处理——实际上虚拟机是采用 CAS 配上失败 重试的方式保证更新操作的原子性；</li>
<li>TLAB - 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为<strong>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</strong>，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li>
</ul>
<p>接下来，需要执行类的构造函数（即 <code>&lt;init&gt;()</code> 方法）对对象进行初始化。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：</p>
<ul>
<li><strong>对象头（Header）</strong> - HotSpot 虚拟机对象的对象头部分包括两类信息。<ul>
<li><strong>Mark Word</strong> - <strong>用于存储对象自身的运行时数据</strong>。如哈 希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特。</li>
<li><strong>类型指针</strong> - <strong>对象指向它的类型元数据的指针</strong>，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li>
</ul>
</li>
<li><strong>实例数据（Instance Data）</strong> - <strong>对象真正存储的有效信息</strong>，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</li>
<li><strong>对齐填充（Padding）</strong> - 并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。主流的对象访问方式主要有使用句柄和直接指针两种：使用句柄访问和使用直接指针访问。</p>
<h4 id="使用句柄访问"><a href="#使用句柄访问" class="headerlink" title="使用句柄访问"></a>使用句柄访问</h4><p>Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p>
<h4 id="使用直接指针访问"><a href="#使用直接指针访问" class="headerlink" title="使用直接指针访问"></a>使用直接指针访问</h4><p>Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot 主要使用第二种方式进行对象访问。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMCase</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">WOMAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		stu.setName(<span class="string">&quot;nick&quot;</span>);</span><br><span class="line">		stu.setSexType(MAN_SEX_TYPE);</span><br><span class="line">		stu.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">JVMCase</span> <span class="variable">jvmcase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMCase</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用静态方法</span></span><br><span class="line">		print(stu);</span><br><span class="line">		<span class="comment">// 调用非静态方法</span></span><br><span class="line">		jvmcase.sayHello(stu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常规静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;name: &quot;</span> + stu.getName() + <span class="string">&quot;; sex:&quot;</span> + stu.getSexType() + <span class="string">&quot;; age:&quot;</span> + stu.getAge());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(stu.getName() + <span class="string">&quot;say: hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sexType;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSexType</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSexType</span><span class="params">(String sexType)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.sexType = sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码时，JVM 处理过程如下：</p>
<p>（1）JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</p>
<p>（2）JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
<p>（3）class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094250.png" alt="img"></p>
<p>（4）完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <code>&lt;clinit&gt;</code> 方法，编译器会在 <code>.java</code> 文件被编译成 <code>.class</code> 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;()</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094329.png" alt="img"></p>
<p>（5）执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094651.png" alt="img"></p>
<p>（6）此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094714.png" alt="img"></p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><p><code>OutOfMemoryError</code> 简称为 OOM。Java 中对 OOM 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：JVM 内存不足了。</p>
<p>在 JVM 规范中，<strong>除了程序计数器区域外，其他运行时区域都可能发生 <code>OutOfMemoryError</code> 异常（简称 OOM）</strong>。</p>
<p>下面逐一介绍 OOM 发生场景。</p>
<h4 id="堆空间溢出"><a href="#堆空间溢出" class="headerlink" title="堆空间溢出"></a>堆空间溢出</h4><p><strong>java.lang.OutOfMemoryError: Java heap space 意味着：堆空间溢出</strong>。</p>
<p>更细致的说法是：Java 堆内存已经达到 <code>-Xmx</code> 设置的最大值。Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 OOM。</p>
<p>堆空间溢出有可能是<strong>内存泄漏（Memory Leak）</strong> 或 <strong>内存溢出（Memory Overflow）</strong> 。</p>
<h5 id="Java-heap-space-分析步骤"><a href="#Java-heap-space-分析步骤" class="headerlink" title="Java heap space 分析步骤"></a>Java heap space 分析步骤</h5><ol>
<li>使用 <code>jmap</code> 或 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 获取堆快照。</li>
<li>使用内存分析工具（VisualVM、MAT、JProfile 等）对堆快照文件进行分析。</li>
<li>根据分析图，重点是确认内存中的对象是否是必要的，分清究竟是是内存泄漏还是内存溢出。</li>
</ol>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><strong>内存泄漏（Memory Leak）是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</strong>。</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。</p>
<p>内存泄漏常见场景：</p>
<ul>
<li>静态容器<ul>
<li>声明为静态（<code>static</code>）的 <code>HashMap</code>、<code>Vector</code> 等集合</li>
<li>通俗来讲 A 中有 B，当前只把 B 设置为空，A 没有设置为空，回收时 B 无法回收。因为被 A 引用。</li>
</ul>
</li>
<li>监听器<ul>
<li>监听器被注册后释放对象时没有删除监听器</li>
</ul>
</li>
<li>物理连接<ul>
<li>各种连接池建立了连接，必须通过 <code>close()</code> 关闭链接</li>
</ul>
</li>
<li>内部类和外部模块等的引用<ul>
<li>发现它的方式同内存溢出，可再加个实时观察</li>
<li><code>jstat -gcutil 7362 2500 70</code></li>
</ul>
</li>
</ul>
<p>重点关注：</p>
<ul>
<li><code>FGC</code> — 从应用程序启动到采样时发生 Full GC 的次数。</li>
<li><code>FGCT</code> — 从应用程序启动到采样时 Full GC 所用的时间（单位秒）。</li>
<li><code>FGC</code> 次数越多，<code>FGCT</code> 所需时间越多，越有可能存在内存泄漏。</li>
</ul>
<p>如果是内存泄漏，可以进一步查看泄漏对象到 GC Roots 的对象引用链。这样就能找到泄漏对象是怎样与 GC Roots 关联并导致 GC 无法回收它们的。掌握了这些原因，就可以较准确的定位出引起内存泄漏的代码。</p>
<p>导致内存泄漏的常见原因是使用容器，且不断向容器中添加元素，但没有清理，导致容器内存不断膨胀。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存泄漏示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapMemoryLeakOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OomObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OomObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OomObject</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h5><p>如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数（<code>-Xmx</code> 和 <code>-Xms</code>），与机器物理内存进行对比，看看是否可以调大。并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆溢出示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOutOfMemoryOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Double[] array = <span class="keyword">new</span> <span class="title class_">Double</span>[<span class="number">999999999</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;array length = [&quot;</span> + array.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一个极端的例子，试图创建一个维度很大的数组，堆内存无法分配这么大的内存，从而报错：<code>Java heap space</code>。</p>
<p>但如果在现实中，代码并没有问题，仅仅是因为堆内存不足，可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h4 id="GC-开销超过限制"><a href="#GC-开销超过限制" class="headerlink" title="GC 开销超过限制"></a>GC 开销超过限制</h4><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 这个错误，官方给出的定义是：<strong>超过 <code>98%</code> 的时间用来做 GC 并且回收了不到 <code>2%</code> 的堆内存时会抛出此异常</strong>。这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC overhead limit exceeded 示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br><span class="line"><span class="comment"> * 发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</span></span><br><span class="line"><span class="comment"> * 官方对此的定义：超过 98%的时间用来做 GC 并且回收了不到 2%的堆内存时会抛出此异常。</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcOverheadLimitExceededOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(d++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>与 <strong>Java heap space</strong> 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h4 id="永久代空间不足"><a href="#永久代空间不足" class="headerlink" title="永久代空间不足"></a>永久代空间不足</h4><p>【错误】</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: PermGen space</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Perm （永久代）空间主要用于存放 <code>Class</code> 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。</p>
<p>根据上面的定义，可以得出 <strong>PermGen 大小要求取决于加载的类的数量以及此类声明的大小</strong>。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。</p>
<p>在 JDK8 之前的版本中，可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。</p>
<h5 id="初始化时永久代空间不足"><a href="#初始化时永久代空间不足" class="headerlink" title="初始化时永久代空间不足"></a>初始化时永久代空间不足</h5><p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 永久代内存空间不足示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: PermGen space (JDK8 以前版本）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: Metaspace (JDK8 及以后版本）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * VM Args:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxPermSize=16M (JDK8 以前版本）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxMetaspaceSize=16M (JDK8 及以后版本）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermGenSpaceOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_000</span>; i++) &#123;</span><br><span class="line">            generate(<span class="string">&quot;eu.plumbr.demo.Generated&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title function_">generate</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">return</span> pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，源代码遍历循环并在运行时生成类。javassist 库正在处理类生成的复杂性。</p>
<h5 id="重部署时永久代空间不足"><a href="#重部署时永久代空间不足" class="headerlink" title="重部署时永久代空间不足"></a>重部署时永久代空间不足</h5><p>对于更复杂，更实际的示例，让我们逐步介绍一下在应用程序重新部署期间发生的 PermGen 空间错误。重新部署应用程序时，你希望垃圾回收会摆脱引用所有先前加载的类的加载器，并被加载新类的类加载器取代。</p>
<p>不幸的是，许多第三方库以及对线程，JDBC 驱动程序或文件系统句柄等资源的不良处理使得无法卸载以前使用的类加载器。反过来，这意味着在每次重新部署期间，所有先前版本的类仍将驻留在 PermGen 中，从而在每次重新部署期间生成数十兆的垃圾。</p>
<p>让我们想象一个使用 JDBC 驱动程序连接到关系数据库的示例应用程序。启动应用程序时，初始化代码将加载 JDBC 驱动程序以连接到数据库。对应于规范，JDBC 驱动程序向 <code>java.sql.DriverManager</code> 进行注册。该注册包括将对驱动程序实例的引用存储在 <code>DriverManager</code> 的静态字段中。</p>
<p>现在，当从应用程序服务器取消部署应用程序时，<code>java.sql.DriverManager</code> 仍将保留该引用。我们最终获得了对驱动程序类的实时引用，而驱动程序类又保留了用于加载应用程序的 <code>java.lang.Classloader</code> 实例的引用。反过来，这意味着垃圾回收算法无法回收空间。</p>
<p>而且该 <code>java.lang.ClassLoader</code> 实例仍引用应用程序的所有类，通常在 PermGen 中占据数十兆字节。这意味着只需少量重新部署即可填充通常大小的 PermGen。</p>
<h5 id="PermGen-space-解决方案"><a href="#PermGen-space-解决方案" class="headerlink" title="PermGen space 解决方案"></a>PermGen space 解决方案</h5><p>（1）解决初始化时的 <code>OutOfMemoryError</code></p>
<p>在应用程序启动期间触发由于 PermGen 耗尽导致的 <code>OutOfMemoryError</code> 时，解决方案很简单。该应用程序仅需要更多空间才能将所有类加载到 PermGen 区域，因此我们只需要增加其大小即可。为此，更改你的应用程序启动配置并添加（或增加，如果存在）<code>-XX:MaxPermSize</code> 参数，类似于以下示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:<span class="attribute">MaxPermSize</span>=512m com.yourcompany.YourClass</span><br></pre></td></tr></table></figure>

<p>上面的配置将告诉 JVM，PermGen 可以增长到 512MB。</p>
<p>清理应用程序中 <code>WEB-INF/lib</code> 下的 jar，用不上的 jar 删除掉，多个应用公共的 jar 移动到 Tomcat 的 lib 目录，减少重复加载。</p>
<p>🔔 注意：<code>-XX:PermSize</code> 一般设为 64M</p>
<p>（2）解决重新部署时的 <code>OutOfMemoryError</code></p>
<p>重新部署应用程序后立即发生 <code>OutOfMemoryError</code> 时，应用程序会遭受类加载器泄漏的困扰。在这种情况下，解决问题的最简单，继续进行堆转储分析–使用类似于以下命令的重新部署后进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:format=b,<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用你最喜欢的堆转储分析器打开转储（Eclipse MAT 是一个很好的工具）。在分析器中可以查找重复的类，尤其是那些正在加载应用程序类的类。从那里，你需要进行所有类加载器的查找，以找到当前活动的类加载器。</p>
<p>对于非活动类加载器，你需要通过从非活动类加载器收集到 GC 根的最短路径来确定阻止它们被垃圾收集的引用。有了此信息，你将找到根本原因。如果根本原因是在第三方库中，则可以进入 Google&#x2F;StackOverflow 查看是否是已知问题以获取补丁&#x2F;解决方法。</p>
<p>（3）解决运行时 <code>OutOfMemoryError</code></p>
<p>第一步是检查是否允许 GC 从 PermGen 卸载类。在这方面，标准的 JVM 相当保守-类是天生的。因此，一旦加载，即使没有代码在使用它们，类也会保留在内存中。当应用程序动态创建许多类并且长时间不需要生成的类时，这可能会成为问题。在这种情况下，允许 JVM 卸载类定义可能会有所帮助。这可以通过在启动脚本中仅添加一个配置参数来实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+CMSClassUnloadingEnabled</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，此选项设置为 false，因此要启用此功能，你需要在 Java 选项中显式设置。如果启用 CMSClassUnloadingEnabled，GC 也会扫描 PermGen 并删除不再使用的类。请记住，只有同时使用 UseConcMarkSweepGC 时此选项才起作用。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>在确保可以卸载类并且问题仍然存在之后，你应该继续进行堆转储分析–使用类似于以下命令的方法进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof,format=b &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后，使用你最喜欢的堆转储分析器（例如 Eclipse MAT）打开转储，然后根据已加载的类数查找最昂贵的类加载器。从此类加载器中，你可以继续提取已加载的类，并按实例对此类进行排序，以使可疑对象排在首位。</p>
<p>然后，对于每个可疑者，就需要你手动将根本原因追溯到生成此类的应用程序代码。</p>
<h4 id="元数据区空间不足"><a href="#元数据区空间不足" class="headerlink" title="元数据区空间不足"></a>元数据区空间不足</h4><p>【错误】</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Exception</span> <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.<span class="built_in">OutOfMemoryError</span>: Metaspace</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Java8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。</p>
<p><strong>元数据区的内存不足，即方法区和运行时常量池的空间不足</strong>。</p>
<p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。这类常见除了 CGLib 字节码增强和动态语言以外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<p>【示例】方法区出现 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(Bean.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解决】</p>
<p>当由于元空间而面临 <code>OutOfMemoryError</code> 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 Metaspace 区域，则应增加 Metaspace 的大小。更改应用程序启动配置并增加以下内容：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:<span class="attribute">MaxMetaspaceSize</span>=512m</span><br></pre></td></tr></table></figure>

<p>上面的配置示例告诉 JVM，允许 Metaspace 增长到 512 MB。</p>
<p>另一种解决方案甚至更简单。你可以通过删除此参数来完全解除对 Metaspace 大小的限制，JVM 默认对 Metaspace 的大小没有限制。但是请注意以下事实：这样做可能会导致大量交换或达到本机物理内存而分配失败。</p>
<h4 id="无法新建本地线程"><a href="#无法新建本地线程" class="headerlink" title="无法新建本地线程"></a>无法新建本地线程</h4><p><code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 这个错误意味着：<strong>Java 应用程序已达到其可以启动线程数的限制</strong>。</p>
<p>【原因】</p>
<p>当发起一个线程的创建时，虚拟机会在 JVM 内存创建一个 <code>Thread</code> 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 JVM 内存，而是系统中剩下的内存。</p>
<p>那么，究竟能创建多少线程呢？这里有一个公式：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 <span class="operator">=</span> (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)</span><br></pre></td></tr></table></figure>

<p>【参数】</p>
<ul>
<li><code>MaxProcessMemory</code> - 一个进程的最大内存</li>
<li><code>JVMMemory</code> - JVM 内存</li>
<li><code>ReservedOsMemory</code> - 保留的操作系统内存</li>
<li><code>ThreadStackSize</code> - 线程栈的大小</li>
</ul>
<p>**给 JVM 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 <code>unable to create new native thread</code>**。所以，JVM 内存不是分配的越大越好。</p>
<p>但是，通常导致 <code>java.lang.OutOfMemoryError</code> 的情况：无法创建新的本机线程需要经历以下阶段：</p>
<ol>
<li>JVM 内部运行的应用程序请求新的 Java 线程</li>
<li>JVM 本机代码代理为操作系统创建新本机线程的请求</li>
<li>操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程</li>
<li>操作系统将拒绝本机内存分配，原因是 32 位 Java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）GB 进程大小限制）或操作系统的虚拟内存已完全耗尽</li>
<li>引发 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 错误。</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableCreateNativeThreadOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MINUTES.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>可以通过增加操作系统级别的限制来绕过无法创建新的本机线程问题。例如，如果限制了 JVM 可在用户空间中产生的进程数，则应检查出并可能增加该限制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dev ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">--- cut for brevity ---</span><br><span class="line">max user processes              (-u) 1800</span><br></pre></td></tr></table></figure>

<p>通常，<code>OutOfMemoryError</code> 对新的本机线程的限制表示编程错误。当应用程序产生数千个线程时，很可能出了一些问题—很少有应用程序可以从如此大量的线程中受益。</p>
<p>解决问题的一种方法是开始进行线程转储以了解情况。</p>
<h4 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h4><p>直接内存（Direct Memory）的容量大小可通过 <code>-XX:MaxDirectMemorySize</code> 参数来指定，如果不指定，则默认与 Java 堆最大值（由 <code>-Xmx</code> 指定）一致。</p>
<p>由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的 Dump 文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是 NIO），那就可以考虑重点检查一下直接内存方面的原因了。</p>
<p>由直接内存导致的内存溢出，一个明显的特征是在 Heapdump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，就可以考虑检查一下是不是这方面的原因。</p>
<p>【示例】直接内存 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机直接内存溢出示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><p>HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。</p>
<p>对于 HotSpot 虚拟机来说，栈容量只由 <code>-Xss</code> 参数来决定。</p>
<p>栈溢出的常见原因：</p>
<ul>
<li><p><strong>递归函数调用层数太深</strong> - 线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常。</p>
</li>
<li><p><strong>大量循环或死循环</strong> - 虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出</p>
<p><code>OutOfMemoryError</code> 异常。</p>
</li>
</ul>
<p>【示例】递归函数调用层数太深导致 <code>StackOverflowError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以一个无限递归的示例方法来展示栈溢出</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 栈溢出时，Java 会抛出 StackOverflowError ，出现此种情况是因为方法运行的时候栈的大小超过了虚拟机的上限所致。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Java 应用程序唤起一个方法调用时就会在调用栈上分配一个栈帧，这个栈帧包含引用方法的参数，本地参数，以及方法的返回地址。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这个返回地址是被引用的方法返回后，程序能够继续执行的执行点。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果没有一个新的栈帧所需空间，Java 就会抛出 StackOverflowError。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * VM 参数：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xss228k - 设置栈大小为 228k&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackOverflowErrorDemo</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackOverflowErrorDemo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj.recursion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈深度：&quot;</span> + obj.stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】大量循环或死循环导致 <code>StackOverflowError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类成员循环依赖，导致 StackOverflowError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM 参数：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xss228k - 设置栈大小为 228k</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:forbreak@163.com&quot;&gt;Zhang Peng&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-06-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowErrorDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> B instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">            value = <span class="number">0</span>;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span> + value + <span class="string">&quot;, &quot;</span> + instance + <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">            value = <span class="number">10</span>;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span> + value + <span class="string">&quot;, &quot;</span> + instance + <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">极客时间教程 - Java 性能调优实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/doulist/2545443/">从表到里学习 JVM 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28935cbfbae0">作为测试你应该知道的 JAVA OOM 及定位分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29912455/article/details/51125748">异常、堆内存溢出、OOM 的几种情况</a></li>
<li><a target="_blank" rel="noopener" href="https://tianmingxing.com/2019/11/17/%E4%BB%8B%E7%BB%8DJVM%E4%B8%ADOOM%E7%9A%848%E7%A7%8D%E7%B1%BB%E5%9E%8B/">介绍 JVM 中 OOM 的 8 种类型</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/d7e7299c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/d7e7299c/" class="post-title-link" itemprop="url">Redis 哨兵</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h1><blockquote>
<p>Redis 2.8 版本，新增了哨兵模式，以支持“自动故障转移”，它是 Redis 的 HA 方案。</p>
<p>Redis 哨兵模式由一个或多个 Sentinel 实例组成 Sentinel 集群，可以监控任意多个主服务器，以及这些主服务器的所有从服务器；并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>关键词：<code>高可用</code>、<code>监控</code>、<code>选主</code>、<code>故障转移</code>、<code>Raft</code></p>
</blockquote>
<h2 id="哨兵简介"><a href="#哨兵简介" class="headerlink" title="哨兵简介"></a>哨兵简介</h2><p>Redis 的主从复制模式，虽然提供了一定程度的 <strong>高可用性（High Availability）</strong>。但是，当主节点出现故障时，只能通过手动操作将从节点晋升为主节点，这显然是比较低效的。为了解决这个问题，Redis 2.8 版本提供了哨兵模式（Sentinel）来支持“自动故障转移”。</p>
<p>Redis 哨兵模式由一个或多个 Sentinel 实例组成 Sentinel 集群，可以监控任意多个主服务器，以及这些主服务器的所有从服务器；并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282134672.png"></p>
<p>Sentinel 的主要功能如下：</p>
<ul>
<li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li>
<li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li>
</ul>
<h2 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h2><p>启动一个 Sentinel 可以使用下面任意一条命令，两条命令效果完全相同。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>当一个 Sentinel 启动时，它需要执行以下步骤：</p>
<ol>
<li>初始化服务器。</li>
<li>使用 Sentinel 专用代码。</li>
<li>初始化 Sentinel 状态。</li>
<li>初始化 Sentinel 的主服务器列表。</li>
<li>创建连向被监视的主服务器的网络连接。</li>
</ol>
<p><strong>Sentinel 本质上是一个运行在“特殊模式”下的 Redis 服务器</strong>。Sentinel 模式下 Redis 服务器只支持 <code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>、<code>PUNSUBSCRIBE</code> 七个命令。</p>
<p>创建连向被监视的主服务器的网络连接，Sentinel 将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。Sentinel 会读入用户指定的配置文件， 为每个要被监视的主服务器创建相应的实例结构， 并创建连向主服务器的命令连接和订阅连接：</p>
<ul>
<li><strong>命令连接</strong> - 专门用于向主服务器发送命令，并接受命令回复。</li>
<li><strong>订阅连接</strong> - 专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="获取服务器信息"><a href="#获取服务器信息" class="headerlink" title="获取服务器信息"></a>获取服务器信息</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282134261.png"></p>
<p>默认情况下， Sentinel 以“<strong>每十秒一次</strong>”的频率向被监视的主服务器和从服务器<strong>发送 <code>INFO</code> 命令</strong>，并通过分析 <code>INFO</code> 命令的回复来获取服务器的当前信息。</p>
<ul>
<li>主服务器 - 可以获取主服务器自身信息，以及其所属从服务器的地址信息。</li>
<li>从服务器 - 从服务器自身信息，以及其主服务器的了解状态和地址。</li>
</ul>
<p><strong>Sentinel 通过向主服务器发送 <code>INFO</code> 命令来获得主服务器属下所有从服务器的地址信息， 并为这些从服务器创建相应的实例结构， 以及连向这些从服务器的“命令连接”和“订阅连接</strong>”。</p>
<p>对于监视同一个主服务器和从服务器的多个 Sentinel 来说， 它们会以“每两秒一次”的频率， 通过向被监视服务器的 <code>__sentinel__:hello</code> 频道发送消息来向其他 Sentinel 宣告自己的存在。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接， Sentinel 与 Sentinel 之间则只创建命令连接。</p>
<h3 id="判断下线"><a href="#判断下线" class="headerlink" title="判断下线"></a>判断下线</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282135416.png"></p>
<h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p><strong>默认，每个 Sentinel 以“每秒一次”的频率，向它所知的“所有实例”发送一个 <code>PING</code> 命令</strong>。</p>
<ul>
<li>“所知”是指，与 Sentinel 创建了命令连接的实例。</li>
<li>“所有实例”包括了主服务器、从服务器以及其他 Sentinel 实例。</li>
</ul>
<p>如果，<strong>某实例在指定的时长（ <code>down-after-milliseconds</code> 设置的值，单位毫秒）中，未向 Sentinel 发送有效回复， Sentinel 会将该实例判定为“主观下线</strong>”。</p>
<ul>
<li>一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果服务器返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 Sentinel 认为服务器返回的回复无效。</li>
<li>“主观下线”适用于所有主节点和从节点。</li>
</ul>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当一个“<strong>主服务器</strong>”被 Sentinel 标记为“<strong>主观下线</strong>”后，为了确认其是否真的下线，Sentinel 会向同样监听该主服务器的其他 Sentinel 发起询问。如果有“<strong>足够数量</strong>”的 Sentinel 在指定的时间范围内认为主服务器已下线，那么这个“<strong>主服务器</strong>”被标记为“<strong>客观下线</strong>”。</p>
<ul>
<li>Sentinel 节点通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 Sentinel 节点询问对某主服务器的 <strong>状态判断</strong>。</li>
<li>“足够数量”是指 Sentinel 配置中 <code>quorum</code> 参数所设的值。</li>
<li>客观下线只适用于主节点。</li>
</ul>
<p>注：默认情况下， Sentinel 以“<strong>每十秒一次</strong>”的频率向被监视的主服务器和从服务器<strong>发送 <code>INFO</code> 命令</strong>。当一个主服务器被 Sentinel 标记为“<strong>客观下线</strong>”时，Sentinel 向该主服务器的所有从服务器发送 <code>INFO</code> 命令的频率，会从“<strong>每十秒一次</strong>”改为“<strong>每秒一次</strong>”。</p>
<h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><blockquote>
<p>Redis Sentinel 采用 <a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">Raft 协议</a> 实现了其 Sentinel 选主流程。Raft 是一种共识性算法，想了解其原理，可以参考 <a href="https://dunwu.github.io/waterdrop/pages/3a64eb94/">深入剖析共识性算法 Raft</a>。</p>
</blockquote>
<p><strong>当一个“主服务器”被判断为“客观下线”时，监视该主服务器的各个 Sentinel 会进行“协商”，选举出一个领头的 Sentinel（Leader），并由领头 Sentinel 对下线主服务器执行“故障转移”操作</strong>。</p>
<p>所有在线 Sentinel 都有资格被选为 Leader。</p>
<ol>
<li>当一个 Sentinel 认定某主服务器是“客观下线”后，该 Sentinel 会先看看自己是否投过票。<ul>
<li>如果已投票给其他 Sentinel 了，在 2 倍故障转移的超时时间内，都不能竞选 <strong>Leader</strong>——相当于它是一个 <strong>Follower</strong>。</li>
<li>如果未投票，那么该 Sentinel 可以竞选 <strong>Leader</strong>，转为 <strong>Candidate</strong>。</li>
</ul>
</li>
<li>如 Raft 协议所描述的，<strong>Candidate</strong> 需要完成几件事情：<ol>
<li>更新故障转移状态为 start</li>
<li>将当前纪元（<code>epoch</code>） 加 1，表明开始新一轮的选举——这里的 <code>epoch</code> 相当于 Raft 协议中的 <code>term</code>。</li>
<li>将自身的超时时间设为当前时间加上一个随机值，随机值为 1s 内的随机毫秒数。</li>
<li>向其他节点发送 <code>is-master-down-by-addr</code> 命令，请求其他节点投票支持自己，命令会携带自己的 <code>epoch</code>。</li>
<li>Candidate 会投票给自己。在 Sentinel 中，投票的方式是把自己 <code>master</code> 结构体里的 <code>leader</code> 和 <code>leader_epoch</code> 改成投给的 Sentinel 和它的 <code>epoch</code>。</li>
</ol>
</li>
<li>其他 Sentinel 收到 <strong>Candidate</strong> 的 <code>is-master-down-by-addr</code> 命令后，如果 Sentinel 当前 <code>epoch</code> 和 <strong>Candidate</strong> 传给他的 <code>epoch</code> 一样，说明他已经把自己 <code>master</code> 结构体里的 <code>leader</code> 和 <code>leader_epoch</code> 改成其他 <strong>Candidate</strong>，相当于把票投给了其他 <strong>Candidate</strong>。投票给其他 Sentinel 后，在当前 <code>epoch</code> 内，该 Sentinel 就只能成为 <strong>Follower</strong>。</li>
<li><strong>Candidate</strong> 会不断的统计自己的票数，如果满足“当选投票条件”，则该 <strong>Candidate</strong> 当选 <strong>Leader</strong>：<ol>
<li>票数超过一半（监控主服务器的 Sentinel 的节点数的一半 + 1）</li>
<li>票数超过 Sentinel 配置的 <code>quorum</code> 参数——注：Raft 协议中没有这个限制，这是 Redis Sentinel 所独有的</li>
</ol>
</li>
<li>如果在一个选举周期内（<code>epoch</code>），<strong>Candidate</strong> 没有满足“当选投票条件”（第 4 点描述的），则竞选失败。</li>
<li>如果在一个选举周期内（<code>epoch</code>），没有一个 <strong>Candidate</strong> 满足“当选投票条件”，说明所有 <strong>Candidate</strong> 都竞选失败，本轮选举作废。在等待超过 2 倍故障转移的超时时间后，开始新一轮的选举。</li>
<li>与 Raft 协议不同的是，Leader 并不会把自己成为 <strong>Leader</strong> 的消息发给其他 Sentinel。当 <strong>Leader</strong> 完成故障转移后，其他 Sentinel 检测到新的主服务器正常工作后，就会去掉“客观下线”的标识，从而不需要再发起选举。</li>
</ol>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在选举产生出 Sentinel Leader 后，Sentinel Leader 将对已下线的主服务器执行故障转移操作。操作含以下三个步骤：</p>
<p>（1）<strong>选出新的主服务器</strong></p>
<p>故障转移第一步，是 Sentinel Leader 在已下线主服务属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器。然后，向这个从服务器发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务器。</p>
<p>Sentinel Leader 如何选出新的主服务器：</p>
<ul>
<li>删除列表中所有处于下线或断线状态的从服务器。</li>
<li>删除列表中所有最近五秒没有回复过 Sentinel Leader 的 <code>INFO</code> 命令的从服务器。</li>
<li>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds * 10</code> 毫秒的从服务器（<code>down-after-milliseconds</code> 指定了判断主服务器下线所需的时间）。</li>
<li>之后， Sentinel Leader 先选出优先级最高的从服务器；如果优先级一样高，再选择复制偏移量最大的从服务器；如果结果还不唯一，则选出运行 ID 最小的从服务器。</li>
</ul>
<p>（2）<strong>修改从服务器的复制目标</strong></p>
<p>选出新的主服务器后，Sentinel Leader 会向所有从服务器发送 <code>SLAVEOF</code> 命令，让它们去复制新的主服务器。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282136227.png"></p>
<p>（3）<strong>将旧的主服务器变为从服务器</strong></p>
<p>Sentinel Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 <code>SLAVEOF</code> 命令，让其成为从服务器。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202503282136527.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.web-lovers.com/redis-source-sentinel.html">渐进式解析 Redis 源码 - 哨兵 sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64">深入剖析 Redis 系列(二) - Redis 哨兵模式与高可用集群</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/20a5fe12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/20a5fe12/" class="post-title-link" itemprop="url">Redis 复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h1><blockquote>
<p>在 Redis 中，<strong>可以通过执行 <code>SLAVEOF</code> 命令或设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器</strong>，其中，后者叫主服务器（master），前者叫从服务器（slave）。</p>
<p>Redis 2.8 以前的复制不能高效处理断线后重复制的情况，而 Redis 2.8 新添的部分重同步可以解决这个问题。</p>
<p>关键词：<code>SLAVEOF</code>、<code>SYNC</code>、<code>PSYNC</code>、<code>命令传播</code>、<code>心跳</code></p>
</blockquote>
<h2 id="复制简介"><a href="#复制简介" class="headerlink" title="复制简介"></a>复制简介</h2><p>Redis 通过 <code>slaveof host port</code> 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p><strong>一个主服务器可以有多个从服务器</strong>。不仅主服务器可以有从服务器，从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个主从链。</p>
<p><strong>一个从服务器只能有一个主服务器，并且不支持主主复制</strong>。</p>
<p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
<p>在使用 Redis 复制功能时的设置中，强烈建议在 master 和在 slave 中启用持久化。当不启用时，例如由于非常慢的磁盘性能而导致的延迟问题，<strong>应该配置实例来避免重置后自动重启</strong>。</p>
<p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p>
<ul>
<li>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a target="_blank" rel="noopener" href="http://redisdoc.com/configure/config_set.html#config-set">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</li>
<li>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</li>
</ul>
<h2 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h2><blockquote>
<p>Redis 2.8 版本以前实现方式：<code>SYNC</code> 命令</p>
</blockquote>
<p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li><strong><code>同步（sync）</code></strong> - 用于将从服务器的数据库状态更新至主服务器当前的数据库状态。</li>
<li><strong><code>命令传播（command propagate）</code></strong> - 当主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><code>SYNC</code> 命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送 <code>SYNC</code> 命令。</li>
<li>收到 <code>SYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>主服务器执行 <code>BGSAVE</code> 完毕后，主服务器会将生成的 RDB 文件发送给从服务器。从服务器接收并载入 RDB 文件，更新自己的数据库状态。</li>
<li>主服务器将记录在缓冲区中的所有写命令发送给从服务器，从服务器执行这些写命令，更新自己的数据库状态。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309172035716.png"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作完成后，主从数据库的数据库状态将达到一致。每当主服务器执行客户端发送的写命令时，主从数据库状态不再一致。需要将写命令发送给从服务器执行，使得二者的数据库状态重新达到一致。</p>
<h3 id="旧版复制的缺陷"><a href="#旧版复制的缺陷" class="headerlink" title="旧版复制的缺陷"></a>旧版复制的缺陷</h3><p>从服务器对主服务器的复制存在两种情况：</p>
<ul>
<li><strong>初次复制</strong> - 从服务器以前没有复制过将要复制的主服务器。</li>
<li><strong>断线后重复制</strong> - 处于命令传播阶段的主从服务器因为网络原因而中断了复制，当从服务器通过自动重连重新连上了主服务器后，继续复制主服务器。</li>
</ul>
<p>对于初次复制，旧版复制功能可用很好完成任务；但是<strong>对于断线后重复制，由于每次任然需要生成 RDB 并传输，效率很低</strong>。</p>
<blockquote>
<p>🔔 注意：<strong>SYNC 命令是一个非常耗费资源的操作。</strong></p>
<ul>
<li>主服务器执行 <code>BGSAVE</code> 命令生成 RDB 文件，这个操作会耗费主服务器大量的 CPU、内存和磁盘 I&#x2F;O 资源。</li>
<li>主服务器传输 RDB 文件给从服务器，这个操作会耗费主从服务器大量的网络资源，并对主服务器响应时延产生影响。</li>
<li>从服务器载入 RDB 文件期间，会阻塞其他命令请求。</li>
</ul>
</blockquote>
<h2 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h2><blockquote>
<p>Redis 2.8 版本以后的新实现方式：使用 <code>PSYNC</code> 命令替代 <code>SYNC</code> 命令。</p>
</blockquote>
<p><code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> - 用于断线后重复制。<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
<h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>部分重同步功能实现由三个部分构成：</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主服务器和从服务器会分别维护一个复制偏移量。</p>
<ul>
<li>如果主从服务器的复制偏移量相同，则说明二者的数据库状态一致；</li>
<li>反之，则说明二者的数据库状态不一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309172031325.png"></p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p><strong>复制积压缓冲区是主服务器维护的一个固定长度的先进先出（FIFO）队列</strong>，默认大小为 <code>1MB</code>。</p>
<p>复制积压缓冲区会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p>
<p>当从服务器断线重连主服务时，从服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作。</p>
<ul>
<li>如果 offset 之后的数据仍然在复制积压缓冲区，则主服务器对从服务器执行部分重同步操作。</li>
<li>反之，则主服务器对从服务器执行完整重同步操作。</li>
</ul>
<blockquote>
<p>🔔 注意：<strong>合理调整复制积压缓冲区的大小</strong></p>
<ul>
<li><p>Redis 复制积压缓冲区默认大小为 <code>1MB</code>。</p>
</li>
<li><p>复制积压缓冲区的最小大小可以根据公式 <code>second * write_size_per_second</code> 估算。</p>
</li>
</ul>
</blockquote>
<h4 id="服务器的运行-ID"><a href="#服务器的运行-ID" class="headerlink" title="服务器的运行 ID"></a>服务器的运行 ID</h4><ul>
<li>每个 Redis 服务器，都有运行 ID，用于唯一识别身份。</li>
<li>运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成。例如：132e358005e29741f8d7b0a42d666aace286edda</li>
</ul>
<p>从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，从服务器会将这个运行 ID 保存下来。</p>
<p>当从服务器断线重连一个主服务器时，从服务器会发送之前保存的运行 ID：</p>
<ul>
<li>如果保存的运行 ID 和当前主服务器的运行 ID 一致，则说明从服务器断线之前连接的就是这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>反之，若运行 ID 不一致，则说明从服务器断线之前连接的不是这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h3 id="PSYNC-命令"><a href="#PSYNC-命令" class="headerlink" title="PSYNC 命令"></a>PSYNC 命令</h3><p>了解了部分重同步的实现，PSYNC 的实现就很容易理解了，它的基本工作原理大致如下：</p>
<p>当从服务接收到 <code>SLAVEOF</code> 命令时，先判断从服务器以前是否执行过复制操作。</p>
<ul>
<li>如果没有复制过任何主服务器，向要复制的主服务器<strong>发送 <code>PSYNC ? -1</code> 命令，主动请求进行完整重同步</strong>。</li>
<li>反之，向要复制的主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令。<ul>
<li><code>runid</code> 是上一次复制的主服务器的运行 ID。</li>
<li><code>offset</code> 是复制偏移量。</li>
</ul>
</li>
</ul>
<p>接收到 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令的主服务会进行分析：</p>
<ul>
<li>假如主从服务器的 <strong>master run id 相同</strong>，并且<strong>指定的偏移量（offset）在内存缓冲区中还有效</strong>，复制就会从上次中断的点开始继续。</li>
<li>如果其中一个条件不满足，就会进行完全重新同步（在 2.8 版本之前就是直接进行完全重新同步）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309172030499.png"></p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在<strong>命令传播</strong>阶段，从服务器默认会以<strong>每秒一次</strong>的频率，向主服务器发送命令：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_offset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>replication_offset</code> 是从服务器当前的复制偏移量。</p>
<p>发送 <code>REPLCONF ACK</code> 命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slaves 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h3 id="检测主从连接状态"><a href="#检测主从连接状态" class="headerlink" title="检测主从连接状态"></a>检测主从连接状态</h3><p><strong>可以通过发送和接收 <code>REPLCONF ACK</code> 命令来检查主从服务器之间的网络连接</strong>是否正常：如果主服务器超过一秒没有收到从服务器发来的 <code>REPLCONF ACK</code> 命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p>
<p>可以通过向主服务器发送 <code>INFO replication</code> 命令，在列出的从服务器列表的 lag 一栏中，可以看到从服务器向主服务器发送 <code>REPLCONF ACK</code> 命令已经过去多少秒。</p>
<h3 id="辅助实现-min-slaves-选项"><a href="#辅助实现-min-slaves-选项" class="headerlink" title="辅助实现 min-slaves 选项"></a>辅助实现 min-slaves 选项</h3><p>Redis 的 <strong><code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 两个选项可以防止主服务器在不安全的情况下执行写命令</strong>。</p>
<p>【示例】min-slaves 配置项</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>以上配置表示：从服务器小于 3 个，或三个从服务器的延迟（lag）都大于等于 10 秒时，主服务器将拒绝执行写命令。</p>
<h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>如果因为网络故障，主服务传播给从服务器的写命令丢失，那么从服务器定时向主服务器发送 <code>REPLCONF ACK</code> 命令时，主服务器将发觉从服务器的复制偏移量少于自己的。然后，主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区中找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h2 id="复制的流程"><a href="#复制的流程" class="headerlink" title="复制的流程"></a>复制的流程</h2><p>通过向从服务器发送如下 SLAVEOF 命令，可以让一个从服务器去复制一个主服务器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF <span class="tag">&lt;<span class="name">master_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">master_port</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤-1-设置主从服务器"><a href="#步骤-1-设置主从服务器" class="headerlink" title="步骤 1. 设置主从服务器"></a>步骤 1. 设置主从服务器</h3><p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slaveof</span> <span class="number">127.0.0.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>当然， 你需要将代码中的 <code>127.0.0.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p>
<p>另外一种方法是调用 <a target="_blank" rel="noopener" href="http://redisdoc.com/replication/slaveof.html#slaveof">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; SLAVEOF <span class="number">127.0.0.1</span> <span class="number">10086</span></span><br><span class="line"><span class="attribute">OK</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤-2-主从服务器建立-TCP-连接。"><a href="#步骤-2-主从服务器建立-TCP-连接。" class="headerlink" title="步骤 2. 主从服务器建立 TCP 连接。"></a>步骤 2. 主从服务器建立 TCP 连接。</h3><h3 id="步骤-3-发送-PING-检查通信状态。"><a href="#步骤-3-发送-PING-检查通信状态。" class="headerlink" title="步骤 3. 发送 PING 检查通信状态。"></a>步骤 3. 发送 PING 检查通信状态。</h3><h3 id="步骤-4-身份验证。"><a href="#步骤-4-身份验证。" class="headerlink" title="步骤 4. 身份验证。"></a>步骤 4. 身份验证。</h3><p>如果主服务器没有设置 <code>requirepass</code> ，从服务器没有设置 <code>masterauth</code>，则不进行身份验证；反之，则需要进行身份验证。如果身份验证失败，则放弃执行复制工作。</p>
<p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>

<p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h3 id="步骤-5-发送端口信息。"><a href="#步骤-5-发送端口信息。" class="headerlink" title="步骤 5. 发送端口信息。"></a>步骤 5. 发送端口信息。</h3><p>从服务器执行 <code>REPLCONF listening-port &lt;port-number&gt;</code> ，向主服务器发送从服务器的监听端口号。</p>
<h3 id="步骤-6-同步。"><a href="#步骤-6-同步。" class="headerlink" title="步骤 6. 同步。"></a>步骤 6. 同步。</h3><p>前文已介绍，此处不赘述。</p>
<h3 id="步骤-7-命令传播。"><a href="#步骤-7-命令传播。" class="headerlink" title="步骤 7. 命令传播。"></a>步骤 7. 命令传播。</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务发送命令：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_coffset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命令的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slave 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h2 id="复制的配置项"><a href="#复制的配置项" class="headerlink" title="复制的配置项"></a>复制的配置项</h2><p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p>
<p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul>
<li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li>
</ul>
<p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p>
<p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p>
<p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<ul>
<li><code>min-slaves-to-write &lt;number of slaves&gt;</code></li>
<li><code>min-slaves-max-lag &lt;number of seconds&gt;</code></li>
</ul>
<p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/docs/management/replication/">Redis 官方文档之复制</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c2fe3db9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c2fe3db9/" class="post-title-link" itemprop="url">Redis 实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-实战"><a href="#Redis-实战" class="headerlink" title="Redis 实战"></a>Redis 实战</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是 Redis 最常见的应用场景。</p>
<p>Redis 有多种数据类型，以及丰富的操作命令，并且有着高性能、高可用的特性，非常适合用于分布式缓存。</p>
<blockquote>
<p>缓存应用的基本原理，请参考 <a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a> 第四 ~ 第六节内容。</p>
</blockquote>
<h2 id="BitMap-和-BloomFilter"><a href="#BitMap-和-BloomFilter" class="headerlink" title="BitMap 和 BloomFilter"></a>BitMap 和 BloomFilter</h2><p>Redis 除了 5 种基本数据类型外，还支持 BitMap 和 BloomFilter（即布隆过滤器，可以通过 Redis Module 支持）。</p>
<p>BitMap 和 BloomFilter 都可以用于解决缓存穿透问题。要点在于：过滤一些不可能存在的数据。</p>
<blockquote>
<p>什么是缓存穿透，可以参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a></p>
</blockquote>
<p>小数据量可以用 BitMap，大数据量可以用布隆过滤器。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>使用 Redis 作为分布式锁，基本要点如下：</p>
<ul>
<li><strong>互斥性</strong> - 使用 <code>setnx</code> 抢占锁。</li>
<li><strong>避免永远不释放锁</strong> - 使用 <code>expire</code> 加一个过期时间，避免一直不释放锁，导致阻塞。</li>
<li><strong>原子性</strong> - setnx 和 expire 必须合并为一个原子指令，避免 setnx 后，机器崩溃，没来得及设置 expire，从而导致锁永不释放。</li>
</ul>
<blockquote>
<p>更多分布式锁的实现方式及细节，请参考：<a href="https://dunwu.github.io/waterdrop/pages/b8f8aeae/">分布式锁基本原理</a></p>
</blockquote>
<p>根据 Redis 的特性，在实际应用中，存在一些应用小技巧。</p>
<h2 id="keys-和-scan"><a href="#keys-和-scan" class="headerlink" title="keys 和 scan"></a>keys 和 scan</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<p>如果这个 redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</p>
<p>首先，Redis 是单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p>
<p>这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<p>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 <code>SMEMBERS</code> 命令可以返回集合键当前包含的所有元素， 但是对于 <code>SCAN</code> 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p>
<h2 id="大-Key-如何处理"><a href="#大-Key-如何处理" class="headerlink" title="大 Key 如何处理"></a>大 Key 如何处理</h2><blockquote>
<p>什么是 Redis Big Key？</p>
</blockquote>
<p>Big Key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为Big Key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000 个，或总大小超过 10MB</li>
</ul>
<blockquote>
<p>Big Key 会造成什么问题？</p>
</blockquote>
<p>Big Key 会带来以下四种影响：</p>
<ul>
<li><strong>内存分布不均</strong>：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有Big Key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
<li><strong>命令阻塞</strong>：Redis 单线程模型，操作大 Key 耗时，阻塞其他命令。</li>
<li><strong>网络传输压力</strong>：每次获取Big Key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>客户端超时</strong>：由于 Redis 执行命令是单线程处理，然后在操作Big Key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
</ul>
<blockquote>
<p>如何找到Big Key ？</p>
</blockquote>
<p><strong>（1）使用 <code>redis-cli --bigkeys</code></strong></p>
<p><strong>命令</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a <span class="string">&quot;password&quot;</span> --bigkeys</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>： </p>
<ul>
<li><strong>推荐在从节点执行</strong>（主节点执行可能阻塞业务）</li>
<li><strong>低峰期执行</strong> 或 <strong>加 <code>-i</code> 参数控制扫描间隔</strong>（如 <code>-i 0.1</code> 表示每 100ms 扫描一次）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>只能返回<strong>每种数据类型最大的 1 个 Key</strong>（无法获取 Top N）</li>
<li>对集合类型<strong>只统计元素个数</strong>，而非实际内存占用</li>
</ul>
<p><strong>（2）使用 <code>SCAN</code> + 内存分析命令</strong> </p>
<p><strong>遍历所有 Key</strong>（避免 <code>KEYS *</code> 阻塞 Redis）：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --scan --pattern <span class="string">&quot;*&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> key; <span class="keyword">do</span> ...; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>分析 Key 大小</strong>：  </p>
<ul>
<li><strong>String</strong>：<code>STRLEN $key</code>（字节数） </li>
<li><strong>集合类型</strong>（List&#x2F;Hash&#x2F;Set&#x2F;ZSet）： <ul>
<li><strong>方法 1</strong>：<code>LLEN</code>&#x2F;<code>HLEN</code>&#x2F;<code>SCARD</code>&#x2F;<code>ZCARD</code>（元素个数 × 预估元素大小） </li>
<li><strong>方法 2</strong>（Redis 4.0+）：<code>MEMORY USAGE $key</code>（精确内存占用）</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>： </p>
<ul>
<li>可自定义筛选条件（如大小 Top 10） </li>
<li>精确计算内存占用</li>
</ul>
<p><strong>（3）使用 <code>RdbTools</code> 分析 RDB 文件</strong>  </p>
<p><strong>命令</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f redis.csv  <span class="comment"># 导出 &gt;10KB 的 Key 到 CSV</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>： </p>
<ul>
<li>离线分析，不影响线上 Redis</li>
<li>精准统计<strong>所有 Key 的内存分布</strong></li>
</ul>
<p><strong>缺点</strong>：需要 Redis 生成 RDB 快照</p>
<blockquote>
<p>如何删除Big Key？</p>
</blockquote>
<p>删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p>
<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<p>因此，删除Big Key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：</p>
<ul>
<li>分批次删除</li>
<li>异步删除（Redis 4.0 版本以上）</li>
</ul>
<p><strong><em>1、分批次删除</em></strong></p>
<p>对于<strong>删除大 Hash</strong>，使用 <code>hscan</code> 命令，每次获取 100 个字段，再用 <code>hdel</code> 命令，每次删除 1 个字段。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_hash</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">    large_hash_key =<span class="string">&quot;xxx&quot;</span> <span class="comment">#要删除的大hash键名</span></span><br><span class="line">    cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 使用 hscan 命令，每次获取 100 个字段</span></span><br><span class="line">        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data.items():</span><br><span class="line">                <span class="comment"># 再用 hdel 命令，每次删除1个字段</span></span><br><span class="line">                r.hdel(large_hash_key, item[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 List</strong>，通过 <code>ltrim</code> 命令，每次删除少量元素。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_list</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_list_key = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">#要删除的大list的键名</span></span><br><span class="line">  <span class="keyword">while</span> r.llen(large_list_key)&gt;<span class="number">0</span>:</span><br><span class="line">      <span class="comment">#每次只删除最右100个元素</span></span><br><span class="line">      r.ltrim(large_list_key, <span class="number">0</span>, -<span class="number">101</span>)</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 Set</strong>，使用 <code>sscan</code> 命令，每次扫描集合中 100 个元素，再用 <code>srem</code> 命令每次删除一个键。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_set</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_set_key = <span class="string">&#x27;xxx&#x27;</span>   <span class="comment"># 要删除的大set的键名</span></span><br><span class="line">  cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span></span><br><span class="line">    cursor, data = r.sscan(large_set_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">      <span class="comment"># 再用 srem 命令每次删除一个键</span></span><br><span class="line">      r.srem(large_size_key, item)</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 ZSet</strong>，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100 个元素。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_sortedset</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;large_sortedset_key&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_sortedset_key=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> r.zcard(large_sortedset_key)&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span></span><br><span class="line">    r.zremrangebyrank(large_sortedset_key,<span class="number">0</span>,<span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<p><strong><em>2、异步删除</em></strong></p>
<p>从 Redis 4.0 版本开始，可以采用<strong>异步删除</strong>法，<strong>用 unlink 命令代替 del 来删除</strong>。</p>
<p>这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。</p>
<p>除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。</p>
<p>主要有 4 种场景，默认都是关闭的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del</span><br><span class="line">noslave-lazy-flush no</span><br></pre></td></tr></table></figure>

<p>它们代表的含义如下：</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h2 id="最受欢迎文章"><a href="#最受欢迎文章" class="headerlink" title="最受欢迎文章"></a>最受欢迎文章</h2><p>选出最受欢迎文章，需要支持对文章进行评分。</p>
<h3 id="对文章进行投票"><a href="#对文章进行投票" class="headerlink" title="对文章进行投票"></a>对文章进行投票</h3><p>（1）使用 HASH 存储文章</p>
<p>使用 <code>HASH</code> 类型存储文章信息。其中：key 是文章 ID；field 是文章的属性 key；value 是属性对应值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200225143038.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>存储文章信息 - 使用 <code>HSET</code> 或 <code>HMGET</code> 命令</li>
<li>查询文章信息 - 使用 <code>HGETALL</code> 命令</li>
<li>添加投票 - 使用 <code>HINCRBY</code> 命令</li>
</ul>
<p>（2）使用 <code>ZSET</code> 针对不同维度集合排序</p>
<p>使用 <code>ZSET</code> 类型分别存储按照时间排序和按照评分排序的文章 ID 集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200225145742.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>添加记录 - 使用 <code>ZADD</code> 命令</li>
<li>添加分数 - 使用 <code>ZINCRBY</code> 命令</li>
<li>取出多篇文章 - 使用 <code>ZREVRANGE</code> 命令</li>
</ul>
<p>（3）为了防止重复投票，使用 <code>SET</code> 类型记录每篇文章 ID 对应的投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200225150105.jpg" alt="img"></p>
<p>操作：</p>
<ul>
<li>添加投票者 - 使用 <code>SADD</code> 命令</li>
<li>设置有效期 - 使用 <code>EXPIRE</code> 命令</li>
</ul>
<p>（4）假设 user:115423 给 article:100408 投票，分别需要高更新评分排序集合以及投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200225150138.jpg" alt="img"></p>
<p>当需要对一篇文章投票时，程序需要用 ZSCORE 命令检查记录文章发布时间的有序集合，判断文章的发布时间是否超过投票有效期（比如：一星期）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">articleVote</span><span class="params">(Jedis conn, String user, String article)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算文章的投票截止时间。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">cutoff</span> <span class="operator">=</span> (System.currentTimeMillis() / <span class="number">1000</span>) - ONE_WEEK_IN_SECONDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还可以对文章进行投票</span></span><br><span class="line">    <span class="comment">// （虽然使用散列也可以获取文章的发布时间，</span></span><br><span class="line">    <span class="comment">// 但有序集合返回的文章发布时间为浮点数，</span></span><br><span class="line">    <span class="comment">// 可以不进行转换直接使用）。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.zscore(<span class="string">&quot;time:&quot;</span>, article) &lt; cutoff) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从article:id标识符（identifier）里面取出文章的ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> article.substring(article.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户是第一次为这篇文章投票，那么增加这篇文章的投票数量和评分。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.sadd(<span class="string">&quot;voted:&quot;</span> + articleId, user) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.zincrby(<span class="string">&quot;score:&quot;</span>, VOTE_SCORE, article);</span><br><span class="line">        conn.hincrBy(article, <span class="string">&quot;votes&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布并获取文章"><a href="#发布并获取文章" class="headerlink" title="发布并获取文章"></a>发布并获取文章</h3><p>发布文章：</p>
<ul>
<li>添加文章 - 使用 <code>INCR</code> 命令计算新的文章 ID，填充文章信息，然后用 <code>HSET</code> 命令或 <code>HMSET</code> 命令写入到 <code>HASH</code> 结构中。</li>
<li>将文章作者 ID 添加到投票名单 - 使用 <code>SADD</code> 命令添加到代表投票名单的 <code>SET</code> 结构中。</li>
<li>设置投票有效期 - 使用 <code>EXPIRE</code> 命令设置投票有效期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">postArticle</span><span class="params">(Jedis conn, String user, String title, String link)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成一个新的文章ID。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">articleId</span> <span class="operator">=</span> String.valueOf(conn.incr(<span class="string">&quot;article:&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">voted</span> <span class="operator">=</span> <span class="string">&quot;voted:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将发布文章的用户添加到文章的已投票用户名单里面，</span></span><br><span class="line">    conn.sadd(voted, user);</span><br><span class="line">    <span class="comment">// 然后将这个名单的过期时间设置为一周（第3章将对过期时间作更详细的介绍）。</span></span><br><span class="line">    conn.expire(voted, ONE_WEEK_IN_SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章信息存储到一个散列里面。</span></span><br><span class="line">    HashMap&lt;String, String&gt; articleData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    articleData.put(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">    articleData.put(<span class="string">&quot;link&quot;</span>, link);</span><br><span class="line">    articleData.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    articleData.put(<span class="string">&quot;now&quot;</span>, String.valueOf(now));</span><br><span class="line">    articleData.put(<span class="string">&quot;votes&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    conn.hmset(article, articleData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文章添加到根据发布时间排序的有序集合和根据评分排序的有序集合里面。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;score:&quot;</span>, now + VOTE_SCORE, article);</span><br><span class="line">    conn.zadd(<span class="string">&quot;time:&quot;</span>, now, article);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页查询最受欢迎文章：</p>
<p>使用 <code>ZINTERSTORE</code> 命令根据页码、每页记录数、排序号，根据评分值从大到小分页查出文章 ID 列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getArticles</span><span class="params">(Jedis conn, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置获取文章的起始索引和结束索引。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (page - <span class="number">1</span>) * ARTICLES_PER_PAGE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + ARTICLES_PER_PAGE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多个文章ID。</span></span><br><span class="line">    Set&lt;String&gt; ids = conn.zrevrange(order, start, end);</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; articles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据文章ID获取文章的详细信息。</span></span><br><span class="line">    <span class="keyword">for</span> (String id : ids) &#123;</span><br><span class="line">        Map&lt;String, String&gt; articleData = conn.hgetAll(id);</span><br><span class="line">        articleData.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        articles.add(articleData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对文章进行分组"><a href="#对文章进行分组" class="headerlink" title="对文章进行分组"></a>对文章进行分组</h3><p>如果文章需要分组，功能需要分为两块：</p>
<ul>
<li>记录文章属于哪个群组</li>
<li>负责取出群组里的文章</li>
</ul>
<p>将文章添加、删除群组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRemoveGroups</span><span class="params">(Jedis conn, String articleId, String[] toAdd, String[] toRemove)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建存储文章信息的键名。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;article:&quot;</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章添加到它所属的群组里面。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toAdd) &#123;</span><br><span class="line">        conn.sadd(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从群组里面移除文章。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toRemove) &#123;</span><br><span class="line">        conn.srem(<span class="string">&quot;group:&quot;</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出群组里的文章：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200225214210.jpg" alt="img"></p>
<ul>
<li>通过对存储群组文章的集合和存储文章评分的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章评分排序的群组文章。</li>
<li>通过对存储群组文章的集合和存储文章发布时间的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章发布时间排序的群组文章。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getGroupArticles</span><span class="params">(Jedis conn, String group, <span class="type">int</span> page, String order)</span> &#123;</span><br><span class="line">    <span class="comment">// 为每个群组的每种排列顺序都创建一个键。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> order + group;</span><br><span class="line">    <span class="comment">// 检查是否有已缓存的排序结果，如果没有的话就现在进行排序。</span></span><br><span class="line">    <span class="keyword">if</span> (!conn.exists(key)) &#123;</span><br><span class="line">        <span class="comment">// 根据评分或者发布时间，对群组文章进行排序。</span></span><br><span class="line">        <span class="type">ZParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZParams</span>().aggregate(ZParams.Aggregate.MAX);</span><br><span class="line">        conn.zinterstore(key, params, <span class="string">&quot;group:&quot;</span> + group, order);</span><br><span class="line">        <span class="comment">// 让Redis在60秒钟之后自动删除这个有序集合。</span></span><br><span class="line">        conn.expire(key, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用之前定义的getArticles函数来进行分页并获取文章数据。</span></span><br><span class="line">    <span class="keyword">return</span> getArticles(conn, page, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管理令牌"><a href="#管理令牌" class="headerlink" title="管理令牌"></a>管理令牌</h2><p>网站一般会以 Cookie、Session、令牌这类信息存储用户身份信息。</p>
<p>可以将 Cookie&#x2F;Session&#x2F;令牌 和用户的映射关系存储在 <code>HASH</code> 结构。</p>
<p>下面以令牌来举例。</p>
<h3 id="查询令牌"><a href="#查询令牌" class="headerlink" title="查询令牌"></a>查询令牌</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">checkToken</span><span class="params">(Jedis conn, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取并返回令牌对应的用户。</span></span><br><span class="line">    <span class="keyword">return</span> conn.hget(<span class="string">&quot;login:&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h3><ul>
<li>用户每次访问页面，可以记录下令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中，以便分析用户是否活跃，继而可以周期性清理最老的令牌，统计当前在线用户数等行为。</li>
<li>用户如果正在浏览商品，可以记录到用户最近浏览过的商品有序集合中（集合可以限定数量，超过数量进行裁剪），存入到一个 <code>ZSET</code> 结构中，以便分析用户最近可能感兴趣的商品，以便推荐商品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 维持令牌与已登录用户之间的映射。</span></span><br><span class="line">    conn.hset(<span class="string">&quot;login:&quot;</span>, token, user);</span><br><span class="line">    <span class="comment">// 记录令牌最后一次出现的时间。</span></span><br><span class="line">    conn.zadd(<span class="string">&quot;recent:&quot;</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录用户浏览过的商品。</span></span><br><span class="line">        conn.zadd(<span class="string">&quot;viewed:&quot;</span> + token, timestamp, item);</span><br><span class="line">        <span class="comment">// 移除旧的记录，只保留用户最近浏览过的25个商品。</span></span><br><span class="line">        conn.zremrangeByRank(<span class="string">&quot;viewed:&quot;</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">&quot;viewed:&quot;</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清理令牌"><a href="#清理令牌" class="headerlink" title="清理令牌"></a>清理令牌</h3><p>上一节提到，更新令牌时，将令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中。所以可以通过排序得知哪些令牌最老。如果没有清理操作，更新令牌占用的内存会不断膨胀，直到导致机器宕机。</p>
<p>比如：最多允许存储 1000 万条令牌信息，周期性检查，一旦发现记录数超出 1000 万条，将 ZSET 从新到老排序，将超出 1000 万条的记录清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CleanSessionsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CleanSessionsThread</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        quit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 找出目前已有令牌的数量。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> conn.zcard(<span class="string">&quot;recent:&quot;</span>);</span><br><span class="line">            <span class="comment">// 令牌数量未超过限制，休眠并在之后重新检查。</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要移除的令牌ID。</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">endIndex</span> <span class="operator">=</span> Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">            Set&lt;String&gt; tokenSet = conn.zrange(<span class="string">&quot;recent:&quot;</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">            String[] tokens = tokenSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[tokenSet.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为那些将要被删除的令牌构建键名。</span></span><br><span class="line">            ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">                sessionKeys.add(<span class="string">&quot;viewed:&quot;</span> + token);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除最旧的那些令牌。</span></span><br><span class="line">            conn.del(sessionKeys.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[sessionKeys.size()]));</span><br><span class="line">            conn.hdel(<span class="string">&quot;login:&quot;</span>, tokens);</span><br><span class="line">            conn.zrem(<span class="string">&quot;recent:&quot;</span>, tokens);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11791607.html">《Redis 实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11486101.html">《Redis 设计与实现》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/page/28/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/blog/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/51/">51</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/30/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"ec521a49c0c7778ff960279f77aff6b7"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
