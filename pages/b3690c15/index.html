<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="Tomcat 连接器1. NioEndpoint 组件Tomcat 的 NioEndPoint 组件利用 Java NIO 实现了 I&#x2F;O 多路复用模型。  NioEndPoint 子组件功能简介：  LimitLatch 是连接控制器，负责控制最大连接数。NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。 Acceptor 负责监听连接请求。Acceptor 运行在一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat连接器">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/b3690c15/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="Tomcat 连接器1. NioEndpoint 组件Tomcat 的 NioEndPoint 组件利用 Java NIO 实现了 I&#x2F;O 多路复用模型。  NioEndPoint 子组件功能简介：  LimitLatch 是连接控制器，负责控制最大连接数。NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。 Acceptor 负责监听连接请求。Acceptor 运行在一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127094302.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127143839.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127145740.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127150729.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151041.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151155.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127153521.jpg">
<meta property="article:published_time" content="2022-02-17T14:34:30.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.708Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JavaWeb">
<meta property="article:tag" content="服务器">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127094302.jpg">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/b3690c15/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/b3690c15/","path":"/pages/b3690c15/","title":"Tomcat连接器"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tomcat连接器 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat-%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">Tomcat 连接器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-NioEndpoint-%E7%BB%84%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">1. NioEndpoint 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-LimitLatch"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1. LimitLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Acceptor"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2. Acceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Poller"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3. Poller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-SocketProcessor"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4. SocketProcessor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Nio2Endpoint-%E7%BB%84%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">2. Nio2Endpoint 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Nio2Acceptor"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. Nio2Acceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Nio2SocketWrapper"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2. Nio2SocketWrapper</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-AprEndpoint-%E7%BB%84%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">3. AprEndpoint 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-AprEndpoint-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1. AprEndpoint 工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-Acceptor"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1. Acceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-Poller"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2. Poller</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-APR-%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E7%A7%98%E5%AF%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2. APR 提升性能的秘密</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-sendfile"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1. sendfile</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Executor-%E7%BB%84%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">4. Executor 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Tomcat-%E5%AE%9A%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1. Tomcat 定制线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Tomcat-%E5%AE%9A%E5%88%B6%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2. Tomcat 定制任务队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-WebSocket-%E7%BB%84%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">5. WebSocket 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-WebSocket-%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1. WebSocket 加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-WebSocket-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2. WebSocket 请求处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.6.</span> <span class="nav-text">6. 参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/b3690c15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Tomcat连接器 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Tomcat连接器<a href="https://github.com/dunwu/blog/blob/master/source/_posts/01.Java/02.JavaEE/02.%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Tomcat/02.Tomcat%E8%BF%9E%E6%8E%A5%E5%99%A8.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Tomcat-连接器"><a href="#Tomcat-连接器" class="headerlink" title="Tomcat 连接器"></a>Tomcat 连接器</h1><h2 id="1-NioEndpoint-组件"><a href="#1-NioEndpoint-组件" class="headerlink" title="1. NioEndpoint 组件"></a>1. NioEndpoint 组件</h2><p>Tomcat 的 NioEndPoint 组件利用 Java NIO 实现了 I&#x2F;O 多路复用模型。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127094302.jpg" alt="img"></p>
<p>NioEndPoint 子组件功能简介：</p>
<ul>
<li><code>LimitLatch</code> 是连接控制器，负责控制最大连接数。NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。</li>
<li><code>Acceptor</code> 负责监听连接请求。<code>Acceptor</code> 运行在一个单独的线程里，它在一个死循环里调用 accept 方法来接收新连接，一旦有新的连接请求到来，accept 方法返回一个 <code>Channel</code> 对象，接着把 <code>Channel</code> 对象交给 <code>Poller</code> 去处理。</li>
<li><code>Poller</code> 的本质是一个 <code>Selector</code>，也运行在单独线程里。<code>Poller</code> 内部维护一个 <code>Channel</code> 数组，它在一个死循环里不断检测 <code>Channel</code> 的数据就绪状态，一旦有 <code>Channel</code> 可读，就生成一个 <code>SocketProcessor</code> 任务对象扔给 <code>Executor</code> 去处理。</li>
<li><code>Executor</code> 就是线程池，负责运行 <code>SocketProcessor</code> 任务类，<code>SocketProcessor</code> 的 run 方法会调用 <code>Http11Processor</code> 来读取和解析请求数据。我们知道，<code>Http11Processor</code> 是应用层协议的封装，它会调用容器获得响应，再把响应通过 <code>Channel</code> 写出。</li>
</ul>
<p>NioEndpoint 如何实现高并发的呢？</p>
<p>要实现高并发需要合理设计线程模型充分利用 CPU 资源，尽量不要让线程阻塞；另外，就是有多少任务，就用相应规模的线程数去处理。</p>
<p>NioEndpoint 要完成三件事情：接收连接、检测 I&#x2F;O 事件以及处理请求，那么最核心的就是把这三件事情分开，用不同规模的线程去处理，比如用专门的线程组去跑 Acceptor，并且 Acceptor 的个数可以配置；用专门的线程组去跑 Poller，Poller 的个数也可以配置；最后具体任务的执行也由专门的线程池来处理，也可以配置线程池的大小。</p>
<h3 id="1-1-LimitLatch"><a href="#1-1-LimitLatch" class="headerlink" title="1.1. LimitLatch"></a>1.1. LimitLatch</h3><p><code>LimitLatch</code> 用来控制连接个数，当连接数到达最大时阻塞线程，直到后续组件处理完一个连接后将连接数减 1。请你注意到达最大连接数后操作系统底层还是会接收客户端连接，但用户层已经不再接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">newCount</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (newCount &gt; limit) &#123;</span><br><span class="line">                count.decrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            count.decrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程调用这个方法来获得接收新连接的许可，线程可能被阻塞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countUpOrAwait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用这个方法来释放一个连接许可，那么前面阻塞的线程可能被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">      <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> getCount();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LimitLatch 内步定义了内部类 Sync，而 Sync 扩展了 AQS，AQS 是 Java 并发包中的一个核心类，它在内部维护一个状态和一个线程队列，可以用来<strong>控制线程什么时候挂起，什么时候唤醒</strong>。我们可以扩展它来实现自己的同步器，实际上 Java 并发包里的锁和条件变量等等都是通过 AQS 来实现的，而这里的 LimitLatch 也不例外。</p>
<p>理解源码要点：</p>
<ul>
<li>用户线程通过调用 LimitLatch 的 countUpOrAwait 方法来拿到锁，如果暂时无法获取，这个线程会被阻塞到 AQS 的队列中。那 AQS 怎么知道是阻塞还是不阻塞用户线程呢？其实这是由 AQS 的使用者来决定的，也就是内部类 Sync 来决定的，因为 Sync 类重写了 AQS 的<strong>tryAcquireShared() 方法</strong>。它的实现逻辑是如果当前连接数 count 小于 limit，线程能获取锁，返回 1，否则返回 -1。</li>
<li>如何用户线程被阻塞到了 AQS 的队列，那什么时候唤醒呢？同样是由 Sync 内部类决定，Sync 重写了 AQS 的<strong>releaseShared() 方法</strong>，其实就是当一个连接请求处理完了，这时又可以接收一个新连接了，这样前面阻塞的线程将会被唤醒。</li>
</ul>
<h3 id="1-2-Acceptor"><a href="#1-2-Acceptor" class="headerlink" title="1.2. Acceptor"></a>1.2. Acceptor</h3><p>Acceptor 实现了 Runnable 接口，因此可以跑在单独线程里。一个端口号只能对应一个 ServerSocketChannel，因此这个 ServerSocketChannel 是在多个 Acceptor 线程之间共享的，它是 Endpoint 的属性，由 Endpoint 完成初始化和端口绑定。</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverSock = <span class="type">ServerSocketChannel</span>.open();</span><br><span class="line">serverSock.socket().<span class="keyword">bind</span>(<span class="keyword">addr</span>,getAcceptCount());</span><br><span class="line">serverSock.configureBlocking(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>bind 方法的第二个参数表示操作系统的等待队列长度，我在上面提到，当应用层面的连接数到达最大值时，操作系统可以继续接收连接，那么操作系统能继续接收的最大连接数就是这个队列长度，可以通过 acceptCount 参数配置，默认是 100。</li>
<li>ServerSocketChannel 被设置成阻塞模式，也就是说它是以阻塞的方式接收连接的。ServerSocketChannel 通过 accept() 接受新的连接，accept() 方法返回获得 SocketChannel 对象，然后将 SocketChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 Poller 的 Queue 里，这是个典型的生产者 - 消费者模式，Acceptor 与 Poller 线程之间通过 Queue 通信。</li>
</ul>
<h3 id="1-3-Poller"><a href="#1-3-Poller" class="headerlink" title="1.3. Poller"></a>1.3. Poller</h3><p><code>Poller</code> 本质是一个 <code>Selector</code>，它内部维护一个 <code>Queue</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SynchronizedQueue</span>&lt;<span class="type">PollerEvent</span>&gt; events <span class="operator">=</span> new <span class="type">SynchronizedQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>SynchronizedQueue</code> 的核心方法都使用了 <code>Synchronized</code> 关键字进行修饰，用来保证同一时刻只有一个线程进行读写。</p>
<p>使用 <code>SynchronizedQueue</code>，意味着同一时刻只有一个 <code>Acceptor</code> 线程对队列进行读写；同时有多个 <code>Poller</code> 线程在运行，每个 <code>Poller</code> 线程都有自己的队列。每个 <code>Poller</code> 线程可能同时被多个 <code>Acceptor</code> 线程调用来注册 <code>PollerEvent</code>。同样 <code>Poller</code> 的个数可以通过 pollers 参数配置。</p>
<p><code>Poller</code> 不断的通过内部的 <code>Selector</code> 对象向内核查询 <code>Channel</code> 的状态，一旦可读就生成任务类 <code>SocketProcessor</code> 交给 <code>Executor</code> 去处理。<code>Poller</code> 的另一个重要任务是循环遍历检查自己所管理的 <code>SocketChannel</code> 是否已经超时，如果有超时就关闭这个 <code>SocketChannel</code>。</p>
<h3 id="1-4-SocketProcessor"><a href="#1-4-SocketProcessor" class="headerlink" title="1.4. SocketProcessor"></a>1.4. SocketProcessor</h3><p>我们知道，<code>Poller</code> 会创建 <code>SocketProcessor</code> 任务类交给线程池处理，而 <code>SocketProcessor</code> 实现了 <code>Runnable</code> 接口，用来定义 <code>Executor</code> 中线程所执行的任务，主要就是调用 <code>Http11Processor</code> 组件来处理请求。<code>Http11Processor</code> 读取 <code>Channel</code> 的数据来生成 <code>ServletRequest</code> 对象，这里请你注意：</p>
<p><code>Http11Processor</code> 并不是直接读取 <code>Channel</code> 的。这是因为 Tomcat 支持同步非阻塞 I&#x2F;O 模型和异步 I&#x2F;O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 <code>AsynchronousSocketChannel</code> 和 <code>SocketChannel</code>，为了对 <code>Http11Processor</code> 屏蔽这些差异，Tomcat 设计了一个包装类叫作 <code>SocketWrapper</code>，<code>Http11Processor</code> 只调用 <code>SocketWrapper</code> 的方法去读写数据。</p>
<h2 id="2-Nio2Endpoint-组件"><a href="#2-Nio2Endpoint-组件" class="headerlink" title="2. Nio2Endpoint 组件"></a>2. Nio2Endpoint 组件</h2><p>Nio2Endpoint 工作流程跟 NioEndpoint 较为相似。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127143839.jpg" alt="img"></p>
<p>Nio2Endpoint 子组件功能说明：</p>
<ul>
<li><code>LimitLatch</code> 是连接控制器，它负责控制最大连接数。</li>
<li><code>Nio2Acceptor</code> 扩展了 <code>Acceptor</code>，用异步 I&#x2F;O 的方式来接收连接，跑在一个单独的线程里，也是一个线程组。<code>Nio2Acceptor</code> 接收新的连接后，得到一个 <code>AsynchronousSocketChannel</code>，<code>Nio2Acceptor</code> 把 <code>AsynchronousSocketChannel</code> 封装成一个 <code>Nio2SocketWrapper</code>，并创建一个 <code>SocketProcessor</code> 任务类交给线程池处理，并且 <code>SocketProcessor</code> 持有 <code>Nio2SocketWrapper</code> 对象。</li>
<li><code>Executor</code> 在执行 <code>SocketProcessor</code> 时，<code>SocketProcessor</code> 的 run 方法会调用 <code>Http11Processor</code> 来处理请求，<code>Http11Processor</code> 会通过 <code>Nio2SocketWrapper</code> 读取和解析请求数据，请求经过容器处理后，再把响应通过 <code>Nio2SocketWrapper</code> 写出。</li>
</ul>
<p>Nio2Endpoint 跟 NioEndpoint 的一个明显不同点是，<strong>Nio2Endpoint 中没有 Poller 组件，也就是没有 Selector。这是为什么呢？因为在异步 I&#x2F;O 模式下，Selector 的工作交给内核来做了。</strong></p>
<h3 id="2-1-Nio2Acceptor"><a href="#2-1-Nio2Acceptor" class="headerlink" title="2.1. Nio2Acceptor"></a>2.1. Nio2Acceptor</h3><p>和 <code>NioEndpint</code> 一样，<code>Nio2Endpoint</code> 的基本思路是用 <code>LimitLatch</code> 组件来控制连接数。</p>
<p>但是 <code>Nio2Acceptor</code> 的监听连接的过程不是在一个死循环里不断的调 accept 方法，而是通过回调函数来完成的。我们来看看它的连接监听方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSock.accept(<span class="literal">null</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>其实就是调用了 accept 方法，注意它的第二个参数是 this，表明 <code>Nio2Acceptor</code> 自己就是处理连接的回调类，因此 <code>Nio2Acceptor</code> 实现了 <code>CompletionHandler</code> 接口。那么它是如何实现 <code>CompletionHandler</code> 接口的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,</span></span><br><span class="line"><span class="params">        Void attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRunning() &amp;&amp; !isPaused()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有连接限制，继续接收新的连接</span></span><br><span class="line">                serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有连接限制，就在线程池里跑 Run 方法，Run 方法会检查连接数</span></span><br><span class="line">                getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>CompletionHandler</code> 的两个模板参数分别是 <code>AsynchronousServerSocketChannel</code> 和 Void，我在前面说过第一个参数就是 <code>accept</code> 方法的返回值，第二个参数是附件类，由用户自己决定，这里为 Void。<code>completed</code> 方法的处理逻辑比较简单：</p>
<ul>
<li>如果没有连接限制，继续在本线程中调用 <code>accept</code> 方法接收新的连接。</li>
<li>如果有连接限制，就在线程池里跑 <code>run</code> 方法去接收新的连接。那为什么要跑 <code>run</code> 方法呢，因为在 <code>run</code> 方法里会检查连接数，当连接达到最大数时，线程可能会被 <code>LimitLatch</code> 阻塞。为什么要放在线程池里跑呢？这是因为如果放在当前线程里执行，<code>completed</code> 方法可能被阻塞，会导致这个回调方法一直不返回。</li>
</ul>
<p>接着 <code>completed</code> 方法会调用 <code>setSocketOptions</code> 方法，在这个方法里，会创建 <code>Nio2SocketWrapper</code> 和 <code>SocketProcessor</code>，并交给线程池处理。</p>
<h3 id="2-2-Nio2SocketWrapper"><a href="#2-2-Nio2SocketWrapper" class="headerlink" title="2.2. Nio2SocketWrapper"></a>2.2. Nio2SocketWrapper</h3><p><code>Nio2SocketWrapper</code> 的主要作用是封装 Channel，并提供接口给 <code>Http11Processor</code> 读写数据。讲到这里你是不是有个疑问：<code>Http11Processor</code> 是不能阻塞等待数据的，按照异步 I&#x2F;O 的套路，<code>Http11Processor</code> 在调用 <code>Nio2SocketWrapper</code> 的 read 方法时需要注册回调类，read 调用会立即返回，问题是立即返回后 <code>Http11Processor</code> 还没有读到数据， 怎么办呢？这个请求的处理不就失败了吗？</p>
<p>为了解决这个问题，<code>Http11Processor</code> 是通过 2 次 read 调用来完成数据读取操作的。</p>
<ul>
<li>第一次 read 调用：连接刚刚建立好后，<code>Acceptor</code> 创建 <code>SocketProcessor</code> 任务类交给线程池去处理，<code>Http11Processor</code> 在处理请求的过程中，会调用 <code>Nio2SocketWrapper</code> 的 read 方法发出第一次读请求，同时注册了回调类 <code>readCompletionHandler</code>，因为数据没读到，<code>Http11Processor</code> 把当前的 <code>Nio2SocketWrapper</code> 标记为数据不完整。<strong>接着 <code>SocketProcessor</code> 线程被回收，<code>Http11Processor</code> 并没有阻塞等待数据</strong>。这里请注意，<code>Http11Processor</code> 维护了一个 <code>Nio2SocketWrapper</code> 列表，也就是维护了连接的状态。</li>
<li>第二次 read 调用：当数据到达后，内核已经把数据拷贝到 <code>Http11Processor</code> 指定的 Buffer 里，同时回调类 <code>readCompletionHandler</code> 被调用，在这个回调处理方法里会<strong>重新创建一个新的 <code>SocketProcessor</code> 任务来继续处理这个连接</strong>，而这个新的 <code>SocketProcessor</code> 任务类持有原来那个 <code>Nio2SocketWrapper</code>，这一次 <code>Http11Processor</code> 可以通过 <code>Nio2SocketWrapper</code> 读取数据了，因为数据已经到了应用层的 Buffer。</li>
</ul>
<p>这个回调类 <code>readCompletionHandler</code> 的源码如下，最关键的一点是，**<code>Nio2SocketWrapper</code> 是作为附件类来传递的**，这样在回调函数里能拿到所有的上下文。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">readCompletionHandler</span> = <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;<span class="title class_">Integer</span>, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">completed</span>(<span class="params"><span class="title class_">Integer</span> nBytes, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt; attachment</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过附件类 SocketWrapper 拿到所有的上下文</span></span><br><span class="line">        <span class="title class_">Nio2SocketWrapper</span>.<span class="property">this</span>.<span class="title function_">getEndpoint</span>().<span class="title function_">processSocket</span>(attachment, <span class="title class_">SocketEvent</span>.<span class="property">OPEN_READ</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">failed</span>(<span class="params"><span class="title class_">Throwable</span> exc, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt; attachment</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-AprEndpoint-组件"><a href="#3-AprEndpoint-组件" class="headerlink" title="3. AprEndpoint 组件"></a>3. AprEndpoint 组件</h2><p>我们在使用 Tomcat 时，可能会在启动日志里看到这样的提示信息：</p>
<blockquote>
<p>The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: ***</p>
</blockquote>
<p>这句话的意思就是推荐你去安装 APR 库，可以提高系统性能。</p>
<p>APR（Apache Portable Runtime Libraries）是 Apache 可移植运行时库，它是用 C 语言实现的，其目的是向上层应用程序提供一个跨平台的操作系统接口库。Tomcat 可以用它来处理包括文件和网络 I&#x2F;O，从而提升性能。Tomcat 支持的连接器有 NIO、NIO.2 和 APR。跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I&#x2F;O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I&#x2F;O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I&#x2F;O 的。</p>
<p>同样是非阻塞 I&#x2F;O，为什么 Tomcat 会提示使用 APR 本地库的性能会更好呢？这是因为在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景，特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的强项。</p>
<p>Tomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序库。</p>
<h3 id="3-1-AprEndpoint-工作流程"><a href="#3-1-AprEndpoint-工作流程" class="headerlink" title="3.1. AprEndpoint 工作流程"></a>3.1. AprEndpoint 工作流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127145740.jpg" alt="img"></p>
<h4 id="3-1-1-Acceptor"><a href="#3-1-1-Acceptor" class="headerlink" title="3.1.1. Acceptor"></a>3.1.1. Acceptor</h4><p>Accpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案就是通过 JNI。具体来说就是两步：先封装一个 Java 类，在里面定义一堆用<strong>native 关键字</strong>修饰的方法，像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Socket</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 用 native 修饰这个方法，表明这个函数是 C 语言实现</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">create</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> protocol, <span class="type">long</span> cont)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">long</span> sock, <span class="type">long</span> sa)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">long</span> sock, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">accept</span><span class="params">(<span class="type">long</span> sock)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着用 C 代码实现这些方法，比如 bind 函数就是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意函数的名字要符合 JNI 规范的要求</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_org_apache_tomcat_jni_Socket_bind</span><span class="params">(JNIEnv *e, jlong sock,jlong sa)</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">jint</span> <span class="variable">rv</span> <span class="operator">=</span> APR_SUCCESS;</span><br><span class="line">	    tcn_socket_t *s = (tcn_socket_t *）sock;</span><br><span class="line">	    apr_sockaddr_t *a = (apr_sockaddr_t *) sa;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 APR 库自己实现的 bind 函数</span></span><br><span class="line">	    rv = (jint)apr_socket_bind(s-&gt;sock, a);</span><br><span class="line">	    <span class="keyword">return</span> rv;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>专栏里我就不展开 JNI 的细节了，你可以<a target="_blank" rel="noopener" href="http://jnicookbook.owsiak.org/contents/">扩展阅读</a>获得更多信息和例子。我们要注意的是函数名字要符合 JNI 的规范，以及 Java 和 C 语言如何互相传递参数，比如在 C 语言有指针，Java 没有指针的概念，所以在 Java 中用 long 类型来表示指针。AprEndpoint 的 Acceptor 组件就是调用了 APR 实现的四个 API。</p>
<h4 id="3-1-2-Poller"><a href="#3-1-2-Poller" class="headerlink" title="3.1.2. Poller"></a>3.1.2. Poller</h4><p>Acceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I&#x2F;O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。</p>
<p>这里有个特别的地方是在 AprEndpoint 中，我们可以配置一个叫<code>deferAccept</code>的参数，它对应的是 TCP 协议中的<code>TCP_DEFER_ACCEPT</code>，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。</p>
<p>这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。</p>
<h3 id="3-2-APR-提升性能的秘密"><a href="#3-2-APR-提升性能的秘密" class="headerlink" title="3.2. APR 提升性能的秘密"></a>3.2. APR 提升性能的秘密</h3><p>APR 连接器之所以能提高 Tomcat 的性能，除了 APR 本身是 C 程序库之外，还有哪些提速的秘密呢？</p>
<p><strong>JVM 堆 VS 本地内存</strong></p>
<p>我们知道 Java 的类实例一般在 JVM 堆上分配，而 Java 是通过 JNI 调用 C 代码来实现 Socket 通信的，那么 C 代码在运行过程中需要的内存又是从哪里分配的呢？C 代码能否直接操作 Java 堆？</p>
<p>为了回答这些问题，我先来说说 JVM 和用户进程的关系。如果你想运行一个 Java 类文件，可以用下面的 Java 命令来执行。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="keyword">my</span>.<span class="built_in">class</span></span><br></pre></td></tr></table></figure>

<p>这个命令行中的<code>java</code>其实是<strong>一个可执行程序，这个程序会创建 JVM 来加载和运行你的 Java 类</strong>。操作系统会创建一个进程来执行这个<code>java</code>可执行程序，而每个进程都有自己的虚拟地址空间，JVM 用到的内存（包括堆、栈和方法区）就是从进程的虚拟地址空间上分配的。请你注意的是，JVM 内存只是进程空间的一部分，除此之外进程空间内还有代码段、数据段、内存映射区、内核空间等。从 JVM 的角度看，JVM 内存之外的部分叫作本地内存，C 程序代码在运行过程中用到的内存就是本地内存中分配的。下面我们通过一张图来理解一下。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127150729.jpg" alt="img"></p>
<p>Tomcat 的 Endpoint 组件在接收网络数据时需要预先分配好一块 Buffer，所谓的 Buffer 就是字节数组<code>byte[]</code>，Java 通过 JNI 调用把这块 Buffer 的地址传给 C 代码，C 代码通过操作系统 API 读取 Socket 并把数据填充到这块 Buffer。Java NIO API 提供了两种 Buffer 来接收数据：HeapByteBuffer 和 DirectByteBuffer，下面的代码演示了如何创建两种 Buffer。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 分配 HeapByteBuffer</span><br><span class="line">ByteBuffer buf <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 分配 DirectByteBuffer</span><br><span class="line">ByteBuffer buf <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>创建好 Buffer 后直接传给 Channel 的 read 或者 write 函数，最终这块 Buffer 会通过 JNI 调用传递给 C 程序。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 buf 作为 read 函数的参数</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.<span class="keyword">read</span>(buf);</span><br></pre></td></tr></table></figure>

<p>那 HeapByteBuffer 和 DirectByteBuffer 有什么区别呢？HeapByteBuffer 对象本身在 JVM 堆上分配，并且它持有的字节数组<code>byte[]</code>也是在 JVM 堆上分配。但是如果用<strong>HeapByteBuffer</strong>来接收网络数据，<strong>需要把数据从内核先拷贝到一个临时的本地内存，再从临时本地内存拷贝到 JVM 堆</strong>，而不是直接从内核拷贝到 JVM 堆上。这是为什么呢？这是因为数据从内核拷贝到 JVM 堆的过程中，JVM 可能会发生 GC，GC 过程中对象可能会被移动，也就是说 JVM 堆上的字节数组可能会被移动，这样的话 Buffer 地址就失效了。如果这中间经过本地内存中转，从本地内存到 JVM 堆的拷贝过程中 JVM 可以保证不做 GC。</p>
<p>如果使用 HeapByteBuffer，你会发现 JVM 堆和内核之间多了一层中转，而 DirectByteBuffer 用来解决这个问题，DirectByteBuffer 对象本身在 JVM 堆上，但是它持有的字节数组不是从 JVM 堆上分配的，而是从本地内存分配的。DirectByteBuffer 对象中有个 long 类型字段 address，记录着本地内存的地址，这样在接收数据的时候，直接把这个本地内存地址传递给 C 程序，C 程序会将网络数据从内核拷贝到这个本地内存，JVM 可以直接读取这个本地内存，这种方式比 HeapByteBuffer 少了一次拷贝，因此一般来说它的速度会比 HeapByteBuffer 快好几倍。你可以通过上面的图加深理解。</p>
<p>Tomcat 中的 AprEndpoint 就是通过 DirectByteBuffer 来接收数据的，而 NioEndpoint 和 Nio2Endpoint 是通过 HeapByteBuffer 来接收数据的。你可能会问，NioEndpoint 和 Nio2Endpoint 为什么不用 DirectByteBuffer 呢？这是因为本地内存不好管理，发生内存泄漏难以定位，从稳定性考虑，NioEndpoint 和 Nio2Endpoint 没有去冒这个险。</p>
<h4 id="3-2-1-sendfile"><a href="#3-2-1-sendfile" class="headerlink" title="3.2.1. sendfile"></a>3.2.1. sendfile</h4><p>我们再来考虑另一个网络通信的场景，也就是静态文件的处理。浏览器通过 Tomcat 来获取一个 HTML 文件，而 Tomcat 的处理逻辑无非是两步：</p>
<ol>
<li>从磁盘读取 HTML 到内存。</li>
<li>将这段内存的内容通过 Socket 发送出去。</li>
</ol>
<p>但是在传统方式下，有很多次的内存拷贝：</p>
<ul>
<li>读取文件时，首先是内核把文件内容读取到内核缓冲区。</li>
<li>如果使用 HeapByteBuffer，文件数据从内核到 JVM 堆内存需要经过本地内存中转。</li>
<li>同样在将文件内容推入网络时，从 JVM 堆到内核缓冲区需要经过本地内存中转。</li>
<li>最后还需要把文件从内核缓冲区拷贝到网卡缓冲区。</li>
</ul>
<p>从下面的图你会发现这个过程有 6 次内存拷贝，并且 read 和 write 等系统调用将导致进程从用户态到内核态的切换，会耗费大量的 CPU 和内存资源。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151041.jpg" alt="img"></p>
<p>而 Tomcat 的 AprEndpoint 通过操作系统层面的 sendfile 特性解决了这个问题，sendfile 系统调用方式非常简洁。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendfile</span>(socket, file, len);</span><br></pre></td></tr></table></figure>

<p>它带有两个关键参数：Socket 和文件句柄。将文件从磁盘写入 Socket 的过程只有两步：</p>
<p>第一步：将文件内容读取到内核缓冲区。</p>
<p>第二步：数据并没有从内核缓冲区复制到 Socket 关联的缓冲区，只有记录数据位置和长度的描述符被添加到 Socket 缓冲区中；接着把数据直接从内核缓冲区传递给网卡。这个过程你可以看下面的图。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151155.jpg" alt="img"></p>
<h2 id="4-Executor-组件"><a href="#4-Executor-组件" class="headerlink" title="4. Executor 组件"></a>4. Executor 组件</h2><p>为了提高处理能力和并发度，Web 容器一般会把处理请求的工作放到线程池里来执行，Tomcat 扩展了原生的 Java 线程池，来满足 Web 容器高并发的需求。</p>
<h3 id="4-1-Tomcat-定制线程池"><a href="#4-1-Tomcat-定制线程池" class="headerlink" title="4.1. Tomcat 定制线程池"></a>4.1. Tomcat 定制线程池</h3><p>Tomcat 的线程池也是一个定制版的 ThreadPoolExecutor。Tomcat 传入的参数是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制版的任务队列</span></span><br><span class="line">taskqueue = <span class="keyword">new</span> <span class="title class_">TaskQueue</span>(maxQueueSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制版的线程工厂</span></span><br><span class="line"><span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(namePrefix,daemon,getThreadPriority());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制版的线程池</span></span><br><span class="line">executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);</span><br></pre></td></tr></table></figure>

<p>其中的两个关键点：</p>
<ul>
<li>Tomcat 有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxQueueSize。</li>
<li>Tomcat 对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。</li>
</ul>
<p>除了资源限制以外，Tomcat 线程池还定制自己的任务处理流程。我们知道 Java 原生线程池的任务处理逻辑比较简单：</p>
<ol>
<li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>
<li>后面再来任务，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>
<li>如果总线程数达到 maximumPoolSize，<strong>执行拒绝策略。</strong></li>
</ol>
<p>Tomcat 线程池扩展了原生的 ThreadPoolExecutor，通过重写 execute 方法实现了自己的任务处理逻辑：</p>
<ol>
<li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>
<li>再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>
<li>如果总线程数达到 maximumPoolSize，<strong>则继续尝试把任务添加到任务队列中去。</strong></li>
<li><strong>如果缓冲队列也满了，插入失败，执行拒绝策略。</strong></li>
</ol>
<p>观察 Tomcat 线程池和 Java 原生线程池的区别，其实就是在第 3 步，Tomcat 在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。那具体如何实现呢，其实很简单，我们来看一下 Tomcat 线程池的 execute 方法的核心代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  public void execute(<span class="type">Runnable</span> command, long timeout, <span class="type">TimeUnit</span> unit) &#123;</span><br><span class="line">      submittedCount.incrementAndGet();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 Java 原生线程池的 execute 去执行任务</span></span><br><span class="line">          <span class="keyword">super</span>.execute(command);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="type">RejectedExecutionException</span> rx) &#123;</span><br><span class="line">         <span class="comment">// 如果总线程数达到 maximumPoolSize，Java 原生线程池执行拒绝策略</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() instanceof <span class="type">TaskQueue</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="type">TaskQueue</span> queue = (<span class="type">TaskQueue</span>)<span class="keyword">super</span>.getQueue();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 继续尝试把任务放到任务队列中去</span></span><br><span class="line">                  <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                      submittedCount.decrementAndGet();</span><br><span class="line">                      <span class="comment">// 如果缓冲队列也满了，插入失败，执行拒绝策略。</span></span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RejectedExecutionException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个方法你可以看到，Tomcat 线程池的 execute 方法会调用 Java 原生线程池的 execute 去执行任务，如果总线程数达到 maximumPoolSize，Java 原生线程池的 execute 方法会抛出 RejectedExecutionException 异常，但是这个异常会被 Tomcat 线程池的 execute 方法捕获到，并继续尝试把这个任务放到任务队列中去；如果任务队列也满了，再执行拒绝策略。</p>
<h3 id="4-2-Tomcat-定制任务队列"><a href="#4-2-Tomcat-定制任务队列" class="headerlink" title="4.2. Tomcat 定制任务队列"></a>4.2. Tomcat 定制任务队列</h3><p>细心的你有没有发现，在 Tomcat 线程池的 execute 方法最开始有这么一行：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submittedCount.incrementAndGet()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这行代码的意思把 submittedCount 这个原子变量加一，并且在任务执行失败，抛出拒绝异常时，将这个原子变量减一：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submittedCount.decrementAndGet()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其实 Tomcat 线程池是用这个变量 submittedCount 来维护已经提交到了线程池，但是还没有执行完的任务个数。Tomcat 为什么要维护这个变量呢？这跟 Tomcat 的定制版的任务队列有关。Tomcat 的任务队列 TaskQueue 扩展了 Java 中的 LinkedBlockingQueue，我们知道 LinkedBlockingQueue 默认情况下长度是没有限制的，除非给它一个 capacity。因此 Tomcat 给了它一个 capacity，TaskQueue 的构造函数中有个整型的参数 capacity，TaskQueue 将 capacity 传给父类 LinkedBlockingQueue 的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(capacity);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 capacity 参数是通过 Tomcat 的 maxQueueSize 参数来设置的，但问题是默认情况下 maxQueueSize 的值是<code>Integer.MAX_VALUE</code>，等于没有限制，这样就带来一个问题：当前线程数达到核心线程数之后，再来任务的话线程池会把任务添加到任务队列，并且总是会成功，这样永远不会有机会创建新线程了。</p>
<p>为了解决这个问题，TaskQueue 重写了 LinkedBlockingQueue 的 offer 方法，在合适的时机返回 false，返回 false 表示任务添加失败，这时线程池会创建新的线程。那什么是合适的时机呢？请看下面 offer 方法的核心源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">// 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize())</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。</span></span><br><span class="line">      <span class="comment">// 表明是可以创建新线程的，那到底要不要创建呢？分两种情况：</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize()))</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 如果已提交的任务数大于当前线程数，线程不够用了，返回 false 去创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 默认情况下总是把任务添加到任务队列</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到，只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。这就是为什么 Tomcat 需要维护已提交任务数这个变量，它的目的就是<strong>在任务队列的长度无限制的情况下，让线程池有机会创建新的线程</strong>。</p>
<p>当然默认情况下 Tomcat 的任务队列是没有限制的，你可以通过设置 maxQueueSize 参数来限制任务队列的长度。</p>
<h2 id="5-WebSocket-组件"><a href="#5-WebSocket-组件" class="headerlink" title="5. WebSocket 组件"></a>5. WebSocket 组件</h2><p>HTTP 协议是“请求 - 响应”模式，浏览器必须先发请求给服务器，服务器才会响应这个请求。也就是说，服务器不会主动发送数据给浏览器。</p>
<p>对于实时性要求比较的高的应用，比如在线游戏、股票基金实时报价和在线协同编辑等，浏览器需要实时显示服务器上最新的数据，因此出现了 Ajax 和 Comet 技术。Ajax 本质上还是轮询，而 Comet 是在 HTTP 长连接的基础上做了一些 hack，但是它们的实时性不高，另外频繁的请求会给服务器带来压力，也会浪费网络流量和带宽。于是 HTML5 推出了 WebSocket 标准，使得浏览器和服务器之间任何一方都可以主动发消息给对方，这样服务器有新数据时可以主动推送给浏览器。</p>
<p>Tomcat 如何支持 WebSocket？简单来说，Tomcat 做了两件事：</p>
<ul>
<li>Endpoint 加载</li>
<li>WebSocket 请求处理</li>
</ul>
<h3 id="5-1-WebSocket-加载"><a href="#5-1-WebSocket-加载" class="headerlink" title="5.1. WebSocket 加载"></a>5.1. WebSocket 加载</h3><p>Tomcat 的 WebSocket 加载是通过 SCI 机制完成的。SCI 全称 ServletContainerInitializer，是 Servlet 3.0 规范中定义的用来<strong>接收 Web 应用启动事件的接口</strong>。那为什么要监听 Servlet 容器的启动事件呢？因为这样我们有机会在 Web 应用启动时做一些初始化工作，比如 WebSocket 需要扫描和加载 Endpoint 类。SCI 的使用也比较简单，将实现 ServletContainerInitializer 接口的类增加 HandlesTypes 注解，并且在注解内指定的一系列类和接口集合。比如 Tomcat 为了扫描和加载 Endpoint 而定义的 SCI 类如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@HandlesTypes(&#123;ServerEndpoint.<span class="keyword">class</span>, ServerApplicationConfig.<span class="keyword">class</span>, Endpoint.<span class="keyword">class</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> WsSci <span class="keyword">implements</span> ServletContainerInitializer &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> onStartup(Set&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; clazzes, ServletContext ctx) <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义好了 SCI，Tomcat 在启动阶段扫描类时，会将 HandlesTypes 注解中指定的类都扫描出来，作为 SCI 的 onStartup 方法的参数，并调用 SCI 的 onStartup 方法。注意到 WsSci 的 HandlesTypes 注解中定义了<code>ServerEndpoint.class</code>、<code>ServerApplicationConfig.class</code>和<code>Endpoint.class</code>，因此在 Tomcat 的启动阶段会将这些类的类实例（注意不是对象实例）传递给 WsSci 的 onStartup 方法。那么 WsSci 的 onStartup 方法又做了什么事呢？</p>
<p>它会构造一个 WebSocketContainer 实例，你可以把 WebSocketContainer 理解成一个专门处理 WebSocket 请求的<strong>Endpoint 容器</strong>。也就是说 Tomcat 会把扫描到的 Endpoint 子类和添加了注解<code>@ServerEndpoint</code>的类注册到这个容器中，并且这个容器还维护了 URL 到 Endpoint 的映射关系，这样通过请求 URL 就能找到具体的 Endpoint 来处理 WebSocket 请求。</p>
<h3 id="5-2-WebSocket-请求处理"><a href="#5-2-WebSocket-请求处理" class="headerlink" title="5.2. WebSocket 请求处理"></a>5.2. WebSocket 请求处理</h3><p>Tomcat 用 ProtocolHandler 组件屏蔽应用层协议的差异，其中 ProtocolHandler 中有两个关键组件：Endpoint 和 Processor。需要注意，这里的 Endpoint 跟上文提到的 WebSocket 中的 Endpoint 完全是两回事，连接器中的 Endpoint 组件用来处理 I&#x2F;O 通信。WebSocket 本质就是一个应用层协议，因此不能用 HttpProcessor 来处理 WebSocket 请求，而要用专门 Processor 来处理，而在 Tomcat 中这样的 Processor 叫作 UpgradeProcessor。</p>
<p>为什么叫 Upgrade Processor 呢？这是因为 Tomcat 是将 HTTP 协议升级成 WebSocket 协议的。</p>
<p>WebSocket 是通过 HTTP 协议来进行握手的，因此当 WebSocket 的握手请求到来时，HttpProtocolHandler 首先接收到这个请求，在处理这个 HTTP 请求时，Tomcat 通过一个特殊的 Filter 判断该当前 HTTP 请求是否是一个 WebSocket Upgrade 请求（即包含<code>Upgrade: websocket</code>的 HTTP 头信息），如果是，则在 HTTP 响应里添加 WebSocket 相关的响应头信息，并进行协议升级。具体来说就是用 UpgradeProtocolHandler 替换当前的 HttpProtocolHandler，相应的，把当前 Socket 的 Processor 替换成 UpgradeProcessor，同时 Tomcat 会创建 WebSocket Session 实例和 Endpoint 实例，并跟当前的 WebSocket 连接一一对应起来。这个 WebSocket 连接不会立即关闭，并且在请求处理中，不再使用原有的 HttpProcessor，而是用专门的 UpgradeProcessor，UpgradeProcessor 最终会调用相应的 Endpoint 实例来处理请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127153521.jpg" alt="img"></p>
<p>你可以看到，Tomcat 对 WebSocket 请求的处理没有经过 Servlet 容器，而是通过 UpgradeProcessor 组件直接把请求发到 ServerEndpoint 实例，并且 Tomcat 的 WebSocket 实现不需要关注具体 I&#x2F;O 模型的细节，从而实现了与具体 I&#x2F;O 方式的解耦。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/b3690c15/" title="Tomcat连接器">https://dunwu.github.io/blog/pages/b3690c15/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
              <a href="/blog/tags/JavaWeb/" rel="tag"># JavaWeb</a>
              <a href="/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag"># 服务器</a>
              <a href="/blog/tags/Tomcat/" rel="tag"># Tomcat</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/a6eabb5c/" rel="prev" title="Tomcat优化">
                  <i class="fa fa-angle-left"></i> Tomcat优化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/20889acf/" rel="next" title="Tomcat 快速入门">
                  Tomcat 快速入门 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"412943d7cae4c801738d451fba3e1dee"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
