<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="《极客时间教程 - Java 并发编程实战》笔记四案例分析（一）：高性能限流器 Guava RateLimiterGuava 是 Google 开源的 Java 类库，提供了一个工具类 RateLimiter。 【示例】使用 RateLimiter 限流 12345678910111213141516171819202122232425&#x2F;&#x2F;限流器流速：2 个请求&#x2F;秒RateLimiter limi">
<meta property="og:type" content="article">
<meta property="og:title" content="《极客时间教程 - Java 并发编程实战》笔记四">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/6ef9bcbd/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="《极客时间教程 - Java 并发编程实战》笔记四案例分析（一）：高性能限流器 Guava RateLimiterGuava 是 Google 开源的 Java 类库，提供了一个工具类 RateLimiter。 【示例】使用 RateLimiter 限流 12345678910111213141516171819202122232425&#x2F;&#x2F;限流器流速：2 个请求&#x2F;秒RateLimiter limi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010943737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010944198.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010945560.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010946590.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947885.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010957084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010959294.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011000910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011004870.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020709300.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020712580.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020714249.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020725868.png">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020729492.png">
<meta property="article:published_time" content="2024-08-30T00:02:52.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.691Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010943737.png">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/6ef9bcbd/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/6ef9bcbd/","path":"/pages/6ef9bcbd/","title":"《极客时间教程 - Java 并发编程实战》笔记四"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《极客时间教程 - Java 并发编程实战》笔记四 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8A%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%95%99%E7%A8%8B-Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0%E5%9B%9B"><span class="nav-number">1.</span> <span class="nav-text">《极客时间教程 - Java 并发编程实战》笔记四</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E9%99%90%E6%B5%81%E5%99%A8-Guava-RateLimiter"><span class="nav-number">1.1.</span> <span class="nav-text">案例分析（一）：高性能限流器 Guava RateLimiter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">经典限流算法：令牌桶算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Guava-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">Guava 如何实现令牌桶算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-Netty"><span class="nav-number">1.2.</span> <span class="nav-text">案例分析（二）：高性能网络应用框架 Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%A7%E8%83%BD%E7%9A%84%E7%93%B6%E9%A2%88"><span class="nav-number">1.2.1.</span> <span class="nav-text">网络编程性能的瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">Reactor 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">Netty 中的线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-Netty-%E5%AE%9E%E7%8E%B0-Echo-%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">用 Netty 实现 Echo 程序服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor"><span class="nav-number">1.3.</span> <span class="nav-text">案例分析（三）：高性能队列 Disruptor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RingBuffer-%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="nav-number">1.3.1.</span> <span class="nav-text">RingBuffer 如何提升性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E2%80%9C%E4%BC%AA%E5%85%B1%E4%BA%AB%E2%80%9D"><span class="nav-number">1.3.2.</span> <span class="nav-text">如何避免“伪共享”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Disruptor-%E4%B8%AD%E7%9A%84%E6%97%A0%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">Disruptor 中的无锁算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-HiKariCP"><span class="nav-number">1.4.</span> <span class="nav-text">案例分析（四）：高性能数据库连接池 HiKariCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">1.4.1.</span> <span class="nav-text">什么是数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FastList-%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">FastList 解决了哪些性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentBag-%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">ConcurrentBag 解决了哪些性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Actor-%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E7%94%9F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">Actor 模型：面向对象原生的并发模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-Actor-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">Hello Actor 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.2.</span> <span class="nav-text">消息和对象方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Actor-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">Actor 的规范化定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-Actor-%E5%AE%9E%E7%8E%B0%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text">用 Actor 实现累加器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98%EF%BC%9A%E5%80%9F%E9%89%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BB%8F%E9%AA%8C"><span class="nav-number">1.6.</span> <span class="nav-text">软件事务内存：借鉴数据库的并发经验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-STM-%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%B4%A6"><span class="nav-number">1.6.1.</span> <span class="nav-text">用 STM 实现转账</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-STM"><span class="nav-number">1.7.</span> <span class="nav-text">自己实现 STM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%9A%E6%9B%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.8.</span> <span class="nav-text">协程：更轻量级的线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSP-%E6%A8%A1%E5%9E%8B%EF%BC%9AGolang-%E7%9A%84%E4%B8%BB%E5%8A%9B%E9%98%9F%E5%91%98"><span class="nav-number">1.9.</span> <span class="nav-text">CSP 模型：Golang 的主力队员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.10.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/6ef9bcbd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《极客时间教程 - Java 并发编程实战》笔记四 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《极客时间教程 - Java 并发编程实战》笔记四<a href="https://github.com/dunwu/blog/blob/master/source/_posts/00.%E7%AC%94%E8%AE%B0/01.Java/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%95%99%E7%A8%8B-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-30 08:02:52" itemprop="dateCreated datePublished" datetime="2024-08-30T08:02:52+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="《极客时间教程-Java-并发编程实战》笔记四"><a href="#《极客时间教程-Java-并发编程实战》笔记四" class="headerlink" title="《极客时间教程 - Java 并发编程实战》笔记四"></a>《极客时间教程 - Java 并发编程实战》笔记四</h1><h2 id="案例分析（一）：高性能限流器-Guava-RateLimiter"><a href="#案例分析（一）：高性能限流器-Guava-RateLimiter" class="headerlink" title="案例分析（一）：高性能限流器 Guava RateLimiter"></a>案例分析（一）：高性能限流器 Guava RateLimiter</h2><p>Guava 是 Google 开源的 Java 类库，提供了一个工具类 RateLimiter。</p>
<p>【示例】使用 RateLimiter 限流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流器流速：2 个请求/秒</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//执行任务的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//记录上一次执行时间</span></span><br><span class="line">prev = System.nanoTime();</span><br><span class="line"><span class="comment">//测试执行 20 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//限流器限流</span></span><br><span class="line">    limiter.acquire();</span><br><span class="line">    <span class="comment">//提交任务异步执行</span></span><br><span class="line">    es.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//打印时间间隔：毫秒</span></span><br><span class="line">        System.out.println((cur - prev) / <span class="number">1000_000</span>);</span><br><span class="line">        prev = cur;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 500</span></span><br><span class="line"><span class="comment">// 499</span></span><br><span class="line"><span class="comment">// 500</span></span><br><span class="line"><span class="comment">// 499</span></span><br></pre></td></tr></table></figure>

<h3 id="经典限流算法：令牌桶算法"><a href="#经典限流算法：令牌桶算法" class="headerlink" title="经典限流算法：令牌桶算法"></a>经典限流算法：令牌桶算法</h3><p>Guava 限流算法采用<strong>令牌桶算法</strong>，其<strong>核心是要想通过限流器，必须拿到令牌</strong>。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。令牌桶算法的详细描述如下：</p>
<ol>
<li>令牌以固定的速率添加到令牌桶中，假设限流的速率是 r&#x2F;秒，则令牌每 1&#x2F;r 秒会添加一个；</li>
<li>假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃；</li>
<li>请求能够通过限流器的前提是令牌桶中有令牌。</li>
</ol>
<p>这个算法中，限流的速率 r 还是比较容易理解的，但令牌桶的容量 b 该怎么理解呢？b 其实是 burst 的简写，意义是<strong>限流器允许的最大突发流量</strong>。比如 b&#x3D;10，而且令牌桶中的令牌已满，此时限流器允许 10 个请求同时通过限流器，当然只是突发流量而已，这 10 个请求会带走 10 个令牌，所以后续的流量只能按照速率 r 通过限流器。</p>
<h3 id="Guava-如何实现令牌桶算法"><a href="#Guava-如何实现令牌桶算法" class="headerlink" title="Guava 如何实现令牌桶算法"></a>Guava 如何实现令牌桶算法</h3><p>Guava 实现令牌桶算法，其关键是<strong>记录并动态计算下一令牌发放的时间</strong>。</p>
<p>假设令牌桶的容量为 b&#x3D;1，限流速率 r &#x3D; 1 个请求&#x2F;秒，如下图所示，如果当前令牌桶中没有令牌，下一个令牌的发放时间是在第 3 秒，而在第 2 秒的时候有一个线程 T1 请求令牌，此时该如何处理呢？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010943737.png"></p>
<p>对于这个请求令牌的线程而言，很显然需要等待 1 秒，因为 1 秒以后（第 3 秒）它就能拿到令牌了。此时需要注意的是，下一个令牌发放的时间也要增加 1 秒，为什么呢？因为第 3 秒发放的令牌已经被线程 T1 预占了。处理之后如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010944198.png"></p>
<p>假设 T1 在预占了第 3 秒的令牌之后，马上又有一个线程 T2 请求令牌，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010945560.png"></p>
<p>很显然，由于下一个令牌产生的时间是第 4 秒，所以线程 T2 要等待两秒的时间，才能获取到令牌，同时由于 T2 预占了第 4 秒的令牌，所以下一令牌产生时间还要增加 1 秒，完全处理之后，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010946590.png"></p>
<p>上面线程 T1、T2 都是在<strong>下一令牌产生时间之前</strong>请求令牌，如果线程在<strong>下一令牌产生时间之后</strong>请求令牌会如何呢？假设在线程 T1 请求令牌之后的 5 秒，也就是第 7 秒，线程 T3 请求令牌，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947529.png"></p>
<p>由于在第 5 秒已经产生了一个令牌，所以此时线程 T3 可以直接拿到令牌，而无需等待。在第 7 秒，实际上限流器能够产生 3 个令牌，第 5、6、7 秒各产生一个令牌。由于我们假设令牌桶的容量是 1，所以第 6、7 秒产生的令牌就丢弃了，其实等价地你也可以认为是保留的第 7 秒的令牌，丢弃的第 5、6 秒的令牌，也就是说第 7 秒的令牌被线程 T3 占有了，于是下一令牌的的产生时间应该是第 8 秒，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010947885.png"></p>
<p>通过上面简要地分析们<strong>只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能</strong>。我们可以将上面的这个算法代码化，示例代码如下所示，依然假设令牌桶的容量是 1。关键是** reserve() 方法**，这个方法会为请求令牌的线程预分配令牌，同时返回该线程能够获取令牌的时间。其实现逻辑就是上面提到的：如果线程请求令牌的时间在下一令牌产生时间之后，那么该线程立刻就能够获取令牌；反之，如果请求时间在下一令牌产生时间之前，那么该线程是在下一令牌产生的时间获取令牌。由于此时下一令牌已经被该线程预占，所以下一令牌产生的时间需要加上 1 秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一令牌产生时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="comment">//请求时间在下一令牌产生时间之后</span></span><br><span class="line">        <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">            <span class="comment">//将下一令牌产生时间重置为当前时间</span></span><br><span class="line">            next = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> next;</span><br><span class="line">        <span class="comment">//设置下一令牌产生时间</span></span><br><span class="line">        next += interval;</span><br><span class="line">        <span class="comment">//返回线程需要等待的时间</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(at, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请令牌</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//申请令牌时的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//预占令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> reserve(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> max(at - now, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按照条件等待</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果令牌桶的容量大于 1，又该如何处理呢？按照令牌桶算法，令牌要首先从令牌桶中出，所以我们需要按需计算令牌桶中的数量，当有线程请求令牌时，先从令牌桶中出。具体的代码实现如下所示。我们增加了一个** resync() 方法<strong>，在这个方法中，如果线程请求令牌的时间在下一令牌产生时间之后，会重新计算令牌桶中的令牌数，</strong>新产生的令牌的计算公式是：(now-next)&#x2F;interval**，你可对照上面的示意图来理解。reserve() 方法中，则增加了先从令牌桶中出令牌的逻辑，不过需要注意的是，如果令牌是从令牌桶中出的，那么 next 就无需增加一个 interval 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前令牌桶中的令牌数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">storedPermits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//令牌桶的容量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxPermits</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//下一令牌产生时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//发放令牌间隔：纳秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求时间在下一令牌产生时间之后，则</span></span><br><span class="line">    <span class="comment">// 1. 重新计算令牌桶中的令牌数</span></span><br><span class="line">    <span class="comment">// 2. 将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">            <span class="comment">//新产生的令牌数</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">newPermits</span> <span class="operator">=</span> (now - next) / interval;</span><br><span class="line">            <span class="comment">//新令牌增加到令牌桶</span></span><br><span class="line">            storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">            <span class="comment">//将下一个令牌发放时间重置为当前时间</span></span><br><span class="line">            next = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预占令牌，返回能够获取令牌的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        resync(now);</span><br><span class="line">        <span class="comment">//能够获取令牌的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> next;</span><br><span class="line">        <span class="comment">//令牌桶中能提供的令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">fb</span> <span class="operator">=</span> min(<span class="number">1</span>, storedPermits);</span><br><span class="line">        <span class="comment">//令牌净需求：首先减掉令牌桶中的令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nr</span> <span class="operator">=</span> <span class="number">1</span> - fb;</span><br><span class="line">        <span class="comment">//重新计算下一令牌产生时间</span></span><br><span class="line">        next = next + nr * interval;</span><br><span class="line">        <span class="comment">//重新计算令牌桶中的令牌</span></span><br><span class="line">        <span class="built_in">this</span>.storedPermits -= fb;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请令牌</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//申请令牌时的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//预占令牌</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">at</span> <span class="operator">=</span> reserve(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> max(at - now, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按照条件等待</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经典的限流算法有两个，一个是<strong>令牌桶算法（Token Bucket）</strong>，另一个是<strong>漏桶算法（Leaky Bucket）</strong>。令牌桶算法是定时向令牌桶发送令牌，请求能够从令牌桶中拿到令牌，然后才能通过限流器；而漏桶算法里，请求就像水一样注入漏桶，漏桶会按照一定的速率自动将水漏掉，只有漏桶里还能注入水的时候，请求才能通过限流器。令牌桶算法和漏桶算法很像一个硬币的正反面，所以你可以参考令牌桶算法的实现来实现漏桶算法。</p>
<h2 id="案例分析（二）：高性能网络应用框架-Netty"><a href="#案例分析（二）：高性能网络应用框架-Netty" class="headerlink" title="案例分析（二）：高性能网络应用框架 Netty"></a>案例分析（二）：高性能网络应用框架 Netty</h2><h3 id="网络编程性能的瓶颈"><a href="#网络编程性能的瓶颈" class="headerlink" title="网络编程性能的瓶颈"></a>网络编程性能的瓶颈</h3><p>BIO 模型里，所有 read() 操作和 write() 操作都会阻塞当前线程的，如果客户端已经和服务端建立了一个连接，而迟迟不发送数据，那么服务端的 read() 操作会一直阻塞，所以<strong>使用 BIO 模型，一般都会为每个 socket 分配一个独立的线程</strong>，这样就不会因为线程阻塞在一个 socket 上而影响对其他 socket 的读写。BIO 的线程模型如下图所示，每一个 socket 都对应一个独立的线程；为了避免频繁创建、消耗线程，可以采用线程池，但是 socket 和线程之间的对应关系并不会变化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010957084.png"></p>
<p>BIO 这种线程模型适用于 socket 连接不是很多的场景；但是现在的互联网场景，往往需要服务器能够支撑十万甚至百万连接，而创建十万甚至上百万个线程显然并不现实，所以 BIO 线程模型无法解决百万连接的问题。如果仔细观察，你会发现互联网场景中，虽然连接多，但是每个连接上的请求并不频繁，所以线程大部分时间都在等待 I&#x2F;O 就绪。也就是说线程大部分时间都阻塞在那里，这完全是浪费，如果我们能够解决这个问题，那就不需要这么多线程了。</p>
<p>可以用一个线程来处理多个连接，这样线程的利用率就上来了，同时所需的线程数量也跟着降下来了。这个思路很好，可是使用 BIO 相关的 API 是无法实现的，这是为什么呢？因为 BIO 相关的 socket 读写操作都是阻塞式的，而一旦调用了阻塞式 API，在 I&#x2F;O 就绪前，调用线程会一直阻塞，也就无法处理其他的 socket 连接了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409010959294.png"></p>
<h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><p>下面是 Reactor 模式的类结构图，其中 Handle 指的是 I&#x2F;O 句柄，在 Java 网络编程里，它本质上就是一个网络连接。Event Handler 很容易理解，就是一个事件处理器，其中 handle_event() 方法处理 I&#x2F;O 事件，也就是每个 Event Handler 处理一个 I&#x2F;O Handle；get_handle() 方法可以返回这个 I&#x2F;O 的 Handle。Synchronous Event Demultiplexer 可以理解为操作系统提供的 I&#x2F;O 多路复用 API，例如 POSIX 标准里的 select() 以及 Linux 里面的 epoll()。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011000910.png"></p>
<p>Reactor 模式的核心自然是 <strong>Reactor 这个类</strong>，其中 register_handler() 和 remove_handler() 这两个方法可以注册和删除一个事件处理器；<strong>handle_events() 方式是核心</strong>，也是 Reactor 模式的发动机，这个方法的核心逻辑如下：首先通过同步事件多路选择器提供的 select() 方法监听网络事件，当有网络事件就绪后，就遍历事件处理器来处理该网络事件。由于网络事件是源源不断的，所以在主程序中启动 Reactor 模式，需要以 <code>while(true)&#123;&#125;</code> 的方式调用 handle_events() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Reactor::handle_events()&#123;</span><br><span class="line">  <span class="comment">//通过同步事件多路选择器提供的</span></span><br><span class="line">  <span class="comment">//select() 方法监听网络事件</span></span><br><span class="line">  select(handlers);</span><br><span class="line">  <span class="comment">//处理网络事件</span></span><br><span class="line">  <span class="keyword">for</span>(h in handlers)&#123;</span><br><span class="line">    h.handle_event();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在主程序中启动事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  handle_events();</span><br></pre></td></tr></table></figure>

<h3 id="Netty-中的线程模型"><a href="#Netty-中的线程模型" class="headerlink" title="Netty 中的线程模型"></a>Netty 中的线程模型</h3><p><strong>Netty 中最核心的概念是事件循环（EventLoop）</strong>，其实也就是 Reactor 模式中的 Reactor，<strong>负责监听网络事件并调用事件处理器进行处理</strong>。在 4.x 版本的 Netty 中，网络连接和 EventLoop 是稳定的多对 1 关系，而 EventLoop 和 Java 线程是 1 对 1 关系，这里的稳定指的是关系一旦确定就不再发生变化。也就是说一个网络连接只会对应唯一的一个 EventLoop，而一个 EventLoop 也只会对应到一个 Java 线程，所以<strong>一个网络连接只会对应到一个 Java 线程</strong>。</p>
<p>一个网络连接对应到一个 Java 线程上，最大的好处就是对于一个网络连接的事件处理是单线程的，这样就<strong>避免了各种并发问题</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409011004870.png"></p>
<p>Netty 中还有一个核心概念是** EventLoopGroup**，顾名思义，一个 EventLoopGroup 由一组 EventLoop 组成。实际使用中，一般都会创建两个 EventLoopGroup，一个称为 bossGroup，一个称为 workerGroup。</p>
<p>这个和 socket 处理网络请求的机制有关，socket 处理 TCP 网络连接请求，是在一个独立的 socket 中，每当有一个 TCP 连接成功建立，都会创建一个新的 socket，之后对 TCP 连接的读写都是由新创建处理的 socket 完成的。也就是说<strong>处理 TCP 连接请求和读写请求是通过两个不同的 socket 完成的</strong>。</p>
<p><strong>在 Netty 中，bossGroup 就用来处理连接请求的，而 workerGroup 是用来处理读写请求的</strong>。bossGroup 处理完连接请求后，会将这个连接提交给 workerGroup 来处理， workerGroup 里面有多个 EventLoop，那新的连接会交给哪个 EventLoop 来处理呢？这就需要一个负载均衡算法，Netty 中目前使用的是<strong>轮询算法</strong>。</p>
<h3 id="用-Netty-实现-Echo-程序服务端"><a href="#用-Netty-实现-Echo-程序服务端" class="headerlink" title="用 Netty 实现 Echo 程序服务端"></a>用 Netty 实现 Echo 程序服务端</h3><p>第一个，如果 NettybossGroup 只监听一个端口，那 bossGroup 只需要 1 个 EventLoop 就可以了，多了纯属浪费。</p>
<p>第二个，默认情况下，Netty 会创建“2*CPU 核数”个 EventLoop，由于网络连接与 EventLoop 有稳定的关系，所以事件处理器在处理网络事件的时候是不能有阻塞操作的，否则很容易导致请求大面积超时。如果实在无法避免使用阻塞操作，那可以通过线程池来异步处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件处理器</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line"><span class="comment">//boss 线程组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//worker 线程组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel.class)</span><br><span class="line">     .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">             ch.pipeline().addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    <span class="comment">//bind 服务端端口</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(<span class="number">9090</span>).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//终止工作线程组</span></span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">    <span class="comment">//终止 boss 线程组</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//socket 连接处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理读事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理读完成事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Netty 是一个款优秀的网络编程框架，性能非常好，为了实现高性能的目标，Netty 做了很多优化，例如优化了 ByteBuffer、支持零拷贝等等，和并发编程相关的就是它的线程模型了。Netty 的线程模型设计得很精巧，每个网络连接都关联到了一个线程上，这样做的好处是：对于一个网络连接，读写操作都是单线程执行的，从而避免了并发程序的各种问题。</p>
<h2 id="案例分析（三）：高性能队列-Disruptor"><a href="#案例分析（三）：高性能队列-Disruptor" class="headerlink" title="案例分析（三）：高性能队列 Disruptor"></a>案例分析（三）：高性能队列 Disruptor</h2><p><strong>Disruptor 是一款高性能的有界内存队列</strong>，目前应用非常广泛，Log4j2、Spring Messaging、HBase、Storm 都用到了 Disruptor，那 Disruptor 的性能为什么这么高呢？Disruptor 项目团队曾经写过一篇论文，详细解释了其原因，可以总结为如下：</p>
<ol>
<li>内存分配更加合理，使用 RingBuffer 数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率；对象循环利用，避免频繁 GC。</li>
<li>能够避免伪共享，提升缓存利用率。</li>
<li>采用无锁算法，避免频繁加锁、解锁的性能消耗。</li>
<li>支持批量消费，消费者可以无锁方式消费多个消息。</li>
</ol>
<p>Disruptor 的使用比 Java SDK 提供 BlockingQueue 要复杂一些，但是总体思路还是一致的，其大致情况如下：</p>
<ul>
<li><p>在 Disruptor 中，生产者生产的对象（也就是消费者消费的对象）称为 Event，使用 Disruptor 必须自定义 Event，例如示例代码的自定义 Event 是 LongEvent；</p>
</li>
<li><p>构建 Disruptor 对象除了要指定队列大小外，还需要传入一个 EventFactory，示例代码中传入的是<code>LongEvent::new</code>；</p>
</li>
<li><p>消费 Disruptor 中的 Event 需要通过 handleEventsWith() 方法注册一个事件处理器，发布 Event 则需要通过 publishEvent() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 Event</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LongEvent</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定 RingBuffer 大小，</span></span><br><span class="line"><span class="comment">// 必须是 2 的 N 次方</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor</span><br><span class="line">  = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(</span><br><span class="line">    LongEvent::<span class="keyword">new</span>,</span><br><span class="line">    bufferSize,</span><br><span class="line">    DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件处理器</span></span><br><span class="line">disruptor.handleEventsWith(</span><br><span class="line">  (event, sequence, endOfBatch) -&gt;</span><br><span class="line">    System.out.println(<span class="string">&quot;E: &quot;</span>+event));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Disruptor</span></span><br><span class="line">disruptor.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 RingBuffer</span></span><br><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer</span><br><span class="line">  = disruptor.getRingBuffer();</span><br><span class="line"><span class="comment">// 生产 Event</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="literal">true</span>; l++)&#123;</span><br><span class="line">  bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">  <span class="comment">// 生产者生产消息</span></span><br><span class="line">  ringBuffer.publishEvent(</span><br><span class="line">    (event, sequence, buffer) -&gt;</span><br><span class="line">      event.set(buffer.getLong(<span class="number">0</span>)), bb);</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RingBuffer-如何提升性能"><a href="#RingBuffer-如何提升性能" class="headerlink" title="RingBuffer 如何提升性能"></a>RingBuffer 如何提升性能</h3><p>Java SDK 中 ArrayBlockingQueue 使用<strong>数组</strong>作为底层的数据存储，而 Disruptor 是使用** RingBuffer **作为数据存储。RingBuffer 本质上也是数组。</p>
<p>生产者线程向 ArrayBlockingQueue 增加一个元素，每次增加元素 E 之前，都需要创建一个对象 E，如下图所示，ArrayBlockingQueue 内部有 6 个元素，这 6 个元素都是由生产者线程创建的，由于创建这些元素的时间基本上是离散的，所以这些元素的内存地址大概率也不是连续的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020709300.png"></p>
<p>Disruptor 内部的 RingBuffer 也是用数组实现的，但是这个数组中的所有元素在初始化时是一次性全部创建的，所以这些元素的内存地址大概率是连续的，相关的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;bufferSize; i++)&#123;</span><br><span class="line">  <span class="comment">//entries[] 就是 RingBuffer 内部的数组</span></span><br><span class="line">  <span class="comment">//eventFactory 就是前面示例代码中传入的 LongEvent::new</span></span><br><span class="line">  entries[BUFFER_PAD + i]</span><br><span class="line">    = eventFactory.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中所有元素内存地址连续能提升性能。因为消费者线程在消费的时候，是遵循空间局部性原理的，消费完第 1 个元素，很快就会消费第 2 个元素；当消费第 1 个元素 E1 的时候，CPU 会把内存中 E1 后面的数据也加载进 Cache，如果 E1 和 E2 在内存中的地址是连续的，那么 E2 也就会被加载进 Cache 中，然后当消费第 2 个元素的时候，由于 E2 已经在 Cache 中了，所以就不需要从内存中加载了，这样就能大大提升性能。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020712580.png"></p>
<p>除此之外，在 Disruptor 中，生产者线程通过 publishEvent() 发布 Event 的时候，并不是创建一个新的 Event，而是通过 event.set() 方法修改 Event， 也就是说 RingBuffer 创建的 Event 是可以循环利用的，这样还能避免频繁创建、删除 Event 导致的频繁 GC 问题。</p>
<h3 id="如何避免“伪共享”"><a href="#如何避免“伪共享”" class="headerlink" title="如何避免“伪共享”"></a>如何避免“伪共享”</h3><p><strong>伪共享指的是由于共享缓存行导致缓存无效的场景</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020714249.png"></p>
<p>避免伪共享的方法是：</p>
<p><strong>每个变量独占一个缓存行、不共享缓存行</strong>就可以了，具体技术是<strong>缓存行填充</strong>。比如想让 takeIndex 独占一个缓存行，可以在 takeIndex 的前后各填充 56 个字节，这样就一定能保证 takeIndex 独占一个缓存行。下面的示例代码出自 Disruptor，Sequence 对象中的 value 属性就能避免伪共享，因为这个属性前后都填充了 56 个字节。Disruptor 中很多对象，例如 RingBuffer、RingBuffer 内部的数组都用到了这种填充技术来避免伪共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前：填充 56 字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LhsPadding</span>&#123;</span><br><span class="line">    <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> <span class="keyword">extends</span> <span class="title class_">LhsPadding</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后：填充 56 字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RhsPadding</span> <span class="keyword">extends</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">    <span class="type">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence</span> <span class="keyword">extends</span> <span class="title class_">RhsPadding</span>&#123;</span><br><span class="line">  <span class="comment">//省略实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Disruptor-中的无锁算法"><a href="#Disruptor-中的无锁算法" class="headerlink" title="Disruptor 中的无锁算法"></a>Disruptor 中的无锁算法</h3><p>Disruptor 中最复杂的是入队操作，所以我们重点来看看入队操作是如何实现的。</p>
<p>对于入队操作，最关键的要求是不能覆盖没有消费的元素；对于出队操作，最关键的要求是不能读取没有写入的元素，所以 Disruptor 中也一定会维护类似出队索引和入队索引这样两个关键变量。Disruptor 中的 RingBuffer 维护了入队索引，但是并没有维护出队索引，这是因为在 Disruptor 中多个消费者可以同时消费，每个消费者都会有一个出队索引，所以 RingBuffer 的出队索引是所有消费者里面最小的那一个。</p>
<p>下面是 Disruptor 生产者入队操作的核心代码，看上去很复杂，其实逻辑很简单：如果没有足够的空余位置，就出让 CPU 使用权，然后重新计算；反之则用 CAS 设置入队索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者获取 n 个写入位置</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//cursor 类似于入队索引，指的是上次生产到这里</span></span><br><span class="line">  current = cursor.get();</span><br><span class="line">  <span class="comment">//目标是在生产 n 个</span></span><br><span class="line">  next = current + n;</span><br><span class="line">  <span class="comment">//减掉一个循环</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">wrapPoint</span> <span class="operator">=</span> next - bufferSize;</span><br><span class="line">  <span class="comment">//获取上一次的最小消费位置</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">cachedGatingSequence</span> <span class="operator">=</span> gatingSequenceCache.get();</span><br><span class="line">  <span class="comment">//没有足够的空余位置</span></span><br><span class="line">  <span class="keyword">if</span> (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)&#123;</span><br><span class="line">    <span class="comment">//重新计算所有消费者里面的最小值位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">gatingSequence</span> <span class="operator">=</span> Util.getMinimumSequence(</span><br><span class="line">        gatingSequences, current);</span><br><span class="line">    <span class="comment">//仍然没有足够的空余位置，出让 CPU 使用权，重新执行下一循环</span></span><br><span class="line">    <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)&#123;</span><br><span class="line">      LockSupport.parkNanos(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从新设置上一次的最小消费位置</span></span><br><span class="line">    gatingSequenceCache.set(gatingSequence);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))&#123;</span><br><span class="line">    <span class="comment">//获取写入位置成功，跳出循环</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="案例分析（四）：高性能数据库连接池-HiKariCP"><a href="#案例分析（四）：高性能数据库连接池-HiKariCP" class="headerlink" title="案例分析（四）：高性能数据库连接池 HiKariCP"></a>案例分析（四）：高性能数据库连接池 HiKariCP</h2><p>业界知名的数据库连接池有不少，例如 c3p0、DBCP、Tomcat JDBC Connection Pool、Druid 等，不过最近最火的是 HiKariCP。</p>
<p><strong>HiKariCP 号称是业界跑得最快的数据库连接池</strong>，这两年发展得顺风顺水，尤其是 Springboot 2.0 将其作为<strong>默认数据库连接池</strong>。</p>
<h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>数据库连接池和线程池一样，都属于池化资源，作用都是避免重量级资源的频繁创建和销毁，对于数据库连接池来说，也就是避免数据库连接频繁创建和销毁。如下图所示，服务端会在运行期持有一定数量的数据库连接，当需要执行 SQL 时，并不是直接创建一个数据库连接，而是从连接池中获取一个；当 SQL 执行完，也并不是将数据库连接真的关掉，而是将其归还到连接池中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020725868.png"></p>
<p>执行数据库操作基本上是一系列规范化的步骤：</p>
<ol>
<li>通过数据源获取一个数据库连接；</li>
<li>创建 Statement；</li>
<li>执行 SQL；</li>
<li>通过 ResultSet 获取 SQL 执行结果；</li>
<li>释放 ResultSet；</li>
<li>释放 Statement；</li>
<li>释放数据库连接。</li>
</ol>
<p>下面的示例代码，通过 <code>ds.getConnection()</code> 获取一个数据库连接时，其实是向数据库连接池申请一个数据库连接，而不是创建一个新的数据库连接。同样，通过 <code>conn.close()</code> 释放一个数据库连接时，也不是直接将连接关闭，而是将连接归还给数据库连接池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接池配置</span></span><br><span class="line"><span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">config.setMinimumIdle(<span class="number">1</span>);</span><br><span class="line">config.setMaximumPoolSize(<span class="number">2</span>);</span><br><span class="line">config.setConnectionTestQuery(<span class="string">&quot;SELECT 1&quot;</span>);</span><br><span class="line">config.setDataSourceClassName(<span class="string">&quot;org.h2.jdbcx.JdbcDataSource&quot;</span>);</span><br><span class="line">config.addDataSourceProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:h2:mem:test&quot;</span>);</span><br><span class="line"><span class="comment">// 创建数据源</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 获取数据库连接</span></span><br><span class="line">  conn = ds.getConnection();</span><br><span class="line">  <span class="comment">// 创建 Statement</span></span><br><span class="line">  stmt = conn.createStatement();</span><br><span class="line">  <span class="comment">// 执行 SQL</span></span><br><span class="line">  rs = stmt.executeQuery(<span class="string">&quot;select * from abc&quot;</span>);</span><br><span class="line">  <span class="comment">// 获取结果</span></span><br><span class="line">  <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//关闭 ResultSet</span></span><br><span class="line">  close(rs);</span><br><span class="line">  <span class="comment">//关闭 Statement</span></span><br><span class="line">  close(stmt);</span><br><span class="line">  <span class="comment">//关闭 Connection</span></span><br><span class="line">  close(conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">(AutoCloseable rs)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">HiKariCP 官方网站</a> 解释了其性能之所以如此之高的秘密。微观上 HiKariCP 程序编译出的字节码执行效率更高，站在字节码的角度去优化 Java 代码，HiKariCP 的作者对性能的执着可见一斑，不过遗憾的是他并没有详细解释都做了哪些优化。而宏观上主要是和两个数据结构有关，一个是 FastList，另一个是 ConcurrentBag。下面我们来看看它们是如何提升 HiKariCP 的性能的。</p>
<h3 id="FastList-解决了哪些性能问题"><a href="#FastList-解决了哪些性能问题" class="headerlink" title="FastList 解决了哪些性能问题"></a>FastList 解决了哪些性能问题</h3><p>按照规范步骤，执行完数据库操作之后，需要依次关闭 ResultSet、Statement、Connection，但是总有粗心的同学只是关闭了 Connection，而忘了关闭 ResultSet 和 Statement。为了解决这种问题，最好的办法是当关闭 Connection 时，能够自动关闭 Statement。为了达到这个目标，Connection 就需要跟踪创建的 Statement，最简单的办法就是将创建的 Statement 保存在数组 ArrayList 里，这样当关闭 Connection 的时候，就可以依次将数组中的所有 Statement 关闭。</p>
<p>HiKariCP 觉得用 ArrayList 还是太慢，当通过 <code>conn.createStatement()</code> 创建一个 Statement 时，需要调用 ArrayList 的 add() 方法加入到 ArrayList 中，这个是没有问题的；但是当通过 <code>stmt.close()</code> 关闭 Statement 的时候，需要调用 ArrayList 的 remove() 方法来将其从 ArrayList 中删除，这里是有优化余地的。</p>
<p>假设一个 Connection 依次创建 6 个 Statement，分别是 S1、S2、S3、S4、S5、S6，按照正常的编码习惯，关闭 Statement 的顺序一般是逆序的，关闭的顺序是：S6、S5、S4、S3、S2、S1，而 ArrayList 的 remove(Object o) 方法是顺序遍历查找，逆序删除而顺序查找，这样的查找效率就太慢了。如何优化呢？很简单，优化成逆序查找就可以了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202409020729492.png"></p>
<p>HiKariCP 中的 FastList 相对于 ArrayList 的一个优化点就是将 <code>remove(Object element)</code> 方法的<strong>查找顺序变成了逆序查找</strong>。除此之外，FastList 还有另一个优化点，是 <code>get(int index)</code> 方法没有对 index 参数进行越界检查，HiKariCP 能保证不会越界，所以不用每次都进行越界检查。</p>
<h3 id="ConcurrentBag-解决了哪些性能问题"><a href="#ConcurrentBag-解决了哪些性能问题" class="headerlink" title="ConcurrentBag 解决了哪些性能问题"></a>ConcurrentBag 解决了哪些性能问题</h3><p>如果让我们自己来实现一个数据库连接池，最简单的办法就是用两个阻塞队列来实现，一个用于保存空闲数据库连接的队列 idle，另一个用于保存忙碌数据库连接的队列 busy；获取连接时将空闲的数据库连接从 idle 队列移动到 busy 队列，而关闭连接时将数据库连接从 busy 移动到 idle。这种方案将并发问题委托给了阻塞队列，实现简单，但是性能并不是很理想。因为 Java SDK 中的阻塞队列是用锁实现的，而高并发场景下锁的争用对性能影响很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忙碌队列</span></span><br><span class="line">BlockingQueue&lt;Connection&gt; busy;</span><br><span class="line"><span class="comment">//空闲队列</span></span><br><span class="line">BlockingQueue&lt;Connection&gt; idle;</span><br></pre></td></tr></table></figure>

<p>HiKariCP 并没有使用 Java SDK 中的阻塞队列，而是自己实现了一个叫做 ConcurrentBag 的并发容器。ConcurrentBag 的设计最初源自 C#，它的一个核心设计是使用 ThreadLocal 避免部分并发问题，不过 HiKariCP 中的 ConcurrentBag 并没有完全参考 C#的实现，下面我们来看看它是如何实现的。</p>
<p>ConcurrentBag 中最关键的属性有 4 个，分别是：用于存储所有的数据库连接的共享队列 sharedList、线程本地存储 threadList、等待数据库连接的线程数 waiters 以及分配数据库连接的工具 handoffQueue。其中，handoffQueue 用的是 Java SDK 提供的 SynchronousQueue，SynchronousQueue 主要用于线程之间传递数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存储所有的数据库连接</span></span><br><span class="line">CopyOnWriteArrayList&lt;T&gt; sharedList;</span><br><span class="line"><span class="comment">//线程本地存储中的数据库连接</span></span><br><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList;</span><br><span class="line"><span class="comment">//等待数据库连接的线程数</span></span><br><span class="line">AtomicInteger waiters;</span><br><span class="line"><span class="comment">//分配数据库连接的工具</span></span><br><span class="line">SynchronousQueue&lt;T&gt; handoffQueue;</span><br></pre></td></tr></table></figure>

<p>当线程池创建了一个数据库连接时，通过调用 ConcurrentBag 的 add() 方法加入到 ConcurrentBag 中，下面是 add() 方法的具体实现，逻辑很简单，就是将这个连接加入到共享队列 sharedList 中，如果此时有线程在等待数据库连接，那么就通过 handoffQueue 将这个连接分配给等待的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将空闲连接添加到队列</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span>&#123;</span><br><span class="line">  <span class="comment">//加入共享队列</span></span><br><span class="line">  sharedList.add(bagEntry);</span><br><span class="line">  <span class="comment">//如果有等待连接的线程，</span></span><br><span class="line">  <span class="comment">//则通过 handoffQueue 直接分配给等待的线程</span></span><br><span class="line">  <span class="keyword">while</span> (waiters.get() &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; bagEntry.getState() == STATE_NOT_IN_USE</span><br><span class="line">    &amp;&amp; !handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">      <span class="keyword">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ConcurrentBag 提供的 borrow() 方法，可以获取一个空闲的数据库连接，borrow() 的主要逻辑是：</p>
<ol>
<li>首先查看线程本地存储是否有空闲连接，如果有，则返回一个空闲的连接；</li>
<li>如果线程本地存储中无空闲连接，则从共享队列中获取。</li>
<li>如果共享队列中也没有空闲的连接，则请求线程需要等待。</li>
</ol>
<p>需要注意的是，线程本地存储中的连接是可以被其他线程窃取的，所以需要用 CAS 方法防止重复分配。在共享队列中获取空闲连接，也采用了 CAS 方法防止重复分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">borrow</span><span class="params">(<span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span>&#123;</span><br><span class="line">  <span class="comment">// 先查看线程本地存储是否有空闲连接</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; list = threadList.get();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> list.remove(i);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">T</span> <span class="variable">bagEntry</span> <span class="operator">=</span> weakThreadLocals</span><br><span class="line">      ? ((WeakReference&lt;T&gt;) entry).get()</span><br><span class="line">      : (T) entry;</span><br><span class="line">    <span class="comment">//线程本地存储中的连接也可以被窃取，</span></span><br><span class="line">    <span class="comment">//所以需要用 CAS 方法防止重复分配</span></span><br><span class="line">    <span class="keyword">if</span> (bagEntry != <span class="literal">null</span></span><br><span class="line">      &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bagEntry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程本地存储中无空闲连接，则从共享队列中获取</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">waiting</span> <span class="operator">=</span> waiters.incrementAndGet();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T bagEntry : sharedList) &#123;</span><br><span class="line">      <span class="comment">//如果共享队列中有空闲连接，则返回</span></span><br><span class="line">      <span class="keyword">if</span> (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bagEntry;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共享队列中没有连接，则需要等待</span></span><br><span class="line">    timeout = timeUnit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> currentTime();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">T</span> <span class="variable">bagEntry</span> <span class="operator">=</span> handoffQueue.poll(timeout, NANOSECONDS);</span><br><span class="line">      <span class="keyword">if</span> (bagEntry == <span class="literal">null</span></span><br><span class="line">        || bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">          <span class="keyword">return</span> bagEntry;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//重新计算等待时间</span></span><br><span class="line">      timeout -= elapsedNanos(start);</span><br><span class="line">    &#125; <span class="keyword">while</span> (timeout &gt; <span class="number">10_000</span>);</span><br><span class="line">    <span class="comment">//超时没有获取到连接，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    waiters.decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放连接需要调用 ConcurrentBag 提供的 requite() 方法，该方法的逻辑很简单，首先将数据库连接状态更改为 STATE_NOT_IN_USE，之后查看是否存在等待线程，如果有，则分配给等待线程；如果没有，则将该数据库连接保存到线程本地存储里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放连接</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">requite</span><span class="params">(<span class="keyword">final</span> T bagEntry)</span>&#123;</span><br><span class="line">  <span class="comment">//更新连接状态</span></span><br><span class="line">  bagEntry.setState(STATE_NOT_IN_USE);</span><br><span class="line">  <span class="comment">//如果有等待的线程，则直接分配给线程，无需进入任何队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; waiters.get() &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bagEntry.getState() != STATE_NOT_IN_USE</span><br><span class="line">      || handoffQueue.offer(bagEntry)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i &amp; <span class="number">0xff</span>) == <span class="number">0xff</span>) &#123;</span><br><span class="line">      parkNanos(MICROSECONDS.toNanos(<span class="number">10</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果没有等待的线程，则进入线程本地存储</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; threadLocalList = threadList.get();</span><br><span class="line">  <span class="keyword">if</span> (threadLocalList.size() &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    threadLocalList.add(weakThreadLocals</span><br><span class="line">      ? <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(bagEntry)</span><br><span class="line">      : bagEntry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor-模型：面向对象原生的并发模型"><a href="#Actor-模型：面向对象原生的并发模型" class="headerlink" title="Actor 模型：面向对象原生的并发模型"></a>Actor 模型：面向对象原生的并发模型</h2><h3 id="Hello-Actor-模型"><a href="#Hello-Actor-模型" class="headerlink" title="Hello Actor 模型"></a>Hello Actor 模型</h3><p>Actor 模型本质上是一种计算模型，基本的计算单元称为 Actor，换言之，<strong>在 Actor 模型中，所有的计算都是在 Actor 中执行的</strong>。在面向对象编程里面，一切都是对象；在 Actor 模型里，一切都是 Actor，并且 Actor 之间是完全隔离的，不会共享任何变量。</p>
<p>并发问题的根源就在于共享变量，而 Actor 模型中 Actor 之间不共享变量，所以很多人就把 Actor 模型定义为一种<strong>并发计算模型</strong>。</p>
<p>Java 语言本身并不支持 Actor 模型，所以如果你想在 Java 语言里使用 Actor 模型，就需要借助第三方类库，目前能完备地支持 Actor 模型而且比较成熟的类库就是** Akka **了。</p>
<p>在下面的示例代码中，我们首先创建了一个 ActorSystem（Actor 不能脱离 ActorSystem 存在）；之后创建了一个 HelloActor，Akka 中创建 Actor 并不是 new 一个对象出来，而是通过调用 system.actorOf() 方法创建的，该方法返回的是 ActorRef，而不是 HelloActor；最后通过调用 ActorRef 的 tell() 方法给 HelloActor 发送了一条消息 “Actor” 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该 Actor 当收到消息 message 后，</span></span><br><span class="line"><span class="comment">//会打印 Hello message</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HelloActor</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//创建 Actor 系统</span></span><br><span class="line">  <span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create(<span class="string">&quot;HelloSystem&quot;</span>);</span><br><span class="line">  <span class="comment">//创建 HelloActor</span></span><br><span class="line">  <span class="type">ActorRef</span> <span class="variable">helloActor</span> <span class="operator">=</span></span><br><span class="line">    system.actorOf(Props.create(HelloActor.class));</span><br><span class="line">  <span class="comment">//发送消息给 HelloActor</span></span><br><span class="line">  helloActor.tell(<span class="string">&quot;Actor&quot;</span>, ActorRef.noSender());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息和对象方法的区别"><a href="#消息和对象方法的区别" class="headerlink" title="消息和对象方法的区别"></a>消息和对象方法的区别</h3><p>Actor 中的消息机制，就可以类比这现实世界里的写信。Actor 内部有一个邮箱（Mailbox），接收到的消息都是先放到邮箱里，如果邮箱里有积压的消息，那么新收到的消息就不会马上得到处理，也正是因为 Actor 使用单线程处理消息，所以不会出现并发问题。你可以把 Actor 内部的工作模式想象成只有一个消费者线程的生产者-消费者模式。</p>
<p>在 Actor 模型里，发送消息仅仅是把消息发出去而已，接收消息的 Actor 在接收到消息后，也不一定会立即处理，也就是说** Actor 中的消息机制完全是异步的<strong>。而</strong>调用对象方法<strong>，实际上是</strong>同步**的，对象方法 return 之前，调用方会一直等待。</p>
<p>除此之外，<strong>调用对象方法</strong>，需要持有对象的引用，<strong>所有的对象必须在同一个进程中</strong>。而在 Actor 中发送消息，类似于现实中的写信，只需要知道对方的地址就可以，<strong>发送消息和接收消息的 Actor 可以不在一个进程中，也可以不在同一台机器上</strong>。因此，Actor 模型不但适用于并发计算，还适用于分布式计算。</p>
<h3 id="Actor-的规范化定义"><a href="#Actor-的规范化定义" class="headerlink" title="Actor 的规范化定义"></a>Actor 的规范化定义</h3><p>Actor 是一种基础的计算单元，具体来讲包括三部分能力，分别是：</p>
<ol>
<li>处理能力，处理接收到的消息。</li>
<li>存储能力，Actor 可以存储自己的内部状态，并且内部状态在不同 Actor 之间是绝对隔离的。</li>
<li>通信能力，Actor 可以和其他 Actor 之间通信。</li>
</ol>
<p>当一个 Actor 接收的一条消息之后，这个 Actor 可以做以下三件事：</p>
<ol>
<li>创建更多的 Actor；</li>
<li>发消息给其他 Actor；</li>
<li>确定如何处理下一条消息。</li>
</ol>
<h3 id="用-Actor-实现累加器"><a href="#用-Actor-实现累加器" class="headerlink" title="用 Actor 实现累加器"></a>用 Actor 实现累加器</h3><p>在下面的示例代码中，CounterActor 内部持有累计值 counter，当 CounterActor 接收到一个数值型的消息 message 时，就将累计值 counter +&#x3D; message；但如果是其他类型的消息，则打印当前累计值 counter。在 main() 方法中，我们启动了 4 个线程来执行累加操作。整个程序没有锁，也没有 CAS，但是程序是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CounterActor</span> <span class="keyword">extends</span> <span class="title class_">UntypedActor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Object message)</span>&#123;</span><br><span class="line">    <span class="comment">//如果接收到的消息是数字类型，执行累加操作，</span></span><br><span class="line">    <span class="comment">//否则打印 counter 的值</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">      counter += ((Number) message).intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="comment">//创建 Actor 系统</span></span><br><span class="line">  <span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create(<span class="string">&quot;HelloSystem&quot;</span>);</span><br><span class="line">  <span class="comment">//4 个线程生产消息</span></span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">//创建 CounterActor</span></span><br><span class="line">  <span class="type">ActorRef</span> <span class="variable">counterActor</span> <span class="operator">=</span></span><br><span class="line">    system.actorOf(Props.create(CounterActor.class));</span><br><span class="line">  <span class="comment">//生产 4*100000 个消息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">    es.execute(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100000</span>; j++) &#123;</span><br><span class="line">        counterActor.tell(<span class="number">1</span>, ActorRef.noSender());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭线程池</span></span><br><span class="line">  es.shutdown();</span><br><span class="line">  <span class="comment">//等待 CounterActor 处理完所有消息</span></span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">//打印结果</span></span><br><span class="line">  counterActor.tell(<span class="string">&quot;&quot;</span>, ActorRef.noSender());</span><br><span class="line">  <span class="comment">//关闭 Actor 系统</span></span><br><span class="line">  system.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="软件事务内存：借鉴数据库的并发经验"><a href="#软件事务内存：借鉴数据库的并发经验" class="headerlink" title="软件事务内存：借鉴数据库的并发经验"></a>软件事务内存：借鉴数据库的并发经验</h2><p><strong>软件事务内存（Software Transactional Memory，简称 STM）</strong>。传统的数据库事务，支持 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的 ACID，STM 由于不涉及到持久化，所以只支持 ACI。</p>
<h3 id="用-STM-实现转账"><a href="#用-STM-实现转账" class="headerlink" title="用 STM 实现转账"></a>用 STM 实现转账</h3><p>并发转账可以简单地使用 synchronized 将 transfer() 方法变成同步方法，但并不能解决并发问题，因为还存在死锁问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeAccount</span> &#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> balance;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnsafeAccount</span><span class="params">(<span class="type">long</span> balance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.balance = balance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(UnsafeAccount target, <span class="type">long</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该转账操作若使用数据库事务就会非常简单，如下面的示例代码所示。如果所有 SQL 都正常执行，则通过 commit() 方法提交事务；如果 SQL 在执行过程中有异常，则通过 rollback() 方法回滚事务。数据库保证在并发情况下不会有死锁，而且还能保证前面我们说的原子性、一致性、隔离性和持久性，也就是 ACID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//获取数据库连接</span></span><br><span class="line">  conn = DriverManager.getConnection();</span><br><span class="line">  <span class="comment">//设置手动提交事务</span></span><br><span class="line">  conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//执行转账 SQL</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="comment">//出现异常回滚事务</span></span><br><span class="line">  conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果用 STM 又该如何实现呢？Java 语言并不支持 STM，不过可以借助第三方的类库来支持，<a target="_blank" rel="noopener" href="https://github.com/pveentjer/Multiverse">Multiverse</a> 就是个不错的选择。下面的示例代码就是借助 Multiverse 实现了线程安全的转账操作，相比较上面线程不安全的 UnsafeAccount，其改动并不大，仅仅是将余额的类型从 long 变成了 TxnLong ，将转账的操作放到了 atomic(()-&gt;{}) 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> TxnLong balance;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> balance)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = StmUtils.newTxnLong(balance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account to, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">//原子化操作</span></span><br><span class="line">    atomic(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.balance.get() &gt; amt) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance.decrement(amt);</span><br><span class="line">        to.balance.increment(amt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关键的 atomic() 方法就把并发问题解决了，这个方案看上去比传统的方案的确简单了很多，那它是如何实现的呢？数据库事务发展了几十年了，目前被广泛使用的是** MVCC**（全称是 Multi-Version Concurrency Control），也就是多版本并发控制。</p>
<p>MVCC 可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。</p>
<p>为了记录数据是否发生了变化，可以给每条数据增加一个版本号，这样每次成功修改数据都会增加版本号的值。MVCC 的工作原理和乐观锁非常相似。有不少 STM 的实现方案都是基于 MVCC 的，例如知名的 Clojure STM。</p>
<p>下面我们就用最简单的代码基于 MVCC 实现一个简版的 STM，这样你会对 STM 以及 MVCC 的工作原理有更深入的认识。</p>
<h2 id="自己实现-STM"><a href="#自己实现-STM" class="headerlink" title="自己实现 STM"></a>自己实现 STM</h2><p>我们首先要做的，就是让 Java 中的对象有版本号，在下面的示例代码中，VersionedRef 这个类的作用就是将对象 value 包装成带版本号的对象。按照 MVCC 理论，数据的每一次修改都对应着一个唯一的版本号，所以不存在仅仅改变 value 或者 version 的情况，用不变性模式就可以很好地解决这个问题，所以 VersionedRef 这个类被我们设计成了不可变的。</p>
<p>所有对数据的读写操作，一定是在一个事务里面，TxnRef 这个类负责完成事务内的读写操作，读写操作委托给了接口 Txn，Txn 代表的是读写操作所在的当前事务， 内部持有的 curRef 代表的是系统中的最新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带版本号的对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">VersionedRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> T value;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">long</span> version;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VersionedRef</span><span class="params">(T value, <span class="type">long</span> version)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.version = version;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持事务的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxnRef</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//当前数据，带版本号</span></span><br><span class="line">  <span class="keyword">volatile</span> VersionedRef curRef;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TxnRef</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.curRef = <span class="keyword">new</span> <span class="title class_">VersionedRef</span>(value, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">(Txn txn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> txn.get(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在当前事务中设置数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value, Txn txn)</span> &#123;</span><br><span class="line">    txn.set(<span class="built_in">this</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STMTxn 是 Txn 最关键的一个实现类，事务内对于数据的读写，都是通过它来完成的。STMTxn 内部有两个 Map：inTxnMap，用于保存当前事务中所有读写的数据的快照；writeMap，用于保存当前事务需要写入的数据。每个事务都有一个唯一的事务 ID txnId，这个 txnId 是全局递增的。</p>
<p>STMTxn 有三个核心方法，分别是读数据的 get() 方法、写数据的 set() 方法和提交事务的 commit() 方法。其中，get() 方法将要读取数据作为快照放入 inTxnMap，同时保证每次读取的数据都是一个版本。set() 方法会将要写入的数据放入 writeMap，但如果写入的数据没被读取过，也会将其放入 inTxnMap。</p>
<p>至于 commit() 方法，我们为了简化实现，使用了互斥锁，所以事务的提交是串行的。commit() 方法的实现很简单，首先检查 inTxnMap 中的数据是否发生过变化，如果没有发生变化，那么就将 writeMap 中的数据写入（这里的写入其实就是 TxnRef 内部持有的 curRef）；如果发生过变化，那么就不能将 writeMap 中的数据写入了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Txn</span> &#123;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span>;</span><br><span class="line">  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STM 事务实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">STMTxn</span> <span class="keyword">implements</span> <span class="title class_">Txn</span> &#123;</span><br><span class="line">  <span class="comment">//事务 ID 生成器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">txnSeq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当前事务所有的相关数据</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;TxnRef, VersionedRef&gt; inTxnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//当前事务所有需要修改的数据</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;TxnRef, Object&gt; writeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//当前事务 ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> txnId;</span><br><span class="line">  <span class="comment">//构造函数，自动生成当前事务 ID</span></span><br><span class="line">  STMTxn() &#123;</span><br><span class="line">    txnId = txnSeq.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span> &#123;</span><br><span class="line">    <span class="comment">//将需要读取的数据，加入 inTxnMap</span></span><br><span class="line">    <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">      inTxnMap.put(ref, ref.curRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) inTxnMap.get(ref).value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在当前事务中修改数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span> &#123;</span><br><span class="line">    <span class="comment">//将需要修改的数据，加入 inTxnMap</span></span><br><span class="line">    <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">      inTxnMap.put(ref, ref.curRef);</span><br><span class="line">    &#125;</span><br><span class="line">    writeMap.put(ref, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (STM.commitLock) &#123;</span><br><span class="line">    <span class="comment">//是否校验通过</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//校验所有读过的数据是否发生过变化</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;TxnRef, VersionedRef&gt; entry : inTxnMap.entrySet())&#123;</span><br><span class="line">      <span class="type">VersionedRef</span> <span class="variable">curRef</span> <span class="operator">=</span> entry.getKey().curRef;</span><br><span class="line">      <span class="type">VersionedRef</span> <span class="variable">readRef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">      <span class="comment">//通过版本号来验证数据是否发生过变化</span></span><br><span class="line">      <span class="keyword">if</span> (curRef.version != readRef.version) &#123;</span><br><span class="line">        isValid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果校验通过，则所有更改生效</span></span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">      writeMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">        k.curRef = <span class="keyword">new</span> <span class="title class_">VersionedRef</span>(v, txnId);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来模拟实现 Multiverse 中的原子化操作 atomic()。atomic() 方法中使用了类似于 CAS 的操作，如果事务提交失败，那么就重新创建一个新的事务，重新执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TxnRunnable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Txn txn)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STM</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">STM</span> &#123;</span><br><span class="line">  <span class="comment">//私有化构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">STM</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//提交数据需要用到的全局锁</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">commitLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">//原子化提交方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomic</span><span class="params">(TxnRunnable action)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">committed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果没有提交成功，则一直重试</span></span><br><span class="line">    <span class="keyword">while</span> (!committed) &#123;</span><br><span class="line">      <span class="comment">//创建新的事务</span></span><br><span class="line">      <span class="type">STMTxn</span> <span class="variable">txn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">STMTxn</span>();</span><br><span class="line">      <span class="comment">//执行业务逻辑</span></span><br><span class="line">      action.run(txn);</span><br><span class="line">      <span class="comment">//提交事务</span></span><br><span class="line">      committed = txn.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>就这样，我们自己实现了 STM，并完成了线程安全的转账操作，使用方法和 Multiverse 差不多，这里就不赘述了，具体代码如下面所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="comment">//余额</span></span><br><span class="line">  <span class="keyword">private</span> TxnRef&lt;Integer&gt; balance;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">TxnRef</span>&lt;Integer&gt;(balance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转账操作</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    STM.atomic((txn)-&gt;&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> balance.getValue(txn);</span><br><span class="line">      balance.setValue(from-amt, txn);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> target.balance.getValue(txn);</span><br><span class="line">      target.balance.setValue(to+amt, txn);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程：更轻量级的线程"><a href="#协程：更轻量级的线程" class="headerlink" title="协程：更轻量级的线程"></a>协程：更轻量级的线程</h2><p><strong>协程</strong>可以理解<strong>为一种轻量级的线程</strong>。从操作系统的角度来看，线程是在内核态中调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。协程虽然也有自己的栈，但是相比线程栈要小得多，典型的线程栈大小差不多有 1M，而协程栈的大小往往只有几 K 或者几十 K。所以，无论是从时间维度还是空间维度来看，协程都比线程轻量得多。</p>
<p>支持协程的语言还是挺多的，例如 Golang、Python、Lua、Kotlin 等都支持协程。</p>
<h2 id="CSP-模型：Golang-的主力队员"><a href="#CSP-模型：Golang-的主力队员" class="headerlink" title="CSP 模型：Golang 的主力队员"></a>CSP 模型：Golang 的主力队员</h2><p>Golang 是一门号称从语言层面支持并发的编程语言，支持并发是 Golang 一个非常重要的特性。</p>
<p>Golang 支持协程，协程可以类比 Java 中的线程，解决并发问题的难点就在于线程（协程）之间的协作。那 Golang 是如何解决协作问题的呢？</p>
<p>总的来说，Golang 提供了两种不同的方案：一种方案支持协程之间以共享内存的方式通信，Golang 提供了管程和原子类来对协程进行同步控制，这个方案与 Java 语言类似；另一种方案支持协程之间以消息传递（Message-Passing）的方式通信，本质上是要避免共享，Golang 的这个方案是基于** CSP**（Communicating Sequential Processes）模型实现的。Golang 比较推荐的方案是后者。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">极客时间教程 - Java 并发编程实战</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/6ef9bcbd/" title="《极客时间教程 - Java 并发编程实战》笔记四">https://dunwu.github.io/blog/pages/6ef9bcbd/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
              <a href="/blog/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/fea959b2/" rel="prev" title="《极客时间教程 - Java 并发编程实战》笔记一">
                  <i class="fa fa-angle-left"></i> 《极客时间教程 - Java 并发编程实战》笔记一
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/33d6187f/" rel="next" title="《极客时间教程 - Java 并发编程实战》笔记三">
                  《极客时间教程 - Java 并发编程实战》笔记三 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"2edc73ed15a34b25a4b6c6def3b96f52"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
