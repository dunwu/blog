<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="Java 基础面试二Java 面向对象【简单】对象实体与对象引用有何不同？（1）对象是用来描述客观事物的一个抽象。一个对象由一组属性和对这组属性进行操作的一组服务组成。 （2）类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。 （3）对象实体与对象引用的不同之处在于：  new 创建对象实例（对象实例在堆内存中），对象引用指向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础面试二">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/46f290c1/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="Java 基础面试二Java 面向对象【简单】对象实体与对象引用有何不同？（1）对象是用来描述客观事物的一个抽象。一个对象由一组属性和对这组属性进行操作的一组服务组成。 （2）类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。 （3）对象实体与对象引用的不同之处在于：  new 创建对象实例（对象实例在堆内存中），对象引用指向对象">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-02T23:44:02.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.705Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JavaCore">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/46f290c1/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/46f290c1/","path":"/pages/46f290c1/","title":"Java 基础面试二"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 基础面试二 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E4%BA%8C"><span class="nav-number">1.</span> <span class="nav-text">Java 基础面试二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">Java 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">【简单】对象实体与对象引用有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">【简单】接口和抽象类有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">【中等】什么是 Java 内部类？内部类有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">【简单】为什么 Java 不支持多重继承？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">【中等】深拷贝和浅拷贝有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">【简单】面向对象和面向过程有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E5%92%8C%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">【中等】面向对象三大特征和五大原则是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.8.</span> <span class="nav-text">设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">1.2.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91Object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">【简单】Object 类的常见方法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91-%E5%92%8C-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">【简单】&#x3D;&#x3D; 和 equals() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">【简单】为什么重写 equals() 时必须重写 hashCode() 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">【简单】finalize 有什么用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">1.3.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">【简单】String、StringBuffer、StringBuilder 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">【简单】String 为什么是不可变的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8%E2%80%9C-%E2%80%9D-%E8%BF%98%E6%98%AF-StringBuilder"><span class="nav-number">1.3.3.</span> <span class="nav-text">【简单】字符串拼接用“+” 还是 StringBuilder?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String-equals-%E5%92%8C-Object-equals-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">【简单】String#equals() 和 Object#equals() 有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.3.5.</span> <span class="nav-text">【简单】字符串常量池有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String-s-new-String-abc-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.3.6.</span> <span class="nav-text">【简单】String s &#x3D; new String(&quot;abc&quot;) 创建了几个字符串对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.3.7.</span> <span class="nav-text">【简单】String#intern 方法有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A%E2%80%9C-%E2%80%9D%E8%BF%90%E7%AE%97%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.8.</span> <span class="nav-text">【简单】String 类型的变量和常量做“+”运算时会发生什么？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/46f290c1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 基础面试二 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 基础面试二<a href="https://github.com/dunwu/blog/blob/master/source/_posts/01.Java/01.JavaCore/99.%E9%9D%A2%E8%AF%95/Java_%E9%9D%A2%E8%AF%95_%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java-基础面试二"><a href="#Java-基础面试二" class="headerlink" title="Java 基础面试二"></a>Java 基础面试二</h1><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><h3 id="【简单】对象实体与对象引用有何不同？"><a href="#【简单】对象实体与对象引用有何不同？" class="headerlink" title="【简单】对象实体与对象引用有何不同？"></a>【简单】对象实体与对象引用有何不同？</h3><p>（1）<strong>对象是用来描述客观事物的一个抽象</strong>。一个对象由一组属性和对这组属性进行操作的一组服务组成。</p>
<p>（2）<strong>类是具有相同属性和方法的一组对象的集合</strong>，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。</p>
<p>（3）对象实体与对象引用的不同之处在于：</p>
<ul>
<li><code>new</code> 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）</li>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="【简单】接口和抽象类有什么区别？"><a href="#【简单】接口和抽象类有什么区别？" class="headerlink" title="【简单】接口和抽象类有什么区别？"></a>【简单】接口和抽象类有什么区别？</h3><p>（1）接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p>
<p>接口的主要特性有：</p>
<ul>
<li>接口不能实例化。</li>
<li>接口不能包含任何非常量成员，任何字段都隐式的被 <code>public static final</code> 修饰。</li>
<li>接口中没有非静态方法，也就是说要么是抽象方法，要么是静态方法。</li>
<li>从 Java8 开始，接口增加了 <code>default</code> 方法特性，可以定义方法的默认实现；Java 9 以后，甚至可以定义私有的 <code>default</code> 方法。</li>
</ul>
<p>（2）抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p>
<p>（3）接口和抽象类有什么相同点和不同点？</p>
<p>Java 中的类可以实现多个接口。</p>
<p>（4）与 C++ 等语言不一样，Java 类不支持多继承。这意味着，Java 不能通过继承多个抽象类来重用逻辑。那么，如何来实现重用呢？Java 的解决方案是：接口支持多继承，准确的说，接口支持扩展多个接口，而接口也支持实现多个接口。</p>
<h3 id="【中等】什么是-Java-内部类？内部类有什么作用？"><a href="#【中等】什么是-Java-内部类？内部类有什么作用？" class="headerlink" title="【中等】什么是 Java 内部类？内部类有什么作用？"></a>【中等】什么是 Java 内部类？内部类有什么作用？</h3><p>::: info 什么是内部类？<br>:::</p>
<p>内部类 (Inner Class) 是定义在另一个类内部的类。Java 中有四种类型的内部类：</p>
<ul>
<li><strong>成员内部类</strong>：作为外部类的成员存在</li>
<li><strong>局部内部类</strong>：定义在方法或作用域内的类</li>
<li><strong>匿名内部类</strong>：没有名字的局部内部类</li>
<li><strong>静态嵌套类</strong>：用 static 修饰的嵌套类</li>
</ul>
<p>::: info 内部类有什么作用？<br>:::</p>
<ul>
<li><strong>逻辑分组</strong>：当某个类只对另一个类有用时，可以将其嵌入使用它的类中，保持代码在一起</li>
<li><strong>增强封装性</strong>：内部类可以访问外部类的私有成员，同时自身也可以对外部完全隐藏</li>
<li><strong>实现多重继承</strong>：通过内部类可以间接实现多重继承的效果</li>
<li><strong>回调机制</strong>：常用于事件处理和监听器实现</li>
<li><strong>代码简洁</strong>：特别是匿名内部类可以减少代码量</li>
</ul>
<p>::: info 内部类有哪些特点？<br>:::</p>
<ul>
<li>内部类可以访问外部类的所有成员（包括 private)</li>
<li>外部类需要通过实例化内部类来访问其成员</li>
<li>内部类编译后会生成独立的。class 文件（格式：<code>OuterClass$InnerClass.class</code>)</li>
<li>非静态内部类不能有静态成员（静态内部类可以）</li>
<li>内部类可以继承其他类或实现接口</li>
</ul>
<h3 id="【简单】为什么-Java-不支持多重继承？"><a href="#【简单】为什么-Java-不支持多重继承？" class="headerlink" title="【简单】为什么 Java 不支持多重继承？"></a>【简单】为什么 Java 不支持多重继承？</h3><p>Java 不支持多重继承的核心原因是<strong>为了避免【菱形继承问题（Diamond Problem）】</strong>。</p>
<p>::: info 什么是菱形继承问题？<br>:::</p>
<p>菱形继承存在歧义性：</p>
<ul>
<li>如果类 C 继承自类 A 和类 B，而 A 和 B 都有同名方法 <code>method()</code></li>
<li>调用 <code>C.method()</code> 时无法确定应该调用 A 还是 B 的版本</li>
</ul>
<p>由于菱形继承歧义性而引发的复杂性增加问题：</p>
<ul>
<li>多重继承会显著增加编译器和 JVM 的实现复杂度</li>
<li>方法调用、构造函数调用顺序变得难以确定</li>
</ul>
<p>::: info Java 如何解决多重继承？<br>:::</p>
<p>在 Java 中，类可以实现多个接口。接口提供多重继承的行为规范，但不包含具体实现。</p>
<p>JDK8 之后，接口支持默认方法（default），是不是又出现了菱形继承问题？</p>
<p>为了规避这个问题，Java 强制规定，如果多个接口存在相同的默认方法，子类必须重写这个方法。否则，编译器会报错。</p>
<h3 id="【中等】深拷贝和浅拷贝有什么区别？"><a href="#【中等】深拷贝和浅拷贝有什么区别？" class="headerlink" title="【中等】深拷贝和浅拷贝有什么区别？"></a>【中等】深拷贝和浅拷贝有什么区别？</h3><p>::: info 深拷贝和浅拷贝有什么区别？<br>:::</p>
<table>
<thead>
<tr>
<th align="left"><strong>关键点</strong></th>
<th align="left"><strong>浅拷贝</strong></th>
<th align="left"><strong>深拷贝</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>复制对象</strong></td>
<td align="left">只复制对象本身（基本类型值拷贝）</td>
<td align="left">递归复制对象及其引用的所有子对象</td>
</tr>
<tr>
<td align="left"><strong>引用类型字段</strong></td>
<td align="left">新旧对象共享同一引用（修改相互影响）</td>
<td align="left">创建全新引用对象（修改完全隔离）</td>
</tr>
<tr>
<td align="left"><strong>内存开销</strong></td>
<td align="left">小（仅复制一层）</td>
<td align="left">大（递归复制所有关联对象）</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">默认<code>Object.clone()</code></td>
<td align="left">需手动实现递归克隆&#x2F;序列化&#x2F;工具类</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">对象无可变引用字段</td>
<td align="left">对象含可变引用字段且需完全独立</td>
</tr>
</tbody></table>
<p><strong>本质区别</strong>：浅拷贝是”复制钥匙”，深拷贝是”复制钥匙+保险箱”。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>深拷贝需处理循环引用问题</li>
<li>推荐使用<code>SerializationUtils.clone()</code>或 JSON 序列化实现深拷贝</li>
<li>不可变对象（如 String）的浅拷贝是安全的</li>
</ul>
<p>::: info 深拷贝和浅拷贝实现方式有什么区别？<br>:::</p>
<p><strong>实现方式对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>浅拷贝</strong></th>
<th align="left"><strong>深拷贝</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Object.clone()</code></td>
<td align="left">✓</td>
<td align="left">✗</td>
<td align="left">默认浅拷贝</td>
</tr>
<tr>
<td align="left"><strong>手动递归克隆</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left">需所有引用类型实现<code>Cloneable</code></td>
</tr>
<tr>
<td align="left"><strong>序列化反序列化</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left">通过<code>ObjectOutputStream</code>实现</td>
</tr>
<tr>
<td align="left"><strong>工具类（Apache Commons）</strong></td>
<td align="left">✗</td>
<td align="left">✓</td>
<td align="left"><code>SerializationUtils.clone()</code></td>
</tr>
</tbody></table>
<p>::: code-tabs#深拷贝和浅拷贝实现示例</p>
<p>@tab 浅拷贝实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// 引用类型字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone(); <span class="comment">// 默认浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;北京&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person)p1.clone();</span><br><span class="line">p2.address.city = <span class="string">&quot;上海&quot;</span>; <span class="comment">// p1.address.city 也会变成&quot;上海&quot;</span></span><br></pre></td></tr></table></figure>

<p>@tab 深拷贝实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person)<span class="built_in">super</span>.clone();</span><br><span class="line">    cloned.address = (Address)address.clone(); <span class="comment">// 手动复制引用对象</span></span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address 类也需实现 Cloneable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::</p>
<h3 id="【简单】面向对象和面向过程有什么区别？"><a href="#【简单】面向对象和面向过程有什么区别？" class="headerlink" title="【简单】面向对象和面向过程有什么区别？"></a>【简单】面向对象和面向过程有什么区别？</h3><p>面向对象和面向过程的主要区别：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>面向对象（OOP）</th>
<th>面向过程（POP）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td>以<strong>对象</strong>为中心</td>
<td>以<strong>步骤</strong>为中心</td>
</tr>
<tr>
<td><strong>代码组织</strong></td>
<td>按<strong>现实实体</strong>抽象为类</td>
<td>按<strong>功能流程</strong>拆分为函数</td>
</tr>
<tr>
<td><strong>数据管理</strong></td>
<td>数据与行为封装在对象中</td>
<td>数据与函数独立</td>
</tr>
<tr>
<td><strong>扩展方式</strong></td>
<td>通过继承&#x2F;多态扩展（开闭原则）</td>
<td>需修改函数逻辑</td>
</tr>
<tr>
<td><strong>典型特性</strong></td>
<td>封装、继承、多态三大特性</td>
<td>无三大特性</td>
</tr>
<tr>
<td><strong>典型语言</strong></td>
<td>Java, Python, C++</td>
<td>C, Pascal</td>
</tr>
</tbody></table>
<h3 id="【中等】面向对象三大特征和五大原则是什么？"><a href="#【中等】面向对象三大特征和五大原则是什么？" class="headerlink" title="【中等】面向对象三大特征和五大原则是什么？"></a>【中等】面向对象三大特征和五大原则是什么？</h3><p>::: info 面向对象三大特征是什么？<br>:::</p>
<p><strong>面向对象三大特征：</strong></p>
<ul>
<li><p><strong>封装（Encapsulation）</strong> ：<strong>隐藏内部细节，暴露安全接口</strong>。</p>
<ul>
<li>用 <code>private</code> 保护数据，通过 <code>getter/setter</code> 控制访问</li>
<li>示例：<code>BankAccount</code> 类隐藏余额，提供 <code>deposit()</code>&#x2F;<code>withdraw()</code> 方法</li>
</ul>
</li>
<li><p><strong>继承（Inheritance）</strong> ：<strong>子类复用父类属性和方法</strong>。</p>
<ul>
<li>通过 <code>extends</code> 实现（如 <code>Dog extends Animal</code>）</li>
<li>注意：Java 是单继承（一个子类只能有一个父类）</li>
</ul>
</li>
<li><p><strong>多态（Polymorphism）</strong> ：<strong>同一行为的不同实现方式</strong>。</p>
<ul>
<li><strong>编译时多态</strong>：方法重载（<code>Overload</code>）</li>
<li><strong>运行时多态</strong>：方法重写（<code>Override</code>）+ 父类引用指向子类对象（如 <code>Animal a = new Dog(); a.sound();</code>）</li>
</ul>
</li>
</ul>
<p><strong>一言以概之</strong>：<strong>封装保证安全性，继承提高复用性，多态增强扩展性</strong>。</p>
<p>::: info 面向对象的五大原则是什么？<br>:::</p>
<p>面向对象的五大原则是 <strong>SOLID</strong> 原则：</p>
<ul>
<li><strong>单一职责原则 (SRP)<strong>：</strong>一个类只负责一个功能</strong>，避免职责过多导致代码臃肿。</li>
<li><strong>开闭原则 (OCP)<strong>：</strong>对扩展开放，对修改关闭</strong>。通过抽象和继承扩展功能，而非直接修改原有代码。</li>
<li><strong>里氏替换原则 (LSP)<strong>：</strong>子类必须能替换父类</strong>，确保继承关系不会破坏程序逻辑。</li>
<li><strong>接口隔离原则 (ISP)<strong>：</strong>接口应当小而专</strong>，避免臃肿接口强制实现不必要的方法。</li>
<li><strong>依赖倒置原则 (DIP)<strong>：</strong>依赖抽象而非具体</strong>，高层模块不直接依赖低层模块，而是通过接口或抽象类交互。</li>
</ul>
<p><strong>一言以概之</strong>：SOLID 原则让代码更灵活、可维护、易扩展。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>典型问题</strong></p>
<p>（1）你知道哪些设计模式？</p>
<p>（2）你知道哪些设计模式在 Java 源码中的应用案例？</p>
<p>（3）你知道哪些设计模式在主流框架中的应用案例？</p>
<p><strong>知识点</strong></p>
<p>（1）23 种经典设计模式分类如下：</p>
<ul>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<p>（2）设计模式在 Java 源码中应用的经典案例：</p>
<p>InputStream 是一个抽象类，标准类库中提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。</p>
<p>（3）设计模式在主流框架中应用的经典案例：</p>
<p>如 Spring 等如何在 API 设计中使用设计模式。你至少要有个大体的印象，如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">BeanFactory</a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationContext.java">ApplicationContext</a> 应用了工厂模式。</li>
<li>在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。</li>
<li>Spring Aop 使用了代理模式、装饰器模式、适配器模式等。</li>
<li>各种事件监听器，是观察者模式的典型应用。</li>
<li>类似 JdbcTemplate 等则是应用了模板模式。</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="【简单】Object-类的常见方法有哪些？"><a href="#【简单】Object-类的常见方法有哪些？" class="headerlink" title="【简单】Object 类的常见方法有哪些？"></a>【简单】Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>方法签名</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>默认行为</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String toString()</code></td>
<td align="left">返回对象的字符串表示</td>
<td align="left"><code>类名@十六进制哈希码</code>（如 <code>Person@1b6d3586</code>）</td>
</tr>
<tr>
<td align="left"><code>boolean equals(Object obj)</code></td>
<td align="left">比较两个对象是否逻辑相等</td>
<td align="left">比较内存地址（<code>==</code>）</td>
</tr>
<tr>
<td align="left"><code>int hashCode()</code></td>
<td align="left">返回对象的哈希码</td>
<td align="left">基于内存地址生成</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getClass()</code></td>
<td align="left">返回对象的运行时类（<code>Class</code> 对象）</td>
<td align="left">由 JVM 提供</td>
</tr>
<tr>
<td align="left"><code>protected Object clone()</code></td>
<td align="left">创建并返回对象的副本</td>
<td align="left">浅拷贝（需实现 <code>Cloneable</code> 接口）</td>
</tr>
<tr>
<td align="left"><code>protected void finalize()</code></td>
<td align="left">已废弃，对象被 GC 回收前调用</td>
<td align="left">空实现（不推荐使用）</td>
</tr>
<tr>
<td align="left"><code>void notify()</code></td>
<td align="left">唤醒一个等待该对象监视器的线程</td>
<td align="left">依赖 JVM 实现</td>
</tr>
<tr>
<td align="left"><code>void notifyAll()</code></td>
<td align="left">唤醒所有等待该对象监视器的线程</td>
<td align="left">依赖 JVM 实现</td>
</tr>
<tr>
<td align="left"><code>void wait()</code></td>
<td align="left">让当前线程等待，直到被唤醒</td>
<td align="left">必须在同步代码块中调用</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeout)</code></td>
<td align="left">让线程等待，最多 <code>timeout</code> 毫秒</td>
<td align="left">超时后自动唤醒</td>
</tr>
<tr>
<td align="left"><code>void wait(long timeout, int nanos)</code></td>
<td align="left">更精确的等待（纳秒级）</td>
<td align="left">实际精度依赖系统</td>
</tr>
</tbody></table>
<h3 id="【简单】-和-equals-有什么区别？"><a href="#【简单】-和-equals-有什么区别？" class="headerlink" title="【简单】&#x3D;&#x3D; 和 equals() 有什么区别？"></a>【简单】&#x3D;&#x3D; 和 equals() 有什么区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong><code>==</code></strong></th>
<th align="left"><strong><code>equals()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本类型比较</strong></td>
<td align="left">比较<strong>值</strong></td>
<td align="left">不能比较</td>
</tr>
<tr>
<td align="left"><strong>引用类型比较</strong></td>
<td align="left">比较<strong>内存地址</strong></td>
<td align="left">默认比较<strong>内存地址</strong>（同 <code>==</code>），但可重写为逻辑比较（如内容是否相同）</td>
</tr>
<tr>
<td align="left"><strong>是否可重写</strong></td>
<td align="left">否（运算符，行为固定）</td>
<td align="left">是（可自定义比较逻辑）</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">快速判断基本类型值相等或引用是否指向同一对象</td>
<td align="left">判断对象逻辑是否相等（如内容、属性等）</td>
</tr>
</tbody></table>
<h3 id="【简单】为什么重写-equals-时必须重写-hashCode-方法？"><a href="#【简单】为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="【简单】为什么重写 equals() 时必须重写 hashCode() 方法？"></a>【简单】为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为 Java 规定：<strong>两个对象若<code>equals()</code>相等，它们的<code>hashCode()</code>必须相同</strong>。</p>
<p>如果违背，则哈希集合（如 <code>HashMap</code>、<code>HashSet</code>）无法正确去重或查找。</p>
<ul>
<li><code>HashMap</code>&#x2F;<code>HashSet</code> 先通过 <code>hashCode()</code> 快速定位数据，再用 <code>equals()</code> 精确匹配。</li>
<li>若 <code>hashCode()</code> 不一致，即使 <code>equals()</code> 为 <code>true</code>，集合会误判为不同对象。</li>
</ul>
<p>::: info 如何正确重写 <code>hashCode()</code>？<br>:::</p>
<ul>
<li>**<code>equals()</code>**：比较所有关键字段（如 <code>name</code>、<code>age</code>）。</li>
<li>**<code>hashCode()</code>**：用 <code>Objects.hash(字段1, 字段2)</code> 生成（确保与 <code>equals()</code> 字段一致）。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals() 的若干问题解答</a></p>
<p>:::</p>
<h3 id="【简单】finalize-有什么用？"><a href="#【简单】finalize-有什么用？" class="headerlink" title="【简单】finalize 有什么用？"></a>【简单】finalize 有什么用？</h3><p>一言以概之，**<code>finalize</code> 可用于对象销毁前的清理，但不可靠且性能差，现代 Java 开发应避免使用，改用 <code>AutoCloseable</code> 或 <code>Cleaner</code>。**</p>
<p>**Java 9+ 已弃用 <code>finalize</code>**，推荐使用：</p>
<ul>
<li><code>try-with-resources</code>（实现 <code>AutoCloseable</code> 接口）</li>
<li><code>Cleaner</code> 或 <code>PhantomReference</code>（更可控的清理机制）。</li>
</ul>
<p><strong><code>finalize</code> 的作用（Java）</strong> ：</p>
<ul>
<li><strong>对象被垃圾回收前的清理</strong>：在对象被 GC 回收前，<code>finalize()</code> 会被调用，可用于释放非内存资源（如文件句柄、数据库连接等）。</li>
<li><strong>最后的补救机会</strong>：如果对象未被正确关闭，<code>finalize</code> 提供最后一次资源释放的机会。</li>
</ul>
<p><strong><code>finalize</code> 的问题</strong> ：</p>
<ul>
<li><strong>不保证执行</strong>：JVM 不保证 <code>finalize</code> 一定会执行（如程序突然终止时）。即使对象可达性失效，GC 可能延迟回收，导致 <code>finalize</code> 延迟调用。</li>
<li><strong>性能开销</strong>：覆写 <code>finalize</code> 的对象会被 JVM 放入特殊队列，垃圾回收变慢。可能引发内存泄漏（如果 <code>finalize</code> 阻塞或执行过久）。</li>
<li><strong>安全问题</strong>：在 <code>finalize</code> 中抛出异常会导致清理中断，且异常被忽略。可能被恶意代码利用（如通过重写 <code>finalize</code> 复活对象，干扰 GC）。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="【简单】String、StringBuffer、StringBuilder-的区别？"><a href="#【简单】String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="【简单】String、StringBuffer、StringBuilder 的区别？"></a>【简单】String、StringBuffer、StringBuilder 的区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>String</strong></th>
<th align="left"><strong>StringBuffer</strong></th>
<th align="left"><strong>StringBuilder</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">❌ 不可变</td>
<td align="left">✅ 可变</td>
<td align="left">✅ 可变</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">✅（因不可变）</td>
<td align="left">✅（同步方法）</td>
<td align="left">❌（非线程安全）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">⚠️ 最差（频繁创建新对象）</td>
<td align="left">⚠️ 中等（同步开销）</td>
<td align="left">✅ 最高（无同步开销）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">常量、少量拼接</td>
<td align="left">多线程字符串操作</td>
<td align="left"><strong>单线程字符串操作（推荐）</strong></td>
</tr>
</tbody></table>
<p><strong>概括</strong></p>
<ul>
<li><strong>用 <code>String</code> 存储常量</strong>，<strong>用 <code>StringBuilder</code> 高效拼接（单线程）</strong>，<strong>用 <code>StringBuffer</code> 保证线程安全（多线程）</strong>。</li>
<li>**优先选 <code>StringBuilder</code>**（90%场景适用）。</li>
</ul>
<h3 id="【简单】String-为什么是不可变的？"><a href="#【简单】String-为什么是不可变的？" class="headerlink" title="【简单】String 为什么是不可变的？"></a>【简单】String 为什么是不可变的？</h3><p><code>String</code> 的不可变性是 Java 为安全、性能、线程安全做的核心设计。</p>
<p><strong>String 不可变的核心原因</strong>：</p>
<ul>
<li><strong><code>final</code> 修饰的 <code>char[]</code> 数组</strong>：Java 中 <code>String</code> 内部用 <code>private final char[]</code>（JDK 9+ 改为 <code>byte[]</code>）存储数据，数组引用和内容均不可修改。</li>
<li><strong>无修改内部状态的方法</strong>：所有看似“修改”的方法（如 <code>concat()</code>、<code>substring()</code>）都返回<strong>新 <code>String</code> 对象</strong>，原对象不变。</li>
</ul>
<p><strong>设计安全优化</strong></p>
<ul>
<li><strong>线程安全</strong>：不可变天然线程安全，无需同步。</li>
<li><strong>缓存哈希值</strong>：<code>String</code> 的 <code>hashCode()</code> 计算结果可缓存（因内容不变），提升性能（如 <code>HashMap</code> 的键）。</li>
<li><strong>字符串常量池复用</strong>：如 <code>String s = &quot;abc&quot;</code> 会复用常量池中的相同字符串，减少内存开销。</li>
</ul>
<p><strong>为什么这样设计</strong>：</p>
<ul>
<li><strong>安全</strong>：防止恶意修改（如网络请求参数、数据库连接字符串被篡改）。</li>
<li><strong>性能</strong>：哈希缓存、常量池复用提升效率。</li>
<li><strong>简单</strong>：避免多线程同步问题。</li>
</ul>
<p><strong>示例验证不可变性</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.concat(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// 输出 &quot;Hello&quot;（原字符串未变）</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 输出 &quot;Hello World&quot;（新对象）</span></span><br></pre></td></tr></table></figure>

<h3 id="【简单】字符串拼接用“-”-还是-StringBuilder"><a href="#【简单】字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="【简单】字符串拼接用“+” 还是 StringBuilder?"></a>【简单】字符串拼接用“+” 还是 StringBuilder?</h3><p><strong>循环&#x2F;动态拼接 → <code>StringBuilder</code>；简单常量拼接 → “+”；多线程 → <code>StringBuffer</code>（极少用）。</strong><br><strong><code>StringBuilder</code> 是默认推荐选择！</strong></p>
<p><strong>优先用 <code>StringBuilder</code>（大多数场景）</strong></p>
<ul>
<li><strong>适用情况</strong>：循环、动态拼接、大量字符串操作。</li>
<li><strong>原因</strong>：<ul>
<li><strong>高性能</strong>：直接修改缓冲区，避免 <code>+</code> 频繁创建新对象。</li>
<li><strong>低内存开销</strong>：减少临时对象和 GC 压力。</li>
</ul>
</li>
</ul>
<p><strong>简单拼接可用 “+”（编译期优化）</strong></p>
<ul>
<li><strong>适用情况</strong>：少量<strong>固定字符串</strong>拼接（如 <code>&quot;a&quot; + &quot;b&quot;</code>）。</li>
<li><strong>原因</strong>：<ul>
<li><strong>代码简洁</strong>：可读性更好。</li>
<li><strong>编译器优化</strong>：JVM 自动合并为常量（如 <code>&quot;ab&quot;</code>），无性能损失。</li>
<li>通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的。</li>
<li>在循环内使用“+”，会导致创建过多的 <code>StringBuilder</code> 对象。JDK9 中，优化了这个问题，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</li>
</ul>
</li>
</ul>
<p><strong>多线程拼接用 <code>StringBuffer</code>（极少需要）</strong></p>
<ul>
<li><strong>适用情况</strong>：多线程环境且需线程安全（通常局部变量仍可用 <code>StringBuilder</code>）。</li>
</ul>
<p>::: tip 扩展</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7182872058743750715">StringBuilder？来重温一下字符串拼接吧</a> 。</p>
<p>:::</p>
<h3 id="【简单】String-equals-和-Object-equals-有何区别？"><a href="#【简单】String-equals-和-Object-equals-有何区别？" class="headerlink" title="【简单】String#equals() 和 Object#equals() 有何区别？"></a>【简单】String#equals() 和 Object#equals() 有何区别？</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong><code>Object#equals()</code></strong></th>
<th align="left"><strong><code>String#equals()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>默认行为</strong></td>
<td align="left">比较<strong>内存地址</strong>（<code>==</code>）</td>
<td align="left">比较<strong>字符串内容</strong>（逐字符对比）</td>
</tr>
<tr>
<td align="left"><strong>重写目的</strong></td>
<td align="left">需子类自行重写以实现逻辑相等</td>
<td align="left">已优化为内容比较，满足字符串业务需求</td>
</tr>
<tr>
<td align="left"><strong>性能影响</strong></td>
<td align="left">无额外开销</td>
<td align="left">需遍历字符数组，但优先检查地址和长度</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">通用对象比较（默认不满足内容相等）</td>
<td align="left">字符串内容对比（如 <code>&quot;abc&quot;.equals(&quot;abc&quot;)</code>）</td>
</tr>
</tbody></table>
<h3 id="【简单】字符串常量池有什么用？"><a href="#【简单】字符串常量池有什么用？" class="headerlink" title="【简单】字符串常量池有什么用？"></a>【简单】字符串常量池有什么用？</h3><p>字符串常量池是JVM 的特殊内存区域，用于存储字符串字面量（如 <code>&quot;abc&quot;</code>），确保相同内容的字符串只存一份。</p>
<p><strong>字符串常量池通过复用相同字符串，节省内存并提升性能，直接赋值（<code>&quot;abc&quot;</code>）优先使用池，<code>new String()</code> 强制创建新对象。</strong></p>
<p>字符串常量池的作用有：</p>
<p><strong>节省内存</strong>：相同字符串复用，避免重复创建（如 <code>String s1 = &quot;hello&quot;</code> 和 <code>String s2 = &quot;hello&quot;</code> 指向同一对象）。</p>
<p><strong>提升性能</strong>：</p>
<ul>
<li><strong>快速比较</strong>：直接通过 <code>==</code> 判断地址是否相同（比 <code>equals()</code> 更快）。</li>
<li><strong>哈希优化</strong>：如 <code>HashMap</code> 的键可复用缓存的 <code>hashCode</code>。</li>
</ul>
<p><strong>实现规则</strong></p>
<ul>
<li><strong>直接赋值</strong>（<code>String s = &quot;abc&quot;</code>）→ <strong>优先从常量池引用</strong>。</li>
<li><strong><code>new String(&quot;abc&quot;)</code></strong> → <strong>强制在堆中创建新对象</strong>（不推荐，除非需隔离实例）。</li>
<li><strong><code>intern()</code> 方法</strong> → 将堆中的字符串对象添加到常量池（若池中不存在）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>**避免滥用 <code>new String()</code>**：无特殊需求时，直接用字面量赋值。</li>
<li><strong><code>intern()</code> 慎用</strong>：可能增加常量池内存压力，需权衡性能。</li>
</ul>
<h3 id="【简单】String-s-new-String-abc-创建了几个字符串对象？"><a href="#【简单】String-s-new-String-abc-创建了几个字符串对象？" class="headerlink" title="【简单】String s = new String(&quot;abc&quot;) 创建了几个字符串对象？"></a>【简单】<code>String s = new String(&quot;abc&quot;)</code> 创建了几个字符串对象？</h3><p><code>new String(&quot;abc&quot;)</code> 可能创建1~2个对象（取决于常量池是否已存在”abc”），但堆中的新对象必定创建。</p>
<ul>
<li><strong>常量池已存在”abc”<strong>：</strong>1个对象</strong>（仅堆中的 <code>new String</code>）</li>
<li><strong>常量池不存在”abc”<strong>：</strong>2个对象</strong>（常量池的”abc” + 堆中的 <code>new String</code>）</li>
</ul>
<h3 id="【简单】String-intern-方法有什么用？"><a href="#【简单】String-intern-方法有什么用？" class="headerlink" title="【简单】String#intern 方法有什么用？"></a>【简单】String#intern 方法有什么用？</h3><p>String#intern 方法的<strong>作用</strong>有：</p>
<ul>
<li><strong>强制字符串入池</strong>：将堆中的 <code>String</code> 对象添加到字符串常量池（若池中不存在）</li>
<li><strong>返回池中引用</strong>：保证相同内容的字符串始终返回同一内存地址</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><strong>JDK7+ 优化</strong>：常量池从方法区移至堆内存，减少内存溢出风险。</li>
<li><strong>慎用场景</strong>：<ul>
<li>避免对动态生成的短生命周期字符串使用（可能导致池膨胀）</li>
<li>优先用于高频使用的静态字符串（如配置键值）</li>
</ul>
</li>
</ul>
<h3 id="【简单】String-类型的变量和常量做“-”运算时会发生什么？"><a href="#【简单】String-类型的变量和常量做“-”运算时会发生什么？" class="headerlink" title="【简单】String 类型的变量和常量做“+”运算时会发生什么？"></a>【简单】String 类型的变量和常量做“+”运算时会发生什么？</h3><p><strong>常量相加编译期优化，变量相加隐式转 <code>StringBuilder</code>，循环拼接必须显式使用 <code>StringBuilder</code> 避免性能损耗。</strong></p>
<p><strong>常量折叠（编译期优化）</strong></p>
<ul>
<li><strong>纯常量运算</strong>（如 <code>&quot;a&quot;+&quot;b&quot;</code>）→ 直接合并为 <code>&quot;ab&quot;</code>，仅存于常量池</li>
<li><strong>final 变量</strong> 视为常量，同样触发优化</li>
</ul>
<p><strong>变量拼接（运行时行为）</strong></p>
<ul>
<li><strong>含变量的运算</strong>（如 <code>str + &quot;b&quot;</code>）→ 隐式转换为 <code>StringBuilder</code> 操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际执行逻辑</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).append(<span class="string">&quot;b&quot;</span>).toString()</span><br></pre></td></tr></table></figure></li>
<li><strong>每次运算</strong> 生成临时 <code>StringBuilder</code> 和最终 <code>String</code> 对象</li>
</ul>
<p><strong>性能关键差异</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>内存&#x2F;性能表现</th>
<th>优化建议</th>
</tr>
</thead>
<tbody><tr>
<td>常量+常量</td>
<td>零运行时开销</td>
<td>无需处理</td>
</tr>
<tr>
<td>单次变量+常量</td>
<td>1次 <code>StringBuilder</code> 创建</td>
<td>可接受</td>
</tr>
<tr>
<td><strong>循环内拼接</strong></td>
<td>多次创建 <code>StringBuilder</code>（性能陷阱）</td>
<td><strong>必须显式用 <code>StringBuilder</code></strong></td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ul>
<li><p><strong>简单拼接</strong>：直接使用 <code>+</code>（可读性优先）</p>
</li>
<li><p><strong>循环&#x2F;批量拼接</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确写法</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String str : list) sb.append(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误写法（低效）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (String str : list) s += str; <span class="comment">// 每次循环隐式新建 StringBuilder</span></span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/46f290c1/" title="Java 基础面试二">https://dunwu.github.io/blog/pages/46f290c1/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
              <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/blog/tags/JavaCore/" rel="tag"># JavaCore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/13b714a7/" rel="prev" title="Java 容器面试一">
                  <i class="fa fa-angle-left"></i> Java 容器面试一
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/191e4e96/" rel="next" title="Java 基础面试三">
                  Java 基础面试三 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"55701e71aeb5e88f922e62124282b021"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
