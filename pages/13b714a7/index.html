<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="Java 容器面试一Java 容器简介【简单】Java 中有哪些集合类？ Java 容器类主要位于 java.util 包，分为 Collection 和 Map 两大类：  Collection（存储独立元素） List（有序、可重复） ArrayList：基于 Object[] 动态数组，查询快，增删慢 LinkedList：基于双链表（JDK1.6 前是循环链表，1.7 取消循环），增删快，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 容器面试一">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/13b714a7/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="Java 容器面试一Java 容器简介【简单】Java 中有哪些集合类？ Java 容器类主要位于 java.util 包，分为 Collection 和 Map 两大类：  Collection（存储独立元素） List（有序、可重复） ArrayList：基于 Object[] 动态数组，查询快，增删慢 LinkedList：基于双链表（JDK1.6 前是循环链表，1.7 取消循环），增删快，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/java-container-structure.png">
<meta property="article:published_time" content="2024-07-02T23:44:02.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.705Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JavaCore">
<meta property="article:tag" content="容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/java-container-structure.png">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/13b714a7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/13b714a7/","path":"/pages/13b714a7/","title":"Java 容器面试一"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 容器面试一 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E4%B8%80"><span class="nav-number">1.</span> <span class="nav-text">Java 容器面试一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java 容器简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">【简单】Java 中有哪些集合类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91Comparable-%E5%92%8C-Comparator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">【简单】Comparable 和 Comparator 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">1.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91ArrayList-%E5%92%8C-Array%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">【简单】ArrayList 和 Array（数组）的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91ArrayList-%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0-null-%E5%80%BC%E5%90%97%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">【简单】ArrayList 可以添加 null 值吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">【简单】ArrayList 和 LinkedList 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">1.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">【简单】HashSet、LinkedHashSet 和 TreeSet 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">1.4.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91Queue-%E4%B8%8E-Deque-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">【简单】Queue 与 Deque 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91ArrayDeque-%E4%B8%8E-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">【简单】ArrayDeque 与 LinkedList 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91PriorityQueue-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">【简单】PriorityQueue 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91BlockingQueue-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">【简单】BlockingQueue 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91ArrayBlockingQueue-%E5%92%8C-LinkedBlockingQueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">【中等】ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/13b714a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 容器面试一 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 容器面试一<a href="https://github.com/dunwu/blog/blob/master/source/_posts/01.Java/01.JavaCore/99.%E9%9D%A2%E8%AF%95/Java_%E9%9D%A2%E8%AF%95_%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java-容器面试一"><a href="#Java-容器面试一" class="headerlink" title="Java 容器面试一"></a>Java 容器面试一</h1><h2 id="Java-容器简介"><a href="#Java-容器简介" class="headerlink" title="Java 容器简介"></a>Java 容器简介</h2><h3 id="【简单】Java-中有哪些集合类？"><a href="#【简单】Java-中有哪些集合类？" class="headerlink" title="【简单】Java 中有哪些集合类？"></a>【简单】Java 中有哪些集合类？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/java-container-structure.png" alt="img"></p>
<p>Java 容器类主要位于 <code>java.util</code> 包，分为 <strong>Collection</strong> 和 <strong>Map</strong> 两大类：</p>
<ul>
<li><strong>Collection（存储独立元素）</strong><ul>
<li><strong>List（有序、可重复）</strong><ul>
<li><strong>ArrayList</strong>：基于 <code>Object[]</code> 动态数组，查询快，增删慢</li>
<li><strong>LinkedList</strong>：基于<strong>双链表</strong>（JDK1.6 前是循环链表，1.7 取消循环），增删快，查询慢</li>
<li><strong>Vector</strong>：线程安全的 <code>Object[]</code> 动态数组（已过时，推荐 <code>ArrayList</code> + <code>Collections.synchronizedList</code>）</li>
</ul>
</li>
<li><strong>Set（无序、不可重复）</strong><ul>
<li><strong>HashSet</strong>：基于 <code>HashMap</code> 实现，不保证顺序</li>
<li><strong>LinkedHashSet</strong>：基于 <code>LinkedHashMap</code>，维护<strong>插入顺序</strong></li>
<li><strong>TreeSet</strong>：基于 <code>TreeMap</code>，支持<strong>自然排序</strong>或<strong>自定义 <code>Comparator</code></strong></li>
</ul>
</li>
<li><strong>Queue（队列，FIFO 或优先级）</strong><ul>
<li><strong>ArrayDeque</strong>：基于动态数组，实现<strong>栈和队列</strong></li>
<li><strong>PriorityQueue</strong>：基于堆，<strong>优先级队列</strong>（按 <code>Comparator</code> 排序）</li>
<li><strong>LinkedList</strong>：也可作为队列&#x2F;双端队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map（键值对存储）</strong><ul>
<li><strong>HashMap</strong>：基于哈希表，<strong>无序</strong>，查找高效（最常用）</li>
<li><strong>LinkedHashMap</strong>：继承 <code>HashMap</code>，额外维护<strong>双向链表</strong>，保持<strong>插入顺序</strong>或<strong>访问顺序</strong></li>
<li><strong>TreeMap</strong>：基于红黑树，<strong>键有序</strong>（自然排序或 <code>Comparator</code>）</li>
<li><strong>Hashtable</strong>：线程安全（<code>synchronized</code> 修饰方法），但性能差，已被 <code>ConcurrentHashMap</code> 取代</li>
<li><strong>ConcurrentHashMap</strong>：分段锁（JDK7）或 CAS + <code>synchronized</code>（JDK8+），高并发优化</li>
</ul>
</li>
<li><strong>工具类</strong><ul>
<li><strong>Collections</strong>：提供集合操作（排序、查找、同步化等）</li>
<li><strong>Arrays</strong>：提供数组操作（排序、二分查找等）</li>
<li><strong>Stream（Java 8+）</strong>：支持函数式编程的流式处理</li>
</ul>
</li>
</ul>
<p><strong>关键区别</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>主要实现类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>List</strong></td>
<td>有序、可重复</td>
<td><code>ArrayList</code>、<code>LinkedList</code></td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>无序、不可重复</td>
<td><code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></td>
</tr>
<tr>
<td><strong>Queue</strong></td>
<td>队列&#x2F;栈</td>
<td><code>ArrayDeque</code>、<code>PriorityQueue</code></td>
</tr>
<tr>
<td><strong>Map</strong></td>
<td>键值对</td>
<td><code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code></td>
</tr>
</tbody></table>
<p><strong>线程安全</strong>：</p>
<ul>
<li>单线程：<code>ArrayList</code>、<code>HashMap</code></li>
<li>多线程：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code></li>
</ul>
<h3 id="【简单】Comparable-和-Comparator-有什么区别？"><a href="#【简单】Comparable-和-Comparator-有什么区别？" class="headerlink" title="【简单】Comparable 和 Comparator 有什么区别？"></a>【简单】Comparable 和 Comparator 有什么区别？</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用。</p>
<ul>
<li><strong>Comparable</strong> → “我能比较”（类自己实现的比较能力）</li>
<li><strong>Comparator</strong> → “比较器”（外部提供的比较工具）</li>
</ul>
<p>两者通常一起使用，为Java对象提供灵活多样的排序能力。</p>
<p><strong>Comparable vs. Comparator</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody><tr>
<td><strong>包位置</strong></td>
<td>java.lang</td>
<td>java.util</td>
</tr>
<tr>
<td><strong>接口方法</strong></td>
<td>compareTo(T o)</td>
<td>compare(T o1, T o2)</td>
</tr>
<tr>
<td><strong>排序逻辑位置</strong></td>
<td>定义在要排序的类内部</td>
<td>定义在单独的类或匿名类中</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>类的”自然排序”</td>
<td>多种排序方式或无法修改类时的排序</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><code>Collections.sort(list)</code></td>
<td><code>Collections.sort(list, comparator)</code></td>
</tr>
<tr>
<td><strong>影响范围</strong></td>
<td>修改类的原始定义</td>
<td>不修改原有类</td>
</tr>
</tbody></table>
<p><strong>设计目的不同</strong></p>
<ul>
<li><code>Comparable</code>：定义对象的<strong>自然排序</strong>（如String按字母顺序，Integer按数值大小）</li>
<li><code>Comparator</code>：定义<strong>多种排序策略</strong>或为无法修改源代码的类提供排序</li>
</ul>
<p><strong>实现方式不同</strong></p>
<ul>
<li><code>Comparable</code>：需要修改类本身，实现<code>compareTo()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Comparator</code>：独立实现，通常使用匿名类或lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; byName = (p1, p2) -&gt; p1.getName().compareTo(p2.getName());</span><br></pre></td></tr></table></figure>

<p><strong>使用场景选择</strong></p>
<ul>
<li>用<code>Comparable</code>当：<ul>
<li>类有明确的自然排序标准</li>
<li>你能修改类的源代码</li>
<li>只需要一种主要排序方式</li>
</ul>
</li>
<li>用<code>Comparator</code>当：<ul>
<li>需要多种排序方式（如按姓名、年龄、工资等）</li>
<li>不能修改类的源代码（如第三方库的类）</li>
<li>需要临时或特殊的排序规则</li>
</ul>
</li>
</ul>
<p><strong>Java 8+的便利支持</strong></p>
<ul>
<li>Comparator提供了许多方便的静态方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多级排序</span></span><br><span class="line">Comparator&lt;Person&gt; comparator =</span><br><span class="line">    Comparator.comparing(Person::getLastName)</span><br><span class="line">              .thenComparing(Person::getFirstName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序排序</span></span><br><span class="line">Comparator&lt;Person&gt; reverseAge =</span><br><span class="line">    Comparator.comparingInt(Person::getAge).reversed();</span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="【简单】ArrayList-和-Array（数组）的区别？"><a href="#【简单】ArrayList-和-Array（数组）的区别？" class="headerlink" title="【简单】ArrayList 和 Array（数组）的区别？"></a>【简单】ArrayList 和 Array（数组）的区别？</h3><p><strong>ArrayList vs. 数组</strong></p>
<table>
<thead>
<tr>
<th><strong>对比点</strong></th>
<th><strong>数组 (Array)</strong></th>
<th><strong>ArrayList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>长度可变性</strong></td>
<td>固定长度，创建后无法调整大小</td>
<td>动态扩容（默认扩容1.5倍）</td>
</tr>
<tr>
<td><strong>存储类型</strong></td>
<td>支持基本类型（<code>int[]</code>）和对象类型</td>
<td>仅支持引用类型（基本类型需装箱，如 <code>Integer</code>）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（无额外对象开销）</td>
<td>有额外内存开销（记录大小、扩容预留空间等）</td>
</tr>
<tr>
<td><strong>访问方式</strong></td>
<td>通过索引直接访问（<code>arr[0]</code>）</td>
<td>通过 <code>get(index)</code>&#x2F;<code>set(index)</code> 方法访问</td>
</tr>
<tr>
<td><strong>操作效率</strong></td>
<td>- 查询：O(1)（极快）<br>- 增删：O(n)（需移动元素）</td>
<td>- 查询：O(1)（底层是数组）<br>- 增删：<br> - 尾部操作：O(1)<br> - 中间操作：O(n)（需移动元素）</td>
</tr>
<tr>
<td><strong>功能方法</strong></td>
<td>功能简单（依赖 <code>Arrays</code> 工具类）</td>
<td>提供丰富方法（<code>add()</code>、<code>remove()</code>、<code>contains()</code> 等）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全（需用 <code>Collections.synchronizedList</code> 包装）</td>
</tr>
<tr>
<td><strong>泛型支持</strong></td>
<td>不支持泛型（类型检查在运行时）</td>
<td>支持泛型（编译时类型安全）</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：</p>
<ul>
<li><strong>动态性</strong>：<code>ArrayList</code> 自动扩容，数组长度固定。</li>
<li><strong>类型支持</strong>：数组可直接存基本类型，<code>ArrayList</code> 需包装类。</li>
<li><strong>性能</strong>：<ul>
<li>数组的随机访问稍快（少一次方法调用）。</li>
<li><code>ArrayList</code> 的尾部插入高效，但中间插入&#x2F;删除需移动元素。</li>
</ul>
</li>
<li><strong>功能</strong>：<code>ArrayList</code> 提供更多便捷方法（如迭代、搜索）。</li>
<li><strong>内存</strong>：数组更节省内存，<code>ArrayList</code> 有额外结构开销。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>选数组</strong>：需极致性能、固定长度或存储基本类型时（如数学计算）。</li>
<li><strong>选ArrayList</strong>：需要动态大小、便捷操作或泛型安全时（大多数业务场景）。</li>
</ul>
<h3 id="【简单】ArrayList-可以添加-null-值吗？"><a href="#【简单】ArrayList-可以添加-null-值吗？" class="headerlink" title="【简单】ArrayList 可以添加 null 值吗？"></a>【简单】ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> <strong>可以添加任意数量的 <code>null</code> 值</strong>，包括重复 <code>null</code>，但需谨慎处理潜在的空指针问题。</p>
<p><code>ArrayList</code>底层基于 <code>Object[]</code> 数组实现，天然支持 <code>null</code>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>**可能引发 <code>NullPointerException</code>**：<ul>
<li>直接调用 <code>null</code> 的方法（如 <code>list.get(0).length()</code>）会报错。</li>
<li>使用 <code>contains(null)</code> 或遍历时需判空。</li>
</ul>
</li>
<li><strong>慎用于特定场景</strong>：如数据库映射、JSON 序列化工具可能对 <code>null</code> 有特殊限制。</li>
</ul>
<p><strong>与其他容器对比</strong>：</p>
<ul>
<li><strong>HashSet</strong>：允许一个 <code>null</code>。</li>
<li><strong>TreeSet</strong>：若用自然排序，添加 <code>null</code> 会抛 <code>NullPointerException</code>。</li>
<li><strong>HashMap</strong>：允许 <code>null</code> 键和值。</li>
<li><strong>Hashtable</strong>：禁止 <code>null</code> 键和值。</li>
</ul>
<p><strong>建议</strong>：</p>
<ul>
<li>明确是否需要 <code>null</code>，避免滥用导致代码健壮性问题。</li>
<li>必要时用 <code>Optional</code> 或默认值替代 <code>null</code>。</li>
</ul>
<h3 id="【简单】ArrayList-和-LinkedList-有什么区别？"><a href="#【简单】ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="【简单】ArrayList 和 LinkedList 有什么区别？"></a>【简单】ArrayList 和 LinkedList 有什么区别？</h3><p><strong><code>ArrayList</code> vs. <code>LinkedList</code></strong></p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>ArrayList</strong></th>
<th><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td>动态数组（<code>Object[]</code>）</td>
<td>双向链表（<code>Node</code> 节点）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（连续内存）</td>
<td>更高（每个元素需额外存储前后节点指针）</td>
</tr>
<tr>
<td><strong>随机访问性能</strong></td>
<td>⚡ **O(1)**（通过索引直接访问）</td>
<td>🐢 **O(n)**（需遍历链表）</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除性能</strong></td>
<td>- 尾部操作：⚡ <strong>O(1)</strong><br>- 中间&#x2F;头部操作：🐢 **O(n)**（需移动元素）</td>
<td>- 头尾操作：⚡ <strong>O(1)</strong><br>- 中间操作：🐢 **O(n)**（需遍历定位）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 频繁随机访问<br>- 数据量稳定或尾部操作多</td>
<td>- 频繁头尾插入&#x2F;删除<br>- 数据动态性强</td>
</tr>
<tr>
<td><strong>额外功能</strong></td>
<td>仅基础列表操作</td>
<td>实现了 <code>Deque</code> 接口（可作队列&#x2F;栈使用）</td>
</tr>
<tr>
<td><strong>空间局部性</strong></td>
<td>✅ 更好（CPU 缓存友好）</td>
<td>❌ 较差（节点分散存储）</td>
</tr>
</tbody></table>
<p><strong>对比小结</strong>：<br>List<code> 需遍历链表。 2. **增删效率**：</code>ArrayList<code> 尾部插入快，中间/头部插入慢；</code>Lin</p>
<ol>
<li><strong>访问速度</strong>：<code>ArrayList</code> 随机访问极快（数组索引），<code>LinkedkedList</code> 头尾插入快，中间插入仍需遍历。</li>
<li><strong>内存开销</strong>：<code>LinkedList</code> 每个元素多消耗 2 个指针空间（前驱+后继）。</li>
<li><strong>功能扩展</strong>：<code>LinkedList</code> 支持队列&#x2F;栈操作（如 <code>addFirst()</code>, <code>pollLast()</code>）。</li>
</ol>
<p><strong>选型建议</strong>：</p>
<ul>
<li>优先用 **<code>ArrayList</code>**（大多数场景性能更优）。</li>
<li>仅当需要频繁在 <strong>头部&#x2F;中间插入删除</strong>，或需要 <strong>队列&#x2F;栈功能</strong> 时选 <code>LinkedList</code>。</li>
</ul>
<blockquote>
<p>💡 <strong>Java 实践提示</strong>：</p>
<ul>
<li>默认情况下，<code>Collections.synchronizedList</code> 包装的 <code>ArrayList</code> 比 <code>LinkedList</code> 线程安全开销更低。</li>
<li>Java 8+ 的 <code>Stream</code> 操作在 <code>ArrayList</code> 上效率更高。</li>
</ul>
</blockquote>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="【简单】HashSet、LinkedHashSet-和-TreeSet-有什么区别？"><a href="#【简单】HashSet、LinkedHashSet-和-TreeSet-有什么区别？" class="headerlink" title="【简单】HashSet、LinkedHashSet 和 TreeSet 有什么区别？"></a>【简单】HashSet、LinkedHashSet 和 TreeSet 有什么区别？</h3><table>
<thead>
<tr>
<th>特性</th>
<th>HashSet</th>
<th>LinkedHashSet</th>
<th>TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层实现</strong></td>
<td>哈希表 (HashMap)</td>
<td>哈希表 + 链表</td>
<td>红黑树</td>
</tr>
<tr>
<td><strong>排序保证</strong></td>
<td>无顺序</td>
<td>插入顺序</td>
<td>自然顺序&#x2F;自定义排序</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>添加&#x2F;删除&#x2F;查找: O(1)</td>
<td>添加&#x2F;删除&#x2F;查找: O(1)</td>
<td>添加&#x2F;删除&#x2F;查找: O(log n)</td>
</tr>
<tr>
<td><strong>允许null元素</strong></td>
<td>允许1个null</td>
<td>允许1个null</td>
<td>不允许(除非自定义Comparator允许)</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>性能特点</strong></td>
<td>最快的基础操作</td>
<td>比HashSet稍慢但保持顺序</td>
<td>最慢但自动排序</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>只需唯一性不关心顺序</td>
<td>需要保持插入顺序</td>
<td>需要排序的集合</td>
</tr>
</tbody></table>
<p><strong>顺序特性</strong></p>
<ul>
<li><code>HashSet</code>：完全不保证任何顺序（基于哈希值存储）</li>
<li><code>LinkedHashSet</code>：维护元素<strong>插入顺序</strong>（迭代时按插入顺序返回）</li>
<li><code>TreeSet</code>：根据元素的<strong>自然顺序</strong>或<strong>Comparator</strong>进行排序</li>
</ul>
<p><strong>性能比较</strong></p>
<ul>
<li><strong>操作速度</strong>：HashSet ≈ LinkedHashSet &gt; TreeSet</li>
<li><strong>内存占用</strong>：LinkedHashSet &gt; HashSet &gt; TreeSet</li>
<li><strong>迭代性能</strong>：LinkedHashSet最优（顺序访问快）</li>
</ul>
<p><strong>实现原理</strong></p>
<ul>
<li><code>HashSet</code>：基于HashMap实现，只使用键</li>
<li><code>LinkedHashSet</code>：继承HashSet，通过链表维护插入顺序</li>
<li><code>TreeSet</code>：基于TreeMap实现（红黑树结构）</li>
</ul>
<p><strong>构造方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet</span></span><br><span class="line">Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet</span></span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet - 自然排序</span></span><br><span class="line">Set&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet - 自定义排序</span></span><br><span class="line">Set&lt;String&gt; customTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p><strong>使用场景建议</strong></p>
<ul>
<li>需要<strong>最快查询</strong>且不关心顺序 → HashSet</li>
<li>需要<strong>保持插入顺序</strong> → LinkedHashSet</li>
<li>需要<strong>自动排序</strong>或<strong>范围查询</strong> → TreeSet</li>
<li>需要<strong>频繁迭代</strong> → LinkedHashSet</li>
</ul>
<p><strong>特殊注意事项</strong></p>
<ul>
<li><p><strong>相等性判断</strong>：</p>
<ul>
<li>三者都使用<code>equals()</code>方法判断元素是否相同</li>
<li>TreeSet同时会使用<code>compareTo()</code>或<code>compare()</code>方法（必须与equals逻辑一致）</li>
</ul>
</li>
<li><p><strong>TreeSet排序规则</strong>：</p>
<ul>
<li>元素必须实现<code>Comparable</code>接口，或在构造时提供<code>Comparator</code></li>
<li>否则会抛出<code>ClassCastException</code></li>
</ul>
</li>
<li><p><strong>线程安全替代方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; syncSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; syncTreeSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<p>选择哪种Set实现取决于你的具体需求：要速度（HashSet）、要插入顺序（LinkedHashSet）还是要自动排序（TreeSet）。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="【简单】Queue-与-Deque-有什么区别？"><a href="#【简单】Queue-与-Deque-有什么区别？" class="headerlink" title="【简单】Queue 与 Deque 有什么区别？"></a>【简单】Queue 与 Deque 有什么区别？</h3><p>::: info Queue vs. Deque<br>:::</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Queue (队列)</th>
<th>Deque (双端队列)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>进出原则</strong></td>
<td>先进先出 (FIFO)</td>
<td>两端都可进出 (FIFO + LIFO)</td>
</tr>
<tr>
<td><strong>主要操作</strong></td>
<td>队尾入队(add&#x2F;offer)，队首出队(remove&#x2F;poll)</td>
<td>支持队首&#x2F;队尾的入队和出队操作</td>
</tr>
<tr>
<td><strong>继承关系</strong></td>
<td>基础接口</td>
<td>继承自 Queue 接口</td>
</tr>
<tr>
<td><strong>代表子类</strong></td>
<td>LinkedList, PriorityQueue</td>
<td>ArrayDeque, LinkedList</td>
</tr>
<tr>
<td><strong>特殊功能</strong></td>
<td>-</td>
<td>支持栈操作(push&#x2F;pop&#x2F;peek)</td>
</tr>
</tbody></table>
<p><strong>基本操作对比</strong></p>
<p>::: code-tabs#重载和重写的示例</p>
<p>@tab <strong>Queue 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue.offer(e);  <span class="comment">// 队尾添加（推荐）</span></span><br><span class="line">queue.add(e);    <span class="comment">// 队尾添加（可能抛异常）</span></span><br><span class="line">queue.poll();    <span class="comment">// 队首移除并返回（推荐）</span></span><br><span class="line">queue.remove();  <span class="comment">// 队首移除并返回（可能抛异常）</span></span><br><span class="line">queue.peek();    <span class="comment">// 查看队首（不移除）</span></span><br><span class="line">queue.element(); <span class="comment">// 查看队首（可能抛异常）</span></span><br></pre></td></tr></table></figure>

<p>@tab <strong>Deque 扩展操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队首操作</span></span><br><span class="line">deque.offerFirst(e);  deque.addFirst(e);</span><br><span class="line">deque.pollFirst();    deque.removeFirst();</span><br><span class="line">deque.peekFirst();    deque.getFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾操作</span></span><br><span class="line">deque.offerLast(e);   deque.addLast(e);</span><br><span class="line">deque.pollLast();     deque.removeLast();</span><br><span class="line">deque.peekLast();     deque.getLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈操作</span></span><br><span class="line">deque.push(e);        <span class="comment">// = addFirst(e)</span></span><br><span class="line">deque.pop();          <span class="comment">// = removeFirst()</span></span><br></pre></td></tr></table></figure>

<p>:::</p>
<p><strong>使用场景差异</strong></p>
<ul>
<li><strong>Queue 适用场景（标准的先进先出场景）</strong>：<ul>
<li>任务调度系统（先来先服务）</li>
<li>消息队列（生产者-消费者模型）</li>
<li>广度优先搜索（BFS）</li>
</ul>
</li>
<li><strong>Deque 适用场景（需要两端操作的场景）</strong>：<ul>
<li>撤销操作历史（两端添加，一端移除）</li>
<li>滑动窗口算法</li>
<li>可同时作为队列和栈使用</li>
<li>工作窃取算法（如ForkJoinPool使用Deque）</li>
<li>实现高效的头尾操作（ArrayDeque比LinkedList更高效）</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结：</p>
<ul>
<li>需要<strong>标准队列行为</strong> → 选择 Queue</li>
<li>需要<strong>两端操作</strong>或<strong>栈功能</strong> → 选择 Deque</li>
<li>需要<strong>优先级排序</strong> → 使用 PriorityQueue（Queue实现）</li>
<li>追求<strong>高性能</strong> → 优先考虑 ArrayDeque（优于 LinkedList）</li>
</ul>
</blockquote>
<p><strong>性能特点</strong></p>
<ul>
<li><code>ArrayDeque</code>（Deque实现）比<code>LinkedList</code>：<ul>
<li>内存更紧凑（数组实现）</li>
<li>大多数操作更高效（O(1)时间）</li>
<li>但不适合频繁的中间插入&#x2F;删除</li>
</ul>
</li>
<li><code>PriorityQueue</code>（Queue实现）：<ul>
<li>基于堆结构</li>
<li>保证每次取出的都是优先级最高的元素（O(log n)时间）</li>
</ul>
</li>
</ul>
<p><strong>线程安全注意</strong></p>
<ul>
<li>两者主要实现类（LinkedList&#x2F;ArrayDeque）都<strong>非线程安全</strong></li>
<li>线程安全替代方案：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; safeQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">Deque&lt;String&gt; safeDeque = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="【简单】ArrayDeque-与-LinkedList-有什么区别？"><a href="#【简单】ArrayDeque-与-LinkedList-有什么区别？" class="headerlink" title="【简单】ArrayDeque 与 LinkedList 有什么区别？"></a>【简单】ArrayDeque 与 LinkedList 有什么区别？</h3><ul>
<li>**性能优先选 <code>ArrayDeque</code>**：队列&#x2F;栈场景，追求更高吞吐和更低内存。</li>
<li>**功能灵活选 <code>LinkedList</code>**：需要中间操作、随机访问或混合数据结构时。</li>
</ul>
<p>以下是 <strong>ArrayDeque</strong> 和 <strong>LinkedList</strong> 的对比表格，清晰概括两者的核心差异：</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>ArrayDeque</strong></th>
<th><strong>LinkedList</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td>动态数组（循环数组）</td>
<td>双向链表</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更低（连续存储，无节点开销）</td>
<td>更高（每个元素需存储前后节点引用）</td>
</tr>
<tr>
<td><strong>头部&#x2F;尾部操作</strong></td>
<td><code>O(1)</code>，常数时间更优</td>
<td><code>O(1)</code>，但实际更慢（需操作节点）</td>
</tr>
<tr>
<td><strong>中间插入&#x2F;删除</strong></td>
<td><code>O(n)</code>（需移动元素）</td>
<td><code>O(1)</code>（已知位置时）</td>
</tr>
<tr>
<td><strong>随机访问</strong></td>
<td>理论上 <code>O(1)</code>，但通常不支持直接索引操作</td>
<td><code>O(n)</code>（需遍历链表）</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>动态扩容（默认翻倍），扩容时有开销</td>
<td>无扩容概念，按需分配节点</td>
</tr>
<tr>
<td><strong>功能支持</strong></td>
<td>仅双端队列操作（<code>Deque</code>）</td>
<td>同时实现 <code>List</code> 和 <code>Deque</code>，支持索引和中间操作</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>迭代效率</strong></td>
<td>更高（连续内存访问）</td>
<td>较低（非连续内存访问）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高频双端操作（如栈、队列）</td>
<td>需要中间操作或混合 <code>List/Deque</code> 需求的场景</td>
</tr>
</tbody></table>
<h3 id="【简单】PriorityQueue-有什么用？"><a href="#【简单】PriorityQueue-有什么用？" class="headerlink" title="【简单】PriorityQueue 有什么用？"></a>【简单】PriorityQueue 有什么用？</h3><p>PriorityQueue 是自动排序的堆结构队列，默认小顶堆，适用优先级调度，但线程不安全。</p>
<p><strong>基本特性</strong></p>
<ul>
<li><strong>基于堆（默认小顶堆）</strong>，元素按优先级出队（最小&#x2F;最大值先出）。</li>
<li><strong>无界队列</strong>（自动扩容），但初始容量为 <code>11</code>。</li>
<li>**不允许 <code>null</code>**，且元素需实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
</ul>
<p><strong>关键操作</strong>  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(E e)</code> &#x2F; <code>offer(E e)</code></td>
<td>O(log n)</td>
<td>插入元素，触发堆调整。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>O(log n)</td>
<td>移除并返回队首（优先级最高）。</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>O(1)</td>
<td>查看队首但不移除。</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>O(n)</td>
<td>删除指定元素（需遍历堆）。</td>
</tr>
</tbody></table>
<p><strong>排序规则</strong></p>
<ul>
<li><strong>默认自然排序</strong>（元素需实现 <code>Comparable</code>）。</li>
<li><strong>自定义排序</strong>：通过 <code>Comparator</code> 指定（如大顶堆）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>任务调度</strong>（按优先级执行）。</li>
<li><strong>Top K 问题</strong>（维护前 K 个最大&#x2F;最小值）。</li>
<li><strong>Dijkstra 算法</strong>（优先处理最短路径）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>非线程安全</strong>：多线程需用 <code>PriorityBlockingQueue</code>。</li>
<li><strong>迭代无序</strong>：遍历顺序不等于优先级顺序。</li>
<li><strong>性能权衡</strong>：插入&#x2F;删除 O(log n)，但查找 O(n)。</li>
</ul>
<h3 id="【简单】BlockingQueue-有什么用？"><a href="#【简单】BlockingQueue-有什么用？" class="headerlink" title="【简单】BlockingQueue 有什么用？"></a>【简单】BlockingQueue 有什么用？</h3><p><strong>BlockingQueue 是线程安全的队列</strong>，支持阻塞操作（队列满时阻塞插入，空时阻塞取出）。主要用于<strong>生产者-消费者模型</strong>，协调多线程数据交换。</p>
<p><strong>关键方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>put(E e)</code></td>
<td>队列满时<strong>阻塞</strong>，直到有空间插入。</td>
</tr>
<tr>
<td><code>take()</code></td>
<td>队列空时<strong>阻塞</strong>，直到有元素可取。</td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>非阻塞插入，成功返回 <code>true</code>，失败返回 <code>false</code>。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>非阻塞取出，有元素返回元素，无元素返回 <code>null</code>。</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>查看队首元素但不移除（无元素返回 <code>null</code>）。</td>
</tr>
</tbody></table>
<p><strong>常见实现类</strong></p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：固定大小数组，单锁，适合低并发。</li>
<li>**<code>LinkedBlockingQueue</code>**：链表，双锁（高并发），默认几乎无界。</li>
<li>**<code>PriorityBlockingQueue</code>**：优先级队列（堆实现），无界。</li>
<li>**<code>SynchronousQueue</code>**：不存储元素，直接传递任务（一对一通信）。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>任务调度</strong>（线程池任务队列）。</li>
<li><strong>数据缓冲</strong>（生产者-消费者模型）。</li>
<li><strong>流量控制</strong>（通过固定容量限制并发）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>线程安全</strong>：所有实现均线程安全，但需注意 <code>peek()</code> 和 <code>poll()</code> 的竞态条件。</li>
<li><strong>阻塞策略</strong>：<code>put()</code>&#x2F;<code>take()</code> 会阻塞，<code>offer()</code>&#x2F;<code>poll()</code> 可设置超时。</li>
<li><strong>无界队列风险</strong>：<code>LinkedBlockingQueue</code> 默认无界，可能导致 <code>OOM</code>，建议设置容量。</li>
</ul>
<p><strong>一句话总结</strong>： 多线程间安全传递数据的阻塞队列，核心方法是 <code>put()</code>（阻塞插入）和 <code>take()</code>（阻塞取出），按场景选实现类。</p>
<h3 id="【中等】ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#【中等】ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="【中等】ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"></a>【中等】ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 都是 Java 并发包（<code>java.util.concurrent</code>）中的<strong>线程安全阻塞队列</strong>，但它们在底层实现、性能和适用场景上有显著区别。</p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：固定容量，单锁，适合低并发或内存敏感场景。</li>
<li>**<code>LinkedBlockingQueue</code>**：动态扩容，双锁，适合高并发和高吞吐场景。</li>
<li>**避免 <code>OOM</code>**：如果使用 <code>LinkedBlockingQueue</code>，建议设置合理容量（默认 <code>MAX_VALUE</code> 可能导致内存问题）。</li>
</ul>
<p><strong><code>ArrayBlockingQueue</code> vs. <code>LinkedBlockingQueue</code></strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
<th><strong>LinkedBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层数据结构</strong></td>
<td><strong>固定大小的数组</strong>（循环队列）</td>
<td><strong>链表</strong>（可动态扩容）</td>
</tr>
<tr>
<td><strong>初始化容量</strong></td>
<td><strong>必须指定容量</strong>（无默认构造方法）</td>
<td>可选指定容量（默认 <code>Integer.MAX_VALUE</code>）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑（连续存储）</td>
<td>稍高（每个节点存储前后指针）</td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td><strong>单锁（入队和出队共用同一把锁）</strong></td>
<td><strong>双锁（入队和出队分离锁，减少竞争）</strong></td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>较低（锁竞争更激烈）</td>
<td>较高（读写分离，并发性能更好）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>固定大小队列，避免 OOM</td>
<td>高并发、动态扩容场景</td>
</tr>
</tbody></table>
<p><strong>底层数据结构</strong></p>
<ul>
<li><p><strong><code>ArrayBlockingQueue</code></strong></p>
<ul>
<li>基于<strong>数组</strong>（循环队列），初始化时必须指定固定容量。</li>
<li>存储连续，内存局部性好，但扩容需重建数组（不支持动态扩容）。</li>
</ul>
</li>
<li><p><strong><code>LinkedBlockingQueue</code></strong></p>
<ul>
<li>基于<strong>链表</strong>，默认容量 <code>Integer.MAX_VALUE</code>（几乎无界）。</li>
<li>可动态增长，但每个节点需额外存储前后指针，内存开销稍大。</li>
</ul>
</li>
</ul>
<p><strong>锁机制</strong></p>
<ul>
<li><p><strong><code>ArrayBlockingQueue</code></strong></p>
<ul>
<li>使用<strong>单锁</strong>（<code>ReentrantLock</code>），入队和出队操作共用同一把锁，竞争较激烈。</li>
<li>适合<strong>低并发</strong>或<strong>容量固定</strong>的场景。</li>
</ul>
</li>
<li><p><strong><code>LinkedBlockingQueue</code></strong></p>
<ul>
<li>采用<strong>双锁</strong>（<code>putLock</code> 和 <code>takeLock</code>），入队和出队操作互不阻塞。</li>
<li><strong>高并发</strong>下吞吐量更高（如生产者-消费者模型）。</li>
</ul>
</li>
</ul>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
<th><strong>LinkedBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>入队（<code>put</code>）</strong></td>
<td>较慢（单锁竞争）</td>
<td>更快（双锁分离）</td>
</tr>
<tr>
<td><strong>出队（<code>take</code>）</strong></td>
<td>较慢（单锁竞争）</td>
<td>更快（双锁分离）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>更紧凑</td>
<td>稍高（链表节点开销）</td>
</tr>
</tbody></table>
<p><strong>使用场景建议</strong></p>
<p><strong>选择 <code>ArrayBlockingQueue</code> 的情况</strong>：</p>
<ul>
<li>✅ <strong>队列大小固定</strong>，防止内存耗尽（如任务队列有严格上限）。</li>
<li>✅ <strong>低&#x2F;中并发</strong>，且对内存占用敏感。</li>
</ul>
<p><strong>选择 <code>LinkedBlockingQueue</code> 的情况</strong>：</p>
<ul>
<li>✅ <strong>高并发</strong>（生产者-消费者模型）。</li>
<li>✅ <strong>队列大小不固定</strong>（默认几乎无界，但可手动指定容量）。</li>
<li>✅ <strong>需要更高的吞吐量</strong>（双锁机制减少竞争）。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/13b714a7/" title="Java 容器面试一">https://dunwu.github.io/blog/pages/13b714a7/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
              <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/blog/tags/JavaCore/" rel="tag"># JavaCore</a>
              <a href="/blog/tags/%E5%AE%B9%E5%99%A8/" rel="tag"># 容器</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/a626f515/" rel="prev" title="Java 容器面试三">
                  <i class="fa fa-angle-left"></i> Java 容器面试三
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/46f290c1/" rel="next" title="Java 基础面试二">
                  Java 基础面试二 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"2dff7059617fc399c0f5c9b3252a928d"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
