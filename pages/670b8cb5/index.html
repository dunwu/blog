<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="Java 容器面试二Map【中等】HashMap 和 Hashtable 有什么区别？HashMap 更高效且灵活，Hashtable 线程安全但过时，推荐用 ConcurrentHashMap 替代。    对比项 HashMap (JDK 1.2+) Hashtable (JDK 1.0)    线程安全 ❌ 非线程安全（需额外同步） ✅ 线程安全（方法用 synchronized 修饰）">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 容器面试二">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/670b8cb5/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="Java 容器面试二Map【中等】HashMap 和 Hashtable 有什么区别？HashMap 更高效且灵活，Hashtable 线程安全但过时，推荐用 ConcurrentHashMap 替代。    对比项 HashMap (JDK 1.2+) Hashtable (JDK 1.0)    线程安全 ❌ 非线程安全（需额外同步） ✅ 线程安全（方法用 synchronized 修饰）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-02T23:44:02.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.705Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="JavaCore">
<meta property="article:tag" content="容器">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/670b8cb5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/670b8cb5/","path":"/pages/670b8cb5/","title":"Java 容器面试二"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 容器面试二 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E4%BA%8C"><span class="nav-number">1.</span> <span class="nav-text">Java 容器面试二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">1.1.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">【中等】HashMap 和 Hashtable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91%E5%AF%B9%E6%AF%94%E4%B8%80%E4%B8%8B-HashMap-%E5%92%8C-HashSet%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">【中等】对比一下 HashMap 和 HashSet？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91HashMap%E3%80%81TreeMap%E3%80%81LinkedHashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">【中等】HashMap、TreeMap、LinkedHashMap 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91HashMap-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">【困难】HashMap 底层实现原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">【困难】HashMap 为什么线程不安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91WeakHashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">【中等】WeakHashMap 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91ConcurrentHashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">【中等】ConcurrentHashMap 和 Hashtable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91ConcurrentHashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">【困难】ConcurrentHashMap 的底层实现原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91ConcurrentHashMap-%E4%B8%BA%E4%BB%80%E4%B9%88-key-%E5%92%8C-value-%E4%B8%8D%E8%83%BD%E4%B8%BA-null%EF%BC%9F"><span class="nav-number">1.1.9.</span> <span class="nav-text">【中等】ConcurrentHashMap 为什么 key 和 value 不能为 null？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91ConcurrentHashMap-%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">【中等】ConcurrentHashMap 能保证复合操作的原子性吗？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/670b8cb5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 容器面试二 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 容器面试二<a href="https://github.com/dunwu/blog/blob/master/source/_posts/01.Java/01.JavaCore/99.%E9%9D%A2%E8%AF%95/Java_%E9%9D%A2%E8%AF%95_%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-03 07:44:02" itemprop="dateCreated datePublished" datetime="2024-07-03T07:44:02+08:00">2024-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/" itemprop="url" rel="index"><span itemprop="name">JavaCore</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaCore/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java-容器面试二"><a href="#Java-容器面试二" class="headerlink" title="Java 容器面试二"></a>Java 容器面试二</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="【中等】HashMap-和-Hashtable-有什么区别？"><a href="#【中等】HashMap-和-Hashtable-有什么区别？" class="headerlink" title="【中等】HashMap 和 Hashtable 有什么区别？"></a>【中等】HashMap 和 Hashtable 有什么区别？</h3><p><code>HashMap</code> 更高效且灵活，<code>Hashtable</code> 线程安全但过时，推荐用 <code>ConcurrentHashMap</code> 替代。</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>HashMap</strong> (JDK 1.2+)</th>
<th><strong>Hashtable</strong> (JDK 1.0)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全</strong></td>
<td>❌ 非线程安全（需额外同步）</td>
<td>✅ 线程安全（方法用 <code>synchronized</code> 修饰）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>⚡ 更高（无锁竞争）</td>
<td>⏳ 较低（同步开销）</td>
</tr>
<tr>
<td><strong>Null 键&#x2F;值</strong></td>
<td>✅ 允许 <code>null</code> 键和值</td>
<td>❌ 不允许 <code>null</code></td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td>**<code>fail-fast</code>**（快速失败，并发修改抛异常）</td>
<td>**<code>enumerator</code>**（不抛异常）</td>
</tr>
<tr>
<td><strong>继承体系</strong></td>
<td>继承 <code>AbstractMap</code></td>
<td>继承 <code>Dictionary</code>（已过时）</td>
</tr>
<tr>
<td><strong>初始容量与扩容</strong></td>
<td>默认 16，扩容为 2 倍</td>
<td>默认 11，扩容为 2 倍 + 1</td>
</tr>
<tr>
<td><strong>哈希冲突解决</strong></td>
<td>链表 + 红黑树（JDK 8+）</td>
<td>仅链表</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong>：</p>
<ul>
<li>**优先用 <code>HashMap</code>**：大多数场景（性能更好），搭配 <code>Collections.synchronizedMap()</code> 或 <code>ConcurrentHashMap</code> 实现线程安全。</li>
<li><strong><code>Hashtable</code> 适用场景</strong>：遗留系统兼容，或需要简单线程安全且不介意性能损耗时（现代开发已少用）。</li>
</ul>
<h3 id="【中等】对比一下-HashMap-和-HashSet？"><a href="#【中等】对比一下-HashMap-和-HashSet？" class="headerlink" title="【中等】对比一下 HashMap 和 HashSet？"></a>【中等】对比一下 HashMap 和 HashSet？</h3><ul>
<li><code>HashMap</code> 是 <strong>键值对容器</strong>，适合快速键值查询。</li>
<li><code>HashSet</code> 是 <strong>唯一元素集合</strong>，基于 <code>HashMap</code> 实现，仅关注元素是否存在。</li>
</ul>
<p><strong>核心区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>HashSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据结构</strong></td>
<td>哈希表（键值对存储）</td>
<td>基于 <code>HashMap</code>（仅用键，值固定为虚拟对象）</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>键（Key） + 值（Value）</td>
<td>仅存储元素（Key）</td>
</tr>
<tr>
<td><strong>重复规则</strong></td>
<td><strong>Key 不可重复</strong>（Value 可重复）</td>
<td><strong>元素（Key）不可重复</strong></td>
</tr>
<tr>
<td><strong>Null 支持</strong></td>
<td>允许 1 个 <code>null</code> 键和多个 <code>null</code> 值</td>
<td>允许 1 个 <code>null</code> 元素</td>
</tr>
</tbody></table>
<p><strong>常用方法对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>HashSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>添加元素</strong></td>
<td><code>put(key, value)</code></td>
<td><code>add(element)</code></td>
</tr>
<tr>
<td><strong>查询元素</strong></td>
<td><code>get(key)</code>（返回值）</td>
<td><code>contains(element)</code>（返回布尔值）</td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td><code>remove(key)</code></td>
<td><code>remove(element)</code></td>
</tr>
</tbody></table>
<p><strong>底层机制</strong></p>
<p><code>HashSet</code> 内部直接使用 <code>HashMap</code> 实现，元素作为 <code>Key</code>，值固定为一个虚拟的 <code>PRESENT</code> 对象（占位符）。</p>
<p>两者均依赖哈希表，平均时间复杂度为 <code>O(1)</code>（冲突时可能退化为 <code>O(n)</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 的简化实现（本质是 HashMap 的包装）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map;  <span class="comment">// 键存储元素，值固定为 PRESENT</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;  <span class="comment">// 若 Key 已存在，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ul>
<li>**<code>HashMap</code>**：需通过键快速访问值的场景（如缓存、数据库索引）。 示例：<code>用户 ID → 用户详细信息</code>。</li>
<li>**<code>HashSet</code>**： 需存储唯一元素的集合（如去重、黑名单）。示例：<code>IP 黑名单</code>、<code>单词去重</code>。</li>
</ul>
<h3 id="【中等】HashMap、TreeMap、LinkedHashMap-有什么区别？"><a href="#【中等】HashMap、TreeMap、LinkedHashMap-有什么区别？" class="headerlink" title="【中等】HashMap、TreeMap、LinkedHashMap 有什么区别？"></a>【中等】HashMap、TreeMap、LinkedHashMap 有什么区别？</h3><p><strong>核心特性</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>TreeMap</strong></th>
<th><strong>LinkedHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层结构</strong></td>
<td>哈希表（数组+链表&#x2F;红黑树）</td>
<td>红黑树（平衡二叉搜索树）</td>
<td>哈希表 + 双向链表</td>
</tr>
<tr>
<td><strong>顺序性</strong></td>
<td>无序</td>
<td>按键的自然顺序或自定义顺序排序</td>
<td>保持插入顺序或访问顺序（LRU）</td>
</tr>
<tr>
<td><strong>null 支持</strong></td>
<td>允许 1 个 null 键和多个 null 值</td>
<td>不允许 null 键（除非自定义比较器）</td>
<td>同 HashMap</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全</td>
<td>非线程安全</td>
<td>非线程安全</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>平均 O(1)</td>
<td>增删查 O(log n)</td>
<td>平均 O(1)</td>
</tr>
</tbody></table>
<p><strong>排序与顺序</strong></p>
<ul>
<li><strong>HashMap</strong>：完全无序，迭代顺序不可预测。</li>
<li><strong>TreeMap</strong>：默认按键的自然顺序排序（Key 需实现<code>Comparable</code>）。可通过<code>Comparator</code>自定义排序规则。</li>
<li><strong>LinkedHashMap</strong>：默认保持<strong>插入顺序</strong>。可配置为<strong>访问顺序</strong>（最近最少使用 LRU）。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>HashMap</strong>：<ul>
<li>需要最高效的查找、插入和删除操作。</li>
<li>不关心元素的顺序。</li>
<li>示例：缓存、快速查找表。</li>
</ul>
</li>
<li><strong>TreeMap</strong>：<ul>
<li>需要元素按键排序。</li>
<li>需要范围查询（如<code>subMap()</code>、<code>headMap()</code>、<code>tailMap()</code>）。</li>
<li>示例：字典、有序事件调度。</li>
</ul>
</li>
<li><strong>LinkedHashMap</strong>：<ul>
<li>需要保持插入顺序或实现 LRU 缓存。</li>
<li>示例：记录访问顺序的缓存、需要按插入顺序迭代的场景。</li>
</ul>
</li>
</ul>
<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>TreeMap</strong></th>
<th><strong>LinkedHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>迭代顺序</strong></td>
<td>无序</td>
<td>有序（Key）</td>
<td>插入&#x2F;访问顺序</td>
</tr>
</tbody></table>
<p><strong>选择依据</strong></p>
<ul>
<li>要<strong>速度</strong>：选<code>HashMap</code>。</li>
<li>要<strong>排序</strong>：选<code>TreeMap</code>。</li>
<li>要<strong>顺序</strong>（插入或访问顺序）：选<code>LinkedHashMap</code>。</li>
</ul>
<p><strong>扩展</strong></p>
<ul>
<li><code>LinkedHashMap</code>可通过<code>accessOrder</code>参数实现 LRU 缓存。</li>
<li><code>TreeMap</code>支持丰富的导航方法（如<code>ceilingKey()</code>、<code>floorKey()</code>）。</li>
</ul>
<h3 id="【困难】HashMap-底层实现原理是什么？"><a href="#【困难】HashMap-底层实现原理是什么？" class="headerlink" title="【困难】HashMap 底层实现原理是什么？"></a>【困难】HashMap 底层实现原理是什么？</h3><p>HashMap 通过哈希函数定位桶，用链表和红黑树解决冲突，动态扩容平衡性能，但非线程安全。</p>
<p><strong>数据结构</strong></p>
<p>HashMap 的数据结构是：<strong>数组 + 链表（JDK 8 以前）</strong> ；<strong>数组 + 链表 + 红黑树（JDK 8+）</strong></p>
<ul>
<li><strong>数组（桶）</strong>：<code>Node&lt;K,V&gt;[] table</code>，初始长度默认为 <code>16</code>。</li>
<li><strong>链表</strong>：相同哈希值的元素组成链表，以解决哈希冲突（拉链地址法）。</li>
<li><strong>红黑树</strong>：当链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转为红黑树（提升查询效率至 <code>O(log n)</code>）。</li>
</ul>
<p><strong>哈希计算</strong></p>
<ul>
<li><p><strong>计算哈希值</strong>：高位与低位异或，使哈希分布更均匀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 8 的哈希扰动函数（减少碰撞）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算桶索引</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (table.length - <span class="number">1</span>) &amp; hash;  <span class="comment">// 等价于 hash % table.length</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>解决哈希冲突</strong></p>
<ul>
<li><strong>拉链地址法</strong>：冲突的键值对以链表形式存储在同一桶中。</li>
<li><strong>红黑树优化</strong>：长链表（≥8）转为红黑树，避免极端情况下性能退化至 <code>O(n)</code>。</li>
</ul>
<p><strong>扩容机制（Rehash）</strong></p>
<ul>
<li><strong>触发条件</strong>：当元素数量 &gt; <code>容量 × 负载因子</code>（默认负载因子 0.75，容量 16 时阈值为 12）。</li>
<li><strong>扩容操作</strong>：<ul>
<li>新建 2 倍大小的数组（<code>newCap = oldCap &lt;&lt; 1</code>）。</li>
<li>重新计算键的索引位置（<code>newIndex = (newCap - 1) &amp; hash</code>）。</li>
<li><strong>JDK 8 优化</strong>：无需重新计算哈希，<strong>通过高位掩码判断新索引位置</strong>（<code>原索引</code> 或 <code>原索引 + oldCap</code>）。</li>
</ul>
</li>
</ul>
<p><strong>关键参数</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>默认值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>初始容量</td>
<td>16</td>
<td>必须为 2 的幂（方便位运算计算索引）。</td>
</tr>
<tr>
<td>负载因子（Load Factor）</td>
<td>0.75</td>
<td>权衡空间与时间效率（过高增加冲突，过低浪费内存）。</td>
</tr>
<tr>
<td>树化阈值</td>
<td>8（链表 → 红黑树）</td>
<td>需同时满足数组长度 ≥ 64，否则优先扩容。</td>
</tr>
<tr>
<td>退化阈值</td>
<td>6（红黑树 → 链表）</td>
<td>扩容或删除节点时检查。</td>
</tr>
</tbody></table>
<p><strong>线程安全问题</strong></p>
<ul>
<li><strong>非线程安全</strong>：多线程下可能导致：<ul>
<li><strong>死循环</strong>（JDK 7 头插法扩容时产生环形链表）。</li>
<li><strong>数据丢失</strong>（并发插入覆盖节点）。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <code>ConcurrentHashMap</code>。</li>
<li>或通过 <code>Collections.synchronizedMap()</code> 包装。</li>
</ul>
</li>
</ul>
<p><strong>JDK 8 的优化</strong></p>
<ul>
<li><strong>链表 → 红黑树</strong>：解决哈希攻击导致的性能退化。</li>
<li><strong>尾插法</strong>：扩容时保持链表顺序，避免环形链表。</li>
<li><strong>高位掩码优化扩容</strong>：减少哈希重计算开销。</li>
</ul>
<p><strong>PUT 流程源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 数组为空时初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2. 计算索引，若桶为空直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 处理哈希冲突（链表/红黑树）</span></span><br><span class="line">        <span class="comment">// ...（省略冲突处理逻辑）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 检查扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【困难】HashMap-为什么线程不安全？"><a href="#【困难】HashMap-为什么线程不安全？" class="headerlink" title="【困难】HashMap 为什么线程不安全？"></a>【困难】HashMap 为什么线程不安全？</h3><p>HashMap 在多线程环境下会出现：</p>
<ul>
<li><strong>JDK 7</strong>：死循环 + 数据丢失（头插法导致）。</li>
<li>**JDK 8+**：数据丢失 + 脏读（无死循环，但依然非线程安全）。</li>
<li><strong>替代方案</strong>：高并发场景始终优先选择 <code>ConcurrentHashMap</code>。</li>
</ul>
<p><strong>一句话</strong>：HashMap 的线程不安全源于非原子操作和并发修改冲突，多线程环境下必须使用同步机制。</p>
<p><strong>（1）并发修改导致数据丢失</strong></p>
<p><strong>问题场景（JDK 8+）</strong></p>
<ul>
<li>两个线程同时执行 <code>put()</code>，计算出的 <strong>桶索引相同</strong>，且该位置为 <code>null</code>。</li>
<li><strong>预期</strong>：两个键值对都成功插入。</li>
<li><strong>实际</strong>：后一个线程的 <code>put</code> 可能覆盖前一个线程的写入，导致数据丢失。</li>
</ul>
<p>示例代码（伪并发）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 1 和线程 2 同时执行：</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) &#123;</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>); <span class="comment">// 可能被覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）JDK 7 扩容死循环问题</strong></p>
<p><strong>问题原因（仅 JDK 7）</strong></p>
<ul>
<li>扩容时采用 <strong>头插法</strong> 迁移链表，多线程并发可能导致 <strong>环形链表</strong>。</li>
<li>后续调用 <code>get()</code> 或 <code>put()</code> 时，遍历链表进入死循环（CPU 100%）。</li>
</ul>
<p>示意图：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span>：<span class="selector-tag">A</span> -&gt; <span class="selector-tag">B</span> → null</span><br><span class="line">线程 <span class="number">2</span>：<span class="selector-tag">B</span> -&gt; <span class="selector-tag">A</span> → null</span><br><span class="line">最终：<span class="selector-tag">A</span> ⇄ <span class="selector-tag">B</span>（环形链表）</span><br></pre></td></tr></table></figure>

<p><strong>（3）并发扩容导致数据错乱</strong></p>
<p>多个线程同时触发 <code>resize()</code>，可能导致：</p>
<ul>
<li><strong>部分节点丢失</strong>（未正确迁移到新数组）。</li>
<li><strong>链表断裂</strong>（节点 <code>next</code> 指针被错误修改）。</li>
</ul>
<p><strong>（4）非原子操作导致脏读</strong></p>
<p><code>size++</code>、<code>modCount++</code> 等操作非原子性，可能导致：</p>
<ul>
<li><code>size</code> 不准确（影响扩容判断）。</li>
<li>迭代时触发 <code>ConcurrentModificationException</code>（快速失败机制）。</li>
</ul>
<p><strong>解决方案</strong></p>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据丢失&#x2F;覆盖</td>
<td>使用 <code>ConcurrentHashMap</code>（CAS + 分段锁）</td>
</tr>
<tr>
<td>死循环（JDK 7）</td>
<td>升级到 JDK 8+（改用尾插法）</td>
</tr>
<tr>
<td>脏读</td>
<td>用 <code>Collections.synchronizedMap()</code> 包装</td>
</tr>
</tbody></table>
<h3 id="【中等】WeakHashMap-有什么用？"><a href="#【中等】WeakHashMap-有什么用？" class="headerlink" title="【中等】WeakHashMap 有什么用？"></a>【中等】WeakHashMap 有什么用？</h3><p><code>WeakHashMap</code> 通过弱引用键实现自动清理，适合管理临时性、生命周期与键对象绑定的数据，但需注意值对象的引用管理和线程安全问题。</p>
<p><strong>基于弱引用的键（Key）管理</strong></p>
<ul>
<li><strong>键是弱引用</strong>：当 <code>WeakHashMap</code> 的键（Key）不再被其他强引用指向时，该键值对会被垃圾回收器自动回收，避免内存泄漏。</li>
<li><strong>适用场景</strong>：适合存储与对象生命周期相关的临时数据（如缓存），当键对象外部不再使用时，自动清理对应条目。</li>
</ul>
<p><strong>自动清理无引用键值对</strong></p>
<ul>
<li><strong>依赖垃圾回收机制</strong>：当键对象仅被 <code>WeakHashMap</code> 弱引用时，GC 会回收该键，并移除对应的键值对（通过内部 <code>ReferenceQueue</code> 机制触发清理）。</li>
<li><strong>无需手动移除</strong>：与普通 <code>HashMap</code> 不同，无需显式调用 <code>remove()</code> 方法避免内存泄漏。</li>
</ul>
<p><strong>典型应用场景</strong></p>
<ul>
<li><strong>缓存系统</strong>：缓存数据时，若缓存键（如临时对象）不再使用，自动释放对应值（如大对象），防止内存堆积。</li>
<li><strong>监听器&#x2F;元数据存储</strong>：存储对象的附加信息，当对象销毁时，关联数据自动清除。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>值（Value）不是弱引用</strong>：仅键是弱引用，值仍可能因强引用导致内存泄漏（需确保值未在其他地方被强引用）。</li>
<li><strong>非线程安全</strong>：需外部同步（如使用 <code>Collections.synchronizedMap</code>）。</li>
<li><strong>不可预测的清理时机</strong>：依赖 GC 运行，条目移除时机不确定。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WeakHashMap&lt;Object, String&gt; weakMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">weakMap.put(key, <span class="string">&quot;Value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 key 的强引用置为 null，且发生 GC 后，weakMap 中的条目会被自动移除</span></span><br><span class="line">key = <span class="literal">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 仅示例，实际中不推荐显式调用 GC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 weakMap 可能已为空（条目被回收）</span></span><br></pre></td></tr></table></figure>

<h3 id="【中等】ConcurrentHashMap-和-Hashtable-有什么区别？"><a href="#【中等】ConcurrentHashMap-和-Hashtable-有什么区别？" class="headerlink" title="【中等】ConcurrentHashMap 和 Hashtable 有什么区别？"></a>【中等】ConcurrentHashMap 和 Hashtable 有什么区别？</h3><ul>
<li>**优先使用 <code>ConcurrentHashMap</code>**：适用于现代高并发程序，性能更优。</li>
<li>**避免 <code>Hashtable</code>**：除非维护历史代码，否则建议替换为 <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code>（非高并发场景）。</li>
</ul>
<p>以下是 <strong>ConcurrentHashMap 和 Hashtable 的区别对比表格</strong>，清晰展示核心差异：</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Hashtable</strong></th>
<th><strong>ConcurrentHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全实现</strong></td>
<td>全表锁（<code>synchronized</code> 方法）</td>
<td><strong>分段锁（JDK7）</strong> 或 <strong>CAS + <code>synchronized</code>（JDK8+）</strong></td>
</tr>
<tr>
<td><strong>并发性能</strong></td>
<td>低（串行化操作，高并发时阻塞严重）</td>
<td>高（读写并发优化，锁粒度更细）</td>
</tr>
<tr>
<td><strong>Null 支持</strong></td>
<td><strong>不允许</strong> <code>null</code> 键或值（抛出异常）</td>
<td><strong>不允许</strong> <code>null</code> 键或值（避免并发歧义）</td>
</tr>
<tr>
<td><strong>迭代器行为</strong></td>
<td>强一致性（修改会抛 <code>ConcurrentModificationException</code>）</td>
<td>弱一致性（可能部分反映修改，不抛异常）</td>
</tr>
<tr>
<td><strong>版本与演进</strong></td>
<td>JDK1.0 遗留类，已过时</td>
<td>JDK1.5 引入，持续优化（如 JDK8 改用 CAS）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>旧代码兼容（不推荐新项目使用）</td>
<td><strong>高并发首选</strong>（缓存、计数器等场景）</td>
</tr>
</tbody></table>
<h3 id="【困难】ConcurrentHashMap-的底层实现原理是什么？"><a href="#【困难】ConcurrentHashMap-的底层实现原理是什么？" class="headerlink" title="【困难】ConcurrentHashMap 的底层实现原理是什么？"></a>【困难】ConcurrentHashMap 的底层实现原理是什么？</h3><p><code>ConcurrentHashMap</code> 是 Java 并发编程中最常用的线程安全 <code>Map</code>，其底层实现经历了 <strong>JDK7（分段锁）</strong> 和 <strong>JDK8+（CAS + <code>synchronized</code> 优化）</strong> 两个重要阶段。以下是核心实现原理：</p>
<p>::: info JDK7 中，ConcurrentHashMap 的实现原理是什么？<br>:::</p>
<p>JDK7 中，<code>ConcurrentHashMap</code> 的核心实现思想是：将整个哈希表分成多个 <code>Segment</code>（默认 16 个），每个 <code>Segment</code> 是一个独立的 <code>HashEntry</code> 数组，<strong>锁粒度细化到<code>Segment</code> 级别</strong>，不同 <code>Segment</code> 可并发操作。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">  ├── Segment[]（默认 <span class="number">16</span> 个，每个 Segment 继承 ReentrantLock）</span><br><span class="line">  │    └── HashEntry[]（链表结构，存储键值对）</span><br><span class="line">  └── 全局的并发控制参数（如 loadFactor）</span><br></pre></td></tr></table></figure>

<p><strong>关键特点</strong></p>
<ul>
<li><strong>锁分段（Segment Locking）</strong><ul>
<li>写操作仅锁对应的 <code>Segment</code>，其他 <code>Segment</code> 仍可并发访问。</li>
<li>读操作无锁（<code>HashEntry</code> 的 <code>value</code> 用 <code>volatile</code> 修饰，保证可见性）。</li>
</ul>
</li>
<li><strong>并发度（Concurrency Level）</strong><ul>
<li>默认 16 个 <code>Segment</code>，即最多支持 16 个线程并发写。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>内存占用较高（每个 <code>Segment</code> 独立维护数组）。</li>
<li>查询时需要两次哈希计算（先定位 <code>Segment</code>，再定位 <code>HashEntry</code>）。</li>
</ul>
<p>::: info JDK8 中，ConcurrentHashMap 的实现原理是什么？<br>:::</p>
<p>JDK8 中，<code>ConcurrentHashMap</code> 的核心实现思想是：抛弃 <code>Segment</code>，改用 <strong><code>Node</code> 数组 + 链表&#x2F;红黑树</strong>，锁粒度细化到 <strong>单个桶（链表头节点）</strong>，并引入 <strong>CAS（无锁化）</strong> 和 <code>synchronized</code> 结合的方式提升并发性能。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap</span><br><span class="line">  ├── Node[] table（数组 + 链表/红黑树）</span><br><span class="line">  │    ├── Node（普通链表节点）</span><br><span class="line">  │    └── TreeBin（红黑树封装，维护平衡）</span><br><span class="line">  └── <span class="keyword">volatile</span> 变量（如 sizeCtl，控制扩容）</span><br></pre></td></tr></table></figure>

<p><strong>关键优化</strong></p>
<ul>
<li><p><strong>锁粒度更细（桶级别锁）</strong></p>
<ul>
<li>写操作仅锁当前桶（链表头节点），其他桶仍可并发访问。</li>
<li>读操作完全无锁（<code>Node</code> 的 <code>value</code> 和 <code>next</code> 用 <code>volatile</code> 修饰）。</li>
</ul>
</li>
<li><p><strong>CAS + <code>synchronized</code> 结合</strong></p>
<ul>
<li><strong>插入数据</strong>：先尝试 CAS 无锁插入，失败后 <code>synchronized</code> 锁住头节点。</li>
<li><strong>扩容</strong>：支持多线程协同扩容（通过 <code>sizeCtl</code> 标志位控制）。</li>
</ul>
</li>
<li><p><strong>链表转红黑树（优化查询）</strong></p>
<ul>
<li>当链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转为红黑树（<code>TreeBin</code>），防止哈希冲突导致性能退化。</li>
</ul>
</li>
<li><p><strong>更高效的计算方式</strong></p>
<ul>
<li>使用 <code>spread()</code> 方法优化哈希计算，减少冲突。</li>
<li><code>size()</code> 方法通过 <code>CounterCell</code> 分段统计，避免全局锁。</li>
</ul>
</li>
</ul>
<p>::: info JDK8 中，ConcurrentHashMap 关键操作流程是怎样的？<br>:::</p>
<p><strong>（1）PUT 操作（JDK8）</strong></p>
<ol>
<li>计算 <code>key</code> 的哈希，定位到桶（数组下标）。</li>
<li>如果桶为空，<strong>CAS 插入新节点</strong>（无锁化）。</li>
<li>如果桶不为空，<code>synchronized</code> 锁住头节点，处理链表或红黑树插入。</li>
<li>如果链表长度 ≥ 8，尝试转红黑树。</li>
</ol>
<p><strong>（2）GET 操作（完全无锁）</strong></p>
<ol>
<li>计算 <code>key</code> 的哈希，定位到桶。</li>
<li>遍历链表或红黑树（依赖 <code>volatile</code> 保证可见性）。</li>
</ol>
<p><strong>（3）扩容（多线程协同）</strong></p>
<ol>
<li>当元素数量超过阈值（<code>sizeCtl</code>），触发扩容。</li>
<li>其他线程检测到扩容时，可协助迁移数据（<code>transfer</code> 方法）。</li>
</ol>
<p>::: info ConcurrentHashMap 在 JDK7 和 JDK8 中的实现有哪些差异？<br>:::</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>JDK7（分段锁）</strong></th>
<th><strong>JDK8+（CAS + <code>synchronized</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁粒度</strong></td>
<td>Segment 级别（粗粒度）</td>
<td>桶级别（更细粒度）</td>
</tr>
<tr>
<td><strong>并发度</strong></td>
<td>固定 16 个 Segment</td>
<td>动态调整，更高并发</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较高（每个 Segment 维护数组）</td>
<td>更低（单层 Node 数组）</td>
</tr>
<tr>
<td><strong>哈希冲突处理</strong></td>
<td>链表</td>
<td>链表 + 红黑树（优化查询）</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>单 Segment 扩容</td>
<td>多线程协同扩容</td>
</tr>
</tbody></table>
<p><strong>小结</strong></p>
<p><strong>JDK7</strong>：分段锁降低冲突，但并发度固定，内存开销大。</p>
<p>**JDK8+**：</p>
<ul>
<li>更细粒度的锁（桶级别），CAS 无锁化优化。</li>
<li>红黑树优化极端哈希冲突场景。</li>
<li>多线程协同扩容，提升性能。</li>
</ul>
<p><strong>适用场景</strong>：高并发读写（如缓存、计数器），是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap()</code> 的现代替代方案。</p>
<h3 id="【中等】ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#【中等】ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="【中等】ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>【中等】ConcurrentHashMap 为什么 key 和 value 不能为 null？</h3><p><code>ConcurrentHashMap</code> 在设计上明确禁止 <code>null</code> 作为 <strong>key</strong> 或 <strong>value</strong>，而普通的 <code>HashMap</code> 是允许的。</p>
<p><strong><code>ConcurrentHashMap</code> 禁止 <code>null</code> 是为了避免并发场景下的二义性问题</strong>。</p>
<ul>
<li><strong>替代方案</strong>：使用特殊标记（如 <code>Optional</code>）或额外方法（如 <code>containsKey()</code>）明确语义。</li>
<li><strong>设计一致性</strong>：延续 <code>Hashtable</code> 的严格约束，确保线程安全行为的清晰性。</li>
</ul>
<p>如果业务必须使用 <code>null</code>，可以考虑：</p>
<ul>
<li>使用 <code>HashMap</code> + 外部同步（如 <code>synchronized</code>）。</li>
<li>用 <code>Optional</code> 或自定义空对象代替 <code>null</code>。</li>
</ul>
<p><code>ConcurrentHashMap</code> 禁止 <code>null</code> 的详细原因如下：</p>
<p><strong>（1）并发场景下的歧义问题（核心原因）</strong></p>
<p><code>ConcurrentHashMap</code> 是线程安全的，但在高并发环境下，<code>null</code> 值会导致 <strong>二义性（Ambiguity）</strong>，无法区分：</p>
<ul>
<li><strong>Key 不存在</strong>（返回 <code>null</code>）。</li>
<li>**Key 存在，但 Value 本身就是 <code>null</code>**。</li>
</ul>
<p>示例场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.get(<span class="string">&quot;non_existent_key&quot;</span>);  <span class="comment">// 返回 null（表示 key 不存在）</span></span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="literal">null</span>);        <span class="comment">// 如果允许，这里存储 null 值</span></span><br><span class="line">map.get(<span class="string">&quot;key&quot;</span>);              <span class="comment">// 仍然返回 null，无法区分是 &quot;key 不存在&quot; 还是 &quot;value 是 null&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：在并发环境下，这种歧义会导致业务逻辑错误（比如缓存系统无法判断数据是否有效）。</p>
<p><strong>（2）<code>HashMap</code> 为什么允许 <code>null</code>？</strong></p>
<p><code>HashMap</code> 是单线程使用的，开发者可以自行约束 <code>null</code> 的使用逻辑，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.get(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 明确知道是 key 不存在，或者 value 是 null（需业务逻辑保证）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在并发环境下，这种约束不可靠，因为其他线程可能同时修改数据。</p>
<p><strong>（3）<code>ConcurrentHashMap</code> 的设计哲学</strong></p>
<p>为了保证 <strong>线程安全</strong> 和 <strong>明确语义</strong>，<code>ConcurrentHashMap</code> 直接禁止 <code>null</code>，强制开发者：</p>
<ul>
<li>**用特殊占位符（如 <code>Optional.empty()</code>）代替 <code>null</code>**。</li>
<li><strong>显式处理 <code>key</code> 不存在的情况</strong>（如 <code>containsKey()</code> 检查）。</li>
</ul>
<p>替代方案示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Optional&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, Optional.empty());  <span class="comment">// 用 Optional 表示空值</span></span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// key 不存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; value = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// value 是 &quot;逻辑上的 null&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）历史原因（兼容性）</strong></p>
<ul>
<li><code>Hashtable</code>（早期线程安全 <code>Map</code>）也不允许 <code>null</code>，<code>ConcurrentHashMap</code> 延续了这一设计。</li>
<li>如果允许 <code>null</code>，会导致从 <code>Hashtable</code> 迁移到 <code>ConcurrentHashMap</code> 时出现兼容性问题。</li>
</ul>
<p>（5）对比其他 Map</p>
<table>
<thead>
<tr>
<th><strong>Map 类型</strong></th>
<th><strong>允许 <code>null</code> Key</strong></th>
<th><strong>允许 <code>null</code> Value</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>单线程使用，无并发歧义</td>
</tr>
<tr>
<td><code>Hashtable</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>线程安全，避免歧义</td>
</tr>
<tr>
<td><code>ConcurrentHashMap</code></td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>并发安全，避免歧义</td>
</tr>
<tr>
<td><code>Collections.synchronizedMap</code></td>
<td>取决于底层 Map</td>
<td>取决于底层 Map</td>
<td>包装类，行为与被包装 Map 一致</td>
</tr>
</tbody></table>
<h3 id="【中等】ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#【中等】ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="【中等】ConcurrentHashMap 能保证复合操作的原子性吗？"></a>【中等】ConcurrentHashMap 能保证复合操作的原子性吗？</h3><p><strong>ConcurrentHashMap 不能保证复合操作的原子性</strong>，尽管它本身提供了高并发性能和线程安全的单个操作。</p>
<p><strong>说明如下</strong>：</p>
<p><strong>单个操作的原子性</strong>：</p>
<ul>
<li><code>put()</code>, <code>get()</code>, <code>remove()</code> 等单个操作是线程安全的</li>
<li>这些操作在内部使用分段锁或 CAS 操作保证原子性</li>
</ul>
<p><strong>复合操作的非原子性</strong>：</p>
<p>像【检查然后执行（check-then-act）】这样的复合操作不是原子的。例如：<code>if (!map.containsKey(key)) &#123; map.put(key, value); &#125;</code>，在检查和方法调用之间，其他线程可能已经修改了 <code>map</code>。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用 <code>putIfAbsent()</code>, <code>computeIfAbsent()</code>, <code>computeIfPresent()</code> 等原子性复合方法</li>
<li>使用显式同步（但会降低并发性能）</li>
<li>使用 <code>compute()</code> 方法原子性地更新值</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原子性复合操作 - 不安全</span></span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);  <span class="comment">// 可能有竞态条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子性替代方案</span></span><br><span class="line">map.putIfAbsent(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 computeIfAbsent</span></span><br><span class="line">map.computeIfAbsent(<span class="string">&quot;key&quot;</span>, k -&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>总结：ConcurrentHashMap 只保证单个方法的原子性，复合操作需要特别处理才能保证线程安全。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/670b8cb5/" title="Java 容器面试二">https://dunwu.github.io/blog/pages/670b8cb5/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
              <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/blog/tags/JavaCore/" rel="tag"># JavaCore</a>
              <a href="/blog/tags/%E5%AE%B9%E5%99%A8/" rel="tag"># 容器</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/b2f6beb8/" rel="prev" title="Java 虚拟机面试一">
                  <i class="fa fa-angle-left"></i> Java 虚拟机面试一
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/a626f515/" rel="next" title="Java 容器面试三">
                  Java 容器面试三 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d249664c7b95cb135d96a10985e294d4"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
