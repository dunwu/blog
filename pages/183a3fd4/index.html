<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"atom-one-light","dark":"atom-one-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>

    <meta name="description" content="《MySQL 实战 45 讲》笔记三极客时间教程 - MySQL 实战 45 讲 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《MySQL 实战 45 讲》笔记三">
<meta property="og:url" content="https://dunwu.github.io/blog/pages/183a3fd4/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="《MySQL 实战 45 讲》笔记三极客时间教程 - MySQL 实战 45 讲 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-20T11:20:08.000Z">
<meta property="article:modified_time" content="2025-09-13T09:56:53.694Z">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/pages/183a3fd4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://dunwu.github.io/blog/pages/183a3fd4/","path":"/pages/183a3fd4/","title":"《MySQL 实战 45 讲》笔记三"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《MySQL 实战 45 讲》笔记三 | Dunwu Blog</title>
  








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>





  <script src="/blog/js/third-party/pace.js" defer></script>


  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Dunwu Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">428</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">124</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">508</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8AMySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2%E3%80%8B%E7%AC%94%E8%AE%B0%E4%B8%89"><span class="nav-number">1.</span> <span class="nav-text">《MySQL 实战 45 讲》笔记三</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E9%99%A4%E4%BA%86%E8%B7%91%E8%B7%AF%EF%BC%8C%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">31 误删数据后除了跑路，还能怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%9C%89-kill-%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.</span> <span class="nav-text">32 为什么还有 kill 不掉的语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">33 我查这么多数据，会不会把数据库内存打爆？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-join"><span class="nav-number">1.4.</span> <span class="nav-text">34 到底可不可以使用 join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-join-%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">35 join 语句怎么优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">36 为什么临时表可以重名？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">37 什么时候会使用内部临时表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E9%83%BD%E8%AF%B4-InnoDB-%E5%A5%BD%EF%BC%8C%E9%82%A3%E8%BF%98%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-Memory-%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">38 都说 InnoDB 好，那还要不要使用 Memory 引擎？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.</span> <span class="nav-text">39 自增主键为什么不是连续的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">40 insert 语句的锁为什么这么多？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.11.</span> <span class="nav-text">41 怎么最快地复制一张表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-grant-%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80-flush-privileges-%E5%90%97%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">42 grant 之后要跟着 flush privileges 吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.13.</span> <span class="nav-text">43 要不要使用分区表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-%E7%AD%94%E7%96%91%E6%96%87%E7%AB%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.14.</span> <span class="nav-text">44 答疑文章（三）：说一说这些好问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E8%87%AA%E5%A2%9E-id-%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">1.15.</span> <span class="nav-text">45 自增 id 用完怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.16.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">508</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">124</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">428</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/183a3fd4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《MySQL 实战 45 讲》笔记三 | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《MySQL 实战 45 讲》笔记三<a href="https://github.com/dunwu/blog/blob/master/source/_posts/00.%E7%AC%94%E8%AE%B0/12.%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%95%99%E7%A8%8B-MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%AC%94%E8%AE%B0%E4%B8%89.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-20 19:20:08" itemprop="dateCreated datePublished" datetime="2022-07-20T19:20:08+08:00">2022-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-13 17:56:53" itemprop="dateModified" datetime="2025-09-13T17:56:53+08:00">2025-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="《MySQL-实战-45-讲》笔记三"><a href="#《MySQL-实战-45-讲》笔记三" class="headerlink" title="《MySQL 实战 45 讲》笔记三"></a>《MySQL 实战 45 讲》笔记三</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a> 学习笔记</p>
<span id="more"></span>

<h2 id="31-误删数据后除了跑路，还能怎么办？"><a href="#31-误删数据后除了跑路，还能怎么办？" class="headerlink" title="31 误删数据后除了跑路，还能怎么办？"></a>31 误删数据后除了跑路，还能怎么办？</h2><p><strong>误删数据的分类</strong>：</p>
<ul>
<li><strong>误删行</strong>：使用 <code>delete</code> 语句误删数据行。</li>
<li><strong>误删表</strong>：使用 <code>drop table</code> 或 <code>truncate table</code> 语句误删数据表。</li>
<li><strong>误删库</strong>：使用 <code>drop database</code> 语句误删数据库。</li>
<li><strong>误删实例</strong>：使用 <code>rm</code> 命令误删整个 MySQL 实例。</li>
</ul>
<p><strong>误删行的恢复</strong>：</p>
<ul>
<li>使用 Flashback 工具通过解析 binlog 恢复数据，前提是 <code>binlog_format=row</code> 和 <code>binlog_row_image=FULL</code>。</li>
<li>恢复数据时，建议在临时库或从库上操作，避免对主库造成二次破坏。</li>
<li><strong>预防措施</strong>：<ul>
<li>设置 <code>sql_safe_updates=on</code>，防止无条件的 <code>delete</code> 或 <code>update</code> 操作。</li>
<li>代码上线前进行 SQL 审计。</li>
</ul>
</li>
</ul>
<p><strong>误删库&#x2F;表的恢复</strong>：</p>
<ul>
<li>使用全量备份加增量日志的方式恢复数据。</li>
<li>恢复流程：<ol>
<li>取最近一次全量备份。</li>
<li>用备份恢复出一个临时库。</li>
<li>从日志备份中取出误删操作之后的日志，应用到临时库。</li>
</ol>
</li>
<li>使用 GTID 模式可以更方便地跳过误删操作的 binlog。</li>
<li><strong>加速恢复的方法</strong>：将临时库设置为线上备库的从库，利用并行复制技术加速恢复。</li>
</ul>
<p><strong>延迟复制备库</strong>：</p>
<ul>
<li>通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code> 命令，设置备库延迟 N 秒复制主库的数据。</li>
<li>延迟复制可以在误删操作后，提供一个时间窗口来恢复数据，缩短恢复时间。</li>
</ul>
<p><strong>预防误删库&#x2F;表的方法</strong>：</p>
<ul>
<li><strong>账号分离</strong>：限制业务开发人员的权限，避免误操作。</li>
<li><strong>操作规范</strong>：删除表前先改名，观察一段时间后再删除。</li>
</ul>
<p><strong>误删实例的恢复</strong>：</p>
<ul>
<li>对于高可用集群，误删单个节点的数据可以通过 HA 系统自动恢复。</li>
<li>建议跨机房或跨城市备份数据，防止大规模数据丢失。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>误删数据的恢复依赖于备份和 binlog，定期检查备份的有效性非常重要。</li>
<li>预防误删数据比事后处理更为重要，建议通过账号分离、操作规范等方式减少误操作的风险。</li>
<li>数据和服务的可靠性需要各个环节共同保障，不仅仅是运维团队的责任。</li>
</ul>
<h2 id="32-为什么还有-kill-不掉的语句"><a href="#32-为什么还有-kill-不掉的语句" class="headerlink" title="32 为什么还有 kill 不掉的语句"></a>32 为什么还有 kill 不掉的语句</h2><p><strong>kill 命令的类型</strong>：</p>
<ul>
<li><code>kill query + 线程 id</code>：终止线程中正在执行的语句。</li>
<li><code>kill connection + 线程 id</code>：断开线程的连接，并终止正在执行的语句。</li>
</ul>
<p><strong>kill 命令的执行机制</strong>：</p>
<ul>
<li><code>kill</code> 命令并不是立即终止线程，而是设置线程的状态为 <code>KILL_QUERY</code> 或 <code>KILL_CONNECTION</code>，并发送信号唤醒线程。</li>
<li>线程在执行过程中会检查自身状态，如果发现被标记为 <code>KILL_QUERY</code> 或 <code>KILL_CONNECTION</code>，才会进入终止逻辑。</li>
</ul>
<p><strong>kill 不掉的两种情况</strong>：</p>
<ul>
<li><strong>线程没有执行到判断状态的逻辑</strong>：例如，线程在等待进入 InnoDB 执行时，没有检查自身状态，导致 <code>kill</code> 命令无效。</li>
<li><strong>终止逻辑耗时较长</strong>：例如，大事务回滚、大查询删除临时文件、DDL 命令删除临时文件等操作耗时较长，导致线程无法立即终止。</li>
</ul>
<p><strong>客户端误解</strong>：</p>
<ul>
<li><strong>表多导致连接慢</strong>：实际上是因为客户端在连接后执行了表名补全功能，导致连接过程变慢。可以通过 <code>-A</code> 参数关闭自动补全功能。</li>
<li><strong>–quick 参数</strong>：该参数并不是让服务端加速，而是让客户端跳过缓存，直接处理结果。虽然客户端响应更快，但可能会降低服务端性能。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><code>kill</code> 命令并不能立即终止线程，而是通过设置状态和发送信号来触发线程的终止逻辑。</li>
<li>如果线程处于 <code>Killed</code> 状态，可以通过调整系统环境（如增加并发度、减少系统压力）来加速终止逻辑的执行。</li>
<li>对于长时间无法终止的线程，建议等待其完成终止逻辑，而不是强行重启 MySQL 进程。</li>
</ul>
<h2 id="33-我查这么多数据，会不会把数据库内存打爆？"><a href="#33-我查这么多数据，会不会把数据库内存打爆？" class="headerlink" title="33 我查这么多数据，会不会把数据库内存打爆？"></a>33 我查这么多数据，会不会把数据库内存打爆？</h2><p><strong>全表扫描对 Server 层的影响</strong>：</p>
<ul>
<li>MySQL 采用“边读边发”的方式处理查询结果，不会在服务端保存完整的结果集。</li>
<li>查询结果会先写入 <code>net_buffer</code>（默认 16K），当 <code>net_buffer</code> 写满后，通过网络接口发送给客户端。</li>
<li>如果客户端接收数据慢，服务端的网络栈可能会被写满，导致查询状态显示为“Sending to client”。</li>
<li>对于返回结果较少的查询，建议使用 <code>mysql_store_result</code> 接口，直接将结果保存到客户端内存；对于大查询，可以使用 <code>mysql_use_result</code> 接口，逐行处理结果。</li>
</ul>
<p><strong>“Sending data”状态的含义</strong>：</p>
<ul>
<li>“Sending data”状态并不一定表示正在发送数据，而是表示查询正在执行过程中，可能包括锁等待等操作。</li>
</ul>
<p><strong>全表扫描对 InnoDB 的影响</strong>：</p>
<ul>
<li>InnoDB 使用 Buffer Pool 来加速查询，Buffer Pool 的大小由 <code>innodb_buffer_pool_size</code> 参数控制，通常设置为物理内存的 60%~80%。</li>
<li>Buffer Pool 使用改进的 LRU 算法来管理内存，将链表分为 young 区域和 old 区域，避免全表扫描导致的热数据被淘汰。</li>
<li>全表扫描的数据页会被放入 old 区域，只有在 old 区域停留超过 1 秒的数据页才会被移到 young 区域，从而避免冷数据影响热数据的命中率。</li>
</ul>
<p><strong>Buffer Pool 的内存命中率</strong>：</p>
<ul>
<li>通过 <code>show engine innodb status</code> 可以查看 Buffer Pool 的命中率，稳定运行的线上系统应保证命中率在 99% 以上。</li>
<li>如果 Buffer Pool 满了，InnoDB 会淘汰最久未使用的数据页（LRU 算法）。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>大查询不会耗尽 MySQL 服务端的内存，因为查询结果是边读边发的，不会在服务端保存完整的结果集。</li>
<li>InnoDB 的 Buffer Pool 通过改进的 LRU 算法，能够有效控制全表扫描对内存的影响，避免热数据被冷数据淘汰。</li>
<li>尽管全表扫描不会打爆内存，但仍会消耗大量 IO 资源，因此在业务高峰期应避免在线上主库执行全表扫描。</li>
</ul>
<h2 id="34-到底可不可以使用-join"><a href="#34-到底可不可以使用-join" class="headerlink" title="34 到底可不可以使用 join"></a>34 到底可不可以使用 join</h2><p><strong><code>JOIN</code>语句的执行方式</strong>：</p>
<ul>
<li>MySQL 支持两种主要的<code>JOIN</code>算法：<strong>Index Nested-Loop Join (NLJ)</strong> 和 **Block Nested-Loop Join (BNL)**。</li>
<li>选择哪种算法取决于被驱动表是否有可用的索引。</li>
</ul>
<p>**Index Nested-Loop Join (NLJ)**：</p>
<ul>
<li>当被驱动表（<code>t2</code>）的<code>JOIN</code>字段上有索引时，MySQL 会使用 NLJ 算法。</li>
<li>执行流程：<ol>
<li>从驱动表（<code>t1</code>）中读取一行数据。</li>
<li>使用该行数据的<code>JOIN</code>字段值去被驱动表（<code>t2</code>）中查找匹配的行。</li>
<li>将匹配的行与驱动表的行组合成结果集的一部分。</li>
<li>重复上述过程，直到驱动表的所有行都被处理。</li>
</ol>
</li>
<li><strong>优点</strong>：由于使用了索引，查询效率较高，扫描行数为<code>N + N*2*log2M</code>（<code>N</code>为驱动表的行数，<code>M</code>为被驱动表的行数）。</li>
<li><strong>驱动表选择</strong>：应该让小表做驱动表，因为扫描行数主要由驱动表的行数决定。</li>
</ul>
<p>**Block Nested-Loop Join (BNL)**：</p>
<ul>
<li>当被驱动表（<code>t2</code>）的<code>JOIN</code>字段上没有索引时，MySQL 会使用 BNL 算法。</li>
<li>执行流程：<ol>
<li>将驱动表（<code>t1</code>）的数据读入内存中的<code>join_buffer</code>。</li>
<li>扫描被驱动表（<code>t2</code>），将每一行与<code>join_buffer</code>中的数据进行匹配，满足条件的行作为结果集返回。</li>
</ol>
</li>
<li><strong>优点</strong>：虽然扫描行数较多（<code>M + N</code>），但由于是内存操作，性能比 Simple Nested-Loop Join（SNL）要好。</li>
<li><strong>驱动表选择</strong>：在<code>join_buffer</code>足够大时，选择哪个表做驱动表对性能影响不大；但在<code>join_buffer</code>不够大时，应该让小表做驱动表，以减少扫描次数。</li>
</ul>
<p><strong><code>join_buffer</code>的影响</strong>：</p>
<ul>
<li><code>join_buffer</code>的大小由参数<code>join_buffer_size</code>控制，默认值为 256KB。</li>
<li>如果驱动表的数据量超过<code>join_buffer</code>的大小，MySQL 会分段处理，导致被驱动表被多次扫描。</li>
<li>增加<code>join_buffer_size</code>可以减少分段次数，提升<code>JOIN</code>性能。</li>
</ul>
<p><strong><code>JOIN</code>的使用建议</strong>：</p>
<ul>
<li><strong>可以使用<code>JOIN</code>的情况</strong>：如果被驱动表有索引，使用<code>JOIN</code>是高效的。</li>
<li><strong>尽量避免使用<code>JOIN</code>的情况</strong>：如果被驱动表没有索引，且表数据量较大，使用<code>JOIN</code>可能会导致大量的全表扫描，性能较差。</li>
<li><strong>驱动表的选择</strong>：无论使用哪种算法，通常应该让小表做驱动表。在决定哪个表是“小表”时，应该考虑参与<code>JOIN</code>的字段的数据量，而不是单纯的行数。数据量较小的表应作为驱动表。</li>
</ul>
<h2 id="35-join-语句怎么优化？"><a href="#35-join-语句怎么优化？" class="headerlink" title="35 join 语句怎么优化？"></a>35 join 语句怎么优化？</h2><p><strong>Multi-Range Read (MRR) 优化</strong>：</p>
<ul>
<li>MRR 优化的目的是通过<strong>顺序读盘</strong>来提升查询性能。</li>
<li>当使用索引进行范围查询时，MRR 会将主键 id 放入<code>read_rnd_buffer</code>中排序，然后按顺序回表查询，减少随机磁盘访问。</li>
<li>启用 MRR 需要设置<code>optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。</li>
</ul>
<p><strong>Batched Key Access (BKA) 优化</strong>：</p>
<ul>
<li>BKA 是对 NLJ 算法的优化，通过将驱动表的多行数据一次性放入<code>join_buffer</code>，然后批量传递给被驱动表进行<code>JOIN</code>操作。</li>
<li>BKA 依赖于 MRR 优化，启用 BKA 需要设置<code>optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;</code>。</li>
</ul>
<p><strong>BNL 算法的性能问题</strong>：</p>
<ul>
<li>BNL 算法在大表<code>JOIN</code>时会导致多次扫描被驱动表，占用大量 CPU 和 IO 资源。</li>
<li>多次扫描冷表可能会导致 Buffer Pool 中的热数据被淘汰，影响内存命中率。</li>
<li>优化 BNL 的方法包括增大<code>join_buffer_size</code>或给被驱动表的<code>JOIN</code>字段加索引，将 BNL 转为 BKA 算法。</li>
</ul>
<p><strong>BNL 转 BKA 的优化方法</strong>：</p>
<ul>
<li>如果无法直接在被驱动表上建索引，可以使用临时表的方式：<ol>
<li>将满足条件的被驱动表数据插入临时表。</li>
<li>在临时表的<code>JOIN</code>字段上创建索引。</li>
<li>使用临时表与驱动表进行<code>JOIN</code>操作。</li>
</ol>
</li>
<li>这种方法可以显著减少条件判断的次数，提升查询性能。</li>
</ul>
<p><strong>Hash Join 的模拟</strong>：</p>
<ul>
<li>MySQL 目前不支持 Hash Join，但可以通过应用端模拟实现：<ol>
<li>将驱动表的数据加载到内存中的哈希结构。</li>
<li>将被驱动表的数据逐行与哈希结构中的数据进行匹配。</li>
</ol>
</li>
<li>这种方法理论上比临时表方案更快。</li>
</ul>
<p><strong>总结与建议</strong>：</p>
<ul>
<li><strong>BKA 优化</strong>：建议默认启用 BKA 优化，提升<code>JOIN</code>性能。</li>
<li><strong>BNL 优化</strong>：尽量通过加索引将 BNL 转为 BKA 算法，避免使用 BNL。</li>
<li><strong>临时表方案</strong>：对于能够提前过滤出小数据的<code>JOIN</code>语句，使用临时表方案效果显著。</li>
<li><strong>Hash Join</strong>：虽然 MySQL 不支持，但可以通过应用端模拟实现，效果优于临时表方案。</li>
</ul>
<h2 id="36-为什么临时表可以重名？"><a href="#36-为什么临时表可以重名？" class="headerlink" title="36 为什么临时表可以重名？"></a>36 为什么临时表可以重名？</h2><p><strong>临时表与内存表的区别</strong></p>
<ul>
<li><strong>内存表</strong>：使用 Memory 引擎，数据存储在内存中，重启后数据丢失，但表结构保留。</li>
<li><strong>临时表</strong>：可以使用多种引擎（如 InnoDB、MyISAM 等），数据可以存储在磁盘上，也可以使用 Memory 引擎。</li>
</ul>
<p><strong>临时表的特性</strong></p>
<ul>
<li>创建语法为<code>create temporary table …</code>。</li>
<li>临时表只能被创建它的 session 访问，对其他线程不可见。</li>
<li>临时表可以与普通表同名，且在 session 内有同名临时表和普通表时，操作的是临时表。</li>
<li><code>show tables</code>命令不显示临时表。</li>
<li>临时表在 session 结束时自动删除。</li>
</ul>
<p><strong>临时表的应用</strong></p>
<ul>
<li>临时表常用于复杂查询的优化，特别是在分库分表系统中进行跨库查询时。</li>
<li>在分库分表系统中，临时表可以用于汇总多个分库的数据，然后在汇总表上进行排序、过滤等操作。</li>
</ul>
<p><strong>临时表的存储机制</strong>：</p>
<ul>
<li>临时表的表结构定义存储在临时文件目录下的<code>.frm</code>文件中，文件名格式为<code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_序列号</code>。</li>
<li>在 MySQL 5.6 及之前版本，临时表的数据存储在<code>.ibd</code>文件中；从 5.7 版本开始，数据存储在临时表表空间中。</li>
<li>临时表的<code>table_def_key</code>由“库名 + 表名 + server_id + thread_id”组成，确保不同线程的同名临时表不会冲突。</li>
</ul>
<p><strong>临时表在主备复制中的行为</strong>：</p>
<ul>
<li>在<code>binlog_format=statement/mixed</code>时，临时表的创建和删除操作会记录到 binlog 中，以便备库同步。</li>
<li>在<code>binlog_format=row</code>时，临时表的操作不会记录到 binlog 中。</li>
<li>备库通过主库的线程 id 来区分不同线程的同名临时表，确保不会冲突。</li>
</ul>
<p><strong>临时表的自动删除</strong>：临时表在 session 结束时自动删除，binlog 中会记录<code>DROP TEMPORARY TABLE</code>命令，以便备库同步删除临时表。</p>
<p><strong>临时表的改名操作</strong>：临时表可以使用<code>alter table</code>语法修改表名，但不能使用<code>rename</code>语法。这是因为临时表的存储机制和<code>table_def_key</code>的特殊性。</p>
<h2 id="37-什么时候会使用内部临时表？"><a href="#37-什么时候会使用内部临时表？" class="headerlink" title="37 什么时候会使用内部临时表？"></a>37 什么时候会使用内部临时表？</h2><p><strong>内部临时表的作用</strong>：内部临时表用于存储 SQL 语句执行过程中的中间结果，辅助完成复杂的查询操作，如<code>UNION</code>和<code>GROUP BY</code>。</p>
<p><strong><code>UNION</code>操作的执行流程</strong>：</p>
<ul>
<li><code>UNION</code>操作需要对两个子查询的结果进行去重合并，因此需要使用临时表来存储中间结果。</li>
<li>执行流程：<ol>
<li>创建一个内存临时表，用于存储子查询的结果。</li>
<li>执行第一个子查询，将结果插入临时表。</li>
<li>执行第二个子查询，尝试将结果插入临时表，若遇到重复值则忽略。</li>
<li>从临时表中读取数据并返回结果，最后删除临时表。</li>
</ol>
</li>
<li>如果使用<code>UNION ALL</code>，则不需要去重，因此不需要临时表。</li>
</ul>
<p><strong><code>GROUP BY</code>操作的执行流程</strong>：</p>
<ul>
<li><code>GROUP BY</code>操作用于对数据进行分组统计，通常需要使用临时表来存储分组结果。</li>
<li>执行流程：<ol>
<li>创建一个内存临时表，包含分组字段和计数字段。</li>
<li>扫描表数据，计算分组字段的值，并更新临时表中的计数。</li>
<li>对临时表中的数据进行排序（如果需要），然后返回结果。</li>
</ol>
</li>
<li>如果内存临时表的大小超过<code>tmp_table_size</code>的限制，MySQL 会将内存临时表转换为磁盘临时表。</li>
</ul>
<p><strong><code>GROUP BY</code>的优化方法</strong>：</p>
<ul>
<li><strong>使用索引</strong>：如果分组字段上有索引，MySQL 可以利用索引的有序性来避免使用临时表和排序操作。可以通过<code>generated column</code>机制创建一个计算列，并在该列上创建索引，从而优化<code>GROUP BY</code>操作。</li>
<li><strong>直接排序</strong>：对于数据量特别大的<code>GROUP BY</code>操作，可以使用<code>SQL_BIG_RESULT</code>提示，告诉优化器直接使用磁盘临时表和排序算法，避免内存临时表的开销。</li>
</ul>
<p><strong>内部临时表的使用场景</strong>：</p>
<ul>
<li>当 SQL 语句的执行过程需要存储中间结果时，MySQL 会使用内部临时表。</li>
<li>内部临时表的使用场景包括：<ul>
<li><code>UNION</code>操作（去重合并）。</li>
<li><code>GROUP BY</code>操作（分组统计）。</li>
<li>其他需要二维表结构的操作。</li>
</ul>
</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>对于<code>GROUP BY</code>操作，如果没有排序要求，可以在语句末尾加上<code>ORDER BY NULL</code>，避免不必要的排序。</li>
<li>尽量让<code>GROUP BY</code>操作使用索引，避免使用临时表和排序。</li>
<li>如果数据量较大，可以适当调大<code>tmp_table_size</code>参数，避免使用磁盘临时表。</li>
<li>对于非常大的数据集，可以使用<code>SQL_BIG_RESULT</code>提示，直接使用排序算法。</li>
</ul>
<h2 id="38-都说-InnoDB-好，那还要不要使用-Memory-引擎？"><a href="#38-都说-InnoDB-好，那还要不要使用-Memory-引擎？" class="headerlink" title="38 都说 InnoDB 好，那还要不要使用 Memory 引擎？"></a>38 都说 InnoDB 好，那还要不要使用 Memory 引擎？</h2><p><strong>Memory 引擎与 InnoDB 引擎的数据组织方式</strong>：</p>
<ul>
<li><strong>InnoDB</strong>：采用索引组织表（Index Organized Table），数据存储在 B+树的主键索引上，数据有序存储。</li>
<li><strong>Memory 引擎</strong>：采用堆组织表（Heap Organized Table），数据存储在数组中，主键索引是哈希索引，数据按写入顺序存储。</li>
</ul>
<p><strong>Memory 引擎的特性</strong>：</p>
<ul>
<li><strong>数据存储</strong>：数据存储在内存中，读写速度快，但数据库重启后数据会丢失。</li>
<li><strong>索引支持</strong>：默认使用哈希索引，但也支持 B-Tree 索引。</li>
<li><strong>锁机制</strong>：只支持表锁，不支持行锁，并发性能较差。</li>
<li><strong>数据类型限制</strong>：不支持 Blob 和 Text 字段，varchar(N) 实际存储为固定长度字符串。</li>
</ul>
<p><strong>Memory 引擎的缺点</strong>：</p>
<ul>
<li><strong>锁粒度问题</strong>：由于只支持表锁，更新操作会阻塞其他读写操作，影响并发性能。</li>
<li><strong>数据持久性问题</strong>：数据库重启后，内存表中的数据会丢失，可能导致主备同步问题。</li>
<li><strong>主备同步问题</strong>：在 M-S 架构或双 M 架构下，备库重启会导致内存表数据丢失，进而导致主备同步停止。</li>
</ul>
<p><strong>Memory 引擎的适用场景</strong>：</p>
<ul>
<li><strong>内存临时表</strong>：在数据量可控、不需要持久化的场景下，内存临时表可以发挥其优势，尤其是在复杂查询中，哈希索引的查找速度较快。</li>
<li><strong>临时表的使用</strong>：内存临时表适合用于临时存储中间结果，尤其是在需要快速查询的场景下。</li>
</ul>
<p><strong>InnoDB 引擎的优势</strong>：</p>
<ul>
<li><strong>数据持久化</strong>：数据存储在磁盘上，重启后数据不会丢失。</li>
<li><strong>行锁支持</strong>：支持行锁，并发性能较好。</li>
<li><strong>数据安全</strong>：支持事务和崩溃恢复，数据安全性更高。</li>
</ul>
<p><strong>生产环境中的建议</strong>：</p>
<ul>
<li><strong>不建议使用普通内存表</strong>：由于数据持久性和锁粒度问题，生产环境中不建议使用 Memory 引擎的普通表。</li>
<li><strong>推荐使用 InnoDB 表</strong>：InnoDB 表在性能和安全性上更有保障，尤其是在高并发和需要持久化的场景下。</li>
<li><strong>内存临时表的适用性</strong>：在数据量较小、不需要持久化的临时表场景下，可以使用内存临时表来加速查询。</li>
</ul>
<h2 id="39-自增主键为什么不是连续的？"><a href="#39-自增主键为什么不是连续的？" class="headerlink" title="39 自增主键为什么不是连续的？"></a>39 自增主键为什么不是连续的？</h2><p><strong>自增主键的存储机制</strong></p>
<ul>
<li><strong>MyISAM 引擎</strong>：自增值保存在数据文件中。</li>
<li><strong>InnoDB 引擎</strong>：自增值保存在内存中，直到 MySQL 8.0 版本才实现了自增值的持久化，通过 redo log 记录自增值的变更，确保重启后自增值不变。</li>
</ul>
<p><strong>自增主键的修改机制</strong></p>
<ul>
<li>当插入数据时，如果未指定自增字段的值，MySQL 会使用当前的自增值。</li>
<li>如果插入的值大于当前自增值，MySQL 会更新自增值为新的值（插入值 + 1）。</li>
<li>自增值的生成算法基于<code>auto_increment_offset</code>和<code>auto_increment_increment</code>两个系统参数，默认值均为 1。</li>
</ul>
<p><strong>自增主键不连续的原因</strong></p>
<ul>
<li><strong>唯一键冲突</strong>：当插入数据时发生唯一键冲突，自增值已经增加，但插入失败，导致自增值不连续。</li>
<li><strong>事务回滚</strong>：事务回滚时，自增值不会回退，导致自增值不连续。</li>
<li><strong>批量插入</strong>：在批量插入数据时，MySQL 会预先分配多个自增值，但实际使用的自增值可能少于分配的数量，导致自增值不连续。</li>
</ul>
<p><strong>自增锁的优化</strong></p>
<p>MySQL 5.1.22 版本引入了<code>innodb_autoinc_lock_mode</code>参数，控制自增锁的范围：</p>
<ul>
<li>0：语句级别锁，语句执行结束后释放锁。</li>
<li>1（默认）：普通插入语句申请后立即释放锁，批量插入语句（如<code>insert … select</code>）在语句结束后释放锁。</li>
<li>2：所有插入语句申请后立即释放锁。</li>
</ul>
<p>为了提升并发性能，建议将<code>innodb_autoinc_lock_mode</code>设置为 2，并将<code>binlog_format</code>设置为<code>row</code>，以避免数据不一致问题。</p>
<p><strong>批量插入的自增 ID 分配策略</strong></p>
<ul>
<li>批量插入时，MySQL 采用指数级分配策略，第一次分配 1 个 ID，第二次分配 2 个，第三次分配 4 个，依此类推。</li>
<li>这种策略可能导致自增 ID 的浪费，进一步导致自增 ID 不连续。</li>
</ul>
<h2 id="40-insert-语句的锁为什么这么多？"><a href="#40-insert-语句的锁为什么这么多？" class="headerlink" title="40 insert 语句的锁为什么这么多？"></a>40 insert 语句的锁为什么这么多？</h2><p><strong><code>INSERT … SELECT</code>语句的加锁行为</strong>：</p>
<ul>
<li>在可重复读隔离级别下，<code>INSERT … SELECT</code>语句会对源表（<code>SELECT</code>的表）的所有记录和间隙加锁（<code>next-key lock</code>），以防止并发操作导致的数据不一致。</li>
<li>这种加锁行为是为了保证主备数据一致性，尤其是在<code>binlog_format=statement</code>的情况下，避免主备数据不一致的问题。</li>
</ul>
<p><strong><code>INSERT</code>循环写入的问题</strong>：</p>
<ul>
<li>当<code>INSERT</code>和<code>SELECT</code>操作的对象是同一个表时，可能会导致循环写入问题。为了避免这种情况，MySQL 会使用临时表来存储中间结果。</li>
<li>通过使用临时表，可以避免在遍历数据的同时更新数据，从而防止逻辑错误。</li>
</ul>
<p><strong><code>INSERT</code>语句中的唯一键冲突</strong>：</p>
<ul>
<li>当<code>INSERT</code>语句发生唯一键冲突时，MySQL 会在冲突的唯一键上加共享的<code>next-key lock</code>（读锁），以防止其他事务删除该行数据。</li>
<li>这种加锁行为可能会导致死锁，尤其是在多个事务同时插入相同唯一键的情况下。</li>
</ul>
<p><strong><code>INSERT INTO … ON DUPLICATE KEY UPDATE</code>语句</strong>：</p>
<ul>
<li>当<code>INSERT</code>语句发生唯一键冲突时，可以使用<code>ON DUPLICATE KEY UPDATE</code>来更新冲突的行。</li>
<li>这种情况下，MySQL 会在冲突的唯一键上加排他的<code>next-key lock</code>（写锁），并执行更新操作。</li>
<li>如果有多个唯一键冲突，MySQL 会按照索引顺序处理第一个冲突的行。</li>
</ul>
<p><strong>死锁场景</strong>：</p>
<ul>
<li>在唯一键冲突的情况下，多个事务同时插入相同唯一键时，可能会导致死锁。例如，事务 A 插入冲突行并加锁，事务 B 和事务 C 也尝试插入相同行并加锁，当事务 A 回滚时，事务 B 和事务 C 会互相等待对方的锁，导致死锁。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>对于<code>INSERT … SELECT</code>操作，可以使用临时表来避免循环写入问题。</li>
<li>在唯一键冲突的情况下，应尽快提交或回滚事务，避免长时间持有锁，减少死锁的风险。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><code>INSERT</code>语句在特殊情况下（如<code>INSERT … SELECT</code>、唯一键冲突等）会有复杂的加锁行为，理解这些行为有助于避免数据不一致和死锁问题。</li>
<li>使用临时表、合理设计事务提交策略等方法可以优化<code>INSERT</code>操作的性能和数据一致性。</li>
</ul>
<h2 id="41-怎么最快地复制一张表？"><a href="#41-怎么最快地复制一张表？" class="headerlink" title="41 怎么最快地复制一张表？"></a>41 怎么最快地复制一张表？</h2><p><strong>mysqldump 方法</strong>：</p>
<ul>
<li>使用<code>mysqldump</code>命令将数据导出为一组<code>INSERT</code>语句，然后将这些语句导入到目标表中。</li>
<li>优点：可以控制导出的数据范围（如<code>WHERE</code>条件），适合导出部分数据。</li>
<li>缺点：不能处理复杂的<code>WHERE</code>条件（如<code>JOIN</code>），且导出的是逻辑数据，速度较慢。</li>
</ul>
<p><strong>导出 CSV 文件方法</strong>：</p>
<ul>
<li>使用<code>SELECT … INTO OUTFILE</code>将查询结果导出为 CSV 文件，然后使用<code>LOAD DATA INFILE</code>将数据导入到目标表中。</li>
<li>优点：灵活，支持所有 SQL 写法，适合导出单表数据。</li>
<li>缺点：每次只能导出一张表的数据，表结构需要单独备份，且需要处理文件路径和权限问题。</li>
</ul>
<p><strong>物理拷贝方法</strong>：</p>
<ul>
<li>使用 MySQL 的<strong>可传输表空间</strong>功能，直接拷贝表的<code>.ibd</code>和<code>.cfg</code>文件，实现物理拷贝。</li>
<li>优点：速度最快，尤其适合大表拷贝，恢复数据时非常高效。</li>
<li>缺点：只能全表拷贝，不能拷贝部分数据，且源表和目标表必须使用 InnoDB 引擎。</li>
</ul>
<p><strong>三种方法的对比</strong>：</p>
<ul>
<li><strong>物理拷贝</strong>：速度最快，适合大表全表拷贝，但限制较多。</li>
<li><strong>mysqldump</strong>：适合导出部分数据，但不能处理复杂查询。</li>
<li><strong>导出 CSV 文件</strong>：最灵活，支持所有 SQL 写法，但每次只能导出一张表的数据。</li>
</ul>
<p><strong>binlog_format&#x3D;statement 时的 load data 问题</strong>：</p>
<ul>
<li>当<code>binlog_format=statement</code>时，<code>LOAD DATA</code>命令会记录到 binlog 中，并在备库执行。为了确保备库能够正确执行，binlog 中的<code>LOAD DATA</code>命令会带有<code>local</code>关键字，指示备库从本地读取文件。</li>
<li>如果不带<code>local</code>，备库将无法找到文件，导致主备同步停止。</li>
</ul>
<h2 id="42-grant-之后要跟着-flush-privileges-吗？"><a href="#42-grant-之后要跟着-flush-privileges-吗？" class="headerlink" title="42 grant 之后要跟着 flush privileges 吗？"></a>42 grant 之后要跟着 flush privileges 吗？</h2><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。</p>
<p>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p>
<p><strong><code>GRANT</code>命令的作用</strong>：</p>
<ul>
<li><code>GRANT</code>命令用于给用户赋权，它会同时更新磁盘上的权限表（如<code>mysql.user</code>、<code>mysql.db</code>等）和内存中的权限数组（如<code>acl_users</code>、<code>acl_dbs</code>等）。</li>
<li>赋权操作是即时生效的，新的连接会使用更新后的权限，但已经存在的连接不会受到影响。</li>
</ul>
<p><strong>权限的存储与生效</strong>：</p>
<ul>
<li><strong>全局权限</strong>：存储在<code>mysql.user</code>表中，内存中保存在<code>acl_users</code>数组中。<code>GRANT</code>和<code>REVOKE</code>操作会同时更新磁盘和内存。</li>
<li><strong>库级权限</strong>：存储在<code>mysql.db</code>表中，内存中保存在<code>acl_dbs</code>数组中。<code>GRANT</code>和<code>REVOKE</code>操作也会同时更新磁盘和内存。</li>
<li><strong>表级和列级权限</strong>：存储在<code>mysql.tables_priv</code>和<code>mysql.columns_priv</code>表中，内存中保存在<code>column_priv_hash</code>结构中。<code>GRANT</code>和<code>REVOKE</code>操作同样会同时更新磁盘和内存。</li>
</ul>
<p><strong><code>FLUSH PRIVILEGES</code>的作用</strong>：</p>
<ul>
<li><code>FLUSH PRIVILEGES</code>命令会清空内存中的权限数组（如<code>acl_users</code>、<code>acl_dbs</code>等），然后从磁盘的权限表中重新加载数据，重建内存中的权限数组。</li>
<li>通常情况下，如果使用<code>GRANT</code>和<code>REVOKE</code>命令来管理权限，内存和磁盘的权限数据是同步的，因此不需要执行<code>FLUSH PRIVILEGES</code>。</li>
</ul>
<p><strong><code>FLUSH PRIVILEGES</code>的使用场景</strong>：</p>
<ul>
<li>当直接使用 DML 语句（如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）修改权限表时，可能会导致内存和磁盘的权限数据不一致。此时需要执行<code>FLUSH PRIVILEGES</code>来重建内存中的权限数据。</li>
<li>例如，直接删除<code>mysql.user</code>表中的用户记录后，内存中的<code>acl_users</code>数组仍然保留该用户，此时需要<code>FLUSH PRIVILEGES</code>来更新内存数据。</li>
</ul>
<p><strong>总结与建议</strong>：</p>
<ul>
<li>正常情况下，使用<code>GRANT</code>和<code>REVOKE</code>命令管理权限时，不需要执行<code>FLUSH PRIVILEGES</code>。</li>
<li>只有在直接操作权限表（如使用 DML 语句）导致内存和磁盘权限数据不一致时，才需要执行<code>FLUSH PRIVILEGES</code>。</li>
<li>建议避免直接操作权限表，而是使用<code>GRANT</code>和<code>REVOKE</code>命令来管理权限。</li>
</ul>
<h2 id="43-要不要使用分区表？"><a href="#43-要不要使用分区表？" class="headerlink" title="43 要不要使用分区表？"></a>43 要不要使用分区表？</h2><p><strong>分区表的概念</strong>：</p>
<ul>
<li>分区表是将一个大表按某种规则（如时间、范围等）分成多个小表，每个分区对应一个独立的物理文件（如<code>.ibd</code>文件）。</li>
<li>对于引擎层来说，每个分区是一个独立的表；对于 Server 层来说，分区表是一个逻辑上的表。</li>
</ul>
<p><strong>分区表的引擎层行为</strong>：</p>
<ul>
<li><strong>InnoDB 引擎</strong>：每个分区在引擎层被视为独立的表，加锁范围仅限于当前分区。例如，间隙锁只会锁定当前分区的间隙，不会影响其他分区。</li>
<li><strong>MyISAM 引擎</strong>：MyISAM 的分区表在引擎层也是独立的表，但由于 MyISAM 只支持表锁，锁的范围是整个分区。</li>
</ul>
<p><strong>分区表的 Server 层行为</strong>：</p>
<ul>
<li>在 Server 层，分区表被视为一个逻辑表，所有分区共享同一个 MDL 锁（Metadata Lock）。这意味着在对分区表执行 DDL 操作时，可能会阻塞其他分区的查询操作。</li>
<li>第一次访问分区表时，MySQL 需要打开所有分区的文件，如果分区过多，可能会导致打开文件数超过系统限制（<code>open_files_limit</code>），从而报错。</li>
</ul>
<p><strong>分区策略</strong>：</p>
<ul>
<li><strong>通用分区策略（Generic Partitioning）</strong>：MySQL 早期支持的分区策略，性能较差，尤其是在 MyISAM 引擎下，访问分区时需要打开所有分区的文件。</li>
<li><strong>本地分区策略（Native Partitioning）</strong>：从 MySQL 5.7.9 开始，InnoDB 引擎引入了本地分区策略，优化了分区表的文件管理和性能。从 MySQL 8.0 开始，MyISAM 分区表被弃用，仅支持 InnoDB 和 NDB 引擎的分区表。</li>
</ul>
<p><strong>分区表的优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>对业务透明，业务代码无需修改即可使用分区表。</li>
<li>方便清理历史数据，可以通过<code>ALTER TABLE ... DROP PARTITION</code>快速删除过期数据，性能优于<code>DELETE</code>操作。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>第一次访问分区表时需要打开所有分区的文件，可能导致性能问题。</li>
<li>所有分区共享同一个 MDL 锁，DDL 操作可能会影响其他分区的查询。</li>
<li>分区过多会导致文件管理复杂，影响性能。</li>
</ul>
</li>
</ul>
<p><strong>分区表的适用场景</strong>：</p>
<ul>
<li>适合按时间分区的场景，尤其是需要定期清理历史数据的业务。</li>
<li>分区表的分区数量不宜过多，建议按需创建分区，避免提前创建过多分区。</li>
</ul>
<p><strong>分区表的注意事项</strong>：</p>
<ul>
<li>分区并不是越细越好，单表或单分区的数据量在 1000 万行以内时，性能通常是可以接受的。</li>
<li>分区表的主键必须包含分区字段，否则无法创建自增主键。</li>
</ul>
<h2 id="44-答疑文章（三）：说一说这些好问题"><a href="#44-答疑文章（三）：说一说这些好问题" class="headerlink" title="44 答疑文章（三）：说一说这些好问题"></a>44 答疑文章（三）：说一说这些好问题</h2><p><strong>join 的写法</strong>：</p>
<ul>
<li><strong>left join 的驱动表</strong>：使用 <code>left join</code> 时，左边的表不一定是驱动表，优化器可能会根据语义进行优化。</li>
<li><strong>on 和 where 的区别</strong>：在 <code>left join</code> 中，如果将条件放在 <code>where</code> 子句中，可能会导致语义变化，优化器可能会将 <code>left join</code> 改写为 <code>join</code>。</li>
<li><strong>join 条件的写法</strong>：对于 <code>join</code> 语句，将条件放在 <code>on</code> 或 <code>where</code> 子句中没有区别。</li>
</ul>
<p><strong>Simple Nested Loop Join 的性能问题</strong>：</p>
<ul>
<li><strong>BNL 算法</strong>：将驱动表的数据读入内存，顺序扫描被驱动表进行匹配，性能较好。</li>
<li><strong>Simple Nested Loop Join 算法</strong>：每次匹配都需要全表扫描，性能较差，主要因为磁盘 I&#x2F;O 和 Buffer Pool 的影响。</li>
</ul>
<p><strong>distinct 和 group by 的性能</strong>：</p>
<ul>
<li>当不需要聚合函数时，<code>distinct</code> 和 <code>group by</code> 的语义和执行流程相同，性能也相同。</li>
<li>两者的执行流程都是通过创建临时表并利用唯一索引去重。</li>
</ul>
<p><strong>备库自增主键问题</strong>：在 <code>binlog_format=statement</code> 时，MySQL 通过 <code>SET INSERT_ID</code> 语句确保主备库的自增主键一致，即使语句执行顺序不同。</p>
<h2 id="45-自增-id-用完怎么办？"><a href="#45-自增-id-用完怎么办？" class="headerlink" title="45 自增 id 用完怎么办？"></a>45 自增 id 用完怎么办？</h2><p><strong>表定义自增 ID</strong>：</p>
<ul>
<li>表定义的自增 ID 达到上限后，再申请下一个 ID 时，值保持不变，导致插入数据时报主键冲突错误。</li>
<li>建议在建表时，如果预计数据量较大，应使用 8 字节的 <code>bigint unsigned</code> 类型。</li>
</ul>
<p><strong>InnoDB 系统自增 row_id</strong>：</p>
<ul>
<li>如果表没有指定主键，InnoDB 会创建一个 6 字节的 <code>row_id</code>。</li>
<li><code>row_id</code> 达到上限后会从 0 开始循环，可能导致数据覆盖。</li>
<li>建议主动创建自增主键，以避免数据覆盖问题。</li>
</ul>
<p><strong>Xid</strong>：</p>
<ul>
<li>Xid 是事务的唯一标识，由 <code>global_query_id</code> 生成。</li>
<li><code>global_query_id</code> 是 8 字节的变量，达到上限后会从 0 开始循环，但理论上重复的概率极低。</li>
<li>Xid 主要用于 redo log 和 binlog 的关联。</li>
</ul>
<p><strong>InnoDB trx_id</strong>：</p>
<ul>
<li><code>trx_id</code> 是事务 ID，用于数据可见性判断。</li>
<li>只读事务不会分配 <code>trx_id</code>，以减少活跃事务数组的大小和锁冲突。</li>
<li><code>max_trx_id</code> 达到上限后会从 0 开始循环，可能导致脏读问题，但这种情况在现实中极少发生。</li>
</ul>
<p><strong>thread_id</strong>：</p>
<ul>
<li>线程 ID 是 MySQL 中最常见的自增 ID，达到上限后会从 0 开始循环。</li>
<li>MySQL 通过唯一数组逻辑确保不会分配重复的 <code>thread_id</code>。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>不同的自增 ID 有不同的上限和达到上限后的行为。</li>
<li>数据库系统需要处理这些边界情况，以确保长期运行的稳定性。</li>
<li>文章还提到了一些其他自增 ID（如 <code>table_id</code>、<code>binlog</code> 文件序号等），鼓励读者自行探索。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">极客时间教程 - MySQL 实战 45 讲</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>钝悟 ◾ Dunwu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://dunwu.github.io/blog/pages/183a3fd4/" title="《MySQL 实战 45 讲》笔记三">https://dunwu.github.io/blog/pages/183a3fd4/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/blog/tags/mysql/" rel="tag"># mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/pages/ef9fb8a5/" rel="prev" title="《MySQL 实战 45 讲》笔记二">
                  <i class="fa fa-angle-left"></i> 《MySQL 实战 45 讲》笔记二
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/pages/3db6a5fd/" rel="next" title="《MySQL 实战 45 讲》笔记">
                  《MySQL 实战 45 讲》笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">4.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">68:08</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"6cf6959c60dcf18ce6445a3a1163308b"}</script>
<script src="/blog/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
